{"version":3.0,"file":"_build/refmt/app.js","sourceRoot":"","names":["dummy_pos","zero_pos","sub_format","formatting_lit","locfmt","current_dir_name","dir_sep","current_dir_name$0","parent_dir_name","dir_sep$0","current_dir_name$1","parent_dir_name$0","dir_sep$1","ast_impl_magic_number","ast_intf_magic_number","ast_impl_magic_number$0","ast_intf_magic_number$0","empty_docs$0","ast_impl_magic_number$1","ast_intf_magic_number$1","ast_impl_magic_number$2","ast_intf_magic_number$2","ast_impl_magic_number$3","ast_intf_magic_number$3","pos","txt","erase_rel","rest","rest$0","rest$1","rest$2","rest$3","rest$4","rest$5","rest$6","rest$7","ty","rest$8","ty1","rest$9","rest$10","rest$11","rest$12","rest$13","concat_fmtty","fmtty1","fmtty2","ty2","concat_fmt","fmt1","fmt2","pad","pad$0","prec","pad$1","iconv","prec$0","pad$2","iconv$0","prec$1","pad$3","iconv$1","prec$2","pad$4","iconv$2","prec$3","pad$5","fconv","str","chr","fmtty","pad$6","fmtty$0","pad$7","rest$14","rest$15","rest$16","fmting_lit","rest$17","fmting_gen","rest$18","rest$19","char_set","width_opt","rest$20","counter","rest$21","rest$22","ign","rest$23","f","arity","failwith","s","invalid_arg","min","x","y","max","abs","lnot","max_int","min_int","_b_","s1","s2","l1","l2","char_of_int","n","string_of_bool","b","string_of_int","valid_float_lexem","l","loop","i","i$0","i$1","string_of_float","append","tl","hd","stdin","stdout","stderr","flush_all","iter","a","output_string","oc","output_substring","ofs","len","open_in_gen","mode","perm","name","c","open_in_bin","input","ic","unsafe_really_input","ofs$0","len$0","r","len$1","ofs$1","really_input","really_input_string","prerr_string","prerr_endline","at_exit","g","do_at_exit","exit","retcode","length_aux","param$1","length","nth","nth_aux","l$0","n$0","l$1","n$1","rev_append","l1$0","l2$0","l1$1","l2$1","rev","flatten","map","mapi","rev_map","rmap_f","fold_left","accu","accu$0","accu$1","fold_right","map2","a2","a1","iter2","fold_left2","fold_right2","for_all","p","exists","for_all2","mem","memq","assoc","assq","mem_assoc","mem_assq","find","find_all","partition","part","split","ry","rx","combine","chop","k","k$0","k$1","stable_sort","cmp","rev_merge","t2","h2","t1","h1","accu$2","rev_merge_rev","sort","x2","x1","x3","x2$0","x1$0","n1","n2","rev_sort","sort_uniq","accu$3","c$0","c$1","c$2","c$3","c$4","c$5","escaped","s$0","uppercase","lowercase_ascii","uppercase_ascii","make","init","empty","copy","to_string","of_string","sub","sub_string","blit","ofs1","ofs2","blit$0","is_space","trim","j","escaped$0","map$0","uppercase_ascii$0","lowercase_ascii$0","apply1","uncapitalize_ascii","capitalize","bos","bts","make$0","init$0","sub$0","ensure_ge","sum_lengths","seplen","unsafe_blits","dst","sep","concat","is_space$0","trim$0","escaped$1","needs_escape","index_rec","lim","index","index_from","contains_from","contains","uppercase_ascii$1","lowercase_ascii$1","uncapitalize_ascii$0","split_on_char","capitalize$0","os_type","max_array_length","max_string_length","to_buffer","buff","v","flags","is_block","lazy_tag","object_tag","forward_tag","make_matrix","sx","sy","res","copy$0","append$0","sub$1","fill","blit$1","iter$0","map$1","map2$0","la","lb","iteri","mapi$0","to_list","tolist","res$0","res$1","list_length","of_list","fold_left$0","exists$0","for_all$0","succ","to_string$0","succ$0","to_string$1","succ$1","to_string$2","engine","tbl","state","buf","result","new_engine","from_string","lexbuf","lexeme","sub_lexeme","i1","i2","sub_lexeme_opt","sub_lexeme_char","lexeme_char","lexeme_start_p","lexeme_end_p","env","grow_stacks","oldsize","newsize","new_s","new_v","new_start","new_end","clear_parser","current_lookahead_fun","yyparse","tables","start","lexer","cmd","arg","cmd$0","arg$0","arg$1","cmd$1","arg$2","init_asp","init_sp","init_stackbase","init_state","init_curr_char","init_lval","init_errflag","exn","curr_char","tok","peek_val","symbol_start_pos","st","en","symbol_end_pos","rhs_start_pos","rhs_end_pos","is_current_lookahead","parse_error","height","h","create","hl","h$0","hr","bal","lr","lv","ll","lrr","lrv","lrl","rr","rv","rl","rlr","rlv","rll","add","t","singleton","add_min_element","add_max_element","join","rh","lh","min_elt","max_elt","remove_min_elt","r$0","merge","match","pres","pres$0","is_empty","remove","union","r2","v2","r1","v1","r2$0","r1$0","inter","diff","cons_enum","e","e$0","s$1","e$1","compare_aux","e1","e2","e1$0","e2$0","e2$1","e1$1","e2$2","e1$2","compare","equal","subset","s1$0","s2$0","fold","filter","pv","lf","lt","rf","rt","cardinal","elements_aux","elements","try_join","v$0","of_sorted_list","l$3","x0","l$4","x0$0","l$5","x0$1","nl","left","mid","l$2","right","x4","d","ld","lrd","rd","rld","data","m","min_binding","max_binding","remove_min_binding","d$0","m$0","add_min_binding","add_max_binding","concat_or_join","d1","d2","d2$0","d1$0","d2$1","d1$1","pvd","m$1","m1","m2","equal_aux","bindings_aux","bindings","iter$1","cell","cell$0","content","next","iter$2","q","raise_undefined","force_lazy_block","blk","closure","create$0","contents","sub$2","length$0","reset","resize","more","new_len","new_buffer","add_char","add_substring","offset","new_position","add_string","create_char_set","add_in_char_set","str_ind","mask","freeze_char_set","rev_char_set","char_set$0","default_float_precision","buffer_create","init_size","buffer_check_size","overhead","min_len","new_str","buffer_add_char","buffer_add_string","str_len","buffer_contents","char_of_fconv","bprint_fconv_flag","string_of_formatting_lit","str$0","bprint_fmtty","sub_fmtty","sub_fmtty$0","symm","fmtty_rel_det","de","ed","af","fa","de$0","ed$0","af$0","fa$0","de$1","ed$1","af$1","fa$1","de$2","ed$2","af$2","fa$2","de$3","ed$3","af$3","fa$3","de$4","ed$4","af$4","fa$4","de$5","ed$5","af$5","fa$5","de$6","ed$6","af$6","fa$6","de$7","ed$7","af$7","fa$7","de$8","ed$8","af$8","fa$8","trans","jd","dj","ga","ag","de$9","ed$9","af$9","fa$9","de$10","ed$10","af$10","fa$10","de$11","ed$11","af$11","fa$11","de$12","ed$12","af$12","fa$12","de$13","ed$13","af$13","fa$13","rest2","rest2$0","rest2$1","rest2$2","rest2$3","rest2$4","rest2$5","rest2$6","rest2$7","rest2$8","ty22","ty21","f4","f2","rest2$9","rest2$10","rest2$11","rest2$12","rest2$13","fmtty_of_padding_fmtty","fmtty_of_custom","arity$0","fmtty_of_fmt$0","fmtty_of_fmt","ty_rest","prec_ty","fmtty_of_precision_fmtty","ty_rest$0","prec_ty$0","ty_rest$1","prec_ty$1","ty_rest$2","prec_ty$2","ty_rest$3","prec_ty$3","fmtty$1","fmtty$2","fmtty$3","ty$0","fmtty$4","fmtty_of_formatting_gen","fmtty_of_ignored_format","fmt","formatting_gen","fmt$0","type_padding","w","padty","padty$0","type_padprec","type_format","type_format_gen","type_ignored_param_one","type_ignored_param","fmtty_rest","pad_opt","pad_opt$0","type_ignored_format_substitution","fmt$1","sub_fmtty$1","type_formatting_gen","fmt0","fmtty0","fmtty3","fmt3","fmt1$0","fmtty2$0","fmt2$0","fmtty3$0","fmt3$0","fmt_rest","fmtty_rest$0","fmt_rest$0","fmt_rest$1","fmtty_rest$1","fmt$2","fmt_rest$2","fmtty_rest$2","fmt$3","fmt_rest$3","fmtty_rest$3","fmt$4","fmt_rest$4","fmtty_rest$4","fmt$5","fmt_rest$5","fmtty_rest$5","fmtty$5","fmt$6","fmt_rest$6","fmtty_rest$6","fmtty$6","fmt$7","fmt_rest$7","fmtty_rest$7","fmtty$7","fmt$8","fmtty_rest$8","fmt_rest$8","fmtty$8","fmt$9","fmt_rest$9","fmtty$9","fmt$10","fmt_rest$10","fmtty$10","fmt$11","fmt_rest$11","fmtty$11","fmt$12","fmtty_rest$9","fmt_rest$12","fmtty$12","fmt$13","fmtty_rest$10","sub_fmtty1","fmt_rest$13","fmtty$13","fmt$14","fmtty_rest$11","fmt_rest$14","fmtty$14","fmt$15","fmtty_rest$12","fmt_rest$15","fmtty$15","fmt$16","fmt_rest$16","fmtty$16","fmt$17","fmt_rest$17","fmtty_rest$13","fmt_rest$18","fmtty$17","fmt$18","fmtty_rest$14","fmt_rest$19","fmtty$18","fmt$19","fmtty_rest$15","fmt_rest$20","fmtty$19","fmt$20","sub_fmtty_rest","sub_fmtty_rest$0","sub_fmtty_rest$1","sub_fmtty_rest$2","sub_fmtty_rest$3","sub_fmtty_rest$4","sub_fmtty_rest$5","sub_fmtty_rest$6","sub_fmtty_rest$7","sub_fmtty_rest$8","sub_fmtty_rest$9","sub_fmtty_rest$10","sub_fmtty_rest$11","sub_fmtty_rest$12","sub_fmtty_rest$13","sub_fmtty_rest$14","sub2_fmtty","sub_fmtty_rest$15","sub2_fmtty$0","sub_fmtty_rest$16","sub2_fmtty$1","sub1_fmtty","sub_fmtty_rest$17","sub2_fmtty$2","sub1_fmtty$0","sub_fmtty_rest$18","sub_fmtty_rest$19","sub_fmtty_rest$20","sub_fmtty_rest$21","sub_fmtty_rest$22","sub_fmtty_rest$23","sub_fmtty_rest$24","sub_fmtty_rest$25","sub_fmtty_rest$26","recast","fix_padding","width","fix_int_precision","string_to_caml_string","format_of_iconv","format_of_iconvL","format_of_iconvl","format_of_iconvn","format_of_fconv","symb","convert_int","convert_int32","convert_nativeint","convert_int64","convert_float","sign","is_valid","format_caml_char","string_of_fmtty","make_float_padding_precision","o","acc","make_printf","p$0","p$1","make_int_padding_precision","make_string_padding","new_acc","make_printf$0","acc$0","acc$1","acc$2","acc$3","acc$4","k$3","koc","kacc","k$4","k$2","make_ignored_param","make_custom$0","make_invalid_arg","make_from_fmtty$0","make_from_fmtty","make_custom","output_acc","p$2","p$3","msg","p$4","strput_acc","failwith_message","open_box_of_string","invalid_box","parse_spaces","parse_lword","j$0","j$1","parse_int","wstart","wend","box_name","nstart","nend","indent","exp_end","box_type","make_padding_fmt_ebb","make_precision_fmt_ebb","make_padprec_fmt_ebb","fmt_ebb_of_string","legacy_behavior","flag","legacy_behavior$0","invalid_format_message","unexpected_end_of_format","end_ind","invalid_nonnull_char_width","invalid_format_without","expected_character","expected","read","add_literal","lit_start","size","parse_literal","str_ind$0","parse_format","parse_after_at","str_ind$1","parse","beg_ind","parse_flags","pct_ind","zero","minus","plus","space","hash","set_flag","read_flags","str_ind$2","str_ind$3","str_ind$4","str_ind$5","parse_padding","parse_ign","parse_conversion","padprec","plus_used","hash_used","space_used","ign_used","pad_used","prec_used","get_plus","get_hash","get_space","get_ign","get_pad","get_prec","get_padprec","get_int_pad","incompatible_flag","check_no_0","opt_of_pad","width$0","width$1","get_pad_opt","get_padprec_opt","get_prec_opt","ndec","fmt_result","sub_end","search_subformat_end","sub_fmt","ignored$2","counter$0","ignored$5","ignored$6","parse_char_set","next_ind","ignored$8","char_format","scan_format","fmt_rest$21","fmt_rest$22","ignored$9","fmt_rest$23","pad$8","fmt_rest$24","sub_end$0","sub_fmt$0","fmt_rest$25","ignored$10","is_int_base","counter_of_char","ignored$4","compute_int_conv","ignored$7","prec$4","compute_float_conv","ignored$3","ignored","ignored$0","ignored$1","plus$0","hash$0","space$0","plus$1","ign$0","parse_after_precision","parse_conv","parse_precision","parse_positive","new_ind","minus$0","parse_after_padding","parse_magic_size","str_ind_1","parse_integer","str_ind_2","str_ind_3","parse_good_break","formatting_lit$0","str_ind_4","str_ind_5","parse_tag","is_open_tag","ind","sub_str","sub_format$0","formatting$0","check_open_box","formatting","add_range","fail_single_percent","parse_char_set_content","parse_char_set_after_char$0","parse_char_set_after_minus","parse_char_set_after_char","parse_char_set_start","reverse","reverse$0","sub_end$1","sub_end$2","str_ind$6","str_ind$7","option","subfmt","kfprintf","fprintf","ksprintf","sprintf","printers","field","other_fields","fields","to_string$3","conv","char$0","line","file","char$1","line$0","file$0","char$2","line$1","file$1","constructor","register_printer","fn","string","new_state","full_init","seed","extract","seed$0","make$1","make_self_init","bits","curval","newval","newval30","ongoing_traversal","flip_ongoing_traversal","params","randomized_default","prng","power_2_above","x$0","x$1","create$1","opt","initial_size","sth","random","reset$0","copy_bucketlist","key","copy$1","length$1","resize$0","indexfun","odata","osize","nsize","ndata","ndata_tail","inplace","insert_bucket","cell$1","nidx","key_index","bucket","remove_bucket","find_rec","find$0","k1","next1","k2","next2","k3","d3","next3","replace_bucket","replace","mem$0","mem_in_bucket","iter$3","do_bucket","old_trav","filter_map_inplace_bucket","data$0","filter_map_inplace","b$0","bucket_length","stats","mbl","histo","find_in_bucket","clear","sz","make_queue","add_queue","pp_enqueue","token","pp_clear_queue","pp_infinity","pp_output_newline","real_indent","bl_ty","tabs","add_tab","ls","ls$0","tags","tag_name","marker","off","off$0","insertion_point","tabs$0","tab","off$1","insertion_point$0","offset$0","bl_type","tbox","tag_name$0","marker$0","size$0","advance_left","enqueue_advance","make_queue_elem","enqueue_string_as","enqueue_string","q_elem","scan_stack_bottom","queue_elem","left_tot","pp_open_box_gen","br_ty","elem","pp_close_box","pp_open_tag","pp_close_tag","pp_set_print_tags","pp_set_mark_tags","pp_set_tags","pp_get_formatter_tag_functions","pp_set_formatter_tag_functions","pct","pot","mct","mot","pp_flush_queue","pp_print_as_size","pp_print_as","isize","pp_print_string","pp_print_char","pp_open_hbox","pp_open_vbox","pp_open_hvbox","pp_open_hovbox","pp_open_box","pp_print_newline","pp_print_flush","pp_force_newline","pp_print_break","pp_print_space","pp_print_cut","pp_set_max_indent","pp_set_margin","new_max_indent","pp_get_margin","pp_set_formatter_out_functions","pp_get_formatter_out_functions","pp_set_formatter_output_functions","pp_get_formatter_output_functions","display_newline","pp_queue","sys_tok","sys_scan_stack","make_formatter","output","flush","ppf","formatter_of_out_channel","formatter_of_buffer","pp_make_buffer","stdbuf","err_formatter","f$0","flush_buffer_formatter","flush_str_formatter","print_string","print_flush","set_mark_tags","tag_acc","output_acc$0","bty","p$5","p$6","f$1","size$1","kfprintf$0","ksprintf$0","sprintf$0","kasprintf","asprintf","create$2","iname","scan_raise_at_end","from_ic","scan_close_ic","eof","register_exception","slot","copy$2","o$0","initial_object_size","public_method_label","tag","compare$0","compare$1","compare$2","table_count","dummy_met","fit_size","new_table","pub_labels","methods","resize$1","array","new_size","old_size","new_buck","put","label","element","method_count","inst_var_count","new_method","table","get_method_label","get_method_labels","names","set_method","new_slot","new_variable","to_array","arr","new_methods_variables","meths","vals","meths$0","nmeths","nvals","create_table","public_methods","met","lab","init_class","make_class_store","pub_meths","class_init","init_table","env_init","create_object_opt","obj_0","obj","get_const","get_var","get_env","get_meth","set_var","app_const","app_var","app_env","app_meth","app_const_const","app_const_var","app_const_meth","app_var_const","app_meth_const","app_const_env","app_env_const","meth_app_const","meth_app_var","meth_app_env","meth_app_meth","send_const","send_var","send_env","send_meth","new_cache","method_impl","clo","n$2","n$3","n$4","f$2","n$5","f$3","f$4","x$2","n$6","f$5","x$3","n$7","f$6","x$4","n$8","f$7","n$9","x$5","f$8","e$2","n$10","x$6","f$9","n$11","x$7","n$12","x$8","n$13","n$14","e$3","n$15","m$2","x$9","m$3","n$16","m$4","e$4","n$17","m$5","n$18","set_methods","generic_quote","quotequote","generic_basename","is_dir_sep","find_beg","find_end","generic_dirname","intermediate_sep","base","trailing_sep","quote","basename","is_dir_sep$0","is_relative","is_implicit","check_suffix","suff","temp_dir_name","quote$0","add_bs","loop$0","loop_bs","has_drive","is_letter","drive_and_path","dirname","path","drive","dir","basename$0","basename$1","dirname$0","dir_sep$2","is_dir_sep$1","basename$2","concat$0","filename","map_signature$0","mapper","map_structure$0","id","shallow_identity","fail","make_top_mapper","signature","structure","map_signature$1","map_structure$1","id$0","shallow_identity$0","fail$0","make_top_mapper$0","doc_loc","docs_attr","ds","exp","item","add_docs_attrs$0","docs","attrs","attrs$0","attrs$1","empty_info$0","add_info_attrs$0","info","text_loc","text_attr$0","add_text_attrs$0","dsl","fdsl","mk$22","loc","sth$0","attr$6","any$1","var$2","arrow$1","tuple$2","constr$2","object$1","class$3","alias$2","variant$2","poly$1","package$1","extension$10","force_poly$0","mk$23","attr$7","any$2","var$3","alias$3","constant$3","interval$0","tuple$3","construct$1","variant$3","record$2","array$1","or$0","constraint$5","type$2","lazy$1","unpack$1","open$3","exception$2","extension$11","mk$24","attr$8","ident$3","constant$4","let$2","fun$1","function$1","apply$3","match$1","try$1","tuple$4","construct$2","variant$4","record$3","field$2","setfield$0","array$2","ifthenelse$0","sequence$1","while$1","for$1","constraint$6","coerce$0","send$0","new$1","setinstvar$0","override$0","letmodule$0","letexception$0","assert$0","lazy$2","poly$2","object$2","newtype$0","pack$0","open$4","extension$12","unreachable$0","case$2","lhs","guard","rhs","mk$25","attr$9","ident$4","alias$4","signature$4","functor$1","with$1","typeof$1","extension$13","mk$26","attr$10","ident$5","structure$3","functor$2","arg_ty","body","apply$4","constraint$7","mty","unpack$2","extension$14","mk$27","value$1","type$3","rec_flag","type_extension$1","exception$3","module$2","rec_module$1","modtype$3","open$5","include$2","class$4","class_type$4","extension$15","attribute$3","mk$28","eval$1","value$2","primitive$1","type$4","type_extension$2","exception$4","module$3","rec_module$2","modtype$4","open$6","class$5","class_type$5","include$3","extension$16","attribute$4","mk$29","attr$11","constr$3","structure$4","fun$2","apply$5","let$3","constraint$8","extension$17","mk$30","attr$12","constr$4","signature$5","arrow$2","extension$18","mk$31","sth$1","inherit$1","val$1","method$1","constraint$9","extension$19","attribute$5","mk$32","inherit$2","val$2","method$2","constraint$10","initializer$0","extension$20","attribute$6","mk$33","typ","sth$2","prim","mk$34","text","mk$35","mk$36","expr","mk$37","lid","override","mk$38","mexpr","mk$39","pat","mk$40","sth$3","virt","sth$4","mk$41","manifest","cstrs","sth$5","kind","sth$6","priv","constructor$1","args","field$3","mut","mk$42","constructors","constructor$2","decl$0","rebind$0","mk$43","self","mk$44","map_fst$0","map_snd$0","map_tuple$0","f1","map_tuple3$0","f3","z","map_opt$0","map_loc$0","row_field$2","map$9","desc","loc$0","tyl","tl$0","lid$0","t$0","sl","lid$1","map_type_declaration$0","ptype_loc","ptype_attributes","ptype_manifest","ptype_private","ptype_kind","ptype_cstrs","ptype_params","ptype_name","map_type_kind$0","map_constructor_arguments$0","map_type_extension$0","ptyext_attributes","ptyext_private","ptyext_constructors","ptyext_params","ptyext_path","map_extension_constructor_kind$0","cto","ctl","li","map_extension_constructor$0","pext_attributes","pext_loc","pext_kind","pext_name","map$10","tys","ct","map_field$1","map_signature$2","pcsig_fields","pcsig_self","map$11","sg","mt2","mt1","mt","me","map_with_constraint$0","lid2","map_signature_item$0","vd","te","map$12","map_structure_item$0","vbs","map$13","pel","def","pel$0","pel$1","el","eo","lab$0","eo$0","el$0","e3","e3$0","e2$3","e1$3","e$5","e$6","e$7","lid$2","e$8","sel","e$9","e$10","cd","e$11","e$12","e$13","cls","e$14","s$2","me$0","e$15","lid$3","ovf","map$14","c2","c1","pl","cf","lpl","pl$0","p2","p1","map$15","ce","ce$0","ce$1","ce$2","map_kind$1","map_field$2","map_structure$2","pcstr_fields","pcstr_self","class_infos$1","pci_attributes","pci_loc","pci_expr","pci_name","pci_virt","this$0","pval_loc","pval_attributes","pval_prim","pval_type","pval_name","pvb_loc","pvb_attributes","pvb_expr","pvb_pat","popen_attributes","popen_loc","popen_override","popen_lid","pmtd_loc","pmtd_attributes","pmtd_type","pmtd_name","pmd_loc","pmd_attributes","pmd_type","pmd_name","pmb_loc","pmb_attributes","pmb_expr","pmb_name","pld_attributes","pld_loc","pld_type","pld_mutable","pld_name","pincl_attributes","pincl_loc","pincl_mod","pcd_attributes","pcd_loc","pcd_res","pcd_args","pcd_name","pc_rhs","pc_guard","pc_lhs","default_mapper","map_signature$3","map_structure$3","id$1","shallow_identity$1","fail$1","make_top_mapper$1","map_signature$4","map_structure$4","id$2","shallow_identity$2","fail$2","make_top_mapper$2","map_signature$5","map_structure$5","id$3","shallow_identity$3","fail$3","make_top_mapper$3","pexp_attributes","pexp_loc","pexp_desc","x0$2","x0$3","x1$1","x0$4","x1$2","x0$5","x1$3","x0$6","x0$7","x1$4","x0$8","x1$5","x0$9","x1$6","x0$10","x1$7","x0$11","x2$1","x1$8","x0$12","x0$13","x2$2","x1$9","x0$14","x1$10","x0$15","x1$11","x0$16","x3$0","x2$3","x1$12","x0$17","x1$13","x0$18","x2$4","x1$14","x0$19","x1$15","x0$20","x0$21","x1$16","x0$22","x0$23","x2$5","x1$17","x0$24","x0$25","x0$26","x1$18","x0$27","x0$28","x1$19","x0$29","x0$30","x2$6","x1$20","x0$31","x0$32","ppat_attributes","ppat_loc","ppat_desc","ptyp_attributes","ptyp_loc","ptyp_desc","pstr_loc","pstr_desc","types","recflag","f0","pci_params","pcl_attributes","pcl_loc","pcl_desc","pcf_attributes","pcf_loc","pcf_desc","pmod_attributes","pmod_loc","pmod_desc","pmty_attributes","pmty_loc","pmty_desc","psig_loc","psig_desc","pcty_attributes","pcty_loc","pcty_desc","pctf_attributes","pctf_loc","pctf_desc","loc_ghost","loc_end","loc_start","pos_cnum","pos_bol","pos_lnum","pos_fname","is_nonrec","attr","types$0","xs","x4$0","otype_cstrs","otype_private","otype_type","otype_params","otype_name","oext_private","oext_ret_type","oext_args","oext_type_params","oext_type_name","oext_name","otyext_private","otyext_constructors","otyext_params","otyext_name","ident","location","feature","oval_prims","oval_type","oval_name","copy_mapper","with_constraint","value_description","value_binding","type_kind","type_extension","type_declaration","structure_item","signature_item","payload","open_description","module_type_declaration","module_type","module_expr","module_declaration","module_binding","label_declaration","include_description","include_declaration","extension_constructor","extension","constructor_declaration","class_type_field","class_type_declaration","class_type","class_structure","class_signature","class_field","class_expr","class_description","class_declaration","cases","case$0","attributes","attribute","copy_mapper$0","oval_attributes","otype_immediate","oattr_name","copy_mapper$1","copy_mapper$2","x1$21","x0$33","otype_unboxed","copy_mapper$3","copy_mapper$4","copy_mapper$5","copy_mapper$6","languageOfString","stringOfLanguage","lang","typeOfString","string_of_code","printer","code","parseRE","parseML","parseREI","parseMLI","printML","implementation","printMLI","printRE","loc1","loc2","col1","line1","col2","line2","errors","prev","error","prevLoc","error$0","error$1","curr","error$2","error$3","optionLoc","prevLoc$0","inLang","message","inLang$0","message$0","inLang$1","message$1","inType","outLang","parsersToTry","parser","results","ast","ast$0","ast$1","ast$2","trueOut","printedResult","trueIn","err","jsString"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCvB4IFrkC;;;4C;;;;;;;;;;4BkB7JAg5B;;;;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAAAA;;;;;;;;;;;2C;;;;;;4BAAAA;;;;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oElBmPA33B;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBsBwtBA+iC,oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBrB75BI1/B;6C;;;;;;;;;;iDFobA;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eEpbAA;;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDFobA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;6C;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CiBlfJkV;4C;;;;;+CAAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OJ4LA/H;;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDbsTI,wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DAAA;;;8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBEpYAtM;iD;;;;;;;;;;;wBAAAA;iD;;;;;;;;;;wBAAAA;iD;uCAgBAE;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFoXA;;sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;sC;;;;;;;;eExYAJ;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAtDA7D,kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDF8bA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCE9bAA,mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDF8bA;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCiBlfJoY;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDjBkfI;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CiBlfJA;oC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6CAAAA;qC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDjBkfI;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCiBlfJA;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BfmEI9U,8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBA6IJ6B;oC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDFkSI;;;;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BiBlfJiT;sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDjBkfI;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBEpbAlV;oC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DFobA;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;;;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAAA;;;;;;;;;;;;;;;;;;;;;;;;;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BEpYAa;sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFoYA;;;;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+DAAA;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDEvUJU;iD;;;;;;;;;;;;;;;;;;;;;;;;;0DFuUI;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;yC;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8BE/aAnB;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wEF+aA;;8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEAAA;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;;;;;;;;;;;;;;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uEAAA;sE;;;;;;;;;;;;;;;;;iDAAA;;;;;;;;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iEAAA;;;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAAA;;iE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBEpYAS;;sD;;;;;;gEFoYA;;gE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CEveJ9B;2C;;;;;;;;;;;;;;;;;mDAAAA,uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFueI;;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eExYA4B;;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DFwYA;;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAAA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;gE;;;;;;;;;;;;;wBEhdAf;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFgdA;;;;;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;;;qD;;;;;;;;;;;;;yBEhYAkB;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDFgYA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;;;;;;;;;;;6D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;;;;;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;;;;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BE9bAhE,kD;;;;;;;;;;;;;;;;;;;;;;iDF8bA;qC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBE9bAA;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDF8bA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAAA;;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uEAAA;;;gE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BE9bAA,wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDF8bA;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;;;;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iEAAA;6D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA,wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBIpdJoH;;iB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BFsBIpH,uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDF8bA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAAA;;qE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAAA;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mEAAA;;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QwBjdF6iC;wC;;;;;;;;;mBAAAA;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDxBidE;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qEAAA;sE;;;;;;;;qBExYAh/B;;2D;;;;;;;;;kCAoBAI,kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDFoXA;;;;;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBUzdJsI;;;;iD;;;;;;;;;;;;;;;;;;;wBCFAE;;;;iD;;;;;;;;;;;;;;;;;;;;wBCFAE;;;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBVyCIzJ;;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFobA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCE1aAK;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDF0aA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBEpbAL;;;;;;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFobA;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAAA;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA,uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;;;;;;;;;;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAAA;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+DAAA;;;;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAAA;;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBEhdAJ;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDFgdA;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDE1aAS;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDF0aA;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDE1aAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAtCAT;;qD;;;;;;;;wBAAAA;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFgdA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDE9bA9C;;iD;;;;;;;;;;;;;;;;4CAAAA;;;;;;;;;;;;;wD;;qDF8bA;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDE9bAA;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+DF8bA;;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA,sD;;;;;;;;;;;;;;;;;;;;mDsBhSJk8B;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDtBgSI;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;;;;;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uBExYAr4B;;8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDFwYA;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DEpXAI,6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDFoXA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCE9bAjE,sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BepDJoY;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDjBkfI;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+BiBlfJA;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BfkCItV;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEFgdA;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;uC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAAA;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAAA;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;;;;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBE9bA9C;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAAAA;;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAAAA;;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DF8bA;;;;;;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBCnaJ1B;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAqLAwB;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDD8OI;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aE/aAwD;;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6CenEJ8U;2C;;;;;;;;;;;gDT8BAvN;;;iDAJAF;;+D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDRwdI;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBClaJpM,QADAD;;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDDmaI;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBClaJC,QADAD;;4C;;;;;;;wBACAC,QADAD,8D;;;;;;;;;;;;;2BACAC,QADAD,+D;;;;;;;;;;;;;;;;;;;;;;uDDmaI;;8E;;;;uBCnaJA;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDDmaI;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2BCnaJA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YuB9CEukC;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDxBidE;;;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBEpYA9+B;0C;wBAAAA;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDFoYA;;oD;;;;;;;;;;;;;;;;;;;;;sBEpZAJ;;;;;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2CAhCAT;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDFobA;qD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;0D;;;;;;;;;;;;;;;;;;;;;;;mDAAA;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBQtdJ0H;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDRsdI;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA,0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDAAA;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BQpdJC;;mE;;;;;;;;;;;;;;;2BAAAA;;iE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDRodI;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;;;;oD;mBEpbA3H;;+D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDFobA;oD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;;;;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;+C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;8C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8DAAA;;;kE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;yC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+DC9OJpD;;sD;;;;;;;;;;;;;;+DAAAA;;;4C;;;;;;;;;;;;;;+DAAAA;;4C;;;;;;;;;;;;;;;;+DAAAA;;;;4C;;;6DAAAA;sD;;;6DAAAA;sD;;;;+DAAAA;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCPpQc;;;;SA4pFZhH,sBACAC;kCA7pFY,SAgqFds1C,gBAAcC;sCAAS;eAATA,kDAA2C;kCAhqF3C,SAiqFdC,gBAAcD;sCAAS;eAATA,kDAA2C;kCAjqF3C,SAoqFZE,SAAKvwC;sCAAI,OAAJA,iCAAK;kCApqFE;KAmqFdwwC;;OACED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCApqFY,SAktFZE;qCACF;qDAA0E;kCAntF5D,SAiwFdC;MAAiBC,UAAWC;qCAC9B,qBAEqC5wC;wCAAK;iBAHZ4wC,UAGO5wC,kCAAgB;qCAFrD;cAhDIywC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAiDiCzwC;gDAAK;yBAFvB2wC,UAEkB3wC,kCAAgB;cAjDjDywC;;;;;;;;;mDAkDoD;kCCpwFxC;;;;SAgwFZ11C,wBACAC;kCAjwFY,SAowFd61C,gBAAcR;sCAAS;eAATA,kDAA2C;kCApwF3C,SAqwFdS,gBAAcT;sCAAS;eAATA,kDAA2C;kCArwF3C,SAwwFZU,WAAK/wC;sCAAI,OAAJA,iCAAK;kCAxwFE;KAuwFdgxC;;OACED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAxwFY,SAszFZE;qCACF;qDAA0E;kCAvzF5D,SAq2FdC;MAAiBP,UAAWC;qCAC9B,qBAEqC5wC;wCAAK;iBAHZ4wC,UAGO5wC,kCAAgB;qCAFrD;cAhDIixC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAiDiCjxC;gDAAK;yBAFvB2wC,UAEkB3wC,kCAAgB;cAjDjDixC;;;;;;;;;qDAkDoD;kCCx2FxC;;;2CA+9BZG,UAAUC;qCAEZ;mDAFYA;sCAEZ,WAAIC;qCAAJ,UAJEH,cASEI,yCAGoB;kCAz+BV,SA2+BZC,iBAAeC,KAAKC;qCACtB;;QADiBD;qCACjB;;;;UAAIE,2CAGW,iBAJOD;;;;;;iDIzflB;WJ0fAC,QADkBD;qCACtB,+BAKA;;QANiBD;qCAMjB;;;yCAGe;;0CAAS;;UAHpBG,wCAGW,OARXD;;;;;;uBAKAC,QALAD;qCAUJ,OALIC,sCAKC;kCAt/BS;KA4/BZC;;kCA5/BY,SAggCZC,iBAAeC,KAAKL;qCACtB,GADiBK;;;0CAGJ;;;0CAAS;mBAHAL;sDAGA;sCADW,OAFXA,qCAGa;kCAngCrB;KA2gCZM;;kCA3gCY,SA6gCZC,YAAUZ;qCAEZ;mDAFYA;sCAEZ,WAAIC;qCAAJ,UAJEU,eASET,yCAGqB;kCAvhCX,SAyhCZW,iBAAeC,IAAIT;qCACrB;wCAAuB;;;kDAA6C;sCAAzD;OAAPU;wCAAO;0DADMD;qCAEjB;kDAdEF,YAaEG,MADiBV,sCAEY;kCA3hCnB,SAg+CVW,MAAKtW,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,sCAC2B;kCAj+C5C,SAk+CVc,OAAKtpC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCAl+CnD,SAo+CVupC,MAAKH,IAAKZ;sCAAW;eAAhBY,IAAKZ,wCAAkC;kCAp+ClC,SAq+CVgB,MAAKJ,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAA+B;kCAr+CrC,SAs+CV2wC,QAAOL,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAAyC;kCAt+CrD,SAu+CVkwC,QAAON,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCAv+CzC,SAw+CV6wC,SAAQP,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAuC;kCAx+ClD,SAy+CV+xC,SAASR,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAuC;kCAz+CnD,SA0+CVgyC,QAAQT,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCA1+CjD,SA2+CViyC,QAAOV,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCA3+ChD,SA4+CVkyC,UAASX,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAA2C;kCA5+CzD,SA6+CVwwC,OAAMZ,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAqC;kCA7+C9C,SA8+CVoyC,UAASb,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,YAAM1vC,EAAEjB,oCAAwC;kCA9+CpD,SA++CVqyC,aAAWd,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAqC;kCA/+CjD,SAi/CVqxC,aAAW5/B;qCACb;;QADaA;qCACb;;cADaA;sCAGN;kBAHMA,4CAGmB;kCAp/CpB,SAw/CV6/B,MAAKvX,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,sCAC2B;kCAz/C5C,SA0/CV6B,OAAKrqC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCA1/CnD,SA4/CVsqC,MAAKlB,IAAKZ;sCAAW;eAAhBY,IAAKZ,wCAAkC;kCA5/ClC,SA6/CV+B,MAAKnB,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAA+B;kCA7/CrC,SA8/CV0xC,QAAOpB,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCA9/ChD,SA+/CV4yC,WAAUrB,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAoC;kCA//C/C,SAggDV4xC,WAAUtB,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAyC;kCAhgDtD,SAigDV8yC,QAAOvB,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCAjgDzC,SAkgDV8xC,YAAWxB,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAA0C;kCAlgDxD,SAmgDVgzC,UAASzB,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAwC;kCAngDpD,SAogDVizC,SAAQ1B,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAuC;kCApgDlD,SAqgDVkzC,QAAO3B,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCArgDzC,SAsgDVkyC,KAAK5B,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAmC;kCAtgD3C,SAugDVozC,aAAa7B,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAA2C;kCAvgD3D,SAwgDVqzC,OAAO9B,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAgC;kCAxgDxC,SAygDVqyC,OAAO/B,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAgC;kCAzgDxC,SA0gDVsyC,SAAQhC,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAkC;kCA1gD3C,SA2gDVuyC,OAAOjC,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAqC;kCA3gD/C,SA4gDVyzC,YAAYlC,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAqC;kCA5gDlD,SA6gDVyyC,aAAWnC,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAqC;kCA7gDjD,SAihDV0yC,MAAK3Y,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,sCAC2B;kCAlhD5C,SAmhDViD,OAAKzrC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCAnhDnD,SAqhDV0rC,QAAOtC,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCArhDzC,SAshDV6yC,WAAUvC,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAoC;kCAthD/C,SAuhDV8yC,MAAMxC,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAAuC;kCAvhDlD,SAwhDVqyC,MAAMzC,IAAKZ,MAAM1vC,EAAEjB,EAAE2B,EAAEqV;sCAAI;eAArBu6B,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,EAAEqV,mCAA0C;kCAxhDvD,SAyhDVi9B,WAAW1C,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAoC;kCAzhDhD,SA0hDVizC,QAAO3C,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCA1hDhD,SA2hDVm0C,QAAQ5C,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCA3hDjD,SA4hDVo0C,MAAM7C,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAoC;kCA5hD7C,SA6hDVq0C,QAAO9C,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCA7hDzC,SA8hDVqzC,YAAW/C,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAA0C;kCA9hDxD,SA+hDVu0C,UAAShD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAwC;kCA/hDpD,SAgiDVw0C,SAAQjD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAuC;kCAhiDlD,SAiiDVy0C,QAAOlD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAsC;kCAjiDhD,SAkiDV00C,WAAUnD,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,mCAA4C;kCAliD3D,SAmiDVgzC,QAAOpD,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAiC;kCAniDzC,SAoiDV2zC,aAAYrD,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,mCAA8C;kCApiD/D,SAqiDVkzC,WAAUtD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAyC;kCAriDtD,SAsiDV80C,QAAQvD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAsC;kCAtiDjD,SAuiDV+0C,MAAMxD,IAAKZ,MAAM1vC,EAAEjB,EAAE2B,EAAEqV,EAAE3C;sCAAI;eAAvBk9B,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,EAAEqV,EAAE3C,mCAA6C;kCAviD5D,SAwiDV2gC,aAAazD,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAA2C;kCAxiD3D,SAyiDVi1C,SAAQ1D,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,mCAA0C;kCAziDvD,SA0iDVuzC,OAAM3D,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAqC;kCA1iD9C,SA2iDVm1C,MAAM5D,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAA+B;kCA3iDtC,SA4iDVm0C,aAAY7D,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAA2C;kCA5iD1D,SA6iDVq1C,WAAU9D,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAoC;kCA7iD/C,SA8iDVq0C,YAAW/D,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAG;eAAlB4vC,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,mCAA4C;kCA9iD5D,SA+iDV4zC,eAAchE,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAA6C;kCA/iD9D,SAgjDVw1C,SAASjE,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAkC;kCAhjD5C,SAijDVw0C,OAAOlE,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAgC;kCAjjDxC,SAkjDVy0C,OAAMnE,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAqC;kCAljD9C,SAmjDV21C,SAASpE,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAkC;kCAnjD5C,SAojDV20C,UAASrE,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,UAAM1vC,EAAEjB,mCAAwC;kCApjDpD,SAqjDV61C,OAAMtE,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAgC;kCArjDvC,SAsjDV60C,OAAOvE,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,UAAM1vC,EAAEjB,EAAE2B,mCAAwC;kCAtjDpD,SAujDVo0C,aAAWxE,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,UAAM1vC,mCAAqC;kCAvjDjD,SAwjDV+0C,cAAazE,IAAKZ;sCAAW;eAAhBY,IAAKZ,wCAA0C;kCAxjDlD,SA0jDVsF,OAAKC,IAAKC,MAAMC;qCAClB,UADOF,IAAKC,MAAMC,mCAKjB;kCA/jDW,SAmkDVC,MAAKrb,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,sCAC2B;kCApkD5C,SAqkDV2F,OAAKnuC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCArkDnD,SAukDVouC,QAAOhF,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCAvkDzC,SAwkDVu1C,QAAOjF,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAiC;kCAxkDzC,SAykDVw1C,YAAWlF,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAqC;kCAzkDjD,SA0kDVy1C,UAAUnF,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAA2C;kCA1kD1D,SA2kDVg1C,OAAOpF,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAqC;kCA3kD/C,SA4kDV42C,SAASrF,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAkC;kCA5kD5C,SA6kDV41C,aAAWtF,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAqC;kCA7kDjD,SAilDZ61C,MAAK9b,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,sCAC2B;kCAllD1C,SAmlDVoG,QAAK5uC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCAnlDnD,SAqlDV6uC,QAAOzF,IAAKZ,MAAM1xC;sCAAI;eAAfsyC,IAAKZ,SAAM1xC,mCAAiC;kCArlDzC,SAslDVg4C,YAAW1F,IAAKZ,MAAM1xC;sCAAI;eAAfsyC,IAAKZ,SAAM1xC,mCAAqC;kCAtlDjD,SAulDVi4C;MAAU3F,IAAKZ,MAAM9gC,IAAIsnC,OAAOC;qCAClC;eADY7F,IAAKZ,SAAM9gC,IAAIsnC,OAAOC,sCACe;kCAxlDrC,SAylDVC,QAAO9F,IAAKZ,MAAMp4B,GAAGC;sCAAK;eAAnB+4B,IAAKZ,SAAMp4B,GAAGC,oCAAyC;kCAzlDpD,SA0lDV8+B,aAAa/F,IAAKZ,MAAMr5B,EAAEigC;sCAAM;eAAnBhG,IAAKZ,SAAMr5B,EAAEigC,qCAA+C;kCA1lD/D,SA2lDVC,SAAQjG,IAAKZ,MAAMt8B;sCAAI;eAAfk9B,IAAKZ,SAAMt8B,mCAAkC;kCA3lD3C,SA4lDVojC,aAAWlG,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAqC;kCA5lDjD,SAgmDVy2C,MAAK1c,IAAoBhkB;sCAAI,GAAxBgkB;uCAAM;4CAANA;YAAME;;WAANqW;sCAAwB,UAAJv6B,EAApBu6B,oCAAuD;kCAhmDlD,SAkmDVoG,QAAOpG,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA0B;kCAlmD3B,SAmmDV22C,OAAOrG,IAAIsG,SAAS52C;sCAAI;eAAjBswC,OAAIsG,SAAS52C,mCAAqC;kCAnmD/C,SAomDV62C,iBAAgBvG,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA2B;kCApmDrC,SAqmDV82C,YAAYxG,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA8B;kCArmDpC,SAsmDV+2C,SAASzG,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA2B;kCAtmD9B,SAumDVg3C,aAAY1G,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA8B;kCAvmDpC,SAwmDVi3C,UAAS3G,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA4B;kCAxmD/B,SAymDVk3C,OAAO5G,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAAyB;kCAzmD1B,SA0mDVm3C,UAAU7G,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA4B;kCA1mDhC,SA2mDVo3C,QAAQ9G,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA0B;kCA3mD5B,SA4mDVq3C,aAAY/G,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA+B;kCA5mDrC,SA6mDVs3C,aAAWhH,IAAMvW,IAAY/5B;sCAAI,GAAhB+5B;uCAAQ;4CAARA;cAAQE;;WAARyV;sCAAgB;eAAtBY,QAAkBtwC,EAAZ0vC,uCAAmD;kCA7mD1D,SA8mDV6H,YAAWjH,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA8B;kCA9mDnC,SAunDVw3C,MAAKzd,IAAoBhkB;sCAAI,GAAxBgkB;uCAAM;4CAANA;YAAME;;WAANqW;sCAAwB,UAAJv6B,EAApBu6B,oCAAuD;kCAvnDlD,SAynDVmH,OAAMnH,IAAMvW,IAAY/5B;sCAAI,GAAhB+5B;uCAAQ;4CAARA;cAAQE;;WAARyV;sCAAgB;eAAtBY,OAAkBtwC,EAAZ0vC,uCAA8C;kCAznDhD,SA0nDVgI,QAAOpH,IAAItwC,EAAEjB;sCAAI;eAAVuxC,OAAItwC,EAAEjB,mCAA+B;kCA1nDlC,SA2nDV44C,YAAWrH,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA8B;kCA3nDnC,SA4nDV43C,OAAOtH,IAAIsG,SAAS52C;sCAAI;eAAjBswC,OAAIsG,SAAS52C,mCAAqC;kCA5nD/C,SA6nDV63C,iBAAgBvH,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA2B;kCA7nDrC,SA8nDV83C,YAAYxH,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA8B;kCA9nDpC,SA+nDV+3C,SAASzH,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA2B;kCA/nD9B,SAgoDVg4C,aAAY1H,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA8B;kCAhoDpC,SAioDVi4C,UAAS3H,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAA4B;kCAjoD/B,SAkoDVk4C,OAAO5H,IAAItwC;sCAAI;eAARswC,OAAItwC,mCAAyB;kCAloD1B,SAmoDVm4C,QAAQ7H,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA0B;kCAnoD5B,SAooDVo4C,aAAY9H,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA+B;kCApoDrC,SAqoDVq4C,UAAU/H,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA4B;kCAroDhC,SAsoDVs4C,aAAWhI,IAAMvW,IAAY/5B;sCAAI,GAAhB+5B;uCAAQ;4CAARA;cAAQE;;WAARyV;sCAAgB;eAAtBY,QAAkBtwC,EAAZ0vC,uCAAmD;kCAtoD1D,SAuoDV6I,YAAWjI,IAAItwC;sCAAI;eAARswC,QAAItwC,mCAA8B;kCAvoDnC,SAgpDVw4C,MAAKze,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,qCAK5B;kCArpDW,SAspDV+I,QAAKvxC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAA+B;;gDAA/BA,sDAAsD;kCAtpDjD,SAwpDVwxC,SAAQpI,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAsC;kCAxpDjD,SAypDV45C,YAAWrI,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAoC;kCAzpDhD,SA0pDV44C,MAAMtI,IAAKZ,MAAM1vC,EAAEjB,EAAE2B,EAAEqV;sCAAI;eAArBu6B,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,EAAEqV,mCAAyC;kCA1pDtD,SA2pDV8iC,QAAOvI,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAqC;kCA3pD/C,SA4pDV+5C,MAAMxI,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAAsC;kCA5pDjD,SA6pDVq4C,aAAazI,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAA0C;kCA7pD1D,SA8pDVi6C,aAAW1I,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAoC;kCA9pDhD,SAkqDVi5C,MAAKlf,UAAkChkB;qCACzC,GADOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B,UADyC35B,EAAlCu6B,IAAsBZ,qCAK5B;kCAvqDW,SAwqDVwJ,QAAKhyC,KAAElH;sCAAI;gDAAJA;uCAAI,MAANkH;uCAAgC;;gDAAhCA,sDAAwD;kCAxqDnD,SA0qDViyC,SAAQ7I,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,SAAM1vC,EAAEjB,mCAAuC;kCA1qDlD,SA2qDVq6C,YAAW9I,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAqC;kCA3qDjD,SA4qDVq5C,QAAO/I,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,SAAM1vC,EAAEjB,EAAE2B,mCAAyC;kCA5qDrD,SA6qDV44C,aAAWhJ,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,SAAM1vC,mCAAqC;kCA7qDjD,SAirDVu5C,MAAKxf,gBACqBhkB;qCAC5B,GAFOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCADgB;;QAAPD,KAAO+J;;WAAP/J,KAvtBTx2C;sCA2tBmB;cAJS8c;cADrBu6B;8CAKY,iBAJVb,KADoBC,sCAM5B;kCAvrDW,SAyrDV+J,UAAUnJ,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,WAAM1vC,mCAAmC;kCAzrD9C,SA0rDV05C,MAAMpJ,IAAKZ,MAAM1vC,EAAEjB,EAAE2B,EAAEqV;sCAAI;eAArBu6B,IAAKZ,cAAM1vC,EAAEjB,EAAE2B,EAAEqV,oCAA0C;kCA1rDvD,SA2rDV4jC,SAASrJ,IAAKZ,MAAM1vC,EAAEjB,EAAE2B,EAAEqV;sCAAI;eAArBu6B,IAAKZ,cAAM1vC,EAAEjB,EAAE2B,EAAEqV,oCAA6C;kCA3rD7D,SA4rDV6jC,aAAatJ,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,cAAM1vC,EAAEjB,oCAA2C;kCA5rD3D,SA6rDV86C,aAAWvJ,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,WAAM1vC,mCAAqC;kCA7rDjD,SA8rDV85C,YAAWxJ,IAAItwC;sCAAI;eAARswC,WAAItwC,mCAA8B;kCA9rDnC,SA0sDV+5C,MAAKhgB,gBACkBhkB;qCACzB,GAFOgkB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAhvBNx2C;sCAovBkB;cAJO8c;cADlBu6B;8CAKW,iBAJZb,KADuBC,sCAM5B;kCAhtDW,SAktDVsK,UAAU1J,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,WAAM1vC,EAAEjB,EAAE2B,mCAA0C;kCAltDzD,SAmtDVu5C,MAAM3J,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,cAAM1vC,EAAEjB,EAAE2B,oCAAsC;kCAntDjD,SAotDVw5C,SAAS5J,IAAKZ,MAAM1vC,EAAEjB,EAAE2B;sCAAI;eAAnB4vC,IAAKZ,cAAM1vC,EAAEjB,EAAE2B,oCAAyC;kCAptDvD,SAqtDVy5C,cAAa7J,IAAKZ,MAAM1vC,EAAEjB;sCAAI;eAAjBuxC,IAAKZ,cAAM1vC,EAAEjB,oCAA0C;kCArtD1D,SAstDVq7C,cAAc9J,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,WAAM1vC,mCAAsC;kCAttDrD,SAutDVq6C,aAAW/J,IAAKZ,MAAM1vC;sCAAI;eAAfswC,IAAKZ,WAAM1vC,mCAAoC;kCAvtDhD,SAwtDVs6C,YAAWhK,IAAItwC;sCAAI;eAARswC,WAAItwC,mCAA6B;kCAxtDlC,SAuuDVu6C;MAAKxgB,sBACUt5B,KAAK+5C;qCACtB,GAFOzgB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCAFkD;;QAAPD,KAAO+J;;WAAP/J,KA5wB3Cx2C;qCA8wBA;uCADa;;QAAPyhD,KAAOD;;WAAPC;sCAIa;cAJFj6C;cAAK+5C;cAAhBE;8CAIa,iBALwBjL,KAAdC;cAAtBY,mCAQN;kCA/uDW,SAmvDVqK;MAAK5gB,sBAC+Bt5B,KAAK+5C;qCAC3C,GAFOzgB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAzxBNx2C;qCA0xBA;uCADkC;;QAAP2hD,KAAOH;;WAAPG;sCAKJ;;yDALjBnL,KADuBC;qCAM1B;cALmCjvC;cAAK+5C;6CAKxC,iBALwBI;cADpBtK,mCAQN;kCA3vDW,SA+vDVuK;MAAK9gB,sBACgCygB,IAAI/5C;qCAC3C,GAFOs5B;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAryBNx2C;qCAsyBA;uCADkC;;QAAP2hD,KAAOH;;WAAPG;sCAKJ;;yDALjBnL,KADuBC;qCAM1B;cALwCjvC;cAAJ+5C;6CAKpC,iBALwBI;cADpBtK,mCAQN;kCAvwDW,SA2wDVwK;MAAK/gB,sBAC+Bt5B,KAAKs6C;qCAC3C,GAFOhhB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAjzBNx2C;qCAkzBA;uCADkC;;QAAP2hD,KAAOH;;WAAPG;sCAKJ;;yDALjBnL,KADuBC;qCAM1B;cALmCjvC;cAAKs6C;6CAKxC,iBALwBH;cADpBtK,mCAQN;kCAnxDW,SAuxDV0K,MAAKjhB,sBACiBkhB;qCACxB,GAFOlhB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCAFkD;;QAAPD,KAAO+J;;WAAP/J,KA5zB3Cx2C;qCA8zBA;uCADiB;;QAAXiiD,SAAWT;;WAAXS;sCAKc;cALID;cAAlBC;cADC5K;8CAMa,iBANuBb,KAAdC,sCAO5B;kCA9xDW,SAkyDVyL,MAAKphB,gBAAuDqhB;qCAC9D,GADOrhB;uCAAM;4CAANA;YAAME;;WAANqW;qCACP;uCADqC;;QAARZ,MAAQa;;WAARb;qCAC7B;uCADkD;;QAAPD,KAAO+J;;WAAP/J,KAv0B3Cx2C;sCA20BoB;cAJ0CmiD;cAAvD9K;8CAIa,iBAJuBb,KAAdC,sCAK5B;kCAvyDW,SA4yDV2L;MAAKthB,sBACUuhB,IAAIP;qCACrB,GAFOhhB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEP;uCAFqC;;QAARZ,MAAQa;;WAARb;qCAE7B;uCAFkD;;QAAPD,KAAO+J;;WAAP/J,KAj1B3Cx2C;qCAm1BA;uCADa;;QAAP2hD,KAAOH;;WAAPG;sCAKiB;;yDANoBnL,KAAdC;qCAM1B;cALc4L;cAAIP;6CAKlB,iBALGH;cADCtK,mCAQN;kCApzDW,SAwzDViL;MAAKxhB,kCAE+Bt5B,KAAKs6C;qCAC3C,GAHOhhB;uCAAM;4CAANA;YAAME;;WAANqW;qCAGP;uCAHqC;;QAARZ,MAAQa;;WAARb;qCAG7B;uCAFa;;QAAPD,KAAO+J;;WAAP/J,KA91BNx2C;qCAg2BA;uCAFkC;;QAAP2hD,KAAOH;;WAAPG;qCAE3B;WADaY,eAAPC,KAAOD;;WAAPC;qCACN;WADkCC,eAATliB,OAASkiB;;WAATliB;sCAOF;;yDARjBiW,KADuBC;qCAS1B;cAPG+L;cAAmBjiB;cAAa/4B;cAAKs6C;cAFpCzK;6CASJ,iBARwBsK,2CAU1B;kCAn0DW,SAu0DVe;MAAK5hB,8CAMJ6hB,SACDn7C;qCACF,GAROs5B;uCAAM;4CAANA;YAAME;;WAANqW;qCAQP;uCARqC;;QAARZ,MAAQa;;WAARb;qCAQ7B;uCAPa;;QAAPD,KAAO+J;;WAAP/J,KA72BNx2C;qCAo3BA;uCAPkC;;QAAP2hD,KAAOH;;WAAPG;qCAO3B;WANaY,eAAThiB,OAASgiB;;WAAThiB;qCAMJ;WALYkiB,eAARG,MAAQH;;WAARG;qCAKJ;WAJWC,eAAPC,KAAOD;;WAAPC;qCAIJ;WAHWC,eAAPC,KAAOD;;WAAPC;sCAWmB;;yDAfjBxM,KADuBC;qCAgB1B;cATDjvC;cALE+4B;cACAqiB;cACAE;cACAE;cACDL;6CAUA,iBAfwBhB;cADpBtK,mCAkBN;kCAz1DW,SA21DV4L;MAAcniB,sBACc/uB,IAAIvK;qCAClC,GAFgBs5B;uCAAM;4CAANA;YAAME;;WAANqW;qCAEhB;uCAF8C;;QAARZ,MAAQa;;WAARb;qCAEtC;uCAF2D;;QAAPK,KAAOyJ;;WAAPzJ,KA/1BpDF;qCAi2BA;uCADa;;QAAPsM,KAAO1B;;WAAP0B;sCAMY;cANgB17C;cAA5B07C;cAAwBnxC;cADdslC;8CAOE,iBAPkCP,KAAdL,sCAQrC;kCAn2DW,SAq2DV0M;MAAQriB,sBACat5B,KAAK+5C;qCAC5B,GAFUzgB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEV;uCAFwC;;QAARZ,MAAQa;;WAARb;qCAEhC;uCAFqD;;QAAPK,KAAOyJ;;WAAPzJ,KAz2B9CF;qCA22BA;uCADY;;QAANwM,IAAM5B;;WAAN4B;sCAMY;cANK57C;cAAjB47C;cAAsB7B;cADlBlK;8CAOQ,iBAP4BP,KAAdL,sCAQ/B;kCA72DW,SAm3DV4M;MAAKviB,sBAC6B0T,KAAK8O;qCACzC,GAFOxiB;uCAAQ;4CAARA;cAAQE;;WAARyV;qCAEP;uCAF4B;;QAAPD,KAAOc;;WAAPd,KAx5BrBx2C;qCA05BA;uCADe;;QAATugC,OAASggB;;WAAThgB;qCACN;uCAD4B;;QAAPyiB,KAAOxB;;WAAPwB;sCAMA;cANexO;cAA9BjU;cAAmC+iB;cAApBN;8CAMA,iBAPAxM,KAAdC,sCAQN;kCA33DW,SA63DV8M;MAAcziB,sBAC8Bt5B,KAAKs7C;qCACnD,GAFgBhiB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEhB;uCAF8C;;QAARZ,MAAQa;;WAARb;qCAEtC;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAn6BNx2C;qCAo6BA;uCADkC;;QAAP82C,KAAO0K;;WAAP1K,KAl4B3BF;sCAu4BuC;;yDALZE,KADWL;sCAMnB;cAL2BjvC;cAAKs7C;cADnCzL;8CAMG,iBALbb,2CAML;kCAp4DW,SAs4DVgN;MAAO1iB,4BAC+C/uB,IAAIvK;qCAC5D,GAFSs5B;uCAAM;4CAANA;YAAME;;WAANqW;qCAET;uCAFuC;;QAARZ,MAAQa;;WAARb;qCAE/B;uCAFoD;;QAAPD,KAAO+J;;WAAP/J,KA36B7Cx2C;qCA66BA;uCADkB;;QAAP82C,KAAO0K;;WAAP1K,KA34BXF;qCA44BA;WADuC2L,eAAPW,KAAOX;;WAAPW;sCAKO;;yDAL5BpM,KADoBL;sCAMZ;cALyCjvC;iBAA5B07C,KAAwBnxC;cAD/CslC;8CAMU,iBAN0Bb,2CAO5C;kCA74DW,SA+4DViN;MAAS3iB,sBACmCt5B,KAAKw6C;qCACnD,GAFWlhB;uCAAM;4CAANA;YAAME;;WAANqW;qCAEX;uCAFyC;;QAARZ,MAAQa;;WAARb;qCAEjC;uCADa;;QAAPD,KAAO+J;;WAAP/J,KAr7BNx2C;qCAs7BA;uCADkC;;QAAP82C,KAAO0K;;WAAP1K,KAp5B3BF;sCAy5BuC;;yDALZE,KADML;sCAMd;cAL2BjvC;iBAAKw6C;cADxC3K;8CAMQ,iBALbb,2CAML;kCAt5DW,SA25DVkN,MAAGC,KAAKjlB;qCACV,UADKilB,KAAKjlB,sCAIT;kCA/5DW,SAm6DVklB,MAAGD,KAAKjlB;qCACV,UADKilB,KAAKjlB,sCAIT;kCAv6DW,SAolEZmlB,UAAQp/C;UAAMO,WAAHD;sCAAS;yDAAZN,EAAGM;cAAGC;kCAplEF,SAqlEZ8+C,UAAQr/C;UAAMO,WAAHD;sCAAY;cAAZA;8CAAY,WAAfN,EAAMO;kCArlEF,SAslEZ++C,YAAUC,GAAGp9B;sCAAmB;OAAZ5hB;OAAHD;uCAAe;mDAAnB6hB,GAAO5hB;sCAAM;yDAAhBg/C,GAAOj/C;;kCAtlEL,SAulEZk/C,aAAWD,GAAGp9B,GAAGs9B;sCAA4B;OAAlBC;OAAHn/C;OAAHD;uCAAwB;mDAA5Bm/C,GAAUC;uCAAY;mDAAzBv9B,GAAU5hB;sCAAS;yDAAtBg/C,GAAUj/C;;;kCAvlET,SAwlEZq/C,UAAQ3/C;iB;wCAAsC;SAALM;;wCAAU;2DAA3CN,EAAiCM;sCAAZ;kCAxlEjB,SA0lEZs/C,UAAQ/1C;UAAK+oC,aAAK72C,mBAAV8N;sCAAwB;cAAd9N;8CAAc,iBAAxB8N,IAAK+oC;kCA1lED,SA+lEViN,YAAUh2C;iB;wCAEuC;SAD9B9H;SAAHV;SAAP2wC;SAAHxwC;eADIqI;yCAEuC;2DAFvCA;yCAE8B;oDADrB9H;yCACqB,MAF9B8H;wCAEC;gBADLrI;gDACK,iBAFDqI,IACDmoC;gBAAO3wC;;sCAEF;;6CAHJwI;sCAGa;+DAHbA,IAGDkK;kCAlmEC,SAomEV+rC,MAAIj2C;sCAEI;OAFqDmoC;OAAvBY;OAAjBmN;aAAjBl2C;uCAEI;yDAFJA,IAAkC+oC;uCAE9B,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,UAHW+N;uCAKT;mBAHVC,UACA/N;;uCAAQ,OAHW8N;;0CAMP;WAAL5/C;YANY4/C;0CAMP;sBAJZC,UACA/N,SAGO9xC;;0CAEgC;WADpBwH,GAPAo4C;WAOJl4C,GAPIk4C;WAOTxW,IAPSwW;iBAAjBl2C;2CAQqC;6DARrCA,IAOiBlC;2CACoB,MARrCkC;0CAQoB;sBANtBm2C;sBACA/N;mBAIU1I;mDACY,iBARpB1/B,IAOahC;;;0CAEC;+CATGk4C;2CASH,MATdl2C;2CAS0C;6DAT1CA;0CASgC;sBAPlCm2C;sBACA/N;mDAMkC,UAAzBgO;;0CAEsC;WAD/Bl+C,GAVGg+C;WAURxC,IAVQwC;iBAAjBl2C;2CAW6C;6DAX7CA;2CAWmC;sDADrB9H;0CACG;sBATnBi+C;sBACA/N;mDAQmB,UAXjBpoC,IAUS0zC;;;;WAEG3vB,EAZKmyB;WAYRv+C,EAZQu+C;WAaf//C;;8CAAwC;eAA/B+T;eAAHzR;eAAHnC;qBAbL0J;+CAa0C;iEAb1CA,IAaWkK;+CAA+B,MAb1ClK;8CAaoB;sBAAf1J;sDAAe,iBAbpB0J,IAaQvH;;0CACU;sBAZpB09C;sBACA/N;mDAWoB,IADhBjyC,EADOwB;mBAAGosB;;0CAIiC;WADhCsyB,KAfIH;WAeTI,MAfSJ;iBAAjBl2C;2CAgB6C;6DAhB7CA;2CAgBmC;sDADtBq2C;0CACI;sBAdnBF;sBACA/N;mDAamB,UAhBjBpoC,IAeQs2C;;;cAEGh3C,IAjBM42C,QAiBThsC,EAjBSgsC,cAAjBl2C;0CAiBmC;sBAfrCm2C;sBACA/N;mDAcqC,iBAjBnCpoC,IAiBQkK;mBAAG5K;;0CAEiB;WADXiK,GAlBA2sC;WAkBH1+C,EAlBG0+C;WAkBPrsC,GAlBOqsC;2CAmBW;uC,OAxBhCF,YAKIh2C;0CAmBkB;sBAjBpBm2C;sBACA/N;mDAgBoB,UADRv+B;mBAAIrS;mBAAG+R;;cAENgtC,IApBML,QAoBVM,GApBUN,cAAjBl2C;0CAoBqC;sBAlBvCm2C;sBACA/N;mBAiBSoO;mDAA8B,iBApBrCx2C,IAoBWu2C;;0CAGwB;iBAvBlBL;WAqBFv7C;WAAL87C;iBArBVz2C;2CAuBmC;6DAvBnCA;2CAuBqB;uC,OAjC3B+1C,UAUM/1C;2CAuBU;uC,OArChBy1C;2CAqCM;sDAFe96C;0CACG;sBApBpBw7C;sBACA/N;mDAmBoB,UAtBlBpoC,IAqBUy2C;;;0CAGM;6CAxBCP;2CAwBD,MAxBhBl2C;0CAwBsC;sBAtBxCm2C;sBACA/N;mDAqBwC,iBAxBtCpoC,IAwBWvJ;kCA5nEL,SA8nEVigD,uBAAqB12C;sCAOf;OADL22C;OADAC;OADAC;OADAC;OADAC;OAD0BC;OAAdC;OAAZC;uCAMK;kDAPel3C,IACpBk3C;uCAMK,MAPel3C;uCAcF;yDAdEA;uCAcX;wDAVT62C;uCAUS,SAXTC;uCAWS,MAdW92C;uCAaf;4DAbeA,IAEpB+2C;uCAWK,MAbe/2C;uCAW6B;yDAX7BA;uCAW6B,MAX7BA;uCAWe;yDAXfA;uCAWe,MAXfA;uCAWC;yDAXDA;sCAWX;mB,OAlDZ21C;sCAiDS;;qDAToBqB;uCASpB,MAVch3C;uCAQM;yDARNA;sCAQH;mB,OAlDpBu1C;sCAkDU;;qDAPK0B;uCAOL;;6CARaj3C;uCAgBd;;;iBAhBcA,IAKpB42C;uCAWM,MAhBc52C;sCAehB;;;wBAfgBA,IAMpB22C;;;;;;;;;;kCApoES,SAgpEVQ,gBAAcn3C;iB;;;;0CAGZ;;iDAHYA;2CAGY;6DAHZA;0CAGE;4DADFrI;wCAEI;;+CAJJqI;yCAI2B;2DAJ3BA;wCAIiB;0DAAlBrF;kCAppEH,SAupEVy8C;MAA0Bp3C;iB;wCACT;;+CADSA;yCACa;2DADbA;wCACG;0DAAjBrI;sCAEV;;6CAHwBqI;uCAGD;yDAHCA;sCAGX;wDADFrF;kCAzpEH,SA4pEV08C,qBAAmBr3C;sCAOT;OAHTs3C;OADAC;OADAC;OADaC;OAAbC;aADkB13C;uCAOT;yDAPSA;sCAOnB;iDALCw3C;sCAID;iDANmBx3C,IAClB03C;sCAKD,SAHCH;sCAGD,MANmBv3C;uCAQQ;yDARRA;sCAQD;mB,OAhFpBu1C;sCAgFU;;qDAPMkC;uCAON;6CARWz3C;sCAUZ;;;wBAVYA,IAIlBs3C;;;;;;kCAhqES,SAwqEVK;MAA+B33C;iB;wCAEwB;SADxC43C;SAALC;eADqB73C;yCAEwB;2DAFxBA;yCAEgB;0DADhC43C;wCACH;;kBAFmB53C,IACrB63C;;sCAGR;OADUC;;sCACE;wDAJiB93C,IAGnB83C;kCA3qEF,SA8qEVC;MAA0B/3C;qCAO1B;OAHCg4C;OADAC;OADAC;OADAC;sCAMD;;UAP0Bn4C,IAEzBk4C;sCAID;iDAN0Bl4C,IACzBm4C;sCAKD;;4CAN0Bn4C;uCASnB;;0DATmBA,IAIzBg4C;uCAKM,MATmBh4C;sCAQrB;;iEARqBA,IAGzBi4C;;;;;;kCAjrES,SA8rEVG,OAAIp4C;sCAEI;OAFqDmoC;OAAzCY;OAAiBmN;aAAjCl2C;uCAEI;yDAFJA,IAAgB+oC;uCAEZ,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,OAH2B+N;;yCAMY;UAD/BmC,IALmBnC;UAKxBxC,IALwBwC;gBAAjCl2C;0CAM6C;4DAN7CA;0CAMmC;qDADrBq4C;yCACG;qBAJnBlC;qBACA/N;kDAGmB,UANjBpoC,IAKS0zC;;;yCAEO;4CAPiBwC;0CAOjB,MAPhBl2C;yCAOsC;qBALxCm2C;qBACA/N;kDAIwC,iBAPtCpoC,IAOWvJ;;yCAEyB;UADpB6hD,GARiBpC;UAQpBhsC,EARoBgsC;UAQzBxW,IARyBwW;gBAAjCl2C;0CASoC;4DATpCA,IAQgBs4C;0CACoB,MATpCt4C;yCASoB;qBAPtBm2C;qBACA/N;kBAKU1I;kDACY,iBATpB1/B,IAQakK;;;yCAEG;8CAViBgsC;0CAUjB,MAVhBl2C;yCAUsC;qBARxCm2C;qBACA/N;kDAOwC,iBAVtCpoC,IAUWqyB;kCAxsEL,SA0sEVkmB,YAAUv4C;sCAGF;OAH2DmoC;OAAvBY;OAAjBmN;aAAjBl2C;uCAGF;yDAHEA,IAAkC+oC;uCAGpC,MAHE/oC;uCAIA;yDAJAA,IAAyDmoC;sCAIzD,OAJiB+N;;yCAMR;6CANQA;0CAMR,MANTl2C;yCAM8B;qBAHtCm2C;qBACA/N;kDAEsC,iBAN9BpoC,IAMGs4C;;;gBANcpC;UAORhsC;UAAHlH;UAAH8L;UAAHxY;gBAPA0J;yCAOsC;qBAJ9Cm2C;qBACA/N;kBAGQ9xC;kBAAGwY;kBAAG9L;kDAAgC,iBAPtChD,IAOSkK;;;kBAPQgsC;UAQLK;UAAH7oC;UAAHpR;UAAHgD;gBARHU;yCAQ4C;qBALpDm2C;qBACA/N;kBAIW9oC;kBAAGhD;kBAAGoR;kDAAmC,iBAR5C1N,IAQYu2C;;yCAEqB;kBAVhBL;UASNp4C;UAAJE;gBATPgC;0CAUiC;4DAVjCA,IASWlC;0CACsB,MAVjCkC;yCAUgB;qBAPxBm2C;qBACA/N;kDAMwB,iBAVhBpoC,IASOhC;;;yCAEG;4CAXOk4C;0CAWP,MAXVl2C;yCAWyB;qBARjCm2C;kDAQiC,iBAXzBn2C,IAWKvJ;;yCACK;8CAZOy/C;0CAYP,MAZVl2C;yCAYgC;qBATxCm2C;qBACA/N;kDAQwC,iBAZhCpoC,IAYKqyB;kCAttEL,SAwtEVmmB,gBAAcx4C;sCAGJ;OAHqBy4C;OAAZC;aAAL14C;uCAGJ;yDAHIA;sCAGd;iDAH+By4C;sCAG/B,MAHcz4C;qCAEd;+DAFcA,IAAK04C;;kCAxtET,SAiuEVC,OAAI34C;sCAEI;OAFqDmoC;OAAvBY;OAAjBmN;aAAjBl2C;uCAEI;yDAFJA,IAAkC+oC;uCAE9B,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,OAHW+N;;yCAKL;UAAL5/C;WALU4/C;yCAKa;qBAHhCC;qBACA/N;kDAEgC,UAL9BpoC,IAKO1J;;yCAEU;6CAPA4/C;0CAOA,MAPjBl2C;yCAOuC;qBALzCm2C;qBACA/N;kDAIyC,iBAPvCpoC,IAOW44C;;yCAIX;UAHkBC,IARD3C;UAQJ4C,IARI5C;UAQP52C,IARO42C;gBAAjBl2C;0CAWA;4DAXAA,IAQkB64C;0CAGlB,MAXA74C;0CAUc;4DAVdA;0CAUA;yDAFa84C;yCACM;qBAPrB3C;qBACA/N;kDAMqB,UATnBpoC,IAQUV;;;;yCAMA;UAFC3H,EAZMu+C;UAYV6C,GAZU7C;gBAAjBl2C;0CAcU;4DAdVA;0CAcA;qDAFWrI;0CAEX,MAdAqI;yCAagB;qBAXlBm2C;qBACA/N;kDAUkB,iBAbhBpoC,IAYO+4C;;;yCAGO;6CAfG7C;0CAeH,MAfdl2C;yCAekC;qBAbpCm2C;qBACA/N;kDAYoC,iBAflCpoC,IAeQg5C;;yCACQ;4CAhBC9C;0CAgBD,MAhBhBl2C;yCAgBsC;qBAdxCm2C;qBACA/N;kDAawC,iBAhBtCpoC,IAgBWvJ;;yCAVC;UAALsV;WANUmqC;yCAMa;qBAJhCC;qBACA/N;kDAGgC,UAN9BpoC,IAMO+L;kCAvuED,SAmvEVktC,sBAAoBj5C;iB;;yCAEW;UADdwO;UAALklC;gBADQ1zC;0CAEW;4DAFXA,IACHwO;yCACH;2DAFMxO,IACR0zC;;;yCAGqB;UADdwF;UAAL5C;0CACmB;qDAJbt2C,IAGDk5C;yCACH;2DAJIl5C,IAGNs2C;;;yCAEO;;gDALDt2C;yCAKiB;kEALjBA,IAKJkP;;yCAEiB;UADdunC;UAAHngD;0CACiB;qDAPb0J,IAMDy2C;yCACD;2DAPEz2C,IAMJ1J;;kCAzvEN,SA4vEV6iD,qBAAmBn5C;sCAEX;OAF6C+oC;OAAjBmN;aAAjBl2C;uCAEX;yDAFWA,IAAkC+oC;sCAE7C,OAF4BmN;;yCAInB;6CAJmBA;0CAInB,MAJEl2C;yCAIS;qBAF1Bm2C;kDAE0B,iBAJTn2C,IAIRo5C;;yCACkC;UAA9BzhD,EALqBu+C;UAKzB9oC,GALyB8oC;gBAAjBl2C;0CAK0B;4DAL1BA;yCAKgB;qBAHjCm2C,OAGS/oC,mCAAwB,UAApBzV;;yCACG;6CANkBu+C;0CAMlB,MANCl2C;yCAMmB;qBAJpCm2C;kDAIoC,iBANnBn2C,IAMPq5C;;yCACS;6CAPenD;0CAOf,MAPFl2C;yCAOkB;qBALnCm2C;kDAKmC,iBAPlBn2C,IAOJyT;;yCACE;4CARmByiC;0CAQnB,MAREl2C;yCAQW;qBAN5Bm2C;kDAM4B,iBARXn2C,IAQPvJ;;yCAEV;8CAVkCy/C;0CAUlC,MAViBl2C;0CAUS;4DAVTA;yCAUD;qBARhBm2C,uCAQgB,UADHx7C;;yCAEG;8CAXkBu7C;0CAWlB,MAXCl2C;yCAWY;qBAT7Bm2C;kDAS6B,iBAXZn2C,IAWNqyB;;yCACE;8CAZqB6jB;0CAYrB,MAZIl2C;yCAYO;qBAVxBm2C;kDAUwB,iBAZPn2C,IAYTsyB;;yCACQ;8CAbkB4jB;0CAalB,MAbCl2C;yCAaa;qBAX9Bm2C;kDAW8B,iBAbbn2C,IAaNsiC;;yCACG;8CAdoB4T;0CAcpB,MAdGl2C;0CAcmB;4DAdnBA;yCAcS;qBAZ1Bm2C,uCAY0B,UAAjBt7C;;yCAET;8CAhBkCq7C;0CAgBlC,MAhBiBl2C;0CAgBS;4DAhBTA;yCAgBD;qBAdhBm2C,uCAcgB,UADF9nC;;yCAII;8CAnBgB6nC;0CAmBhB,MAnBDl2C;yCAmBgB;qBAjBjCm2C;kDAiBiC,iBAnBhBn2C,IAmBJyiC;;yCADE;UADE0F,MAjBiB+N;UAiBpBtT,IAjBoBsT;gBAAjBl2C;0CAkBF;4DAlBEA,IAiBH4iC;0CACC,MAlBE5iC;yCAkB2B;qBAhB5Cm2C;;mDAgB4C,iBAlB3Bn2C,IAiBAmoC;;kCA7wET,SAsxEVmR,OAAIt5C;sCAEI;OAFqDmoC;OAAzCY;OAAiBmN;aAAjCl2C;uCAEI;yDAFJA,IAAgB+oC;uCAEZ,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,OAH2B+N;;yCAKrB;UAALz/C;WAL0By/C;yCAKH;qBAHhCC;qBACA/N;kDAEgC,UAL9BpoC,IAKOvJ;;yCACW;8CANey/C;0CAMf,MANlBl2C;yCAMwC;qBAJ1Cm2C;qBACA/N;kDAG0C,iBANxCpoC,IAMWnL;;yCAIX;UAHuB+5C,KAPUsH;UAOlBvH,OAPkBuH;UAOvB7uC,IAPuB6uC;gBAAjCl2C;0CAUA;4DAVAA,IAOuB4uC;0CAGvB,MAVA5uC;0CASc;4DATdA;0CASA;yDAFe2uC;yCACI;qBANrBwH;qBACA/N;kDAKqB,UARnBpoC,IAOUqH;;;;yCAK+B;UAD7B2I,GAXqBkmC;UAWzBnmC,GAXyBmmC;gBAAjCl2C;0CAYyC;4DAZzCA,IAWYgQ;0CAC6B,MAZzChQ;yCAYgB;qBAVlBm2C;qBACA/N;kDASkB,iBAZhBpoC,IAWQ+P;;;yCAIE;UAFMg/B,IAbiBmH;UAapBpnC,EAboBonC;gBAAjCl2C;0CAeU;4DAfVA,IAagB+uC;0CAEN,MAfV/uC;yCAcsB;qBAZxBm2C;qBACA/N;kDAWwB,iBAdtBpoC,IAaa8O;;;yCAGA;4CAhBoBonC;0CAgBpB,MAhBbl2C;yCAgBgC;qBAdlCm2C;qBACA/N;kDAakC,iBAhBhCpoC,IAgBQ6L;;yCACQ;8CAjBiBqqC;0CAiBjB,MAjBhBl2C;yCAiBsC;qBAfxCm2C;qBACA/N;kDAcwC,iBAjBtCpoC,IAiBWqyB;kCAvyEL,SAyyEVknB,qBAAmBv5C;sCAEX;OAF2B+oC;OAAiBmN;aAAjCl2C;uCAEX;yDAFWA,IAAgB+oC;sCAE3B,OAF4CmN;;yCAKN;UADhC/N,MAJsC+N;UAIzCz/C,EAJyCy/C;gBAAjCl2C;0CAK2B;4DAL3BA,IAIRvJ;0CACmC,MAL3BuJ;yCAKA;qBAHjBm2C;;mDAGiB,iBALAn2C,IAILmoC;;;yCAEgC;UAA/BqR,IANqCtD;UAMxCx8C,EANwCw8C;gBAAjCl2C;0CAM2B;4DAN3BA;yCAMiB;qBAJlCm2C,OAIUz8C,kCAAwB,UAArB8/C;;yCACM;6CAP+BtD;0CAO/B,MAPFl2C;yCAOiB;qBALlCm2C;kDAKkC,iBAPjBn2C,IAOJo5C;;yCAC8B;UAA9BzhD,EARqCu+C;UAQzC9oC,GARyC8oC;gBAAjCl2C;0CAQ0B;4DAR1BA;yCAQgB;qBANjCm2C,OAMS/oC,mCAAwB,UAApBzV;;yCACG;6CATkCu+C;0CASlC,MATCl2C;yCASmB;qBAPpCm2C;kDAOoC,iBATnBn2C,IASPq5C;;yCACS;6CAV+BnD;0CAU/B,MAVFl2C;yCAUkB;qBARnCm2C;kDAQmC,iBAVlBn2C,IAUJyT;;yCACE;8CAXmCyiC;0CAWnC,MAXEl2C;yCAWW;qBAT5Bm2C;kDAS4B,iBAXXn2C,IAWPqyB;;yCACQ;8CAZgC6jB;0CAYhC,MAZDl2C;0CAY2B;4DAZ3BA;yCAYiB;qBAVlCm2C,uCAUkC,UAArBx7C;;yCACG;8CAbkCu7C;0CAalC,MAbCl2C;yCAaY;qBAX7Bm2C;kDAW6B,iBAbZn2C,IAaNsyB;;yCACE;8CAdqC4jB;0CAcrC,MAdIl2C;yCAcO;qBAZxBm2C;kDAYwB,iBAdPn2C,IAcTsiC;;yCACM;8CAfoC4T;0CAepC,MAfGl2C;0CAemB;4DAfnBA;yCAeS;qBAb1Bm2C,uCAa0B,UAAjBt7C;;yCAET;8CAjBkDq7C;0CAiBlD,MAjBiBl2C;0CAiBS;4DAjBTA;yCAiBD;qBAfhBm2C,uCAegB,UADF9nC;;yCAEE;8CAlBkC6nC;0CAkBlC,MAlBCl2C;yCAkBa;qBAhB9Bm2C;kDAgB8B,iBAlBbn2C,IAkBNyiC;;yCAGO;8CArBgCyT;0CAqBhC,MArBDl2C;yCAqBgB;qBAnBjCm2C;kDAmBiC,iBArBhBn2C,IAqBJ4iC;;yCADE;UADEwF,QAnBiC8N;UAmBpClT,IAnBoCkT;gBAAjCl2C;0CAoBF;4DApBEA,IAmBHgjC;0CACC,MApBEhjC;yCAoB2B;qBAlB5Cm2C;;mDAkB4C;2BApB3Bn2C,IAmBAooC;;kCA5zET,SAo0EVqR,OAAIz5C;sCAEI;OAFqDmoC;OAAzCY;OAAiBmN;aAAjCl2C;uCAEI;yDAFJA,IAAgB+oC;uCAEZ,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,UAH2B+N;uCAwEjB;mBAtElBC,UACA/N;;uCAAQ,OAH2B8N;;0CAKrB;WAALz/C;YAL0By/C;0CAKH;sBAHhCC;sBACA/N;mDAEgC,UAL9BpoC,IAKOvJ;;0CACQ;WAAL47B;YANuB6jB;0CAMlB;sBAJjBC,UACA/N,SAGY/V;;0CAGV;WAFcxmB,EAPmBqqC;WAOxBsD,IAPwBtD;WAO3Bx8C,EAP2Bw8C;iBAAjCl2C;2CASA;6DATAA,IAOc6L;2CAEd,MATA7L;2CAQ2B;6DAR3BA;0CAQiB;sBANnBm2C;sBACA/N;mBAIQ1uC;mDACW,UADR8/C;;;0CAMQ;+CAbgBtD;2CAahB,MAbjBl2C;0CAauC;sBAXzCm2C;sBACA/N;mDAUyC,iBAbvCpoC,IAaU05C;;0CADV;WAFmB5tC,IAVcoqC;WAUjB55C,EAViB45C;WAUtByD,IAVsBzD;WAU3BxW,IAV2BwW;iBAAjCl2C;2CAYA;6DAZAA,IAUmB8L;2CAEnB,MAZA9L;2CAWgD;6DAXhDA,IAUgB1D;2CACgC,MAXhD0D;2CAW4B;6DAX5BA;0CAWmB;sBATrBm2C;sBACA/N;mBAOQ1I;mDACa,gBADRia;;;;0CAKyC;WADzChiD,EAdsBu+C;WAczBlqC,IAdyBkqC;iBAAjCl2C;2CAeoD;6DAfpDA;2CAe2C;uC,OA9PjDw1C;2CA8PuC;sDADtB79C;2CACsB,MAfjCqI;0CAegB;sBAblBm2C;sBACA/N;mDAYkB,iBAfhBpoC,IAcQgM;;;0CAG0B;WADvB4tC,MAhBsB1D;WAgBzBhT,IAhByBgT;iBAAjCl2C;2CAiBkC;6DAjBlCA,IAgBW45C;2CACuB,MAjBlC55C;0CAiBiB;sBAfnBm2C;sBACA/N;mDAcmB,iBAjBjBpoC,IAgBQkjC;;;0CAE2C;WAA1C2W,MAlBwB3D;WAkB3BtS,IAlB2BsS;iBAAjCl2C;2CAkBmD;6DAlBnDA,IAkBS65C;2CAA0C,MAlBnD75C;0CAkBkC;sBAhBpCm2C;sBACA/N;mDAeoC,iBAlBlCpoC,IAkBM4jC;;;0CACO;8CAnBoBsS;2CAmBpB,MAnBbl2C;2CAmByC;6DAnBzCA;0CAmB+B;sBAjBjCm2C;sBACA/N;mDAgBiC,UAAxB0R;;0CAEwC;WAD9BzyC,IApBgB6uC;WAoBrBxC,IApBqBwC;iBAAjCl2C;2CAqB+C;6DArB/CA;2CAqBsC;4DADrBqH;0CACG;sBAnBtB8uC;sBACA/N;mDAkBsB,UArBpBpoC,IAoBY0zC;;;0CAGmB;WADhBqG,GAtBkB7D;WAsBvB8D,MAtBuB9D;iBAAjCl2C;2CAuB+B;6DAvB/BA;0CAuBsB;sBArBxBm2C;sBACA/N;mBAmBY4R;mDACY,gBADPD;;0CAIN;WAFGE,KAxBqB/D;WAwBxBv7C,IAxBwBu7C;iBAAjCl2C;2CA0BS;6DA1BTA;2CA0BA;4DAFYi6C;2CAEZ,MA1BAj6C;2CAyBoD;6DAzBpDA;2CAyBsC;uC,OAnQ5C+1C,UA0OM/1C;2CAyB2B;uC,OAvQjCy1C;0CAuQuB;sBAvBnBU;sBACA/N;mDAsBmB,UADRztC;;;0CAIwB;WADtB27C,MA3BsBJ;WA2BzB/R,IA3ByB+R;2CA4BA;sDA5BjCl2C,IA2BWs2C;2CACsB,MA5BjCt2C;0CA4BgB;sBA1BlBm2C;sBACA/N;mDAyBkB,iBA5BhBpoC,IA2BQmkC;;;0CAIR;WAFoBh4B,GA7Ba+pC;WA6BlBO,MA7BkBP;WA6BtBhqC,GA7BsBgqC;iBAAjCl2C;2CA+BA;6DA/BAA,IA6BoBmM;2CACiB;sDA9BrCnM,IA6Bey2C;2CACsB,MA9BrCz2C;0CA8BmB;sBA5BrBm2C;sBACA/N;mDA2BqB,iBA9BnBpoC,IA6BWkM;;;;0CAGE;gDAhCoBgqC;2CAgCpB,MAhCbl2C;2CAgCyC;6DAhCzCA;0CAgC+B;sBA9BjCm2C;sBACA/N;mDA6BiC,UAAxB8R;;0CAGE;WAFYC,GAjCYjE;WAiChB7pC,KAjCgB6pC;WAiCpB9pC,KAjCoB8pC;iBAAjCl2C;2CAmCS;6DAnCTA;2CAmCA;4DAFqBm6C;2CAErB,MAnCAn6C;2CAkCuC;6DAlCvCA,IAiCiBqM;2CACsB,MAlCvCrM;0CAkCqB;sBAhCvBm2C;sBACA/N;mDA+BuB,iBAlCrBpoC,IAiCaoM;;;;0CAIwB;WADtBE,KApCkB4pC;WAoCtB3pC,KApCsB2pC;iBAAjCl2C;2CAqCqC;6DArCrCA,IAoCesM;2CACsB,MArCrCtM;0CAqCmB;sBAnCrBm2C;sBACA/N;mDAkCqB,iBArCnBpoC,IAoCWuM;;;0CAGwB;WADvBC,KAtCqB0pC;WAsCzBzpC,KAtCyBypC;iBAAjCl2C;2CAuCmC;6DAvCnCA,IAsCYwM;2CACuB,MAvCnCxM;0CAuCiB;sBArCnBm2C;sBACA/N;mDAoCmB,iBAvCjBpoC,IAsCQyM;;;0CAIR;WAFoB2tC,KAxCalE;WAwChB1nC,EAxCgB0nC;WAwCpBmE,KAxCoBnE;WAwCxBoE,KAxCwBpE;WAwC3BhyB,IAxC2BgyB;iBAAjCl2C;2CA0CA;6DA1CAA,IAwCoBo6C;2CAEpB,MA1CAp6C;2CAyCiD;6DAzCjDA,IAwCaq6C;2CACoC,MAzCjDr6C;2CAyC+B;6DAzC/BA,IAwCSs6C;2CACsB,MAzC/Bt6C;0CAyCe;sBAvCjBm2C;sBACA/N;mDAsCiB,iBAzCfpoC,IAwCMkkB;;;mBAAW1V;;;0CAOsB;WADvBtE,EA9CiBgsC;WA8CpBqE,IA9CoBrE;iBAAjCl2C;2CA+CuC;6DA/CvCA,IA8CgBkK;2CACuB,MA/CvClK;0CA+CsB;sBA7CxBm2C;sBACA/N;mDA4CwB,iBA/CtBpoC,IA8Cau6C;;;0CADb;WAFgBz8C,GA3CiBo4C;WA2CrBl4C,GA3CqBk4C;WA2CxBsE,IA3CwBtE;iBAAjCl2C;2CA6CA;6DA7CAA,IA2CgBlC;2CAEhB,MA7CAkC;2CA4C2C;6DA5C3CA;2CA4CkC;4DADtBhC;2CACsB,MA5ClCgC;0CA4CiB;sBA1CnBm2C;sBACA/N;mDAyCmB,iBA5CjBpoC,IA2CSw6C;;;;cAKClkD,EAhDuB4/C,QAgD1BuE,IAhD0BvE,cAAjCl2C;0CAgDiC;sBA9CnCm2C;sBACA/N;mDA6CmC,iBAhDjCpoC,IAgDOy6C;mBAAGnkD;;0CACE;WAAPokD;YAjD4BxE;0CAiDJ;sBA/C/BC;sBACA/N;mDA8C+B,UAjD7BpoC,IAiDK06C;;0CAEgC;WADrBC,IAlDiBzE;WAkDpB52C,IAlDoB42C;iBAAjCl2C;2CAmDqC;6DAnDrCA,IAkDgB26C;0CACK;sBAjDvBxE;sBACA/N;mDAgDuB,UAnDrBpoC,IAkDaV;;;0CAGf;+CArDmC42C;2CAqDnC,MArDEl2C;2CAsDmC;6DAtDnCA;2CAsDqB;uC,OAhS3B+1C,UA0OM/1C;2CAsDU;uC,OApShBy1C;0CAoSM;sBApDFU;sBACA/N;mDAmDE,UAFUwS;;0CAKV;WAFmBC,IAvDc3E;WAuDlB8C,GAvDkB9C;WAuDrBnqC,IAvDqBmqC;iBAAjCl2C;2CAyDA;6DAzDAA,IAuDmB66C;2CAEnB,MAzDA76C;2CAwDoC;6DAxDpCA,IAuDeg5C;0CACK;sBAtDtB7C;sBACA/N;mDAqDsB,UAxDpBpoC,IAuDY+L;;;;0CAMZ;WAHmB+uC,KA1Dc5E;WA0DlB6E,GA1DkB7E;iBAAjCl2C;2CA6DA;6DA7DAA,IA0DmB86C;2CAGnB,MA7DA96C;0CA4DA;sBA1DFm2C;sBACA/N;mDAyDE,iBA5DApoC,IA0De+6C;;;0CAIF;gDA9DoB7E;2CA8DpB,MA9Dbl2C;0CA8DiC;sBA5DnCm2C;sBACA/N;mDA2DmC,iBA9DjCpoC,IA8DQg7C;;0CACG;gDA/DsB9E;2CA+DtB,MA/DXl2C;0CA+D6B;sBA7D/Bm2C;sBACA/N;mDA4D+B,iBA/D7BpoC,IA+DMi7C;;0CAEmC;WAD/B1E,IAhEuBL;WAgE1BgF,KAhE0BhF;iBAAjCl2C;2CAiEyC;6DAjEzCA;2CAiEgC;4DADtBu2C;2CACsB,MAjEhCv2C;0CAiEe;sBA/DjBm2C;sBACA/N;mDA8DiB,iBAjEfpoC,IAgEOk7C;;;0CAEQ;+CAlEkBhF;2CAkElB,MAlEfl2C;0CAkEmC;sBAhErCm2C;sBACA/N;mDA+DqC,iBAlEnCpoC,IAkEQm7C;;cACKC,KAnEoBlF,QAmEvBmF,IAnEuBnF,cAAjCl2C;0CAmEyC;sBAjE3Cm2C;sBACA/N;mBAgEYiT;mDAA+B,iBAnEzCr7C,IAmEao7C;;0CACD;gDApEqBlF;2CAoErB,MApEZl2C;0CAoE6B;sBAlE/Bm2C;sBACA/N;mDAiE+B,iBApE7BpoC,IAoEMs7C;;0CAEgC;WADrBC,KArEgBrF;WAqErBsF,MArEqBtF;WAqE1BuF,IArE0BvF;iBAAjCl2C;2CAsEsC;6DAtEtCA,IAqEiBu7C;0CACG;sBApEtBpF;sBACA/N;mBAkESqT;mDACa,UAtEpBz7C,IAqEYw7C;;;0CAEI;+CAvEiBtF;2CAuEjB,MAvEhBl2C;0CAuEsC;sBArExCm2C;sBACA/N;mDAoEwC,iBAvEtCpoC,IAuEWsyB;kCA34EL,SAk5EVopB,OAAI17C;sCAEI;OAFqDmoC;OAAvBY;OAAjBmN;aAAjBl2C;uCAEI;yDAFJA,IAAkC+oC;uCAE9B,MAFJ/oC;uCAGM;yDAHNA,IAAyDmoC;sCAGnD,UAHW+N;uCAKT;mBAHVC,UACA/N;;uCAAQ,OAHW8N;;0CAMP;WAAL5/C;YANY4/C;0CAMS;sBAJ5BC;sBACA/N;mDAG4B,UAN1BpoC,IAMK1J;;0CAC8C;WAAxCgJ,IAPM42C;WAOT55C,EAPS45C;2CAOkC;sDAPnDl2C,IAOWV;2CAAwC,MAPnDU;0CAOmC;sBALrCm2C;sBACA/N;mDAIqC,iBAPnCpoC,IAOQ1D;;;0CACO;WAALnD;YARO+8C;0CAQF;sBANjBC,UACA/N,SAKYjvC;;cACKwiD,GATEzF,QASN0F,GATM1F;iBAl5BrB7L,cAo5BE8L,UACA/N,SAMawT,GAAID;;0CACF;8CAVIzF;2CAUJ,MAVbl2C;2CAUyC;6DAVzCA;0CAU+B;sBARjCm2C;sBACA/N;mDAOiC,UAAxByT;;0CAEsC;WAD9B33B,IAXEgyB;WAWLv+C,EAXKu+C;iBAAjBl2C;2CAY6C;6DAZ7CA;2CAYoC;4DADrBkkB;0CACK;sBAVtBiyB;sBACA/N;mDASsB,UAZpBpoC,IAWYrI;;;0CAEsC;WAArCwsB,IAbI+xB;WAaPv7C,IAbOu7C;iBAAjBl2C;2CAakD;6DAblDA;0CAayC;sBAX3Cm2C;sBACA/N;mBAUYztC;mDAA+B,gBAA5BwpB;;0CAG2B;WAF1B23B,GAdG5F;WAcR6F,IAdQ7F;iBAAjBl2C;2CAgBwC;6DAhBxCA;2CAgB0B;uC,OAxUhC+1C,UAwTM/1C;2CAgBe;uC,OA5UrBy1C;0CA4UW;sBAdPU;sBACA/N;mDAaO,UAFI2T;mBAAKD;;0CAGD;gDAjBI5F;2CAiBJ,MAjBbl2C;2CAiByC;6DAjBzCA;0CAiB+B;sBAfjCm2C;sBACA/N;mDAciC,UAAxB4T;;0CAC0C;WAAxCC,GAlBQ/F;WAkBZgG,GAlBYhG;iBAAjBl2C;2CAkBiD;6DAlBjDA,IAkBSi8C;2CAAwC,MAlBjDj8C;0CAkBgC;sBAhBlCm2C;sBACA/N;mDAekC,iBAlBhCpoC,IAkBKk8C;;;0CAEiC;WADtBhyC,EAnBCgsC;WAmBJzwB,IAnBIywB;iBAAjBl2C;2CAoBsC;6DApBtCA,IAmBgBkK;2CACsB,MApBtClK;0CAoBsB;sBAlBxBm2C;sBACA/N;mDAiBwB,iBApBtBpoC,IAmBaylB;;;0CAEF;WAAL1Z;YArBWmqC;0CAqBY;sBAnB/BC;sBACA/N;mDAkB+B,UArB7BpoC,IAqBM+L;;0CACK;+CAtBMmqC;2CAsBN,MAtBXl2C;0CAsB6B;sBApB/Bm2C;sBACA/N;mDAmB+B,iBAtB7BpoC,IAsBM0lB;;0CACO;WAAL21B;YAvBSnF;0CAuBe;sBArBlCC;sBACA/N;mDAoBkC,UAvBhCpoC,IAuBQq7C;;0CAEQ;+CAzBCnF;2CAyBD,MAzBhBl2C;0CAyBuC;sBAvBzCm2C;sBACA/N;mDAsByC,iBAzBvCpoC,IAyBW4lB;;0CACK;6CA1BCswB;2CA0BD,MA1BhBl2C;0CA0BsC;sBAxBxCm2C;sBACA/N;mDAuBwC,iBA1BtCpoC,IA0BWvJ;;0CAF0C;WAA1CqlC,IAxBMoa;WAwBVxC,IAxBUwC;iBAAjBl2C;2CAwBqD;6DAxBrDA,IAwBW87B;0CAAwB;sBAtBrCqa;sBACA/N;mDAqBqC,UAxBnCpoC,IAwBO0zC;;kCA16ED,SAk7EVyI,OAAIn8C;sCAEI;OAFkDmoC;OAAvCY;OAAgBmN;aAA/Bl2C;uCAEI;yDAFJA,IAAe+oC;uCAEX,MAFJ/oC;uCAGM;yDAHNA,IAAsDmoC;sCAGhD,OAHyB+N;;yCAMc;UADhCmC,IALkBnC;UAKvBxC,IALuBwC;gBAA/Bl2C;0CAM6C;4DAN7CA;0CAMmC;qDADtBq4C;yCACI;qBAJnBlC;qBACA/N;kDAGmB,UANjBpoC,IAKQ0zC;;;yCAGV;4CARiCwC;0CAQjC,MAREl2C;yCAQoB;qBANtBm2C;qBACA/N;kDAKsB,iBARpBpoC,IAOU1J;;yCAMV;UAJgB8lD,GATelG;UASlB55C,EATkB45C;UASrBrqC,EATqBqqC;UAS1BxW,IAT0BwW;gBAA/Bl2C;0CAaA;4DAbAA,IASgBo8C;0CAIhB,MAbAp8C;0CAYA;4DAZAA,IASa1D;0CAGb,MAZA0D;0CAWS;4DAXTA;yCAWA;qBATFm2C;qBACA/N;kBAMO1I;kDAEL,gBAFU7zB;;;;yCAOS;UAFRlU,EAdoBu+C;UAcxBmG,KAdwBnG;gBAA/Bl2C;0CAgBmB;4DAhBnBA;0CAgBU;sC,OA7WhBw1C;0CA6WM;qDAFW79C;0CAEX,MAhBAqI;yCAegB;qBAblBm2C;qBACA/N;kDAYkB,iBAfhBpoC,IAcOq8C;;;yCAKP;UAFaC,KAjBkBpG;UAiBvBsD,IAjBuBtD;UAiB1Bx8C,EAjB0Bw8C;gBAA/Bl2C;0CAmBA;4DAnBAA,IAiBas8C;0CAEb,MAnBAt8C;0CAkB2B;4DAlB3BA;yCAkBiB;qBAhBnBm2C;qBACA/N;kBAcO1uC;kDACY,UADT8/C;;;yCAIsC;UAD9BlB,GApBepC;UAoBnBqG,KApBmBrG;gBAA/Bl2C;0CAqB8C;4DArB9CA,IAoBgBs4C;0CAC8B,MArB9Ct4C;yCAqBsB;qBAnBxBm2C;qBACA/N;kDAkBwB,iBArBtBpoC,IAoBYu8C;;;yCAEG;4CAtBgBrG;0CAsBhB,MAtBfl2C;yCAsBqC;qBApBvCm2C;qBACA/N;kDAmBuC,iBAtBrCpoC,IAsBUvJ;kCAx8EJ,SA08EV+lD,WAASx8C;iB;wCAEQ;;+CAFRA;wCAEoB;iEAFpBA,IAEGkK;UADK2B,WAAHkY,iBADL/jB;sCAC+B;cAA1B+jB;8CAA0B,iBAD/B/jB,IACQ6L;kCA38EP,SA88EV4wC,YAAUz8C;sCAEF;OAFwDmoC;OAAtBY;OAAhBmN;aAAhBl2C;uCAEF;yDAFEA,IAAgC+oC;uCAElC,MAFE/oC;uCAGA;yDAHAA,IAAsDmoC;sCAGtD,OAHgB+N;;aAKN5/C,EALM4/C,QAKVkG,GALUlG,QAKbnyB,EALamyB,cAAhBl2C;yCAKuC;qBAH/Cm2C;qBACA/N;kBAEWrkB;kDAAoC,iBALvC/jB,IAKMo8C;kBAAI9lD;;yCACoC;gBAN9B4/C;UAMX14C;UAAHsR;UAAHxP;0CAA+C;sDAN9CU,IAMKxC;yCAAuB;qBAJpC24C;qBACA/N;kDAGoC,UAN5BpoC,IAMDV;kBAAGwP;;;yCAE4B;kBARdonC;UAORz4C;UAAHnB;UAAHyP;0CAC4B;sDAR9B/L,IAOQvC;yCACI;qBANpB04C;qBACA/N;kDAKoB,UARZpoC,IAOE+L;kBAAGzP;;;yCAG4B;kBAVjB45C;UASNp4C;UAAJE;gBATNgC;0CAUiC;4DAVjCA,IASUlC;0CACuB,MAVjCkC;yCAUgB;qBARxBm2C;qBACA/N;kDAOwB,iBAVhBpoC,IASMhC;;;yCAEK;4CAXKk4C;0CAWL,MAXXl2C;yCAWoC;qBAT5Cm2C;qBACA/N;kDAQ4C,iBAXpCpoC,IAWM6L;;yCACG;4CAZOqqC;0CAYP,MAZTl2C;yCAYwB;qBAVhCm2C;kDAUgC,iBAZxBn2C,IAYIvJ;;yCACK;8CAbOy/C;0CAaP,MAbTl2C;yCAa+B;qBAXvCm2C;qBACA/N;kDAUuC,iBAb/BpoC,IAaIqyB;kCA39EJ,SA69EVqqB,gBAAc18C;sCAGU;OAHO28C;OAAZC;aAAL58C;uCAGU;yDAHVA;uCAGC;kDAHgB28C;uCAGhB,MAHD38C;sCAED;+DAFCA,IAAK48C;;kCA79ET,SAm+EVC,cAAY78C,IAAI7J;qCAMhB;OAL4B2mD;OAATC;OADqCC;OAAVC;OAAJpB;OAAvBqB;sCAMnB;kDANgB/mD,EAAwC6mD;sCAKxD;iDALYh9C,IAAkCi9C;sCAK9C,MALYj9C;uCAIc;yDAJdA;sCAIK;mB,OAnZnBu1C;sCAmZS;;qDAJmCsG;uCAInC,SAJYqB;uCAIZ;;6CAJKl9C;uCAQL;;0DARKA,IACgB88C;uCAOrB,MARK98C;sCAOP;;iEAPOA,IACO+8C;;;;;;;;kCAp+ET,eA6gFLI;qCAAL;;;;;;4CAAKA;uCAID;yDAJCA,OAAiBI;uCAGlB;kDAHCJ,OAAMK;uCAGP,SAH6BF;uCAG7B;6CAHCH;uCAKM;;;iBALNA,OACME;uCAIA,MALNF;sCAMI;;;wBANJA,OAAuCC;;;;;oDAQ3C;kCArhFS,eA6kFLD;qCAAL;;;;;4CAAKA;uCAGA;yDAHAA,OAAeQ;uCAGf,MAHAR;uCAEA;yDAFAA,OAAMS;uCAEN;;6CAFAT;uCAKO;;;iBALPA,OAAyBO;uCAKlB,MALPP;sCAIK;;;wBAJLA,OAAyCM;;;;;oDAM7C;kCAnlFS,eAo/EKN,OAAKxlD;sCAAK;;QAAVwlD;sCAAmB;gEAAnBA,QAAKxlD,kCAA0C;kCAp/EpD,eAu/EKwlD,OAAKxlD;sCAAK;;QAAVwlD;sCAAmB;gEAAnBA,QAAKxlD,kCAA0C;kCAv/EpD,eA4nFLwlD;qCAAL;;yCACe;;gDADVA;yCACe;kEADfA,OACK1mD;;yCACK;;gDAFV0mD;yCAEe;kEAFfA,OAEK9qB;;yCACK;;gDAHV8qB;yCAGe;kEAHfA,OAGK7qB;;yCACyC;UAArCp4B;UAAHooC;gBAJN6a;0CAI8C;4DAJ9CA;0CAIsC;2DAA7BjjD;0CAA6B,MAJtCijD;yCAIqB;kEAJrBA,OAIM7a;uDACV;kCAjoFS,eAqjFL6a;qCAAL;;;;;uCACU;kDADLA,OAAMa;uCACD,SADYD;uCACZ;6CADLZ;uCAIO;;;iBAJPA,OAAiCU;uCAI1B,MAJPV;sCAGK;;;wBAHLA,OAAmDW;;;;oDAKvD;kCA1jFS,eAoiFLX;qCAAL;;;;;uCAEK;kDAFAA,OAAMiB;uCAEN,MAFAjB;uCAGc;yDAHdA;uCAGK;wDAHYgB;uCAGZ;;6CAHLhB;uCAIO;;;iBAJPA,OAA4Be;uCAIrB,MAJPf;sCAKK;;;wBALLA,OAA6Cc;;;;;oDAMjD;kCA1iFS,eA2hFLd;qCAAL;;;;;4CAAKA;uCAGA;yDAHAA,OAAgBoB;uCAEhB;kDAFApB,OAAMqB;uCAEN;;6CAFArB;uCAIO;;;iBAJPA,OAA0BmB;uCAInB,MAJPnB;sCAKK;;;wBALLA,OAA0CkB;;;;;oDAM9C;kCAjiFS,eA6iFLlB;qCAAL;;;;;4CAAKA;uCAC4B;yDAD5BA,OAAgBwB;uCACZ;kDADJxB,OAAMyB;uCACF;;6CADJzB;uCAEO;;;iBAFPA,OAA0BuB;uCAEnB,MAFPvB;sCAGK;;;wBAHLA,OAA0CsB;;;;;oDAI9C;kCAjjFS,eAsnFItB,OAAMxlD;sCAAK,OAALA,iCAAM;kCAtnFhB,eAimFLwlD;qCAAL;;;;;;4CAAKA;uCAGA;yDAHAA,OAAgB4B;uCAEhB;kDAFA5B,OAAM8B;uCAEN,SAFmCD;uCAEnC;6CAFA7B;uCAMO;;;iBANPA,OAAgD0B;uCAMzC,MANP1B;sCAKK;;;wBALLA,OAA0B2B;;;;;oDAO9B;kCAxmFS,eA8jFL3B;qCAAL;;;;4CAAKA;uCACM;yDADNA,OAAMiC;uCACA;6CADNjC;uCAGO;;;iBAHPA,OAAiB+B;uCAGV,MAHP/B;sCAEK;;;wBAFLA,OAAmCgC;;;oDAIvC;kCAlkFS,eAqkFLhC;qCAAL;;;;4CAAKA;uCACM;yDADNA,OAAMiC;uCACA;6CADNjC;uCAGO;;;iBAHPA,OAAiB+B;uCAGV,MAHP/B;sCAEK;;;wBAFLA,OAAmCgC;;;oDAIvC;kCAzkFS,eAwnFKhC;sCAAL;;;6CAAKA;uCAAgC;yDAAhCA,OAAStxC;sCAAO;wDAAhBsxC,OAAM7mD;oDAA+C;kCAxnF1D,eAulFL6mD;qCAAL;;;;;;uCAEI;kDAFCA,OAAMsC;uCAEP,MAFCtC;uCAIa;yDAJbA;uCAII;wDAJsBoC;uCAGrB;;;WAHLpC,OAAgBqC;uCAGX;6CAHLrC;uCAMM;;;iBANNA,OAA4CkC;uCAMtC,MANNlC;sCAKI;;;wBALJA,OAAmCmC;;;;;oDAOvC;kCA9lFS,eAogFLnC;sCAAQ;6CAARA;uCAA4B;yDAA5BA;sCAA4B;mB,OAjCjCN,cAiCKM,oDAAkD;kCApgF7C,eAsgFLA;sCAAQ;6CAARA;uCAA4B;yDAA5BA;sCAA4B;mB,OAnCjCN,cAmCKM,oDAAkD;kCAtgF7C,eA4/ELA;sCAAQ;6CAARA;uCAA4B;yDAA5BA;sCAA4B;mB,OAzBjCN,cAyBKM,oDAAkD;kCA5/E7C,eA0mFCA,OAAKxlD;sCAAK;;QAAVwlD;sCAAmB;gEAAnBA,QAAKxlD,kCAAgC;kCA1mFtC,eA4mFLwlD;qCAAL;;;;4CAAKA;uCAIS;yDAJTA,OAAwBuC;uCAIf,MAJTvC;uCAGmB;yDAHnBA;uCAGW;wDAHGwC;uCAGH,MAHXxC;sCAES;+DAFTA,OAAMyC;;mDAMV;kCAlnFS,eA0nFMzC,OAAKxlD;sCAAK;;QAAVwlD;sCAAmB;gEAAnBA,QAAKxlD,kCAAqC;kCA1nFhD;;;gBAynFKwlD;yCAAL;;;gDAAKA;0CAAgC;4DAAhCA,OAAStxC;yCAAO;2DAAhBsxC,OAAM7mD;uDAA+C;;;;;;OAvMpE6lD;OA4BAM;OAtPAjE;OAqQAkE;OA/RAtE;;OAYAG;;OA0HAkB;;OAtJA1B;;;;;;;OAwGAuB;OArDAX;;;OAiLA+C;;;OAtJAvC;;OA6CAI;OArMAtD;OA0BAS;OA8BAW;OAZAF;;;OAmGA8B;mCAnvEU;;SAkxFZtnD,wBACAC;kCAnxFY,SAsxFdkuD,gBAAchZ;sCAAS;eAATA,kDAA2C;kCAtxF3C,SAuxFdiZ,gBAAcjZ;sCAAS;eAATA,kDAA2C;kCAvxF3C,SA0xFZkZ,WAAKvpD;sCAAI,OAAJA,iCAAK;kCA1xFE;KAyxFdwpD;;OACED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCA1xFY,SAw0FZE;qCACF;qDAA0E;kCAz0F5D,SAu3FdC;MAAiB/Y,UAAWC;qCAC9B,qBAEqC5wC;wCAAK;iBAHZ4wC,UAGO5wC,kCAAgB;qCAFrD;cAhDIypD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAiDiCzpD;gDAAK;yBAFvB2wC,UAEkB3wC,kCAAgB;cAjDjDypD;;;;;;;;;qDAkDoD;kCC13FxC;;;;SA21FZruD,wBACAC;kCA51FY,SA+1FdsuD,gBAActZ;sCAAS;eAATA,kDAA2C;kCA/1F3C,SAg2FduZ,gBAAcvZ;sCAAS;eAATA,kDAA2C;kCAh2F3C,SAm2FZwZ,WAAK7pD;sCAAI,OAAJA,iCAAK;kCAn2FE;KAk2Fd8pD;;OACED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAn2FY,SAi5FZE;qCACF;qDAA0E;kCAl5F5D,SAg8FdC;MAAiBrZ,UAAWC;qCAC9B,qBAEqC5wC;wCAAK;iBAHZ4wC,UAGO5wC,kCAAgB;qCAFrD;cAhDI+pD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAiDiC/pD;gDAAK;yBAFvB2wC,UAEkB3wC,kCAAgB;cAjDjD+pD;;;;;;;;;qDAkDoD;kCCv7FxC;;;;SA23FZzuD,wBACAC;kCA53FY,SA+3Fd0uD,gBAAc5Z;sCAAS;eAATA,kDAA2C;kCA/3F3C,SAg4Fd6Z,gBAAc7Z;sCAAS;eAATA,kDAA2C;kCAh4F3C,SAm4FZ8Z,WAAKnqD;sCAAI,OAAJA,iCAAK;kCAn4FE;KAk4FdoqD;;OACED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAn4FY,SAi7FZE;qCACF;qDAA0E;kCAl7F5D,SAg+FdC;MAAiB3Z,UAAWC;qCAC9B,qBAEqC5wC;wCAAK;iBAHZ4wC,UAGO5wC,kCAAgB;qCAFrD;cAhDIqqD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAiDiCrqD;gDAAK;yBAFvB2wC,UAEkB3wC,kCAAgB;cAjDjDqqD;;;;;;;;;qDAkDoD;mC8Bl/FhC3iB,MAAM8U;6DAG9B;;QAH8BA;6DAG9B;eAHwB9U;;;;;;;;;;;yEAOpB;mBADyD3vB;;yEACzD,OADyDA;6DAEtD,OARuBykC,2DAQpB;;6DAMV;;;;;;;8DAWM;;UAR+B+N;8DAM/B;;UAPwBC;6DAKxB;;gBANyBC;;2EAW5B;;6DAMH;;gEAEI;UADwBrzC;;gEAEtB;;kCAFsBA;;gEAKxB;UAD2BE;;gEAEzB;;mBAFyBA;;iEAOvB;UAJyB1P;UAAHC;UAAH2P;kEAInB;;aAJyB5P;kEAGzB;;gCAHsBC;gEAEvB;;mBAFoB2P;;;;gEAMvB;UAD2BkzC;;gEAEzB;;6BAFyBA;;iEAQvB;UAL4B5iD;UAAHC;UAAHC;UAAH2iD;kEAKnB;;aAL4B7iD;kEAI5B;;aAJyBC;kEAGzB;;uBAHsBC;gEAEvB;;mBAFoB2iD;;;;;iEASnB;UAHwBC;UAAHC;;oBAIb7qD;qEACF;yEADEA;sEACF,GADEA;sEAGA;;iBAFM6H;qEACP;;uBADIuP;mFAEkB;kEAJ7B;;mBAHwBwzC;gEAEzB;;mBAFsBC;;;iEAWrB;UAHwBC;UAAHC;kEAGrB;;uBAHwBD;gEAEzB;;mBAFsBC;;;iEAOrB;UAHsBC;UAAHC;kEAGnB;;uBAHsBD;gEAEvB;;mBAFoBC;;;gEAKvB;UADwBC;;gEAEtB;;6BAFsBA;;iEAOpB;UAJ4BC;UAAHC;kEAIzB;;uBAJ4BD;gEAE7B;;kCAF0BC;;;kEAQzB;UAH0BC;UAAHC;mEAGvB;;uBAH0BD;iEAE3B;;mBAFwBC;;;kEAYvB;UARyBC;UAAHC;mEAQtB;;uBARyBD;mEAQzB;oBALOvrD;sEACF;0EADEA;uEACF,GADEA;uEAIA;;iBAHM6H;sEACP;;sCADIuP;oFAGkB;iEAL7B;;yBAFuBo0C;;;kEAYtB;UAHwBC;UAAHC;mEAGrB;;4BAHwBD;iEAEzB;;mBAFsBC;;;kEAUrB;UAL8BC;UAAHC;UAAHC;mEAKxB;;aAL8BF;mEAG9B;;4BAH2BC;iEAE5B;;mBAFyBC;;;;iEAO5B;UADwBC;;iEAEtB;;6BAFsBA;;kEAOpB;UAJgCC;UAAHC;UAAHC;mEAI1B;;uBAJgCF;mEAGhC;;aAH6BC;iEAE9B;;mBAF2BC;;;;kEAQ1B;UAH2BC;UAAHC;mEAGxB;;aAH2BD;iEAE5B;;mBAFyBC;;;kEAOxB;UAHwBC;UAAHC;mEAGrB;;aAHwBD;iEAEzB;;mBAFsBC;;;kEAUrB;UAN+Bv0C;UAAHw0C;UAAHC;UAAHC;UAAHC;mEAMnB;;aAN+B30C;mEAK/B;;aAL4Bw0C;mEAI5B;;aAJyBC;mEAGzB;;aAHsBC;iEAEvB;;mBAFoBC;;;;;;kEAUnB;UAH6BC;UAAHC;mEAG1B;;aAH6BD;iEAE9B;;mBAF2BC;;;kEAQ1B;UAJ4BC;UAAHC;UAAHC;mEAItB;;aAJ4BF;mEAG5B;;sBAHyBC;iEAE1B;;mBAFuBC;;;;aAKCC,eAAHC;iEAErB;;mBAFqBA;iBAAGD;;iEAI3B;UADsBE;;iEAEpB;;kCAFoBA;;kEAOlB;UAH6BC;UAAHC;mEAG1B;;aAH6BD;mEAG7B;oBADcltD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF2BmtD;;;iEAK9B;;;;oBAEUntD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;iBAFM6H;sEAEN;;eADc7H;wEAAM,OAANA,0DAAO;sEAAtB;;6BADIoX;oFAEkB;iEAJ7B;;yBAFyBg2C;;kEAWvB;UAJ+BC;UAAHC;UAAHC;mEAIzB;;aAJ+BF;mEAG/B;;aAH4BC;mEAG5B;oBADcttD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF0ButD;;;;iEAM7B;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UADuBC;;iEAErB;;mBAFqBA;;kEAMnB;UAHuBC;UAAHC;mEAGpB;;sBAHuBD;iEAExB;;mBAFqBC;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;aAGKC,eAAHC;kEAEpB;iBAFoBA;0EAEpB;mBAFuBD;;iEAI9B;UADuBE;;iEAErB;;mBAFqBA;;kEAQnB;UAL0BC;UAAHC;UAAHC;mEAKpB;;aAL0BF;mEAG1B;;4BAHuBC;iEAExB;;mBAFqBC;;;;iEAOxB;UAD4BC;;iEAE1B;;mBAF0BA,iEAEP;;8DAMzB;;;;yEAE6C;;8DAI7C;;;;;+DAWM;;UARsBlF;+DAMtB;;oBAPwBC;8DAKxB;;gBANsBC;;4EAWzB;;8DAMH;;;;;;;;;+DAcM;;UAVuBnC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAMxB;;gBAPuBC;;;4EAc1B;;8DAIH;;;;;;;+DAWM;;UAR+BiH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;;;qBACiBtuD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFoBoX;;mEAMlB;WAHwBvP;WAAHyP;;qBAGNtX;uEAAM,OAANA,0DAAO;oEAAtB;;oBAHwB6H;kEAEzB;;oBAFsByP;;;kEAKzB;WAD2BE;;kEAEzB;;oBAFyBA;;mEAMvB;WAH2BxP;WAAH0iD;oEAGxB;;cAH2B1iD;kEAE5B;;oBAFyB0iD;;;kEAK5B;WADwBC;;kEAEtB;;6BAFsBA;;mEAOpB;WAJ4BC;WAAHC;oEAIzB;;uBAJ4BD;kEAE7B;;mCAF0BC;;;mEAQzB;WAH0BC;WAAHC;oEAGvB;;uBAH0BD;kEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;cARyBD;oEAQzB;qBALOhrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;uCADIuP;qFAGe;kEAL1B;;0BAFuB6zC;;;kEAU1B;WADwBC;;kEAEtB;;6BAFsBA;;mEAMpB;WAHqBC;WAAHC;oEAGlB;;cAHqBD;kEAEtB;;oBAFmBC;;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;kEAK9B;WADuBE;;kEAErB;;mCAFqBA;;kEAKvB;WADuBE;;kEAErB;;oBAFqBA;;kEAIvB;;;;qBACiB1rD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFuB6rD;;kEAIzB;WAD4BC;;kEAE1B;;oBAF0BA;;kEAI5B;WAD4BG;;kEAE1B;;oBAF0BA,iEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+BsC;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;WADsBr3C;;kEACtB;kBADsBA;;mEAGV;WADmBxP;WAAHC;WAAHyP;oEACb;;cADaA;mEAKtB;;cAL4B1P;oEAIb;;cAHd8/B,MADwB7/B;kEAIzB;kBAHC6/B;0EAGD;;;;kEAGH;WADwBlwB;;kEAEtB;;6BAFsBA;;mEAOpB;WAJyBxP;WAAH0iD;oEAItB;;uBAJyB1iD;kEAE1B;;mCAFuB0iD;;;mEAYtB;WAPyBE;WAAHD;oEAOtB;;cAPyBC;oEAOzB;qBAJO5qD;uEACF;;gBADEA;wEACF;gBADEA;wEACF;gBADEA;wEAGA;;kBAFS4H;uEACN;sBADAwP;+EACA;wBADGvP;qFAEc;kEAJ5B;;0BAFuB8iD;;;mEAYtB;WAJwBG;WAAHD;oEAIrB;;uBAJwBC;kEAEzB;;mCAFsBD;;;cAKGG,cAAHD;kEAEtB;;oBAFsBA;kBAAGC;;mEAOxB;WAJ6BjjD;WAAHojD;WAAHF;;qBAKfjrD;uEAAM;kCAANA,2DAA2B;oEADnC;;oBAJ6B+H;oEAG7B;;cAH0BojD;kEAE3B;;mCAFwBF;;;;mEASvB;WAHuBI;WAAHH;oEAGpB;;cAHuBG;oEAGvB;qBADcrrD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFqBkrD;;;kEAKxB;WAD0BE;;kEAExB;;oBAFwBA;;kEAI1B;WAD4BE;;kEAE1B;;oBAF0BA,gEAEP;+BAMrBtrD;8DACF;kEADEA;+DACF,GADEA;8DACF;QAGUA;iEACF;qEADEA;kEACF,GADEA;kEAIA;;YAHM6H;iEACP;;iCADIuP;+EAGiB;8DAL5B;;0EAFMvP;8DACP;;+BADIuP;6EAO+B;;8DAMtC;;iEAKQ;SAJwBtP;SAAHF;SAAHC;SAAHuP;kEAIf;;qBAJwBtP;kEAGF;;YAHDF;kEAGrB;;YAHkBC;gEAEnB;;kBAFgBuP;;;;8DAMnB;OADsBE;;8DAEpB;;gBAFoBA,+DAED;6BAKnBtX;+DAAM;8BAANA,2DAA+B;4BAMjCA;8DACF;kEADEA;+DACF,GADEA;+DAGA;;UAFM6H;8DAEN;QADc7H;iEAAM,OAANA,0DAAO;8DAAtB;;sBADIoX;6EAEe;;8DAItB;;iEAEI;UADkBA;;iEAEhB;;mBAFgBA;;iEAIlB;UADkBE;;iEAEhB;;mBAFgBA;;kEAMd;UAHkBzP;UAAH2P;mEAGf;;uBAHkB3P;iEAEnB;;mBAFgB2P;iFAGkB;4BAKnCxX;+DAAM;mCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB0uD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;kEAIQ;UAHuB9mD;UAAHuP;mEAGpB;;aAHuBvP;iEAExB;;mBAFqBuP;;;kEAOpB;UAHwBpP;UAAHsP;mEAGrB;;gCAHwBtP;iEAEzB;;mBAFsBsP;;;iEAKzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;;;mEAAqB;;aADEkzC;mEACF;;;;;iBAAjBmE;iBAASD;;iEAGb;UADyBjE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;uCAF0BA;;iEAI5B;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UADwBE;;iEAEtB;;0CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;+CAF2BA;;iEAI7B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UAD4BG;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4BjB;UAAHkB;mEAGzB;;aAH4BlB;iEAE7B;;mBAF0BkB;iFAGJ;gCA8iBzBgD;+DAAJ;;;;;;;iEAWQ;;UAPgCrG;iEAKhC;;UANyBC;gEAIF;;gBAP3BoG,GAE6BnG;;6EAU5B;sCApjBD3oD;8DACF;gCADEA,2DAEkB;8BAqflB8uD;+DAAJ;;;;;;;;;;;;;iEAwBQ;;UAjB8BzI;iEAe9B;;UAhBuBC;iEAcD;;UApB1BwI,GAK4BvI;gEAeF;QADPvmD;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAfwBwmD;gEAexB;QALQxmD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;gEAJ3B;;;gBAV0B23C;gEAQ1B;;gBATwBtI;;;;;6EAuB3B;oCAxgBDzmD;8DACF;+BADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR8BgvD;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJwBrnD;UAAHuP;mEAIrB;;sBAJwBvP;iEAEzB;;kCAFsBuP;;;iEAMzB;UAD2BE;;iEAEzB;;mBAFyBA;;kEAQvB;UAL2BxP;UAAHF;UAAHI;UAAHwP;mEAKlB;;aAL2B1P;mEAI3B;;aAJwBF;mEAGxB;;uBAHqBI;iEAEtB;;mBAFmBwP;;;;;kEASlB;UAHuBozC;UAAHF;;oBAIZ1qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;iBAFM6H;sEACP;;uBADIuP;oFAEkB;mEAJ7B;;mBAHuBwzC;iEAExB;;mBAFqBF;;;kEAYpB;UAJwB3iD;UAAH+iD;UAAHH;mEAIlB;;aAJwB5iD;mEAGxB;;gCAHqB+iD;iEAEtB;;mBAFmBH;;;;kEAQlB;UAH4BK;UAAHH;mEAGzB;;aAH4BG;iEAE7B;;mBAF0BH;;;iEAK7B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;;;;+DAQM;;2BAN4B7E;8DAI5B;;gBAL0BC;4EAQ7B;;8DAMH;;;;;;;+DAWM;;UAR8BgJ;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJ4BznD;UAAHC;UAAHuP;;oBAIJpX;sEAAM,OAANA,0DAAO;mEAAzB;;mBAJ4B4H;mEAG5B;;aAHyBC;iEAE1B;;mBAFuBuP;;;;iEAM1B;;;uEADqBE;kEACrB,KADqBA;kEACrB,KADqBA;mEAKhB;;aAHSvP;mEAET;;aAFMC;mEAEN;oBADchI;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADIwX;;;;iEAKR;;;uEADwBkzC;kEACxB,KADwBA;kEACxB,KADwBA;mEAKnB;;aAHSiB;mEAET;;aAFMf;mEAEN;oBADc5qD;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADI2qD;;;;iEAKR;;;uEAD4BE;kEAC5B,KAD4BA;mEAIvB;;aAFMC;kEACP;;;oBADIC;;;iEAIR;UAD6BE;;iEAE3B;;mBAF2BA;;iEAI7B;UAD2BC;;iEAEzB;;mBAFyBA;;iEAI3B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;gEAEI;SADyBh0C;;gEAEvB;;kBAFuBA;+DAMrB;OAH0BvP;OAAHyP;gEAGvB;2EAH0BzP;8DAE3B;;gBAFwByP;6EAGF;;8DAM7B;;;;;;;;;+DAcM;;UAVuB0wC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAQxB;QAFeloD;iEAAM,OAANA,0DAAO;8DAAtB;;sBAPwBmoD;;;4EAc3B;;8DAMH;;;;;;;+DAWM;;UAR+BmH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBp4C;;iEAEtB;;kCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;8BAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHwBxP;UAAH0iD;mEAGrB;;aAHwB1iD;iEAEzB;;mBAFsB0iD;;;kEAOrB;UAH6BE;UAAHD;mEAG1B;;aAH6BC;iEAE9B;;mBAF2BD;;;iEAK9B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+B0E;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBv4C;;iEAEtB;;kCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;8BAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHuBxP;UAAH0iD;mEAGpB;;kCAHuB1iD;iEAExB;;mBAFqB0iD;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADwBE;;iEAEtB;;kCAFsBA,gEAGhB;;8DAMZ;;kEAKQ;UAJwBljD;UAAHuP;mEAIrB;;aAJwBvP;iEAEzB;;kCAFsBuP;;;kEASrB;UAJ0BpP;UAAHsP;mEAIvB;;4BAJ0BtP;iEAE3B;;kCAFwBsP;;;iEAO3B;UAD6BE;;iEAE3B;;mBAF2BA;;kEAMzB;UAH4BozC;UAAHF;mEAGzB;;4BAH4BE;mEAG5B;oBADc5qD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF0B0qD;iFAIH;4BAKxB1qD;+DAAM;mCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB4vD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;iEAEI;UADwBz4C;;iEAEtB;;mBAFsBA;;iEAIxB;;;mEAAqB;;aADEE;mEACF;;;;;iBAAjBu3C;iBAASD;;iEAGb;UADyBp3C;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BkzC;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;2CAF0BA;;iEAI5B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADwBE;;iEAEtB;;0CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;+CAF2BA;;iEAI7B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4B3jD;UAAH6jD;mEAGzB;;aAH4B7jD;iEAE7B;;mBAF0B6jD;iFAGJ;yCAMzB1rD;8DACF;+BADEA,2DAEiB;oCAMjBA;8DACF;+BADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR+B8vD;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;kEAKQ;UAJyBnoD;UAAHuP;mEAItB;;sBAJyBvP;iEAE1B;;kCAFuBuP;;;iEAM1B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAIhB;UADmB1P;UAAHI;UAAHwP;mEACb;;aADaA;kEAKtB;;aAL4B5P;mEAIb;;aAHd8/B,MADwB1/B;iEAIzB;iBAHC0/B;yEAGD;;;;iEAGH;UAD4BgjB;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;+DAQM;;gCAN4B1I;8DAI5B;;gBAL0BC;4EAS7B;;8DAMH;;;;;;;+DAWM;;UAR+BgO;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;+DAMH;;;kEAEI;UAD0B/4C;;kEAExB;;mBAFwBA;;kEAI1B;;;sEADsBE;mEACtB,GADsBA;mEACtB,GADsBA;mEACtB;WADsBA;oEAKjB;;aAHYxP;oEAEZ;;aAFSF;mEACN;;kBADA4P;4EACA;oBADG3P;;;;kEAKX;;;;WADyB6iD;mEACzB;WADyBA;mEACzB;WADyBA;mEACzB;WADyBA;oEAKpB;;aAHY4B;oEAEZ;;aAFSvkD;mEACN;;kBADA4iD;4EACA;oBADG3iD;;;;kEAKX;;;;WAD6B6iD;mEAC7B;WAD6BA;oEAIxB;;aAFMD;mEACP;;;oBADIG;;;kEAIR;UAD4BE;;kEAE1B;;mBAF0BA;;kEAI5B;UAD4BC;;kEAE1B;;mBAF0BA,iEAEP;4BAMrBlrD;+DACF;mEADEA;gEACF,GADEA;gEAGA;;UAFM6H;+DAEN;QADc7H;kEAAM,OAANA,2DAAO;+DAAtB;;sBADIoX;8EAEe;;+DAuCtB;;;;0EAEiD;sCAM7CpX;+DACF;gCADEA,4DAEkB;;+DA0BtB;;;;;;;;;gEAeM;;UAXgConD;gEAShC;;UAVyBC;gEAQzB;;UAT8BC;+DAM9B;;+BAPyBC;;;6EAe5B;;+DAMH;;;;0EAE2C;;+DAM3C;;;;;;;;;gEAcM;;UAVwBC;gEAQxB;;UAT+BC;gEAO/B;;2BARyBC;+DAQzB;QAFe1nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB2nD;;;6EAc5B;;+DAMH;;;;;;;;;gEAcM;;UAVuBC;gEAQvB;;UAT8BC;gEAO9B;;UARwBC;+DAQxB;QAFe9nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPwB+nD;;;6EAc3B;;+DAMH;;;;;;;;;;;gEAuBM;;UAlBiClH;gEAgBjC;;UAjB8BC;gEAc9B;;qCAfmCC;+DAenC;QALQ/gD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAV6B4pC;+DAO7B;;+BAR2BC;;;;6EAuB9B;;+DAMH;;;;;;;;;gEAcM;;UAV+BM;gEAQ/B;;UATwBC;gEAOxB;;UARyBC;+DAQzB;QAFezhD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB0hD;;;6EAc5B;;+DAMH;;kEAIQ;SAHuB75C;SAAHuP;mEAGpB;;qBAHuBvP;kEAEC;;;4BAFJuP;;+DAKxB;OADyBE;;+DAEvB;;+BAFuBA,gEAGjB;;+DAMZ;;;;;;;;;;;;;;;;;gEAmCM;;UA3ByB4oC;gEAyBzB;;UA1BgCC;gEAwBhC;;mBAzB8BC;gEAuB9B;;UAxB6BC;gEAsB7B;;UAvB0BC;+DAuB1B;QANQtgD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAIA;;YAHS4H;mEAET;;YAFMC;kEACP;;kBADIuP;;gFAGgB;+DAL3B;;;gBAjB2BmpC;+DAiB3B;QALQvgD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAZ4BopC;+DAY5B;QAFexgD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAX0BygD;;;;;;;6EAmC7B;;+DAMH;;;;0EAE6C;;+DAM7C;;;;;;;;;;mEAII;WAD2BrpC;;mEAEzB;;iDAFyBA;iEAI3B;SAD0BE;;iEAExB;;yCAFwBA,iEAIH;;+DAM3B;;;;;;;;;;;gEAiBM;;UAZ8B8wC;gEAU9B;;UAXuBC;gEASvB;;UAVwBC;gEAQxB;;UAT2BC;+DAS3B;QAFevoD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBwoD;;;;6EAiB3B;;+DAMH;;;;0EAG+C;;+DAM/C;;;;;;;;;;;gEAiBM;;UAZ8BI;gEAU9B;;UAXuBC;gEASvB;;mBAVuBC;iEAQE;;;oBATDC;gEASC;QAFV/oD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBgpD;;;;6EAiB3B;;+DAIH;;kEAEI;;kEAEA;;kEAEA,mEAAqB;;+DAMzB;;;;;;;;;;;gEAiBM;;UAZwBrC;gEAUxB;;UAX+BC;+DAW/B;QAFe5mD;kEAAM,OAANA,2DAAO;+DAAtB;;;gBAVyB6mD;gEAQzB;;UATyBC;+DASzB;QAFe9mD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARyB+mD;;;;6EAiB5B;;+DAMH;;;;0EAEyC;wBAIrC/mD;+DACF,OADEA,0DACD;4BAICA;+DACC;;UADDA;iEAEG;;;;YAFHA;oEAEoB;;;cAFpBA;;;;;qEAEoB;oEAAqB;;oBAFzCA;kEAGK,UAHLA;+DAKA,kEAAmB;;+DAMvB;;;;0EAIyB;;+DAIzB;;;kEAEI;;;mEAA6B;;mBADPoX;;;kEAGtB;UADuBE;;kEACvB;iBADuBA;;;UAEMzP;UAAH2P;;oBAEDxX;uEAAM,OAANA,2DAAO;mEAAzB;iBAFmBwX;2EAEnB;yBAFsB3P;;kEAI7B;UADwB6iD;;kEACxB;iBADwBA;;;aAEAC;mEACK;;mBADLA;;;aAEAE;mEACK;;mBADLA;;;aAEIE;mEACC;;mBADDA;kFACkC;yBAG9D+D;+DAAJ;kEAAiD;SAAN13C;;kEAAW;;kBAAlD03C,GAAuC13C;gEAAZ,kEAA8B;;+DAI7D;;;kEAEI;UADoBA;;kEACpB;iBADoBA;;aAEEvP,YAAHyP;mEACA;;mBADAA;iBAAGzP;;mEAGoB;UADlBG;UAAHwP;oEACqB;;aADlBxP;mEACH;;mBADAwP;kFACyC;sBAO9Ds3C;+DAAJ;;;iEAOwB;;UAJExc;gEAGF;;gBANpBwc,GAEsBrzD;6EAMrB;;+DAIL;;;;;;;iEAQ4B;;UALE20D;iEAIJ;;UALEC;gEAIA;;gBALEC;;6EAQ3B;;gEAE0B;;;;0EAA0C;;+DAGvE;;;;;;;;;;cACuBI;cAA6BD;cAC/BD;cAA2BD,kEAO7C;iCAEiB3B;+DACpB;OAAI+B;;mB,IAAWC;+DACT;OAQJC;iEARI;gCAFcjC;+DAEd,GAQJiC;YAPMC,GAOND,WAPC7wD,EAOD6wD,iBAPC7wD;iEACI;;YAHH2wD;mEAIA;0EAFD3wD;oEAEC;qBACmBA;wEAAS;;;uBAATA,4DAAsB;oEAAvC;;;;;;;;sBAHHA,8BAEKmgD,iBAFLngD;mBAAK8wD;gEAOG;;cAATD,kEAAuC;;+DAIzC;;;mEAIQ;UAHyBhpD;UAAHuP;oEAGtB;;aAHyBvP;kEAE1B;;mBAFuBuP;;;kEAK1B;;;;oBAEUpX;uEACF;;eADEA;wEACF;eADEA;wEAGA;;gCAFM6H;uEACP;;uBADIuP;qFAE6B;kEAJxC;;yBAF4BE;;kEAQ9B;;;;WAD8BE;mEAC9B;WAD8BA;oEAGX;;aADRxP;mEACP;;;oBADI0iD;oFACgC;sBAEd1qD;gEAAM,OAANA,2DAAO;;+DAIrC;;;mEASQ;UARmC8X;UAAHhQ;UAAHF;UAAHC;UAAHuP;oEAQvB;;aARmCU;oEAO3B;;aAPwBhQ;oEAOxB;oBAHA9H;uEACF;;eADEA;wEACF;eADEA;wEACF;eAAQ6H;wEAAR;eAAQA;wEACoC;;iBAA9BG;uEAAc;qBADvBoP;;gFACuB;wBAAjBE;uFAAkD;oEAHnE;;mBAH6B1P;kEAE9B;;mBAFwBwP;iBAAGvP;;;;;mEAiB1B;UARwCkpD;UAAHzE;UAAHvkD;UAAHC;UAAHsP;oEAQ5B;;aARwCy5C;oEAOhC;;aAP6BzE;oEAO7B;oBAHAtsD;uEACF;;eADEA;wEACF;eADEA;wEACF;eAAQ6H;wEAAR;eAAQA;wEACoC;;iBAA9BG;uEAAc;qBADvBoP;;gFACuB;wBAAjBE;uFAAkD;oEAHnE;;mBAHkCvP;kEAEnC;;mBAF6BuP;iBAAGtP;;;;;mEAY/B;UAH2B4iD;UAAHpzC;oEAGxB;;aAH2BozC;kEAE5B;;mBAFyBpzC;;;aAIIszC,cAAHJ;mEAEtB;iBAFsBA;2EAEtB;mBAFyBI;;mEAM5B;UAH8Ba;UAAHX;UAAHL;oEAGxB;;aAH8BgB;mEAE3B;iBAFqBhB;2EAErB;mBAFwBK;;;mEAO3B;UAHyBG;UAAHN;oEAGtB;;aAHyBM;kEAE1B;;mBAFuBN;;;mEAQe;UAJRkB;UAAHV;UAAHN;;;oBAI4B/qD;uEAAK,OAALA,2DAAM;oEAApB;;mBAJR+rD;mEAGO;;kBAHbhB;4EAGa;oBAHVM;;oFAKoB;;+DAItD;;;;;;;;;;;;QAqBcrrD;kEACF;sEADEA;mEACF,GADEA;mEAGD;;YAFO6H;kEACP;;kBADIuP;gFAEe;+DAJ1B;;;gBAf6B45C;gEAe7B;gEAFA;;UAd+BC;gEAY/B;;UAb4BC;+DAa5B;QALQlxD;kEACF;sEADEA;mEACF,GADEA;mEACF,KAAQ6H;mEAAR,KAAQA;mEACoC;;YAA9BG;kEAAc;gBADvBoP;;2EACuB;mBAAjBE;kFAAkD;+DAHnE;cAT4B85C;uEAS5B;sBAR8BD;;;;6EAwBjC;;+DAKH;;iEACqC;;gEADrC;;;oEAKQ;WAH+BvpD;WAAHC;WAAHuP;qEAGzB;;cAH+BxP;oEAE5B;kBAFsBwP;4EAEtB;yCAFyBvP;;;mEAKhC;WAD0ByP;;oEACA;;oBADAA;;mEAG1B;WAD8BE;;mEAE5B;;sCAF4BA;;mEAI9B;WAD0BkzC;;oEACA;;oBADAA,iEACmB;;+DAIjD;;mEACkC;;mEACD;;mEACK,mEAA6B;;+DAMnE;;;;;;;;;;;;;gEAkBM;;UAZ8B2G;gEAU9B;;wBAX+BC;gEAS/B;;wBAV2BC;+DAU3B;QAFevxD;kEAAM,OAANA,2DAAO;+DAAtB;cAX2B0xD;cACKD;uEAUhC;sBATkCD;;;6EAgBrC;;+DAIH;;mEACgC;;mEACE;;mEACD,mEAAwB;;+DAIzD;;;mEAIQ;UAH2B3pD;UAAHuP;oEAGxB;;2BAH2BvP;kEAE5B;;mBAFyBuP;;;mEAOxB;UAH6BxP;UAAHI;UAAHsP;oEAGvB;;aAH6B1P;mEAE1B;iBAFoB0P;2EAEpB;mBAFuBtP;;;mEAO1B;UAH8B4iD;UAAHpzC;oEAG3B;;qCAH8BozC;kEAE/B;;iCAF4BpzC;kFAGW;;+DAM9C;;;mEAIQ;UAH+B3P;UAAHuP;oEAG5B;;aAH+BvP;kEAEhC;;mBAF6BuP;;;mEAO5B;UAHiCtP;UAAHF;UAAHI;UAAHsP;oEAGxB;;aAHiCxP;oEAEd;;aAFWF;mEAE3B;iBAFqB0P;2EAErB;mBAFwBtP;;;;mEAO3B;UAHgCskD;UAAHvkD;UAAH6iD;UAAHpzC;oEAGvB;;aAHgC80C;oEAEb;;aAFUvkD;mEAE1B;iBAFoByP;2EAEpB;mBAFuBozC;;kFAGP;;+DAI3B;;;;;;;;;;;cAGkC/iD,YAAHuP;mEAExB;;oBAFwBA;kBAAGvP;;oEAM1B;WAH6BD;WAAHI;WAAHsP;qEAGvB;;cAH6B1P;oEAE1B;kBAFoB0P;4EAEpB;oBAFuBtP;;;oEAO1B;WAH6BD;WAAH6iD;WAAHpzC;qEAGvB;;4BAH6BzP;qEAEd;;cAFW6iD;mEAE3B;;oBAFwBpzC;;;;oEAOvB;WAH2BszC;WAAHJ;qEAGxB;;4BAH2BI;mEAE5B;;oBAFyBJ;;;oEAOxB;WAH6BM;WAAHL;qEAG1B;;cAH6BK;mEAE9B;;oBAF2BL;;;oEAU1B;WAN2BQ;WAAHN;qEAMxB;;wBAN2BM;qEAM3B;qBAHOnrD;wEACF;;gBADEA;yEACF;gBADEA;wEAEG;sBADAoX;gFACA;wBADGvP,8DACgB;mEAH9B;;0BAFyBgjD;;;mEAQ5B;;;;qBAEU7qD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAEmB;;kBADV4H;wEACN;sBADAwP;gFACA;wBADGvP;sFACgC;mEAH9C;;0BAFyBkjD;;oEAOK;WAANE;;oEAAM;kBAANA;;mEAE1B;;;;qBAEUjrD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAGA;;gCAFS4H;wEACN;sBADAwP;gFACA;sCADGvP;sFAEyB;mEAJvC;;0BAFsBqjD;;mEAQxB;WAD0BE;;mEAExB;;kCAFwBA;;cAGEC,cAAHC;oEACA;;oBADAA;kBAAGD;;oEAMxB;WAJkCvjD;WAAH6jD;WAAHJ;WAAHC;;qBAIPxrD;wEAAM;gCAAcA;mFAAM,OAANA,2DAAO;uBAA3BA,4DAA8B;qEAAhD;;oBAJkC8H;qEAGlC;;cAH+B6jD;qEAEhB;;cAFaJ;mEAE7B;;oBAF0BC;;;;;oEAOG;WAFHC;WAAHC;qEAEM;;cAFHD;qEAEG;qBAAdzrD;wEAAM,OAANA,2DAAO;mEAAtB;;0BAFuB0rD;;;oEAMtB;WAH8BK;WAAHH;WAAHC;qEAGxB;;4BAH8BE;qEAG9B;qBADkB/rD;wEAAM,OAANA,2DAAO;oEAAtB;kBAFqB6rD;4EAErB;0BAFwBD;mFAGC;;+DAIpC;;iEAEI;;;mBAEU5rD;sEACF;0EADEA;uEACF,GADEA;uEACF,GADEA;uEAGA;;8BAFS4H;sEACN;oBADAwP;8EACA;sBADGvP;oFAEsB;iEAJpC;;wBAFyBuP;gEAUvB;OAHyBvP;OAAHyP;iEAGtB;;wBAHyBzP;+DAE1B;;gBAFuByP;8EAGM;;+DAIpC;;iEASqC;;gEATrC;;;mEAEI;WAD0BF;;mEAExB;;mCAFwBA;;oEAGK;WAANE;;oEAAM;kBAANA;;oEAIrB;WAH2BzP;WAAH2P;qEAGxB;;6BAH2B3P;mEAE5B;;oBAFyB2P;;;mEAM5B;WAD0BkzC;;oEACA;;oBADAA;;oEAEI;WAANC;;oEAAM;kBAANA;;oEACQ;WAANE;;oEAAM;kBAANA;;oEACM;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD8BE;;mEAC9B;kBAD8BA;;mEAG9B;WADyBC;;mEAEvB;;mCAFuBA;;mEAIzB;WAD4BE;;mEAC5B;kBAD4BA;;mEAG5B;;;;qBAEUprD;wEACF;;gBADEA;yEACF;gBADEA;yEAGA;;kBAFM6H;wEACP;;wBADIuP;sFAEiB;mEAJ5B;;0BAFyBk0C;;oEAOM;WAANE;;oEAAM;kBAANA;;oEACK;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD0BG;;mEAExB;;mCAFwBA;;cAGM7jD,cAAH8jD;oEAEtB;kBAFsBA;4EAEtB;mCAFyB9jD,iEAEO;wBAEPhI;gEAAM,OAANA,2DAAO;;+DAI3C;;;mEAIQ;UAH0B6H;UAAHuP;oEAGvB;;aAH0BvP;kEAE3B;;mBAFwBuP;;;aAICpP,cAAHsP;kEAEtB;;mBAFsBA;iBAAGtP;;mEAGI;UAANwP;;mEAAM;iBAANA,gEAAkC;;+DAIhE;;iEAEI;SADsBJ;;kEACA;;kBADAA;UAEIvP,YAAHyP;gEAEhB;cAFgBA;wEAEhB;gBAFmBzP,8DAEU;;+DAIxC;;iEAC+B;;gEAD/B;;;oEAEmC;WAANuP;;oEAAM;kBAANA;;oEACG;;;;oEAAuB;;oBAA7BE;;;oEACQ;WAANE;;oEAA8B;;oBAA9BA;;oEACK;WAANkzC;;oEAA6B;;oBAA7BA,iEAA2C;;+DAItE;;;;;;;;;gEAkBM;;UAdgCiH;+DAchC;QANQ3xD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAGA;;0BAFS4H;kEACN;gBADAwP;0EACA;gCADGvP;gFAEyB;+DAJvC;;;gBARqC+pD;+DAQrC;QAFe5xD;kEAAM,OAANA,2DAAO;+DAAtB;cAR6B8xD;uEAQ7B;sBAP+BD;;6EAiBlC;wBAEU7xD;gEAAI;yBAAJA,4DAAwB;;;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kC7Bp0Dd0nC,MAAM3vB;6DAG7B;eAHuB2vB;+DAKrB;sEAL2B3vB;gEAK3B;;;aACItc,IADA62C;+DAAJ;mBAEIyf,SAPuBh6C;gBAKvBu6B;;6DAIC,OATsBv6B,yDASrB;wC,IAE4Bu6B;6BAElB0f,SAASC;6DAC3B;;aAD2BA;aAATD,iEAC6B;;6DAM/C;;;;;;;8DAWM;;UAR+BzH;8DAM/B;;UAPwBC;6DAKxB;;gBALwBA,SADCC;;2EAW5B;oCAEoBnY;iB;+DA8JnB;gBA9JmBA;;;;iEAMnB;WADwBl7B;;iEAEtB;;qCAFsBA;;iEAKxB;WAD2BE;;iEAEzB;;oBAXiBg7B,IASQh7B;;kEAOvB;WAJyB1P;WAAHC;WAAH2P;mEAInB;;cAJyB5P;mEAGzB;;mCAHsBC;iEAEvB;;oBAFoB2P;;;;iEAMvB;WAD2BkzC;;iEAEzB;;gCAFyBA;;kEAQvB;WAL4B5iD;WAAHC;WAAHC;WAAH2iD;mEAKnB;;cAL4B7iD;mEAI5B;;cAJyBC;mEAGzB;;0BAHsBC;iEAEvB;;oBAFoB2iD;;;;;kEASnB;WAHwBC;WAAHC;;qBAIb7qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;kBAFM6H;sEACP;;wBADIuP;oFAEkB;mEAJ7B;;oBAHwBwzC;iEAEzB;;oBAFsBC;;;kEAWrB;WAHwBC;WAAHC;mEAGrB;;0BAHwBD;iEAEzB;;oBAFsBC;;;kEAOrB;WAHsBC;WAAHC;mEAGnB;;0BAHsBD;iEAEvB;;oBAFoBC;;;iEAKvB;WADwBC;;iEAEtB;;gCAFsBA;;mEAOpB;WAJ4BC;WAAHC;oEAIzB;;0BAJ4BD;kEAE7B;;qCAF0BC;;;mEAQzB;WAH0BC;WAAHC;oEAGvB;;0BAH0BD;kEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;0BARyBD;oEAQzB;qBALOvrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;yCADIuP;qFAGkB;kEAL7B;;0BAFuBo0C;;;mEAYtB;WAHwBC;WAAHC;oEAGrB;;+BAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAL8BC;WAAHC;WAAHC;oEAKxB;;cAL8BF;oEAG9B;;+BAH2BC;kEAE5B;;oBAFyBC;;;;kEAO5B;WADwBC;;kEAEtB;;gCAFsBA;;mEAOpB;WAJgCC;WAAHC;WAAHC;oEAI1B;;0BAJgCF;oEAGhC;;cAH6BC;kEAE9B;;oBAF2BC;;;;mEAQ1B;WAH2BC;WAAHC;oEAGxB;;cAH2BD;kEAE5B;;oBAFyBC;;;mEAOxB;WAHwBC;WAAHC;oEAGrB;;cAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAN+Bv0C;WAAHw0C;WAAHC;WAAHC;WAAHC;oEAMnB;;cAN+B30C;oEAK/B;;cAL4Bw0C;oEAI5B;;cAJyBC;oEAGzB;;cAHsBC;kEAEvB;;oBAFoBC;;;;;;mEAUnB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;mEAQ1B;WAJ4BC;WAAHC;WAAHC;oEAItB;;cAJ4BF;oEAG5B;;yBAHyBC;kEAE1B;;oBAFuBC;;;;cAKCC,eAAHC;kEAErB;;oBAFqBA;kBAAGD;;kEAI3B;WADsBE;;kEAEpB;;qCAFoBA;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;oEAG7B;qBADcltD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF2BmtD;;;kEAK9B;;;;qBAEUntD;uEACF;;gBADEA;wEACF;gBADEA;wEAGA;;kBAFM6H;uEAEN;;gBADc7H;yEAAM,OAANA,0DAAO;uEAAtB;;8BADIoX;qFAEkB;kEAJ7B;;0BAFyBg2C;;mEAWvB;WAJ+BC;WAAHC;WAAHC;oEAIzB;;cAJ+BF;oEAG/B;;cAH4BC;oEAG5B;qBADcttD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF0ButD;;;;kEAM7B;WADyBC;;kEAEvB;;oBAFuBA;;kEAIzB;WADuBC;;kEAErB;;oBAFqBA;;mEAMnB;WAHuBC;WAAHC;oEAGpB;;yBAHuBD;kEAExB;;oBAFqBC;;;kEAKxB;WADyBC;;kEAEvB;;oBAFuBA;;cAGKC,eAAHC;mEAEpB;kBAFoBA;2EAEpB;oBAFuBD;;kEAI9B;WADuBE;;kEAErB;;oBAFqBA;;mEAQnB;WAL0BC;WAAHC;WAAHC;oEAKpB;;cAL0BF;oEAG1B;;+BAHuBC;kEAExB;;oBAFqBC;;;;kEAOxB;WAD4BC;;kEAE1B;;oBAF0BA;;8DAUhC;;;;yEAE6C;;8DAI7C;;;;;+DAWM;;UARsBlF;+DAMtB;;sBAPwBC;8DAKxB;;gBANsBC;;4EAWzB;;8DAMH;;;;;;;;;+DAcM;;UAVuBnC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAMxB;;gBAPuBC;;;4EAc1B;;8DAIH;;;;;;;+DAWM;;UAR+BiH;+DAM/B;;UAPwBC;8DAKxB;;gBALwBA,SADCC;;4EAW5B;iCAEiBhc;iB;+DAMhB;;;;kEAEA;;;qBACiBtyC;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFoBoX;;mEAMlB;WAHwBvP;WAAHyP;;qBAGNtX;uEAAM,OAANA,0DAAO;oEAAtB;;oBAHwB6H;kEAEzB;;oBAFsByP;;;kEAKzB;WAD2BE;;kEAEzB;;oBAhBc86B,IAcW96B;;mEAMvB;WAH2BxP;WAAH0iD;oEAGxB;;cApBYpY,IAiBetqC;kEAE5B;;oBAnBasqC,IAiBYoY;;;kEAK5B;WADwBC;;kEAEtB;;+BAFsBA;;mEAOpB;WAJ4BC;WAAHC;oEAIzB;;yBAJ4BD;kEAE7B;;qCAF0BC;;;mEAQzB;WAH0BC;WAAHC;oEAGvB;;yBAH0BD;kEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;cARyBD;oEAQzB;qBALOhrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;yCADIuP;qFAGe;kEAL1B;;0BAFuB6zC;;;kEAU1B;WADwBC;;kEAEtB;;+BAFsBA;;mEAMpB;WAHqBC;WAAHC;oEAGlB;;cAHqBD;kEAEtB;;oBAFmBC;;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;kEAK9B;WADuBE;;kEAErB;;qCAFqBA;;kEAKvB;WADuBE;;kEAErB;;oBAFqBA;;kEAIvB;;;;qBACiB1rD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFuB6rD;;kEAIzB;WAD4BC;;kEAE1B;;oBAF0BA;;kEAI5B;WAD4BG;;kEAE1B;;oBAF0BA;;8DAQhC;;;;;;;+DAWM;;UAR+BsC;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;WADsBr3C;;kEACtB;kBADsBA;;mEAMlB;WAJ2BxP;WAAHC;WAAHyP;oEAIrB;;cAJ2B1P;oEAGH;;cAHAC;oEAGxB;;cAHqByP;kEAEtB;;oBAFsBA;;;;kEAMzB;WADwBE;;kEAEtB;;+BAFsBA;;mEAOpB;WAJyBxP;WAAH0iD;oEAItB;;yBAJyB1iD;kEAE1B;;qCAFuB0iD;;;mEAYtB;WAPyBE;WAAHD;oEAOtB;;cAPyBC;oEAOzB;qBAJO5qD;uEACF;;gBADEA;wEACF;gBADEA;wEACF;gBADEA;wEAGA;;kBAFS4H;uEACN;sBADAwP;+EACA;wBADGvP;qFAEc;kEAJ5B;;0BAFuB8iD;;;mEAYtB;WAJwBG;WAAHD;oEAIrB;;yBAJwBC;kEAEzB;;qCAFsBD;;;cAKGG,cAAHD;kEAEtB;;oBAFsBA;kBAAGC;;mEAOxB;WAJ6BjjD;WAAHojD;WAAHF;;qBAKfjrD;uEAAM;oCAANA,2DAA2B;oEADnC;;oBAJ6B+H;oEAG7B;;cAH0BojD;kEAE3B;;qCAFwBF;;;;mEASvB;WAHuBI;WAAHH;oEAGpB;;cAHuBG;oEAGvB;qBADcrrD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFqBkrD;;;kEAKxB;WAD0BE;;kEAExB;;oBAFwBA;;kEAI1B;WAD4BE;;kEAE1B;;oBAF0BA,gEAEP;iCAMrBtrD;8DACF;kEADEA;+DACF,GADEA;8DACF;QAGUA;iEACF;qEADEA;kEACF,GADEA;kEAIA;;YAHM6H;iEACP;;mCADIuP;+EAGiB;8DAL5B;;0EAFMvP;8DACP;;iCADIuP;6EAO+B;;8DAMtC;;iEAKQ;SAJwBtP;SAAHF;SAAHC;SAAHuP;kEAIf;;uBAJwBtP;kEAGF;;YAHDF;kEAGrB;;YAHkBC;gEAEnB;;kBAFgBuP;;;;8DAMnB;OADsBE;;8DAEpB;;gBAFoBA,+DAED;+BAKnBtX;+DAAM;gCAANA,2DAA+B;8BAMjCA;8DACF;kEADEA;+DACF,GADEA;gEAGc;0EAFXoX;+DAEH;;gBAFMvP;8DAEN;QADc7H;iEAAM,OAANA,0DAAO;8DAAtB;;sBADIoX;6EAE6B;4BAErBk7B;iB;;iEAIX;UADkBl7B;;iEAEhB;;mBAFgBA;;iEAIlB;kBAPWk7B;;iEASX;UADkBh7B;;iEAEhB;;mBAFgBA;;kEAMd;UAHkBzP;UAAH2P;mEAGf;;yBAHkB3P;iEAEnB;;mBAFgB2P;;8BAQjBxX;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB0uD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;kEAIQ;UAHuB9mD;UAAHuP;mEAGpB;;aAHuBvP;iEAExB;;mBAFqBuP;;;kEAOpB;UAHwBpP;UAAHsP;mEAGrB;;kCAHwBtP;iEAEzB;;mBAFsBsP;;;iEAKzB;UAD4BE;;iEAE1B;;mBAF0BA;;aAGDozC,cAAHF;kEACD;;mBADCA,KAAGE;;iEAG3B;UADyBD;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;yCAF0BA;;iEAI5B;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UAD4BG;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4Bf;UAAHgB;mEAGzB;;aAH4BhB;iEAE7B;;mBAF0BgB;iFAGJ;kCA4iBzBgD;+DAAJ;;;;;;;iEAWQ;;UAPgCrG;iEAKhC;;UANyBC;gEAIF;;gBAP3BoG,GAE6BnG;;6EAU5B;wCAljBD3oD;8DACF;kCADEA,2DAEkB;gCAmflB8uD;+DAAJ;;;;;;;;;;;;;iEAwBQ;;UAjB8BzI;iEAe9B;;UAhBuBC;iEAcD;;UApB1BwI,GAK4BvI;gEAeF;QADPvmD;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAfwBwmD;gEAexB;QALQxmD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;gEAJ3B;;;gBAV0B23C;gEAQ1B;;gBATwBtI;;;;;6EAuB3B;sCAtgBDzmD;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR8BgvD;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJwBrnD;UAAHuP;mEAIrB;;wBAJwBvP;iEAEzB;;oCAFsBuP;;;iEAMzB;UAD2BE;;iEAEzB;;mBAFyBA;;kEAQvB;UAL2BxP;UAAHF;UAAHI;UAAHwP;mEAKlB;;aAL2B1P;mEAI3B;;aAJwBF;mEAGxB;;yBAHqBI;iEAEtB;;mBAFmBwP;;;;;kEASlB;UAHuBozC;UAAHF;;oBAIZ1qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;iBAFM6H;sEACP;;uBADIuP;oFAEkB;mEAJ7B;;mBAHuBwzC;iEAExB;;mBAFqBF;;;kEAYpB;UAJwB3iD;UAAH+iD;UAAHH;mEAIlB;;aAJwB5iD;mEAGxB;;kCAHqB+iD;iEAEtB;;mBAFmBH;;;;kEAQlB;UAH4BK;UAAHH;mEAGzB;;aAH4BG;iEAE7B;;mBAF0BH;;;iEAK7B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;;;;+DAQM;;6BAN4B7E;8DAI5B;;gBAL0BC;4EAQ7B;;8DAMH;;;;;;;+DAWM;;UAR8BgJ;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJ4BznD;UAAHC;UAAHuP;;oBAIJpX;sEAAM,OAANA,0DAAO;mEAAzB;;mBAJ4B4H;mEAG5B;;aAHyBC;iEAE1B;;mBAFuBuP;;;;iEAM1B;;;uEADqBE;kEACrB,KADqBA;kEACrB,KADqBA;mEAKhB;;aAHSvP;mEAET;;aAFMC;mEAEN;oBADchI;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADIwX;;;;iEAKR;;;uEADwBkzC;kEACxB,KADwBA;kEACxB,KADwBA;mEAKnB;;aAHSiB;mEAET;;aAFMf;mEAEN;oBADc5qD;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADI2qD;;;;iEAKR;;;uEAD4BE;kEAC5B,KAD4BA;mEAIvB;;aAFMC;kEACP;;;oBADIC;;;iEAIR;UAD6BE;;iEAE3B;;mBAF2BA;;iEAI7B;UAD2BC;;iEAEzB;;mBAFyBA;;iEAI3B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;gEAEI;SADyBh0C;;gEAEvB;;kBAFuBA;+DAMrB;OAH0BvP;OAAHyP;gEAGvB;;UAH0BzP;8DAE3B;;gBAFwByP;6EAGF;;8DAM7B;;;;;;;;;+DAcM;;UAVuB0wC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAQxB;QAFeloD;iEAAM,OAANA,0DAAO;8DAAtB;;sBAPwBmoD;;;4EAc3B;;8DAMH;;;;;;;+DAWM;;UAR+BmH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBp4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHwBxP;UAAH0iD;mEAGrB;;aAHwB1iD;iEAEzB;;mBAFsB0iD;;;kEAOrB;UAH6BE;UAAHD;mEAG1B;;aAH6BC;iEAE9B;;mBAF2BD;;;iEAK9B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+B0E;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBv4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHuBxP;UAAH0iD;mEAGpB;;oCAHuB1iD;iEAExB;;mBAFqB0iD;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADwBE;;iEAEtB;;oCAFsBA,gEAGhB;;8DAMZ;;kEAKQ;UAJwBljD;UAAHuP;mEAIrB;;aAJwBvP;iEAEzB;;oCAFsBuP;;;kEASrB;UAJ0BpP;UAAHsP;mEAIvB;;8BAJ0BtP;iEAE3B;;oCAFwBsP;;;iEAO3B;UAD6BE;;iEAE3B;;mBAF2BA;;kEAMzB;UAH4BozC;UAAHF;mEAGzB;;8BAH4BE;mEAG5B;oBADc5qD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF0B0qD;iFAIH;8BAKxB1qD;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB4vD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;iEAEI;UADwBz4C;;iEAEtB;;mBAFsBA;;aAGGvP,YAAHyP;kEACD;;mBADCA,KAAGzP;;iEAG3B;UADyB2P;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BkzC;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;6CAF0BA;;iEAI5B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4BxjD;UAAH0jD;mEAGzB;;aAH4B1jD;iEAE7B;;mBAF0B0jD;iFAGJ;2CAMzB1rD;8DACF;iCADEA,2DAEiB;sCAMjBA;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR+B8vD;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;kEAKQ;UAJyBnoD;UAAHuP;mEAItB;;wBAJyBvP;iEAE1B;;oCAFuBuP;;;iEAM1B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ2B1P;UAAHI;UAAHwP;mEAIrB;;aAJ2B5P;mEAGH;;aAHAI;mEAGxB;;aAHqBwP;iEAEtB;;mBAFsBA;;;;iEAMzB;UAD4BkzC;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;+DAQM;;kCAN4B1I;8DAI5B;;gBAL0BC;4EAS7B;;8DAMH;;;;;;;gEAWM;;UAR+BgO;gEAM/B;;UAPwBC;+DAKxB;;gBANyBC;;6EAW5B;;+DAMH;;;kEAEI;UAD0B/4C;;kEAExB;;mBAFwBA;;kEAI1B;;;sEADsBE;mEACtB,GADsBA;mEACtB,GADsBA;mEACtB;WADsBA;oEAKjB;;aAHYxP;oEAEZ;;aAFSF;mEACN;;kBADA4P;4EACA;oBADG3P;;;;kEAKX;;;;WADyB6iD;mEACzB;WADyBA;mEACzB;WADyBA;mEACzB;WADyBA;oEAKpB;;aAHY4B;oEAEZ;;aAFSvkD;mEACN;;kBADA4iD;4EACA;oBADG3iD;;;;kEAKX;;;;WAD6B6iD;mEAC7B;WAD6BA;oEAIxB;;aAFMD;mEACP;;;oBADIG;;;kEAIR;UAD4BE;;kEAE1B;;mBAF0BA;;kEAI5B;UAD4BC;;kEAE1B;;mBAF0BA,iEAEP;8BAMrBlrD;+DACF;mEADEA;gEACF,GADEA;iEAGc;2EAFXoX;gEAEH;;gBAFMvP;+DAEN;QADc7H;kEAAM,OAANA,2DAAO;+DAAtB;;sBADIoX;8EAE6B;;+DAuCpC;;;;0EAEiD;wCAM7CpX;+DACF;kCADEA,4DAEkB;;+DA0BtB;;;;;;;;;gEAeM;;UAXgConD;gEAShC;;UAVyBC;gEAQzB;;UAT8BC;+DAM9B;;iCAPyBC;;;6EAe5B;;+DAMH;;;;0EAE2C;;+DAM3C;;;;;;;;;gEAcM;;UAVwBC;gEAQxB;;UAT+BC;gEAO/B;;6BARyBC;+DAQzB;QAFe1nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB2nD;;;6EAc5B;;+DAMH;;;;;;;;;gEAcM;;UAVuBC;gEAQvB;;UAT8BC;gEAO9B;;UARwBC;+DAQxB;QAFe9nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPwB+nD;;;6EAc3B;;+DAMH;;;;;;;;;;;gEAuBM;;UAlBiClH;gEAgBjC;;UAjB8BC;gEAc9B;;uCAfmCC;+DAenC;QALQ/gD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAV6B4pC;+DAO7B;;iCAR2BC;;;;6EAuB9B;;+DAMH;;;;;;;;;gEAcM;;UAV+BM;gEAQ/B;;UATwBC;iEAOS;;UATRE;gEASzB;;gBARyBD;+DAQzB;QAFezhD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB0hD;;;6EAc5B;+CAE+BpP;iB;kEAQ1B;SAHuBzqC;SAAHuP;mEAGpB;;uBAHuBvP;iEAExB;;kBAP2ByqC,IAKNl7B;;+DAKxB;OADyBE;;+DAEvB;;iCAFuBA;;+DAS7B;;;;;;;;;;;;;;;;;gEAmCM;;UA3ByB4oC;gEAyBzB;;UA1BgCC;gEAwBhC;;qBAzB8BC;gEAuB9B;;UAxB6BC;gEAsB7B;;UAvB0BC;+DAuB1B;QANQtgD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAIA;;YAHS4H;mEAET;;YAFMC;kEACP;;kBADIuP;;gFAGgB;+DAL3B;;;gBAjB2BmpC;+DAiB3B;QALQvgD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAZ4BopC;+DAY5B;QAFexgD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAX0BygD;;;;;;;6EAmC7B;;+DAMH;;;;0EAE6C;;+DAM7C;;;;;;;;;;mEAII;WAD2BrpC;;mEAEzB;;mDAFyBA;iEAI3B;SAD0BE;;iEAExB;;2CAFwBA,iEAIH;;+DAM3B;;;;;;;;;;;gEAiBM;;UAZ8BsxC;gEAU9B;;UAXuBC;gEASvB;;qBAVuBC;iEAQK;;UAVJE;gEAUxB;;gBATwBD;+DASxB;QAFe/oD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBgpD;;;;6EAiB3B;wCAE0B1W;iB;iEAMzB;SADyBl7B;;iEACzB;4BADyBA;+DAGzB;eARyBk7B;;+DAc7B;;;;;;;;;;;gEAiBM;;UAZ8B8V;gEAU9B;;UAXuBC;gEASvB;;UAVwBC;gEAQxB;;UAT2BC;+DAS3B;QAFevoD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBwoD;;;;6EAiB3B;;+DAMH;;;;0EAG+C;;+DAI/C;;kEAEI;;kEAEA;;kEAEA,mEAAqB;;+DAMzB;;;;;;;;;;;gEAiBM;;UAZwB7B;gEAUxB;;UAX+BC;+DAW/B;QAFe5mD;kEAAM,OAANA,2DAAO;+DAAtB;;;gBAVyB6mD;gEAQzB;;UATyBC;+DASzB;QAFe9mD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARyB+mD;;;;6EAiB5B;;+DAKH;;iEAC4B;;iEAD5B;;oEAE+B;WAAN3vC;;oEAAM,OAANA;kEACM;SAANE;;kEAAM;uBAANA,gEAAc;;+DAMvC;;;;0EAEyC;0BAIrCtX;gEAAM,OAANA,2DAAO;;+DAIX;;;;0EAIyB;6BAETsyC;iB;;aAIoBzqC,YAAHuP;YAAGvP;;;;;;2EAIL;;2BAJEuP;;;2EAQE;;2BARFA;;;;+EAMF;uBANEA;qEASlB;oBAbCk7B;mEAMmB;;mBAFFl7B;;kEAY7B;UADyBE;;kEACzB;iBADyBA;mBAEMtP,cAAHwP,6BAAGxP;;aAED4iD,cAAHF;gBAAGE;4EAGlB;oBAtBAtY;qBAmBeoY;2BAO3BoE;+DAAJ;kEAAiD;SAAN13C;;kEAAW;;kBAAlD03C,GAAuC13C;gEAAZ,kEAA8B;;gEAEL;;;kEAEpD;UADoBA;;kEACpB;iBADoBA;;aAEEvP,YAAHyP;kEAEhB;;mBAFgBA;iBAAGzP;;mEAKE;UAFAG;UAAHwP;oEAEG;;aAFAxP;kEAErB;;mBAFkBwP;kFAEuB;wBAO5Cs3C;+DAAJ;;;iEAOwB;;UAJExc;gEAGF;;gBANpBwc,GAEsBrzD;6EAMrB;;+DAIL;;;;;;;iEAQ4B;;UALE20D;iEAIJ;;UALEC;gEAIA;;gBALEC;;6EAQ3B;;gEAE0B;;;;0EAA0C;;+DAGvE;;;;;;;;;;cACuBI;cAA6BD;cAC/BD;cAA2BD,kEAO7C;iCAEiB1B,QAAQD;gEAEhB;OAEev6C;kEAFf;kCAFgBu6C;gEAEhB;cAFQC;WAIOx6C;;WAESy8C,GAFTz8C;WAEIrU,EAFJqU;WAKnBi+B,OAFA92C;WAIA2kD,gCAFA7N,YAHuBtyC;;mDAKvBmgD,iBALuBngD;kBAAK8wD;kEADA;gEADA,OAATz8C,+DAWqB;;+DAIhD;;;mEAIQ;UAHyBxM;UAAHuP;oEAGtB;;aAHyBvP;kEAE1B;;mBAFuBuP;;;kEAK1B;;;;oBAEUpX;uEACF;;eADEA;wEACF;eADEA;wEAGA;;kCAFM6H;uEACP;;uBADIuP;qFAE6B;kEAJxC;;yBAF4BE;;kEAQ9B;;;;WAD8BE;mEAC9B;WAD8BA;oEAGX;;aADRxP;mEACP;;;oBADI0iD;oFACgC;wBAEd1qD;gEAAM,OAANA,2DAAO;;+DA4CrC;;;;;;;;QASqBA;kEAAM,OAANA,2DAAO;+DAArB;;;gBAN2BkyD;+DAK3B;cAP0BE;uEAO1B;gBAN0BD;6EAQ3B;;+DAlDN;;gEAoCI;;gEApCJ;;;oEASQ;WARmCr6C;WAAHhQ;WAAHF;WAAHC;WAAHuP;qEAQvB;;cARmCU;qEAO3B;;cAPwBhQ;qEAOxB;qBAHA9H;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAH6B1P;mEAE9B;;oBAFwBwP;kBAAGvP;;;;;oEAiB1B;WARwCkpD;WAAHzE;WAAHvkD;WAAHC;WAAHsP;qEAQ5B;;cARwCy5C;qEAOhC;;cAP6BzE;qEAO7B;qBAHAtsD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAHkCvP;mEAEnC;;oBAF6BuP;kBAAGtP;;;;;oEAY/B;WAH2B4iD;WAAHpzC;qEAGxB;;cAH2BozC;mEAE5B;;oBAFyBpzC;;;cAIIszC,cAAHJ;oEAEtB;kBAFsBA;4EAEtB;oBAFyBI;;oEAM5B;WAH8Ba;WAAHX;WAAHL;qEAGxB;;cAH8BgB;oEAE3B;kBAFqBhB;4EAErB;oBAFwBK;;;oEAO3B;WAHyBG;WAAHN;qEAGtB;;cAHyBM;mEAE1B;;oBAFuBN;;;oEAIM;WAANE;;oEAAM;mBAANA,gEAEyC;;+DAkBvE;;;;;;;;;;;;QAuBc/qD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAhB6B45C;gEAa7B;;UAf+BC;gEAa/B;;UAd4BC;+DAc5B;QALQlxD;kEACF;sEADEA;mEACF,GADEA;mEACF,KAAQ6H;mEAAR,KAAQA;mEACoC;;YAA9BG;kEAAc;gBADvBoP;;2EACuB;mBAAjBE;kFAAkD;+DAHnE;cAV4B85C;uEAU5B;sBAT8BD;;;6EAyBjC;;+DAKH;;iEACqC;;gEADrC;;;oEAKQ;WAH+BvpD;WAAHC;WAAHuP;qEAGzB;;cAH+BxP;oEAE5B;kBAFsBwP;4EAEtB;2CAFyBvP;;;mEAKhC;WAD0ByP;;oEACA;;oBADAA;;mEAG1B;WAD8BE;;mEAE5B;;wCAF4BA;;mEAI9B;WAD0BkzC;;oEACA;;oBADAA,iEACmB;;+DAIjD;;mEACkC;;mEACD;;mEACK,mEAA6B;;+DAMnE;;;;;;;;;;;;;gEAkBM;;UAZ8B2G;gEAU9B;;0BAX+BC;gEAS/B;;0BAV2BC;+DAU3B;QAFevxD;kEAAM,OAANA,2DAAO;+DAAtB;cAX2B0xD;cACKD;uEAUhC;sBATkCD;;;6EAgBrC;;+DAIH;;;;0EAE6C;;+DAI7C;;mEACgC;;mEACE;;mEACD,mEAAwB;;+DAIzD;;;mEAIQ;UAH2B3pD;UAAHuP;oEAGxB;;6BAH2BvP;kEAE5B;;mBAFyBuP;;;mEAOxB;UAH6BxP;UAAHI;UAAHsP;oEAGvB;;aAH6B1P;mEAE1B;iBAFoB0P;2EAEpB;mBAFuBtP;;;mEAO1B;UAH8B4iD;UAAHpzC;oEAG3B;;uCAH8BozC;kEAE/B;;mCAF4BpzC;kFAGW;;+DAM9C;;;mEAIQ;UAH+B3P;UAAHuP;oEAG5B;;aAH+BvP;kEAEhC;;mBAF6BuP;;;mEAO5B;UAHiCtP;UAAHF;UAAHI;UAAHsP;oEAGxB;;aAHiCxP;oEAEd;;aAFWF;mEAE3B;iBAFqB0P;2EAErB;mBAFwBtP;;;;mEAO3B;UAHgCskD;UAAHvkD;UAAH6iD;UAAHpzC;oEAGvB;;aAHgC80C;oEAEb;;aAFUvkD;mEAE1B;iBAFoByP;2EAEpB;mBAFuBozC;;kFAGP;;+DAI3B;;;;;;;;;;;cAGkC/iD,YAAHuP;mEAExB;;oBAFwBA;kBAAGvP;;oEAM1B;WAH6BD;WAAHI;WAAHsP;qEAGvB;;cAH6B1P;oEAE1B;kBAFoB0P;4EAEpB;oBAFuBtP;;;oEAO1B;WAH6BD;WAAH6iD;WAAHpzC;qEAGvB;;8BAH6BzP;qEAEd;;cAFW6iD;mEAE3B;;oBAFwBpzC;;;;oEAOvB;WAH2BszC;WAAHJ;qEAGxB;;8BAH2BI;mEAE5B;;oBAFyBJ;;;oEAOxB;WAH6BM;WAAHL;qEAG1B;;cAH6BK;mEAE9B;;oBAF2BL;;;oEAU1B;WAN2BQ;WAAHN;qEAMxB;;0BAN2BM;qEAM3B;qBAHOnrD;wEACF;;gBADEA;yEACF;gBADEA;wEAEG;sBADAoX;gFACA;wBADGvP,8DACgB;mEAH9B;;0BAFyBgjD;;;mEAQ5B;;;;qBAEU7qD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAEmB;;kBADV4H;wEACN;sBADAwP;gFACA;wBADGvP;sFACgC;mEAH9C;;0BAFyBkjD;;oEAOK;WAANE;;oEAAM;kBAANA;;mEAE1B;;;;qBAEUjrD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAGA;;kCAFS4H;wEACN;sBADAwP;gFACA;wCADGvP;sFAEyB;mEAJvC;;0BAFsBqjD;;mEAQxB;WAD0BE;;mEAExB;;oCAFwBA;;cAGEC,cAAHC;oEACA;;oBADAA;kBAAGD;;oEAMxB;WAJkCvjD;WAAH6jD;WAAHJ;WAAHC;;qBAIPxrD;wEAAM;gCAAcA;mFAAM,OAANA,2DAAO;uBAA3BA,4DAA8B;qEAAhD;;oBAJkC8H;qEAGlC;;cAH+B6jD;qEAEhB;;cAFaJ;mEAE7B;;oBAF0BC;;;;;oEAOG;WAFHC;WAAHC;qEAEM;;cAFHD;qEAEG;qBAAdzrD;wEAAM,OAANA,2DAAO;mEAAtB;;0BAFuB0rD;;;oEAMtB;WAH8BK;WAAHH;WAAHC;qEAGxB;;8BAH8BE;qEAG9B;qBADkB/rD;wEAAM,OAANA,2DAAO;oEAAtB;kBAFqB6rD;4EAErB;0BAFwBD;;;mEAK/B,mEAA4B;;+DAYhC;;iEAEI;;;mBAEU5rD;sEACF;0EADEA;uEACF,GADEA;uEACF,GADEA;uEAGA;;gCAFS4H;sEACN;oBADAwP;8EACA;sBADGvP;oFAEsB;iEAJpC;;wBAFyBuP;gEAUvB;OAHyBvP;OAAHyP;iEAGtB;;0BAHyBzP;+DAE1B;;gBAFuByP;8EAGM;;+DAIpC;;iEASqC;;gEATrC;;;mEAEI;WAD0BF;;mEAExB;;qCAFwBA;;oEAGK;WAANE;;oEAAM;kBAANA;;oEAIrB;WAH2BzP;WAAH2P;qEAGxB;;+BAH2B3P;mEAE5B;;oBAFyB2P;;;mEAM5B;WAD0BkzC;;oEACA;;oBADAA;;oEAEI;WAANC;;oEAAM;kBAANA;;oEACQ;WAANE;;oEAAM;kBAANA;;oEACM;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD8BE;;mEAC9B;kBAD8BA;;mEAG9B;WADyBC;;mEAEvB;;qCAFuBA;;mEAIzB;WAD4BE;;mEAC5B;kBAD4BA;;mEAG5B;;;;qBAEUprD;wEACF;;gBADEA;yEACF;gBADEA;yEAGA;;kBAFM6H;wEACP;;wBADIuP;sFAEiB;mEAJ5B;;0BAFyBk0C;;oEAOM;WAANE;;oEAAM;kBAANA;;oEACK;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD0BG;;mEAExB;;qCAFwBA;;cAGM7jD,cAAH8jD;oEAEtB;kBAFsBA;4EAEtB;qCAFyB9jD,iEAEO;0BAEPhI;gEAAM,OAANA,2DAAO;;+DAI3C;;;mEAIQ;UAH0B6H;UAAHuP;oEAGvB;;aAH0BvP;kEAE3B;;mBAFwBuP;;;aAICpP,cAAHsP;kEAEtB;;mBAFsBA;iBAAGtP;;mEAGI;UAANwP;;mEAAM;iBAANA,gEAAkC;;+DAIhE;;iEAEI;SADsBJ;;kEACA;;kBADAA;UAEIvP,YAAHyP;gEAEhB;cAFgBA;wEAEhB;gBAFmBzP,8DAEU;;+DAMxC;;iEAC+B;;gEAD/B;;;oEAEmC;WAANuP;;oEAAM;kBAANA;;mEAEzB;WADuBE;;mEACvB;;oBADuBA;;mEAGvB;WADwBE;;oEACA;;oBADAA;;mEAGxB;WADuBkzC;;oEACA;;oBADAA,iEACc;;+DAIzC;;;;;;;;;gEAkBM;;UAdgCiH;+DAchC;QANQ3xD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAGA;;4BAFS4H;kEACN;gBADAwP;0EACA;kCADGvP;gFAEyB;+DAJvC;;;gBARqC+pD;+DAQrC;QAFe5xD;kEAAM,OAANA,2DAAO;+DAAtB;cAR6B8xD;uEAQ7B;sBAP+BD;;6EAiBlC;0BAEU7xD;gEAAI;2BAAJA,4DAAwB;a8B72DnCqyD,YACFhiB;sDADgB;;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,YAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,SAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,KAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,MAChBA;uDADgB,OAChBA;uDADgB,WAChBA;uDADgB,UAChBA;sDADgB,qBA0FWrwC;yDAAkD;;;YAAlDA;yDAA0B;;mBAjDlDsyD,gBAxCHjiB,gEAyFwG;sDA1FxF,qBAyFarwC;yDAAsD;;;YAAtDA;yDAA4B;;mBAjDtDuyD,kBAvCHliB,gEAwFgH;sDAzFhG,qBAwFSrwC;yDAA8C;;;YAA9CA;yDAAwB;;mBAjD9CwyD,cAtCHniB,+DAuFgG;sDAxFhF,qBAuFKrwC;yDAAsC;;4EAAtCA;yDAAoB;;mBAjDtCyyD,UArCHpiB,+DAsFgF;sDAvFhE,qBAsFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD0yD,eApCHriB,gEAqFoG;sDAtFpF,qBAqFYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD2yD,iBAnCHtiB,gEAoF4G;sDArF5F,qBAoFDrwC;yDAA0B;;sEAA1BA;yDAAc;;mBAjD1Bw8C,IAlCHnM,+DAmFwD;sDApFxC,qBAmFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD4yD,eAjCHviB,gEAkFoG;sDAnFpF,qBAkFKrwC;yDAAsC;;4EAAtCA;yDAAoB;;mBAjDtC4wC,UAhCHP,+DAiFgF;sDAlFhE,qBAiFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD6yD,eA/BHxiB,gEAgFoG;sDAjFpF,qBAgFKrwC;yDAAsC;;4EAAtCA;yDAAoB;;mBAjDtC2wC,UA9BHN,+DA+EgF;sDAhFhE,qBA4FGrwC;yDAAkC;;;iBAAlCA;yDAAkB;;mBAjDlC8yD,QA1CHziB,+DA2FsF;sDA5FtE,qBA+EDrwC;yDAA0B;;sEAA1BA;yDAAc;;mBAjD1Bs9C,IA7BHjN,+DA8EwD;sDA/ExC,qBA8EYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD+yD,iBA5BH1iB,gEA6E4G;sDA9E5F,qBA6EmBrwC;0DAAkE;;;YAAlEA;yDAAkC;;mBAjDlEgzD,wBA3BH3iB,gEA4EwI;sDA7ExH,qBA4EOrwC;yDAA0C;;;YAA1CA;yDAAsB;;mBAjD1CizD,YA1BH5iB,+DA2EwF;sDA5ExE,qBA2EOrwC;yDAA0C;;;YAA1CA;yDAAsB;;mBAjD1CkzD,YAzBH7iB,+DA0EwF;sDA3ExE,qBA0EcrwC;yDAAwD;;;YAAxDA;yDAA6B;;mBAjDxDmzD,mBAxBH9iB,gEAyEoH;sDA1EpG,qBAyEUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhDozD,eAvBH/iB,gEAwEoG;sDAzEpF,qBAwEIrwC;yDAAoC;;2EAApCA;yDAAmB;;mBAjDpCgyD,SAtBH3hB,+DAuE4E;sDAxE5D,qBAuEarwC;yDAAsD;;;YAAtDA;yDAA4B;;mBAjDtDqzD,kBArBHhjB,gEAsEgH;sDAvEhG,qBAsEerwC;yDAA0D;;;YAA1DA;yDAA8B;;mBAjD1DszD,oBApBHjjB,gEAqEwH;sDAtExG,qBAqEerwC;yDAA0D;;;YAA1DA;yDAA8B;;mBAjD1DuzD,oBAnBHljB,gEAoEwH;sDArExG,qBAoEiBrwC;yDAA8D;;;YAA9DA;yDAAgC;;mBAjD9DwzD,sBAlBHnjB,gEAmEgI;sDApEhH,qBAmEKrwC;yDAAsC;;4EAAtCA;yDAAoB;;mBAjDtCyzD,UAjBHpjB,+DAkEgF;sDAnEhE,qBAkEArwC;yDAA4B;;uEAA5BA;yDAAe;;mBAjD5B+8C,KAhBH1M,+DAiE4D;sDAlE5C,qBAiEmBrwC;0DAAkE;;;YAAlEA;yDAAkC;;mBAjDlE0zD,wBAfHrjB,gEAgEwI;sDAjExH,qBAgEYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD2zD,iBAdHtjB,gEA+D4G;sDAhE5F,qBA+DkBrwC;0DAAgE;;;YAAhEA;yDAAiC;;mBAjDhE4zD,uBAbHvjB,gEA8DoI;sDA/DpH,qBA8DMrwC;wDAAwC;;4EAAxCA;wDAAqB;;mBAjDxC6zD,WAZHxjB,8DA6DoF;sDA9DpE,qBA6DWrwC;wDAAkD;;;YAAlDA;wDAA0B;;mBAjDlD8zD,gBAXHzjB,+DA4DwG;sDA7DxF,qBA4DWrwC;wDAAkD;;;YAAlDA;wDAA0B;;mBAjDlD+zD,gBAVH1jB,+DA2DwG;sDA5DxF,qBA2DOrwC;wDAA0C;;;YAA1CA;wDAAsB;;mBAjD1Cg0D,YATH3jB,8DA0DwF;sDA3DxE,qBA0DMrwC;wDAAwC;;4EAAxCA;wDAAqB;;mBAjDxCi0D,WARH5jB,8DAyDoF;sDA1DpE,qBAyDarwC;wDAAsD;;;YAAtDA;wDAA4B;;mBAjDtDk0D,kBAPH7jB,+DAwDgH;sDAzDhG,qBAwDarwC;wDAAsD;;;YAAtDA;wDAA4B;;mBAjDtDm0D,kBANH9jB,+DAuDgH;sDAxDhG,qBAuDCrwC;wDAA8B;;uEAA9BA;wDAAgB;;mBAjD9Bo0D,MALH/jB,8DAsDgE;sDAvDhD,qBAsDArwC;wDAA4B;;sEAA5BA;wDAAe;;mBAjD5Bq0D,OAJHhkB,8DAqD4D;sDAtD5C,qBAqDMrwC;wDAAwC;;4EAAxCA;wDAAqB;;mBAjDxCs0D,WAHHjkB,8DAoDoF;sDArDpE;6BAoDKrwC;gEAAsC;;;oBAAtCA;gEAAoB;;2BAnDtCu0D,UAAHlkB,8DAmDgF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oEAyC/E;aC7FCmkB,cACFnkB;sDADgB;;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,YAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,SAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,KAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,MAChBA;uDADgB,OAChBA;uDADgB,WAChBA;uDADgB,UAChBA;sDADgB,qBA0FWrwC;yDAAkD;;;YAAlDA;yDAA0B;;mBAjDlDsyD,gBAxCHjiB,gEAyFwG;sDA1FxF,qBAyFarwC;yDAAsD;;;YAAtDA;yDAA4B;;mBAjDtDuyD,kBAvCHliB,gEAwFgH;sDAzFhG,qBAwFSrwC;yDAA8C;;;YAA9CA;yDAAwB;;mBAjD9CwyD,cAtCHniB,+DAuFgG;sDAxFhF,qBAuFKrwC;yDAAsC;;0EAAtCA;yDAAoB;;mBAjDtCyyD,UArCHpiB,+DAsFgF;sDAvFhE,qBAsFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD0yD,eApCHriB,gEAqFoG;sDAtFpF,qBAqFYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD2yD,iBAnCHtiB,gEAoF4G;sDArF5F,qBAoFDrwC;yDAA0B;;oEAA1BA;yDAAc;;mBAjD1Bw8C,IAlCHnM,+DAmFwD;sDApFxC,qBAmFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD4yD,eAjCHviB,gEAkFoG;sDAnFpF,qBAkFKrwC;yDAAsC;;0EAAtCA;yDAAoB;;mBAjDtC4wC,UAhCHP,+DAiFgF;sDAlFhE,qBAiFUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhD6yD,eA/BHxiB,gEAgFoG;sDAjFpF,qBAgFKrwC;yDAAsC;;0EAAtCA;yDAAoB;;mBAjDtC2wC,UA9BHN,+DA+EgF;sDAhFhE,qBA4FGrwC;yDAAgD;;wEAAhDA;yDAAgC;;;mBAjDhD8yD,QA1CHziB,+DA2FsF;sDA5FtE,qBA+EDrwC;yDAA0B;;oEAA1BA;yDAAc;;mBAjD1Bs9C,IA7BHjN,+DA8EwD;sDA/ExC,qBA8EYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD+yD,iBA5BH1iB,gEA6E4G;sDA9E5F,qBA6EmBrwC;0DAAkE;;;YAAlEA;yDAAkC;;mBAjDlEgzD,wBA3BH3iB,gEA4EwI;sDA7ExH,qBA4EOrwC;yDAA0C;;4EAA1CA;yDAAsB;;mBAjD1CizD,YA1BH5iB,+DA2EwF;sDA5ExE,qBA2EOrwC;yDAA0C;;4EAA1CA;yDAAsB;;mBAjD1CkzD,YAzBH7iB,+DA0EwF;sDA3ExE,qBA0EcrwC;yDAAwD;;;YAAxDA;yDAA6B;;mBAjDxDmzD,mBAxBH9iB,gEAyEoH;sDA1EpG,qBAyEUrwC;yDAAgD;;;YAAhDA;yDAAyB;;mBAjDhDozD,eAvBH/iB,gEAwEoG;sDAzEpF,qBAwEIrwC;yDAAoC;;yEAApCA;yDAAmB;;mBAjDpCgyD,SAtBH3hB,+DAuE4E;sDAxE5D,qBAuEarwC;yDAAsD;;;YAAtDA;yDAA4B;;mBAjDtDqzD,kBArBHhjB,gEAsEgH;sDAvEhG,qBAsEerwC;yDAA0D;;;YAA1DA;yDAA8B;;mBAjD1DszD,oBApBHjjB,gEAqEwH;sDAtExG,qBAqEerwC;yDAA0D;;;YAA1DA;yDAA8B;;mBAjD1DuzD,oBAnBHljB,gEAoEwH;sDArExG,qBAoEiBrwC;yDAA8D;;;YAA9DA;yDAAgC;;mBAjD9DwzD,sBAlBHnjB,gEAmEgI;sDApEhH,qBAmEKrwC;yDAAsC;;0EAAtCA;yDAAoB;;mBAjDtCyzD,UAjBHpjB,+DAkEgF;sDAnEhE,qBAkEArwC;yDAA4B;;qEAA5BA;yDAAe;;mBAjD5B+8C,KAhBH1M,+DAiE4D;sDAlE5C,qBAiEmBrwC;0DAAkE;;;YAAlEA;yDAAkC;;mBAjDlE0zD,wBAfHrjB,gEAgEwI;sDAjExH,qBAgEYrwC;yDAAoD;;;YAApDA;yDAA2B;;mBAjDpD2zD,iBAdHtjB,gEA+D4G;sDAhE5F,qBA+DkBrwC;0DAAgE;;;YAAhEA;yDAAiC;;mBAjDhE4zD,uBAbHvjB,gEA8DoI;sDA/DpH,qBA8DMrwC;wDAAwC;;0EAAxCA;wDAAqB;;mBAjDxC6zD,WAZHxjB,8DA6DoF;sDA9DpE,qBA6DWrwC;wDAAkD;;;YAAlDA;wDAA0B;;mBAjDlD8zD,gBAXHzjB,+DA4DwG;sDA7DxF,qBA4DWrwC;wDAAkD;;;YAAlDA;wDAA0B;;mBAjDlD+zD,gBAVH1jB,+DA2DwG;sDA5DxF,qBA2DOrwC;wDAA0C;;2EAA1CA;wDAAsB;;mBAjD1Cg0D,YATH3jB,8DA0DwF;sDA3DxE,qBA0DMrwC;wDAAwC;;0EAAxCA;wDAAqB;;mBAjDxCi0D,WARH5jB,8DAyDoF;sDA1DpE,qBAyDarwC;wDAAsD;;;YAAtDA;wDAA4B;;mBAjDtDk0D,kBAPH7jB,+DAwDgH;sDAzDhG,qBAwDarwC;wDAAsD;;;YAAtDA;wDAA4B;;mBAjDtDm0D,kBANH9jB,+DAuDgH;sDAxDhG,qBAuDCrwC;wDAA8B;;qEAA9BA;wDAAgB;;mBAjD9Bo0D,MALH/jB,8DAsDgE;sDAvDhD,qBAsDArwC;wDAA4B;;oEAA5BA;wDAAe;;mBAjD5Bq0D,OAJHhkB,8DAqD4D;sDAtD5C,qBAqDMrwC;wDAAwC;;0EAAxCA;wDAAqB;;mBAjDxCs0D,WAHHjkB,8DAoDoF;sDArDpE;6BAoDKrwC;gEAAsC;;;oBAAtCA;gEAAoB;;2BAnDtCu0D,UAAHlkB,8DAmDgF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oEAyC/E;;6DC1GD;;;;;;;8DAWM;;UAR+Bka;8DAM/B;;UAPwBC;6DAKxB;;gBANyBC;;2EAW5B;;6DAMH;;+DA0JI;;8DA1JJ;;iEAEI;WADwBrzC;;iEAEtB;;qCAFsBA;;iEAKxB;WAD2BE;;iEAEzB;;oBAFyBA;;kEAOvB;WAJyB1P;WAAHC;WAAH2P;mEAInB;;cAJyB5P;mEAGzB;;mCAHsBC;iEAEvB;;oBAFoB2P;;;;iEAMvB;WAD2BkzC;;iEAEzB;;gCAFyBA;;kEAQvB;WAL4B5iD;WAAHC;WAAHC;WAAH2iD;mEAKnB;;cAL4B7iD;mEAI5B;;cAJyBC;mEAGzB;;0BAHsBC;iEAEvB;;oBAFoB2iD;;;;;kEASnB;WAHwBC;WAAHC;;qBAIb7qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;kBAFM6H;sEACP;;wBADIuP;oFAEkB;mEAJ7B;;oBAHwBwzC;iEAEzB;;oBAFsBC;;;kEAWrB;WAHwBC;WAAHC;mEAGrB;;0BAHwBD;iEAEzB;;oBAFsBC;;;kEAOrB;WAHsBC;WAAHC;mEAGnB;;0BAHsBD;iEAEvB;;oBAFoBC;;;iEAKvB;WADwBC;;iEAEtB;;gCAFsBA;;kEAOpB;WAJ4BC;WAAHC;mEAIzB;;0BAJ4BD;iEAE7B;;qCAF0BC;;;kEAQzB;WAH0BC;WAAHC;mEAGvB;;0BAH0BD;iEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;0BARyBD;oEAQzB;qBALOvrD;sEACF;0EADEA;uEACF,GADEA;uEAIA;;kBAHM6H;sEACP;;yCADIuP;oFAGkB;iEAL7B;;0BAFuBo0C;;;mEAYtB;WAHwBC;WAAHC;oEAGrB;;+BAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAL8BC;WAAHC;WAAHC;oEAKxB;;cAL8BF;oEAG9B;;+BAH2BC;kEAE5B;;oBAFyBC;;;;kEAO5B;WADwBC;;kEAEtB;;gCAFsBA;;mEAOpB;WAJgCC;WAAHC;WAAHC;oEAI1B;;0BAJgCF;oEAGhC;;cAH6BC;kEAE9B;;oBAF2BC;;;;mEAQ1B;WAH2BC;WAAHC;oEAGxB;;cAH2BD;kEAE5B;;oBAFyBC;;;mEAOxB;WAHwBC;WAAHC;oEAGrB;;cAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAN+Bv0C;WAAHw0C;WAAHC;WAAHC;WAAHC;oEAMnB;;cAN+B30C;oEAK/B;;cAL4Bw0C;oEAI5B;;cAJyBC;oEAGzB;;cAHsBC;kEAEvB;;oBAFoBC;;;;;;mEAUnB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;mEAQ1B;WAJ4BC;WAAHC;WAAHC;oEAItB;;cAJ4BF;oEAG5B;;yBAHyBC;kEAE1B;;oBAFuBC;;;;cAKCC,eAAHC;kEAErB;;oBAFqBA;kBAAGD;;kEAI3B;WADsBE;;kEAEpB;;qCAFoBA;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;oEAG7B;qBADcltD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF2BmtD;;;kEAK9B;;;;qBAEUntD;uEACF;;gBADEA;wEACF;gBADEA;wEAGA;;kBAFM6H;uEAEN;;gBADc7H;yEAAM,OAANA,0DAAO;uEAAtB;;8BADIoX;qFAEkB;kEAJ7B;;0BAFyBg2C;;mEAWvB;WAJ+BC;WAAHC;WAAHC;oEAIzB;;cAJ+BF;oEAG/B;;cAH4BC;oEAG5B;qBADcttD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF0ButD;;;;kEAM7B;WADyBC;;kEAEvB;;oBAFuBA;;kEAIzB;WADuBC;;kEAErB;;oBAFqBA;;mEAMnB;WAHuBC;WAAHC;oEAGpB;;yBAHuBD;kEAExB;;oBAFqBC;;;kEAKxB;WADyBC;;kEAEvB;;oBAFuBA;;cAGKC,eAAHC;mEAEpB;kBAFoBA;2EAEpB;oBAFuBD;;kEAI9B;WADuBE;;kEAErB;;oBAFqBA;;mEAQnB;WAL0BC;WAAHC;WAAHC;oEAKpB;;cAL0BF;oEAG1B;;+BAHuBC;kEAExB;;oBAFqBC;;;;kEAOxB;WAD4BC;;kEAE1B;;oBAF0BA,iEAIC;;8DAMjC;;;;yEAE6C;;8DAI7C;;;;;+DAWM;;UARsBlF;+DAMtB;;sBAPwBC;8DAKxB;;gBANsBC;;4EAWzB;;8DAMH;;;;;;;;;+DAcM;;UAVuBnC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAMxB;;gBAPuBC;;;4EAc1B;;8DAIH;;;;;;;+DAWM;;UAR+BiH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;;;qBACiBtuD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFoBoX;;mEAMlB;WAHwBvP;WAAHyP;;qBAGNtX;uEAAM,OAANA,0DAAO;oEAAtB;;oBAHwB6H;kEAEzB;;oBAFsByP;;;kEAKzB;WAD2BE;;kEAEzB;;oBAFyBA;;mEAMvB;WAH2BxP;WAAH0iD;oEAGxB;;cAH2B1iD;kEAE5B;;oBAFyB0iD;;;kEAK5B;WADwBC;;kEAEtB;;+BAFsBA;;mEAOpB;WAJ4BC;WAAHC;oEAIzB;;yBAJ4BD;kEAE7B;;qCAF0BC;;;mEAQzB;WAH0BC;WAAHC;oEAGvB;;yBAH0BD;kEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;cARyBD;oEAQzB;qBALOhrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;yCADIuP;qFAGe;kEAL1B;;0BAFuB6zC;;;kEAU1B;WADwBC;;kEAEtB;;+BAFsBA;;mEAMpB;WAHqBC;WAAHC;oEAGlB;;cAHqBD;kEAEtB;;oBAFmBC;;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;kEAK9B;WADuBE;;kEAErB;;qCAFqBA;;kEAKvB;WADuBE;;kEAErB;;oBAFqBA;;kEAIvB;;;;qBACiB1rD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFuB6rD;;kEAIzB;WAD4BC;;kEAE1B;;oBAF0BA;;kEAI5B;WAD4BG;;kEAE1B;;oBAF0BA,iEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+BsC;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;WADsBr3C;;kEACtB;kBADsBA;;mEAMlB;WAJ2BxP;WAAHC;WAAHyP;oEAIrB;;cAJ2B1P;oEAG3B;;cAHwBC;kEAEzB;;oBAFsByP;;;;kEAMzB;WADwBE;;kEAEtB;;+BAFsBA;;mEAOpB;WAJyBxP;WAAH0iD;oEAItB;;yBAJyB1iD;kEAE1B;;qCAFuB0iD;;;mEAYtB;WAPyBE;WAAHD;oEAOtB;;cAPyBC;oEAOzB;qBAJO5qD;uEACF;;gBADEA;wEACF;gBADEA;wEACF;gBADEA;wEAGA;;kBAFS4H;uEACN;sBADAwP;+EACA;wBADGvP;qFAEc;kEAJ5B;;0BAFuB8iD;;;mEAYtB;WAJwBG;WAAHD;oEAIrB;;yBAJwBC;kEAEzB;;qCAFsBD;;;cAKGG,cAAHD;kEAEtB;;oBAFsBA;kBAAGC;;mEAOxB;WAJ6BjjD;WAAHojD;WAAHF;;qBAKfjrD;uEAAM;oCAANA,2DAA2B;oEADnC;;oBAJ6B+H;oEAG7B;;cAH0BojD;kEAE3B;;qCAFwBF;;;;mEASvB;WAHuBI;WAAHH;oEAGpB;;cAHuBG;oEAGvB;qBADcrrD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFqBkrD;;;kEAKxB;WAD0BE;;kEAExB;;oBAFwBA;;kEAI1B;WAD4BE;;kEAE1B;;oBAF0BA,gEAEP;iCAMrBtrD;8DACF;kEADEA;+DACF,GADEA;8DACF;QAGUA;iEACF;qEADEA;kEACF,GADEA;kEAIA;;YAHM6H;iEACP;;mCADIuP;+EAGiB;8DAL5B;;0EAFMvP;8DACP;;iCADIuP;6EAO+B;;8DAMtC;;iEAKQ;SAJwBtP;SAAHF;SAAHC;SAAHuP;kEAIf;;uBAJwBtP;kEAGF;;YAHDF;kEAGrB;;YAHkBC;gEAEnB;;kBAFgBuP;;;;8DAMnB;OADsBE;;8DAEpB;;gBAFoBA,+DAED;+BAKnBtX;+DAAM;gCAANA,2DAA+B;8BAMjCA;8DACF;kEADEA;+DACF,GADEA;+DAGA;;UAFM6H;8DAEN;QADc7H;iEAAM,OAANA,0DAAO;8DAAtB;;sBADIoX;6EAEe;;8DAItB;;iEAEI;UADkBA;;iEAEhB;;mBAFgBA;;iEAIlB;UADkBE;;iEAEhB;;mBAFgBA;;iEAIlB;UADkBE;;iEAEhB;;mBAFgBA;;kEAMd;UAHkB3P;UAAH6iD;mEAGf;;yBAHkB7iD;iEAEnB;;mBAFgB6iD;iFAGkB;8BAKnC1qD;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB0uD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;kEAIQ;UAHuB9mD;UAAHuP;mEAGpB;;aAHuBvP;iEAExB;;mBAFqBuP;;;kEAOpB;UAHwBpP;UAAHsP;mEAGrB;;kCAHwBtP;iEAEzB;;mBAFsBsP;;;iEAKzB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAHuBozC;UAAHF;mEAGpB;;qCAHuBE;iEAExB;;mBAFqBF;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;yCAF0BA;;iEAI5B;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UAD4BG;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4Bf;UAAHgB;mEAGzB;;aAH4BhB;iEAE7B;;mBAF0BgB;iFAGJ;kCA8iBzBgD;+DAAJ;;;;;;;iEAWQ;;UAPgCrG;iEAKhC;;UANyBC;gEAIF;;gBAP3BoG,GAE6BnG;;6EAU5B;wCApjBD3oD;8DACF;kCADEA,2DAEkB;gCAqflB8uD;+DAAJ;;;;;;;;;;;;;iEAwBQ;;UAjB8BzI;iEAe9B;;UAhBuBC;iEAcD;;UApB1BwI,GAK4BvI;gEAeF;QADPvmD;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAfwBwmD;gEAexB;QALQxmD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;gEAJ3B;;;gBAV0B23C;gEAQ1B;;gBATwBtI;;;;;6EAuB3B;sCAxgBDzmD;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR8BgvD;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJwBrnD;UAAHuP;mEAIrB;;wBAJwBvP;iEAEzB;;oCAFsBuP;;;iEAMzB;UAD2BE;;iEAEzB;;mBAFyBA;;kEAQvB;UAL2BxP;UAAHF;UAAHI;UAAHwP;mEAKlB;;aAL2B1P;mEAI3B;;aAJwBF;mEAGxB;;yBAHqBI;iEAEtB;;mBAFmBwP;;;;;kEASlB;UAHuBozC;UAAHF;;oBAIZ1qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;iBAFM6H;sEACP;;uBADIuP;oFAEkB;mEAJ7B;;mBAHuBwzC;iEAExB;;mBAFqBF;;;kEAYpB;UAJwB3iD;UAAH+iD;UAAHH;mEAIlB;;aAJwB5iD;mEAGxB;;kCAHqB+iD;iEAEtB;;mBAFmBH;;;;kEAQlB;UAH4BK;UAAHH;mEAGzB;;aAH4BG;iEAE7B;;mBAF0BH;;;iEAK7B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;;;;+DAQM;;6BAN4B7E;8DAI5B;;gBAL0BC;4EAQ7B;;8DAMH;;;;;;;+DAWM;;UAR8BgJ;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJ4BznD;UAAHC;UAAHuP;;oBAIJpX;sEAAM,OAANA,0DAAO;mEAAzB;;mBAJ4B4H;mEAG5B;;aAHyBC;iEAE1B;;mBAFuBuP;;;;iEAM1B;;;uEADqBE;kEACrB,KADqBA;kEACrB,KADqBA;mEAKhB;;aAHSvP;mEAET;;aAFMC;mEAEN;oBADchI;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADIwX;;;;iEAKR;;;uEADwBkzC;kEACxB,KADwBA;kEACxB,KADwBA;mEAKnB;;aAHSiB;mEAET;;aAFMf;mEAEN;oBADc5qD;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADI2qD;;;;iEAKR;;;uEAD4BE;kEAC5B,KAD4BA;mEAIvB;;aAFMC;kEACP;;;oBADIC;;;iEAIR;UAD6BE;;iEAE3B;;mBAF2BA;;iEAI7B;UAD2BC;;iEAEzB;;mBAFyBA;;iEAI3B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;gEAEI;SADyBh0C;;gEAEvB;;kBAFuBA;+DAMrB;OAH0BvP;OAAHyP;gEAGvB;;UAH0BzP;8DAE3B;;gBAFwByP;6EAGF;;8DAM7B;;;;;;;;;+DAcM;;UAVuB0wC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAQxB;QAFeloD;iEAAM,OAANA,0DAAO;8DAAtB;;sBAPwBmoD;;;4EAc3B;;8DAMH;;;;;;;+DAWM;;UAR+BmH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBp4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHwBxP;UAAH0iD;mEAGrB;;aAHwB1iD;iEAEzB;;mBAFsB0iD;;;kEAOrB;UAH6BE;UAAHD;mEAG1B;;aAH6BC;iEAE9B;;mBAF2BD;;;iEAK9B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+B0E;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBv4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHuBxP;UAAH0iD;mEAGpB;;oCAHuB1iD;iEAExB;;mBAFqB0iD;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADwBE;;iEAEtB;;oCAFsBA,gEAGhB;;8DAMZ;;kEAKQ;UAJwBljD;UAAHuP;mEAIrB;;aAJwBvP;iEAEzB;;oCAFsBuP;;;kEASrB;UAJ0BpP;UAAHsP;mEAIvB;;8BAJ0BtP;iEAE3B;;oCAFwBsP;;;iEAO3B;UAD6BE;;iEAE3B;;mBAF2BA;;kEAMzB;UAH4BozC;UAAHF;mEAGzB;;8BAH4BE;mEAG5B;oBADc5qD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF0B0qD;iFAIH;8BAKxB1qD;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB4vD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;iEAEI;UADwBz4C;;iEAEtB;;mBAFsBA;;kEAMpB;UAHuBvP;UAAHyP;mEAGpB;;qCAHuBzP;iEAExB;;mBAFqByP;;;iEAKxB;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BkzC;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;6CAF0BA;;iEAI5B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4BxjD;UAAH0jD;mEAGzB;;aAH4B1jD;iEAE7B;;mBAF0B0jD;iFAGJ;2CAMzB1rD;8DACF;iCADEA,2DAEiB;sCAMjBA;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR+B8vD;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;kEAKQ;UAJyBnoD;UAAHuP;mEAItB;;wBAJyBvP;iEAE1B;;oCAFuBuP;;;iEAM1B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ2B1P;UAAHI;UAAHwP;mEAIrB;;aAJ2B5P;mEAG3B;;aAHwBI;iEAEzB;;mBAFsBwP;;;;iEAMzB;UAD4BkzC;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;+DAQM;;kCAN4B1I;8DAI5B;;gBAL0BC;4EAS7B;;8DAMH;;;;;;;+DAWM;;UAR+BgO;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;+DAMH;;;kEAEI;UAD0B/4C;;kEAExB;;mBAFwBA;;kEAI1B;;;sEADsBE;mEACtB,GADsBA;mEACtB,GADsBA;mEACtB;WADsBA;oEAKjB;;aAHYxP;oEAEZ;;aAFSF;mEACN;;kBADA4P;4EACA;oBADG3P;;;;kEAKX;;;;WADyB6iD;mEACzB;WADyBA;mEACzB;WADyBA;mEACzB;WADyBA;oEAKpB;;aAHY4B;oEAEZ;;aAFSvkD;mEACN;;kBADA4iD;4EACA;oBADG3iD;;;;kEAKX;;;;WAD6B6iD;mEAC7B;WAD6BA;oEAIxB;;aAFMD;mEACP;;;oBADIG;;;kEAIR;UAD4BE;;kEAE1B;;mBAF0BA;;kEAI5B;UAD4BC;;kEAE1B;;mBAF0BA,iEAEP;8BAMrBlrD;+DACF;mEADEA;gEACF,GADEA;gEAGA;;UAFM6H;+DAEN;QADc7H;kEAAM,OAANA,2DAAO;+DAAtB;;sBADIoX;8EAEe;;+DAuCtB;;;;0EAEiD;wCAM7CpX;+DACF;kCADEA,4DAEkB;;+DA0BtB;;;;;;;;;gEAeM;;UAXgConD;gEAShC;;UAVyBC;gEAQzB;;UAT8BC;+DAM9B;;iCAPyBC;;;6EAe5B;;+DAMH;;;;0EAE2C;;+DAM3C;;;;;;;;;gEAcM;;UAVwBC;gEAQxB;;UAT+BC;gEAO/B;;6BARyBC;+DAQzB;QAFe1nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB2nD;;;6EAc5B;;+DAMH;;;;;;;;;gEAcM;;UAVuBC;gEAQvB;;UAT8BC;gEAO9B;;UARwBC;+DAQxB;QAFe9nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPwB+nD;;;6EAc3B;;+DAMH;;;;;;;;;;;gEAuBM;;UAlBiClH;gEAgBjC;;UAjB8BC;gEAc9B;;uCAfmCC;+DAenC;QALQ/gD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAV6B4pC;+DAO7B;;iCAR2BC;;;;6EAuB9B;;+DAMH;;;;;;;;;gEAcM;;UAV+BM;gEAQ/B;;UATwBC;gEAOxB;;UARyBC;+DAQzB;QAFezhD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB0hD;;;6EAc5B;;+DAMH;;kEAIQ;SAHuB75C;SAAHuP;mEAGpB;;uBAHuBvP;iEAExB;;kBAFqBuP;;+DAKxB;OADyBE;;+DAEvB;;iCAFuBA,gEAGjB;;+DAMZ;;;;;;;;;;;;;;;;;gEAmCM;;UA3ByB4oC;gEAyBzB;;UA1BgCC;gEAwBhC;;qBAzB8BC;gEAuB9B;;UAxB6BC;gEAsB7B;;UAvB0BC;+DAuB1B;QANQtgD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAIA;;YAHS4H;mEAET;;YAFMC;kEACP;;kBADIuP;;gFAGgB;+DAL3B;;;gBAjB2BmpC;+DAiB3B;QALQvgD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAZ4BopC;+DAY5B;QAFexgD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAX0BygD;;;;;;;6EAmC7B;;+DAMH;;;;0EAE6C;;+DAM7C;;;;;;;;;;mEAII;WAD2BrpC;;mEAEzB;;mDAFyBA;iEAI3B;SAD0BE;;iEAExB;;2CAFwBA,iEAIH;;+DAM3B;;;;;;;;;;;gEAiBM;;UAZ8BsxC;gEAU9B;;UAXuBC;gEASvB;;qBAVuBC;gEAQvB;;UATwBC;+DASxB;QAFe/oD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBgpD;;;;6EAiB3B;;+DAMH;;iEAEI;SADyB5xC;;iEAEvB;;6BAFuBA;+DAIzB;OAD0BE;;+DAExB;;yCAFwBA,gEAEY;;+DAM1C;;;;;;;;;;;gEAiBM;;UAZ8B8wC;gEAU9B;;UAXuBC;gEASvB;;UAVwBC;gEAQxB;;UAT2BC;+DAS3B;QAFevoD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBwoD;;;;6EAiB3B;;+DAMH;;;;0EAG+C;;+DAI/C;;kEAEI;;kEAEA;;kEAEA,mEAAqB;;+DAMzB;;;;;;;;;;;gEAiBM;;UAZwB7B;gEAUxB;;UAX+BC;+DAW/B;QAFe5mD;kEAAM,OAANA,2DAAO;+DAAtB;;;gBAVyB6mD;gEAQzB;;UATyBC;+DASzB;QAFe9mD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARyB+mD;;;;6EAiB5B;;+DAKH;;iEAC4B;;iEAD5B;;mEAGI;WADqB3vC;;mEACrB;kBADqBA;iEAGrB;SADqBE;;iEACrB;gBADqBA,gEACE;;+DAM3B;;;;0EAEyC;0BAIrCtX;gEAAM,OAANA,2DAAO;;+DAIX;;;;0EAIyB;;+DAKzB;;;;UACoC6H;UAAHuP;;oBAEJpX;uEAAM,OAANA,2DAAO;mEAAzB;iBAFsBoX;2EAEtB;yBAFyBvP;;kEAIhC;UADyByP;;kEACzB;iBADyBA;;;UAEMtP;UAAHwP;;oBAEHxX;uEAAM,OAANA,2DAAO;mEAAzB;iBAFqBwX;2EAErB;yBAFwBxP;;;UAGD4iD;UAAHF;;oBAEF1qD;uEAAM,OAANA,2DAAO;mEAAzB;iBAFoB0qD;2EAEpB;yBAFuBE,iEAEQ;2BAGtCkE;+DAAJ;kEAAiD;SAAN13C;;kEAAW;;kBAAlD03C,GAAuC13C;gEAAZ,kEAA8B;;+DAI7D;;;kEAEI;UADoBA;;kEACpB;iBADoBA;;aAEEvP,YAAHyP;kEAEhB;;mBAFgBA;iBAAGzP;;mEAKE;UAFAG;UAAHwP;oEAEG;;aAFAxP;kEAErB;;mBAFkBwP;kFAEuB;wBAO5Cs3C;+DAAJ;;;iEAOwB;;UAJExc;gEAGF;;gBANpBwc,GAEsBrzD;6EAMrB;;+DAIL;;;;;;;iEAQ4B;;UALE20D;iEAIJ;;UALEC;gEAIA;;gBALEC;;6EAQ3B;;gEAE0B;;;;0EAA0C;;+DAGvE;;;;;;;;;;cACuBI;cAA6BD;cAC/BD;cAA2BD,kEAO7C;;+DAIH;;;mEAIQ;UAHyB1oD;UAAHuP;oEAGtB;;aAHyBvP;kEAE1B;;mBAFuBuP;;;kEAK1B;;;;oBAEUpX;uEACF;;eADEA;wEACF;eADEA;wEAGA;;kCAFM6H;uEACP;;uBADIuP;qFAE6B;kEAJxC;;yBAF4BE;;kEAQ9B;;;;WAD8BE;mEAC9B;WAD8BA;oEAGX;;aADRxP;mEACP;;;oBADI0iD;oFACgC;wBAEd1qD;gEAAM,OAANA,2DAAO;;+DAIrC;;iEAqCqC;;gEArCrC;;;oEASQ;WARmC8X;WAAHhQ;WAAHF;WAAHC;WAAHuP;qEAQvB;;cARmCU;qEAO3B;;cAPwBhQ;qEAOxB;qBAHA9H;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAH6B1P;mEAE9B;;oBAFwBwP;kBAAGvP;;;;;oEAiB1B;WARwCkpD;WAAHzE;WAAHvkD;WAAHC;WAAHsP;qEAQ5B;;cARwCy5C;qEAOhC;;cAP6BzE;qEAO7B;qBAHAtsD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAHkCvP;mEAEnC;;oBAF6BuP;kBAAGtP;;;;;oEAY/B;WAH2B4iD;WAAHpzC;qEAGxB;;cAH2BozC;mEAE5B;;oBAFyBpzC;;;cAIIszC,cAAHJ;oEAEtB;kBAFsBA;4EAEtB;oBAFyBI;;oEAM5B;WAH8Ba;WAAHX;WAAHL;qEAGxB;;cAH8BgB;oEAE3B;kBAFqBhB;4EAErB;oBAFwBK;;;oEAO3B;WAHyBG;WAAHN;qEAGtB;;cAHyBM;mEAE1B;;oBAFuBN;;;mEAK1B;WAD0BE;;mEAExB;;oBAFwBA,iEAGmC;;+DAIjE;;;;;;;;;gEAYM;;6BARiC0J;+DAQjC;QAFyCz0D;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAPEkyD;+DAM5B;cAR2BE;uEAQ3B;gBAP2BD;;6EAW9B;;+DAIH;;;;;;;;;;;;;;QAwBcnyD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAjB6B45C;gEAiB7B;iEAH+B;;UAfE0D;gEAcjC;;UAf+BzD;gEAa/B;;UAd4BC;+DAc5B;QALQlxD;kEACF;sEADEA;mEACF,GADEA;mEACF,KAAQ6H;mEAAR,KAAQA;mEACoC;;YAA9BG;kEAAc;gBADvBoP;;2EACuB;mBAAjBE;kFAAkD;+DAHnE;cAV4B85C;uEAU5B;sBAT8BD;;;;;6EA0BjC;;+DAKH;;iEACqC;;gEADrC;;;oEAKQ;WAH+BvpD;WAAHC;WAAHuP;qEAGzB;;cAH+BxP;oEAE5B;kBAFsBwP;4EAEtB;2CAFyBvP;;;mEAKhC;WAD0ByP;;oEACA;;oBADAA;;mEAG1B;WAD8BE;;mEAE5B;;wCAF4BA;;mEAI9B;WAD0BkzC;;oEACA;;oBADAA,iEACmB;;+DAIjD;;mEACkC;;mEACD;;mEACK,mEAA6B;;+DAMnE;;;;;;;;;;;;;gEAkBM;;UAZ8B2G;gEAU9B;;0BAX+BC;gEAS/B;;0BAV2BC;+DAU3B;QAFevxD;kEAAM,OAANA,2DAAO;+DAAtB;cAX2B0xD;cACKD;uEAUhC;sBATkCD;;;6EAgBrC;;+DAIH;;;;0EAE6C;;+DAI7C;;mEACgC;;mEACE;;mEACD,mEAAwB;;+DAIzD;;;mEAIQ;UAH2B3pD;UAAHuP;oEAGxB;;6BAH2BvP;kEAE5B;;mBAFyBuP;;;mEAOxB;UAH6BxP;UAAHI;UAAHsP;oEAGvB;;aAH6B1P;mEAE1B;iBAFoB0P;2EAEpB;mBAFuBtP;;;mEAO1B;UAH8B4iD;UAAHpzC;oEAG3B;;uCAH8BozC;kEAE/B;;mCAF4BpzC;kFAGW;;+DAM9C;;;mEAIQ;UAH+B3P;UAAHuP;oEAG5B;;aAH+BvP;kEAEhC;;mBAF6BuP;;;mEAO5B;UAHiCtP;UAAHF;UAAHI;UAAHsP;oEAGxB;;aAHiCxP;oEAEd;;aAFWF;mEAE3B;iBAFqB0P;2EAErB;mBAFwBtP;;;;mEAO3B;UAHgCskD;UAAHvkD;UAAH6iD;UAAHpzC;oEAGvB;;aAHgC80C;oEAEb;;aAFUvkD;mEAE1B;iBAFoByP;2EAEpB;mBAFuBozC;;kFAGP;;+DAI3B;;;;;;;;;;;cAGkC/iD,YAAHuP;mEAExB;;oBAFwBA;kBAAGvP;;oEAM1B;WAH6BD;WAAHI;WAAHsP;qEAGvB;;cAH6B1P;oEAE1B;kBAFoB0P;4EAEpB;oBAFuBtP;;;oEAO1B;WAH6BD;WAAH6iD;WAAHpzC;qEAGvB;;8BAH6BzP;qEAEd;;cAFW6iD;mEAE3B;;oBAFwBpzC;;;;oEAOvB;WAH2BszC;WAAHJ;qEAGxB;;8BAH2BI;mEAE5B;;oBAFyBJ;;;oEAOxB;WAH6BM;WAAHL;qEAG1B;;cAH6BK;mEAE9B;;oBAF2BL;;;oEAU1B;WAN2BQ;WAAHN;qEAMxB;;0BAN2BM;qEAM3B;qBAHOnrD;wEACF;;gBADEA;yEACF;gBADEA;wEAEG;sBADAoX;gFACA;wBADGvP,8DACgB;mEAH9B;;0BAFyBgjD;;;mEAQ5B;;;;qBAEU7qD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAEmB;;kBADV4H;wEACN;sBADAwP;gFACA;wBADGvP;sFACgC;mEAH9C;;0BAFyBkjD;;oEAOK;WAANE;;oEAAM;kBAANA;;mEAE1B;;;;qBAEUjrD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAGA;;kCAFS4H;wEACN;sBADAwP;gFACA;wCADGvP;sFAEyB;mEAJvC;;0BAFsBqjD;;mEAQxB;WAD0BE;;mEAExB;;oCAFwBA;;cAGEC,cAAHC;oEACA;;oBADAA;kBAAGD;;oEAMxB;WAJkCvjD;WAAH6jD;WAAHJ;WAAHC;;qBAIPxrD;wEAAM;gCAAcA;mFAAM,OAANA,2DAAO;uBAA3BA,4DAA8B;qEAAhD;;oBAJkC8H;qEAGlC;;cAH+B6jD;qEAEhB;;cAFaJ;mEAE7B;;oBAF0BC;;;;;oEAOG;WAFHC;WAAHC;qEAEM;;cAFHD;qEAEG;qBAAdzrD;wEAAM,OAANA,2DAAO;mEAAtB;;0BAFuB0rD;;;oEAMtB;WAH8BK;WAAHH;WAAHC;qEAGxB;;8BAH8BE;qEAG9B;qBADkB/rD;wEAAM,OAANA,2DAAO;oEAAtB;kBAFqB6rD;4EAErB;0BAFwBD;;;oEAO3B;WAH8BI;WAAHF;qEAG3B;;cAH8BE;mEAE/B;;oBAF4BF;mFAGH;;+DAIhC;OAAoC6I;;+DAApC;cAAoCA,qEACQ;;+DAI5C;;iEAEI;;;mBAEU30D;sEACF;0EADEA;uEACF,GADEA;uEACF,GADEA;uEAGA;;gCAFS4H;sEACN;oBADAwP;8EACA;sBADGvP;oFAEsB;iEAJpC;;wBAFyBuP;gEAUvB;OAHyBvP;OAAHyP;iEAGtB;;0BAHyBzP;+DAE1B;;gBAFuByP;8EAGM;;+DAIpC;;iEASqC;;gEATrC;;;mEAEI;WAD0BF;;mEAExB;;qCAFwBA;;oEAGK;WAANE;;oEAAM;kBAANA;;oEAIrB;WAH2BzP;WAAH2P;qEAGxB;;+BAH2B3P;mEAE5B;;oBAFyB2P;;;mEAM5B;WAD0BkzC;;oEACA;;oBADAA;;oEAEI;WAANC;;oEAAM;kBAANA;;oEACQ;WAANE;;oEAAM;kBAANA;;oEACM;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD8BE;;mEAC9B;kBAD8BA;;mEAG9B;WADyBC;;mEAEvB;;qCAFuBA;;mEAIzB;WAD4BE;;mEAC5B;kBAD4BA;;mEAG5B;;;;qBAEUprD;wEACF;;gBADEA;yEACF;gBADEA;yEAGA;;kBAFM6H;wEACP;;wBADIuP;sFAEiB;mEAJ5B;;0BAFyBk0C;;oEAOM;WAANE;;oEAAM;kBAANA;;oEACK;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD0BG;;mEAExB;;qCAFwBA;;cAGM7jD,cAAH8jD;oEAEtB;kBAFsBA;4EAEtB;qCAFyB9jD,iEAEO;0BAEPhI;gEAAM,OAANA,2DAAO;;+DAI3C;;;mEAEoD;UADlB6H;UAAHuP;oEACqB;;aADlBvP;mEACH;;mBADAuP;;;aAECpP,cAAHsP;mEACA;;mBADAA;iBAAGtP;;mEAEI;UAANwP;;mEAAM;iBAANA,gEAAkC;;+DAIhE;;iEAEI;SADsBJ;;kEACA;;kBADAA;UAEIvP,YAAHyP;gEACI;cADJA;wEACI;gBADDzP,8DAC4B;;+DAI1D;;iEAC+B;;gEAD/B;;;oEAEmC;WAANuP;;oEAAM;kBAANA;;;WACCvP;WAAHyP;;qBACqBtX;wEAAM,OAANA,2DAAO;oEAAxB;kBADJsX;4EACI;0BADDzP;;mEAG1B;WADwB2P;;oEACA;;oBADAA;;mEAGxB;WADuBkzC;;oEACA;;oBADAA,iEACc;;+DAIzC;;;;;;;;;gEAkBM;;UAdgCiH;+DAchC;QANQ3xD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAGA;;4BAFS4H;kEACN;gBADAwP;0EACA;kCADGvP;gFAEyB;+DAJvC;;;gBARqC+pD;+DAQrC;QAFe5xD;kEAAM,OAANA,2DAAO;+DAAtB;cAR6B8xD;uEAQ7B;sBAP+BD;;6EAiBlC;0BAEU7xD;gEAAI;2BAAJA,4DAAwB;+BCz1DnBgyD,SAASC;6DAC3B;;aAD2BA;aAATD,iEAC6B;;6DAM/C;;;;;;;8DAWM;;UAR+BzH;8DAM/B;;UAPwBC;6DAKxB;;gBALwBA,SADCC;;2EAW5B;oCAEoBnY;iB;+DAgKnB;;;;iEA1JA;WADwBl7B;;iEAEtB;;qCAFsBA;;iEAKxB;WAD2BE;;iEAEzB;;oBAFyBA;;kEAOvB;WAJyB1P;WAAHC;WAAH2P;mEAInB;;cAJyB5P;mEAGzB;;mCAHsBC;iEAEvB;;oBAFoB2P;;;;iEAMvB;WAD2BkzC;;iEAEzB;;gCAFyBA;;kEAQvB;WAL4B5iD;WAAHC;WAAHC;WAAH2iD;mEAKnB;;cAL4B7iD;mEAI5B;;cAJyBC;mEAGzB;;0BAHsBC;iEAEvB;;oBAFoB2iD;;;;;kEASnB;WAHwBC;WAAHC;;qBAIb7qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;kBAFM6H;sEACP;;wBADIuP;oFAEkB;mEAJ7B;;oBAHwBwzC;iEAEzB;;oBAFsBC;;;kEAWrB;WAHwBC;WAAHC;mEAGrB;;0BAHwBD;iEAEzB;;oBAFsBC;;;kEAOrB;WAHsBC;WAAHC;mEAGnB;;0BAHsBD;iEAEvB;;oBAFoBC;;;iEAKvB;WADwBC;;iEAEtB;;gCAFsBA;;kEAOpB;WAJ4BC;WAAHC;mEAIzB;;0BAJ4BD;iEAE7B;;qCAF0BC;;;kEAQzB;WAH0BC;WAAHC;mEAGvB;;0BAH0BD;iEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;0BARyBD;oEAQzB;qBALOvrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;yCADIuP;qFAGkB;kEAL7B;;0BAFuBo0C;;;mEAYtB;WAHwBC;WAAHC;oEAGrB;;+BAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAL8BC;WAAHC;WAAHC;oEAKxB;;cAL8BF;oEAG9B;;+BAH2BC;kEAE5B;;oBAFyBC;;;;kEAO5B;WADwBC;;kEAEtB;;gCAFsBA;;mEAOpB;WAJgCC;WAAHC;WAAHC;oEAI1B;;0BAJgCF;oEAGhC;;cAH6BC;kEAE9B;;oBAF2BC;;;;mEAQ1B;WAH2BC;WAAHC;oEAGxB;;cAH2BD;kEAE5B;;oBAFyBC;;;mEAOxB;WAHwBC;WAAHC;oEAGrB;;cAHwBD;kEAEzB;;oBAFsBC;;;mEAUrB;WAN+Bv0C;WAAHw0C;WAAHC;WAAHC;WAAHC;oEAMnB;;cAN+B30C;oEAK/B;;cAL4Bw0C;oEAI5B;;cAJyBC;oEAGzB;;cAHsBC;kEAEvB;;oBAFoBC;;;;;;mEAUnB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;mEAQ1B;WAJ4BC;WAAHC;WAAHC;oEAItB;;cAJ4BF;oEAG5B;;yBAHyBC;kEAE1B;;oBAFuBC;;;;cAKCC,eAAHC;kEAErB;;oBAFqBA;kBAAGD;;kEAI3B;WADsBE;;kEAEpB;;qCAFoBA;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;oEAG7B;qBADcltD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF2BmtD;;;kEAK9B;;;;qBAEUntD;uEACF;;gBADEA;wEACF;gBADEA;wEAGA;;kBAFM6H;uEAEN;;gBADc7H;yEAAM,OAANA,0DAAO;uEAAtB;;8BADIoX;qFAEkB;kEAJ7B;;0BAFyBg2C;;mEAWvB;WAJ+BC;WAAHC;WAAHC;oEAIzB;;cAJ+BF;oEAG/B;;cAH4BC;oEAG5B;qBADcttD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAF0ButD;;;;kEAM7B;mBAlImBjb;;kEAoInB;WADyBkb;;kEAEvB;;oBAFuBA;;kEAIzB;WADuBC;;kEAErB;;oBAFqBA;;mEAMnB;WAHuBC;WAAHC;oEAGpB;;yBAHuBD;kEAExB;;oBAFqBC;;;kEAKxB;WADyBC;;kEAEvB;;oBAFuBA;;cAGKC,eAAHC;mEAEpB;kBAFoBA;2EAEpB;oBAFuBD;;kEAI9B;WADuBE;;kEAErB;;oBAFqBA;;mEAQnB;WAL0BC;WAAHC;WAAHC;oEAKpB;;cAL0BF;oEAG1B;;+BAHuBC;kEAExB;;oBAFqBC;;;;kEAOxB;WAD4BC;;kEAE1B;;oBAF0BA;;8DAUhC;;;;yEAE6C;;8DAI7C;;;;;+DAWM;;UARsBlF;+DAMtB;;sBAPwBC;8DAKxB;;gBANsBC;;4EAWzB;;8DAMH;;;;;;;;;+DAcM;;UAVuBnC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAMxB;;gBAPuBC;;;4EAc1B;;8DAIH;;;;;;;+DAWM;;UAR+BiH;+DAM/B;;UAPwBC;8DAKxB;;gBALwBA,SADCC;;4EAW5B;iCAEiBhc;iB;+DAMhB;;;;kEAEA;;;qBACiBtyC;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFoBoX;;mEAMlB;WAHwBvP;WAAHyP;;qBAGNtX;uEAAM,OAANA,0DAAO;oEAAtB;;oBAHwB6H;kEAEzB;;oBAFsByP;;;kEAKzB;WAD2BE;;kEAEzB;;oBAFyBA;;mEAMvB;WAH2BxP;WAAH0iD;oEAGxB;;cAH2B1iD;kEAE5B;;oBAFyB0iD;;;kEAK5B;WADwBC;;kEAEtB;;+BAFsBA;;mEAOpB;WAJ4BC;WAAHC;oEAIzB;;yBAJ4BD;kEAE7B;;qCAF0BC;;;mEAQzB;WAH0BC;WAAHC;oEAGvB;;yBAH0BD;kEAE3B;;oBAFwBC;;;mEAYvB;WARyBC;WAAHC;oEAQtB;;cARyBD;oEAQzB;qBALOhrD;uEACF;;gBADEA;wEACF;gBADEA;wEAIA;;kBAHM6H;uEACP;;yCADIuP;qFAGe;kEAL1B;;0BAFuB6zC;;;kEAU1B;WADwBC;;kEAEtB;;+BAFsBA;;mEAMpB;WAHqBC;WAAHC;oEAGlB;;cAHqBD;kEAEtB;;oBAFmBC;;;mEAOlB;WAH6BC;WAAHC;oEAG1B;;cAH6BD;kEAE9B;;oBAF2BC;;;kEAK9B;WADuBE;;kEAErB;;qCAFqBA;;kEAKvB;WADuBE;;kEAErB;;oBAFqBA;;kEAIvB;;;;qBACiB1rD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFuB6rD;;kEAIzB;WAD4BC;;kEAE1B;;oBAF0BA;;kEAI5B;WAD4BG;;kEAE1B;;oBAF0BA;;kEAI5B;mBAtEgB3Z;;8DA2EpB;;;;;;;+DAWM;;UAR+Bic;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;+DAEI;;+DAFJ;;;kEAII;WADsBr3C;;kEACtB;kBADsBA;;mEAMlB;WAJ2BxP;WAAHC;WAAHyP;oEAIrB;;cAJ2B1P;oEAG3B;;cAHwBC;kEAEzB;;oBAFsByP;;;;kEAMzB;WADwBE;;kEAEtB;;+BAFsBA;;mEAOpB;WAJyBxP;WAAH0iD;oEAItB;;yBAJyB1iD;kEAE1B;;qCAFuB0iD;;;mEAYtB;WAPyBE;WAAHD;oEAOtB;;cAPyBC;oEAOzB;qBAJO5qD;uEACF;;gBADEA;wEACF;gBADEA;wEACF;gBADEA;wEAGA;;kBAFS4H;uEACN;sBADAwP;+EACA;wBADGvP;qFAEc;kEAJ5B;;0BAFuB8iD;;;mEAYtB;WAJwBG;WAAHD;oEAIrB;;yBAJwBC;kEAEzB;;qCAFsBD;;;cAKGG,cAAHD;kEAEtB;;oBAFsBA;kBAAGC;;mEAOxB;WAJ6BjjD;WAAHojD;WAAHF;;qBAKfjrD;uEAAM;oCAANA,2DAA2B;oEADnC;;oBAJ6B+H;oEAG7B;;cAH0BojD;kEAE3B;;qCAFwBF;;;;mEASvB;WAHuBI;WAAHH;oEAGpB;;cAHuBG;oEAGvB;qBADcrrD;uEAAM,OAANA,0DAAO;kEAAtB;;0BAFqBkrD;;;kEAKxB;WAD0BE;;kEAExB;;oBAFwBA;;kEAI1B;WAD4BE;;kEAE1B;;oBAF0BA,gEAEP;iCAMrBtrD;8DACF;kEADEA;+DACF,GADEA;8DACF;QAGUA;iEACF;qEADEA;kEACF,GADEA;kEAIA;;YAHM6H;iEACP;;mCADIuP;+EAGiB;8DAL5B;;0EAFMvP;8DACP;;iCADIuP;6EAO+B;;8DAMtC;;iEAKQ;SAJwBtP;SAAHF;SAAHC;SAAHuP;kEAIf;;uBAJwBtP;kEAGF;;YAHDF;kEAGrB;;YAHkBC;gEAEnB;;kBAFgBuP;;;;8DAMnB;OADsBE;;8DAEpB;;gBAFoBA,+DAED;+BAKnBtX;+DAAM;gCAANA,2DAA+B;8BAMjCA;8DACF;kEADEA;+DACF,GADEA;+DAGA;;UAFM6H;8DAEN;QADc7H;iEAAM,OAANA,0DAAO;8DAAtB;;sBADIoX;6EAEe;;8DAItB;;iEAEI;UADkBA;;iEAEhB;;mBAFgBA;;iEAIlB;UADkBE;;iEAEhB;;mBAFgBA;;iEAIlB;UADkBE;;iEAEhB;;mBAFgBA;;kEAMd;UAHkB3P;UAAH6iD;mEAGf;;yBAHkB7iD;iEAEnB;;mBAFgB6iD;iFAGkB;8BAKnC1qD;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB0uD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;kEAIQ;UAHuB9mD;UAAHuP;mEAGpB;;aAHuBvP;iEAExB;;mBAFqBuP;;;kEAOpB;UAHwBpP;UAAHsP;mEAGrB;;kCAHwBtP;iEAEzB;;mBAFsBsP;;;iEAKzB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAHuBozC;UAAHF;mEAGpB;;qCAHuBE;iEAExB;;mBAFqBF;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;yCAF0BA;;iEAI5B;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UAD4BG;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4Bf;UAAHgB;mEAGzB;;aAH4BhB;iEAE7B;;mBAF0BgB;iFAGJ;kCA8iBzBgD;+DAAJ;;;;;;;iEAWQ;;UAPgCrG;iEAKhC;;UANyBC;gEAIF;;gBAP3BoG,GAE6BnG;;6EAU5B;wCApjBD3oD;8DACF;kCADEA,2DAEkB;gCAqflB8uD;+DAAJ;;;;;;;;;;;;;iEAwBQ;;UAjB8BzI;iEAe9B;;UAhBuBC;iEAcD;;UApB1BwI,GAK4BvI;gEAeF;QADPvmD;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAfwBwmD;gEAexB;QALQxmD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;gEAJ3B;;;gBAV0B23C;gEAQ1B;;gBATwBtI;;;;;6EAuB3B;sCAxgBDzmD;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR8BgvD;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJwBrnD;UAAHuP;mEAIrB;;wBAJwBvP;iEAEzB;;oCAFsBuP;;;iEAMzB;UAD2BE;;iEAEzB;;mBAFyBA;;kEAQvB;UAL2BxP;UAAHF;UAAHI;UAAHwP;mEAKlB;;aAL2B1P;mEAI3B;;aAJwBF;mEAGxB;;yBAHqBI;iEAEtB;;mBAFmBwP;;;;;kEASlB;UAHuBozC;UAAHF;;oBAIZ1qD;sEACF;0EADEA;uEACF,GADEA;uEAGA;;iBAFM6H;sEACP;;uBADIuP;oFAEkB;mEAJ7B;;mBAHuBwzC;iEAExB;;mBAFqBF;;;kEAYpB;UAJwB3iD;UAAH+iD;UAAHH;mEAIlB;;aAJwB5iD;mEAGxB;;kCAHqB+iD;iEAEtB;;mBAFmBH;;;;kEAQlB;UAH4BK;UAAHH;mEAGzB;;aAH4BG;iEAE7B;;mBAF0BH;;;iEAK7B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;;;;+DAQM;;6BAN4B7E;8DAI5B;;gBAL0BC;4EAQ7B;;8DAMH;;;;;;;+DAWM;;UAR8BgJ;+DAM9B;;UAPuBC;8DAKvB;;gBANwBC;;4EAW3B;;8DAMH;;kEAKQ;UAJ4BznD;UAAHC;UAAHuP;;oBAIJpX;sEAAM,OAANA,0DAAO;mEAAzB;;mBAJ4B4H;mEAG5B;;aAHyBC;iEAE1B;;mBAFuBuP;;;;iEAM1B;;;uEADqBE;kEACrB,KADqBA;kEACrB,KADqBA;mEAKhB;;aAHSvP;mEAET;;aAFMC;mEAEN;oBADchI;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADIwX;;;;iEAKR;;;uEADwBkzC;kEACxB,KADwBA;kEACxB,KADwBA;mEAKnB;;aAHSiB;mEAET;;aAFMf;mEAEN;oBADc5qD;sEAAM,OAANA,0DAAO;kEAAtB;;;0BADI2qD;;;;iEAKR;;;uEAD4BE;kEAC5B,KAD4BA;mEAIvB;;aAFMC;kEACP;;;oBADIC;;;iEAIR;UAD6BE;;iEAE3B;;mBAF2BA;;iEAI7B;UAD2BC;;iEAEzB;;mBAFyBA;;iEAI3B;UAD2BE;;iEAEzB;;mBAFyBA,gEAEN;;8DAMzB;;gEAEI;SADyBh0C;;gEAEvB;;kBAFuBA;+DAMrB;OAH0BvP;OAAHyP;gEAGvB;;UAH0BzP;8DAE3B;;gBAFwByP;6EAGF;;8DAM7B;;;;;;;;;+DAcM;;UAVuB0wC;+DAQvB;;UAT8BC;+DAO9B;;UARwBC;8DAQxB;QAFeloD;iEAAM,OAANA,0DAAO;8DAAtB;;sBAPwBmoD;;;4EAc3B;;8DAMH;;;;;;;+DAWM;;UAR+BmH;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBp4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHwBxP;UAAH0iD;mEAGrB;;aAHwB1iD;iEAEzB;;mBAFsB0iD;;;kEAOrB;UAH6BE;UAAHD;mEAG1B;;aAH6BC;iEAE9B;;mBAF2BD;;;iEAK9B;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;;;+DAWM;;UAR+B0E;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;iEAEI;UADwBv4C;;iEAEtB;;oCAFsBA;;iEAKxB;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ6B1P;UAAHC;UAAH2P;mEAIvB;;aAJ6B5P;mEAG7B;;gCAH0BC;mEAG1B;oBADc7H;sEAAM,OAANA,0DAAO;iEAAtB;;yBAFwBwX;;;;kEAQvB;UAHuBxP;UAAH0iD;mEAGpB;;oCAHuB1iD;iEAExB;;mBAFqB0iD;;;iEAKxB;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;mBAF0BA;;iEAI5B;UADwBE;;iEAEtB;;oCAFsBA,gEAGhB;;8DAMZ;;kEAKQ;UAJwBljD;UAAHuP;mEAIrB;;aAJwBvP;iEAEzB;;oCAFsBuP;;;kEASrB;UAJ0BpP;UAAHsP;mEAIvB;;8BAJ0BtP;iEAE3B;;oCAFwBsP;;;iEAO3B;UAD6BE;;iEAE3B;;mBAF2BA;;kEAMzB;UAH4BozC;UAAHF;mEAGzB;;8BAH4BE;mEAG5B;oBADc5qD;sEAAM,OAANA,0DAAO;iEAAtB;;yBAF0B0qD;iFAIH;8BAKxB1qD;+DAAM;qCAANA,2DAAoC;;8DAM1C;;;;;+DAQM;;UANwB4vD;8DAIxB;;gBALyBC;4EAQ5B;;8DAMH;;iEAEI;UADwBz4C;;iEAEtB;;mBAFsBA;;kEAMpB;UAHuBvP;UAAHyP;mEAGpB;;qCAHuBzP;iEAExB;;mBAFqByP;;;iEAKxB;UADyBE;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BkzC;;iEAE1B;;mBAF0BA;;iEAI5B;UADyBC;;iEAEvB;;mBAFuBA;;iEAIzB;UAD4BE;;iEAE1B;;6CAF0BA;;iEAI5B;UAD0BE;;iEAExB;;mBAFwBA;;iEAI1B;UADuBE;;iEAErB;;mBAFqBA;;iEAIvB;UAD0BC;;iEAExB;;mBAFwBA;;iEAI1B;UADwBE;;iEAEtB;;4CAFsBA;;iEAIxB;UAD6BE;;iEAE3B;;iDAF2BA;;iEAI7B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAMxB;UAH4BxjD;UAAH0jD;mEAGzB;;aAH4B1jD;iEAE7B;;mBAF0B0jD;iFAGJ;2CAMzB1rD;8DACF;iCADEA,2DAEiB;sCAMjBA;8DACF;iCADEA,2DAEiB;;8DAMrB;;;;;;;+DAWM;;UAR+B8vD;+DAM/B;;UAPwBC;8DAKxB;;gBANyBC;;4EAW5B;;8DAMH;;kEAKQ;UAJyBnoD;UAAHuP;mEAItB;;wBAJyBvP;iEAE1B;;oCAFuBuP;;;iEAM1B;UAD4BE;;iEAE1B;;mBAF0BA;;kEAOxB;UAJ2B1P;UAAHI;UAAHwP;mEAIrB;;aAJ2B5P;mEAG3B;;aAHwBI;iEAEzB;;mBAFsBwP;;;;iEAMzB;UAD4BkzC;;iEAE1B;;mBAF0BA,gEAEP;;8DAMzB;;;;;+DAQM;;kCAN4B1I;8DAI5B;;gBAL0BC;4EAS7B;;8DAMH;;;;;;;gEAWM;;UAR+BgO;gEAM/B;;UAPwBC;8DAKxB;;gBANyBC;;6EAW5B;;+DAMH;;;kEAEI;UAD0B/4C;;kEAExB;;mBAFwBA;;kEAI1B;;;sEADsBE;mEACtB,GADsBA;mEACtB,GADsBA;mEACtB;WADsBA;oEAKjB;;aAHYxP;oEAEZ;;aAFSF;mEACN;;kBADA4P;4EACA;oBADG3P;;;;kEAKX;;;;WADyB6iD;mEACzB;WADyBA;mEACzB;WADyBA;mEACzB;WADyBA;oEAKpB;;aAHY4B;oEAEZ;;aAFSvkD;mEACN;;kBADA4iD;4EACA;oBADG3iD;;;;kEAKX;;;;WAD6B6iD;mEAC7B;WAD6BA;oEAIxB;;aAFMD;mEACP;;;oBADIG;;;kEAIR;UAD4BE;;kEAE1B;;mBAF0BA;;kEAI5B;UAD4BC;;kEAE1B;;mBAF0BA,iEAEP;8BAMrBlrD;+DACF;mEADEA;gEACF,GADEA;gEAGA;;UAFM6H;+DAEN;QADc7H;kEAAM,OAANA,2DAAO;+DAAtB;;sBADIoX;8EAEe;;+DAuCtB;;;;0EAEiD;wCAM7CpX;+DACF;kCADEA,4DAEkB;;+DA0BtB;;;;;;;;;gEAeM;;UAXgConD;gEAShC;;UAVyBC;gEAQzB;;UAT8BC;+DAM9B;;iCAPyBC;;;6EAe5B;;+DAMH;;;;0EAE2C;;+DAM3C;;;;;;;;;gEAcM;;UAVwBC;gEAQxB;;UAT+BC;gEAO/B;;6BARyBC;+DAQzB;QAFe1nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB2nD;;;6EAc5B;;+DAMH;;;;;;;;;gEAcM;;UAVuBC;gEAQvB;;UAT8BC;gEAO9B;;UARwBC;+DAQxB;QAFe9nD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPwB+nD;;;6EAc3B;;+DAMH;;;;;;;;;;;gEAuBM;;UAlBiClH;gEAgBjC;;UAjB8BC;gEAc9B;;uCAfmCC;+DAenC;QALQ/gD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAV6B4pC;+DAO7B;;iCAR2BC;;;;6EAuB9B;;+DAMH;;;;;;;;;gEAcM;;UAV+BM;gEAQ/B;;UATwBC;gEAOxB;;UARyBC;+DAQzB;QAFezhD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAPyB0hD;;;6EAc5B;;+DAMH;;kEAIQ;SAHuB75C;SAAHuP;mEAGpB;;uBAHuBvP;iEAExB;;kBAFqBuP;;+DAKxB;OADyBE;;+DAEvB;;iCAFuBA,gEAGjB;;+DAMZ;;;;;;;;;;;;;;;;;gEAmCM;;UA3ByB4oC;gEAyBzB;;UA1BgCC;gEAwBhC;;qBAzB8BC;gEAuB9B;;UAxB6BC;gEAsB7B;;UAvB0BC;+DAuB1B;QANQtgD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAIA;;YAHS4H;mEAET;;YAFMC;kEACP;;kBADIuP;;gFAGgB;+DAL3B;;;gBAjB2BmpC;+DAiB3B;QALQvgD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAZ4BopC;+DAY5B;QAFexgD;kEAAM,OAANA,2DAAO;+DAAtB;;sBAX0BygD;;;;;;;6EAmC7B;;+DAMH;;;;0EAE6C;;+DAM7C;;;;;;;;;;mEAII;WAD2BrpC;;mEAEzB;;mDAFyBA;iEAI3B;SAD0BE;;iEAExB;;2CAFwBA,iEAIH;;+DAM3B;;;;;;;;;;;gEAiBM;;UAZ8BsxC;gEAU9B;;UAXuBC;gEASvB;;qBAVuBC;gEAQvB;;UATwBC;+DASxB;QAFe/oD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBgpD;;;;6EAiB3B;;+DAMH;;iEAEI;SADyB5xC;;iEAEvB;;6BAFuBA;+DAIzB;OAD0BE;;+DAExB;;yCAFwBA,gEAEY;;+DAM1C;;;;;;;;;;;gEAiBM;;UAZ8B8wC;gEAU9B;;UAXuBC;gEASvB;;UAVwBC;gEAQxB;;UAT2BC;+DAS3B;QAFevoD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARwBwoD;;;;6EAiB3B;;+DAMH;;;;0EAG+C;;+DAI/C;;kEAEI;;kEAEA;;kEAEA,mEAAqB;;+DAMzB;;;;;;;;;;;gEAiBM;;UAZwB7B;gEAUxB;;UAX+BC;+DAW/B;QAFe5mD;kEAAM,OAANA,2DAAO;+DAAtB;;;gBAVyB6mD;gEAQzB;;UATyBC;+DASzB;QAFe9mD;kEAAM,OAANA,2DAAO;+DAAtB;;sBARyB+mD;;;;6EAiB5B;;+DAKH;;iEAC4B;;iEAD5B;;mEAGI;WADqB3vC;;mEACrB;kBADqBA;iEAGrB;SADqBE;;iEACrB;gBADqBA,gEACE;;+DAM3B;;;;0EAEyC;0BAIrCtX;gEAAM,OAANA,2DAAO;;+DAIX;;;;0EAIyB;;+DAKzB;;;;UACoC6H;UAAHuP;;oBAEJpX;uEAAM,OAANA,2DAAO;mEAAzB;iBAFsBoX;2EAEtB;yBAFyBvP;;kEAIhC;UADyByP;;kEACzB;iBADyBA;;;UAEMtP;UAAHwP;;oBAEHxX;uEAAM,OAANA,2DAAO;mEAAzB;iBAFqBwX;2EAErB;yBAFwBxP;;;UAGD4iD;UAAHF;;oBAEF1qD;uEAAM,OAANA,2DAAO;mEAAzB;iBAFoB0qD;2EAEpB;yBAFuBE,iEAEQ;2BAGtCkE;+DAAJ;kEAAiD;SAAN13C;;kEAAW;;kBAAlD03C,GAAuC13C;gEAAZ,kEAA8B;;+DAI7D;;;kEAEI;UADoBA;;kEACpB;iBADoBA;;aAEEvP,YAAHyP;kEAEhB;;mBAFgBA;iBAAGzP;;mEAKE;UAFAG;UAAHwP;oEAEG;;aAFAxP;kEAErB;;mBAFkBwP;kFAEuB;wBAO5Cs3C;+DAAJ;;;iEAOwB;;UAJExc;gEAGF;;gBANpBwc,GAEsBrzD;6EAMrB;;+DAIL;;;;;;;iEAQ4B;;UALE20D;iEAIJ;;UALEC;gEAIA;;gBALEC;;6EAQ3B;;gEAE0B;;;;0EAA0C;;+DAGvE;;;;;;;;;;cACuBI;cAA6BD;cAC/BD;cAA2BD,kEAO7C;;+DAIH;;;mEAIQ;UAHyB1oD;UAAHuP;oEAGtB;;aAHyBvP;kEAE1B;;mBAFuBuP;;;kEAK1B;;;;oBAEUpX;uEACF;;eADEA;wEACF;eADEA;wEAGA;;kCAFM6H;uEACP;;uBADIuP;qFAE6B;kEAJxC;;yBAF4BE;;kEAQ9B;;;;WAD8BE;mEAC9B;WAD8BA;oEAGX;;aADRxP;mEACP;;;oBADI0iD;oFACgC;wBAEd1qD;gEAAM,OAANA,2DAAO;;+DAIrC;;iEAqCqC;;gEArCrC;;;oEASQ;WARmC8X;WAAHhQ;WAAHF;WAAHC;WAAHuP;qEAQvB;;cARmCU;qEAO3B;;cAPwBhQ;qEAOxB;qBAHA9H;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAH6B1P;mEAE9B;;oBAFwBwP;kBAAGvP;;;;;oEAiB1B;WARwCkpD;WAAHzE;WAAHvkD;WAAHC;WAAHsP;qEAQ5B;;cARwCy5C;qEAOhC;;cAP6BzE;qEAO7B;qBAHAtsD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBAAQ6H;yEAAR;gBAAQA;yEACoC;;kBAA9BG;wEAAc;sBADvBoP;;iFACuB;yBAAjBE;wFAAkD;qEAHnE;;oBAHkCvP;mEAEnC;;oBAF6BuP;kBAAGtP;;;;;oEAY/B;WAH2B4iD;WAAHpzC;qEAGxB;;cAH2BozC;mEAE5B;;oBAFyBpzC;;;cAIIszC,cAAHJ;oEAEtB;kBAFsBA;4EAEtB;oBAFyBI;;oEAM5B;WAH8Ba;WAAHX;WAAHL;qEAGxB;;cAH8BgB;oEAE3B;kBAFqBhB;4EAErB;oBAFwBK;;;oEAO3B;WAHyBG;WAAHN;qEAGtB;;cAHyBM;mEAE1B;;oBAFuBN;;;mEAK1B;WAD0BE;;mEAExB;;oBAFwBA,iEAGmC;;+DAIjE;;;;;;;;;gEAYM;;+BARiC0J;+DAQjC;QAFyCz0D;kEAAM,OAANA,2DAAO;gEAAtB;;;gBAPEkyD;+DAM5B;cAR2BE;uEAQ3B;gBAP2BD;;6EAW9B;;+DAIH;;;;;;;;;;;;;;QAwBcnyD;kEACF;sEADEA;mEACF,GADEA;mEAGA;;YAFM6H;kEACP;;kBADIuP;gFAEgB;+DAJ3B;;;gBAhB6B45C;iEAcE;;UAhBE0D;gEAejC;;UAhB+BzD;gEAc/B;;UAf4BC;+DAe5B;QALQlxD;kEACF;sEADEA;mEACF,GADEA;mEACF,KAAQ6H;mEAAR,KAAQA;mEACoC;;YAA9BG;kEAAc;gBADvBoP;;2EACuB;mBAAjBE;kFAAkD;+DAHnE;cAX4B85C;uEAW5B;sBAV8BD;;;;6EA0BjC;;+DAKH;;iEACqC;;gEADrC;;;oEAKQ;WAH+BvpD;WAAHC;WAAHuP;qEAGzB;;cAH+BxP;oEAE5B;kBAFsBwP;4EAEtB;2CAFyBvP;;;mEAKhC;WAD0ByP;;oEACA;;oBADAA;;mEAG1B;WAD8BE;;mEAE5B;;wCAF4BA;;mEAI9B;WAD0BkzC;;oEACA;;oBADAA,iEACmB;;+DAIjD;;mEACkC;;mEACD;;mEACK,mEAA6B;;+DAMnE;;;;;;;;;;;;;gEAkBM;;UAZ8B2G;gEAU9B;;0BAX+BC;gEAS/B;;0BAV2BC;+DAU3B;QAFevxD;kEAAM,OAANA,2DAAO;+DAAtB;cAX2B0xD;cACKD;uEAUhC;sBATkCD;;;6EAgBrC;;+DAIH;;;;0EAE6C;;+DAI7C;;mEACgC;;mEACE;;mEACD,mEAAwB;;+DAIzD;;;mEAIQ;UAH2B3pD;UAAHuP;oEAGxB;;6BAH2BvP;kEAE5B;;mBAFyBuP;;;mEAOxB;UAH6BxP;UAAHI;UAAHsP;oEAGvB;;aAH6B1P;mEAE1B;iBAFoB0P;2EAEpB;mBAFuBtP;;;mEAO1B;UAH8B4iD;UAAHpzC;oEAG3B;;uCAH8BozC;kEAE/B;;mCAF4BpzC;kFAGW;;+DAM9C;;;mEAIQ;UAH+B3P;UAAHuP;oEAG5B;;aAH+BvP;kEAEhC;;mBAF6BuP;;;mEAO5B;UAHiCtP;UAAHF;UAAHI;UAAHsP;oEAGxB;;aAHiCxP;oEAEd;;aAFWF;mEAE3B;iBAFqB0P;2EAErB;mBAFwBtP;;;;mEAO3B;UAHgCskD;UAAHvkD;UAAH6iD;UAAHpzC;oEAGvB;;aAHgC80C;oEAEb;;aAFUvkD;mEAE1B;iBAFoByP;2EAEpB;mBAFuBozC;;kFAGP;;+DAI3B;;;;;;;;;;;cAGkC/iD,YAAHuP;mEAExB;;oBAFwBA;kBAAGvP;;oEAM1B;WAH6BD;WAAHI;WAAHsP;qEAGvB;;cAH6B1P;oEAE1B;kBAFoB0P;4EAEpB;oBAFuBtP;;;oEAO1B;WAH6BD;WAAH6iD;WAAHpzC;qEAGvB;;8BAH6BzP;qEAEd;;cAFW6iD;mEAE3B;;oBAFwBpzC;;;;oEAOvB;WAH2BszC;WAAHJ;qEAGxB;;8BAH2BI;mEAE5B;;oBAFyBJ;;;oEAOxB;WAH6BM;WAAHL;qEAG1B;;cAH6BK;mEAE9B;;oBAF2BL;;;oEAU1B;WAN2BQ;WAAHN;qEAMxB;;0BAN2BM;qEAM3B;qBAHOnrD;wEACF;;gBADEA;yEACF;gBADEA;wEAEG;sBADAoX;gFACA;wBADGvP,8DACgB;mEAH9B;;0BAFyBgjD;;;mEAQ5B;;;;qBAEU7qD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAEmB;;kBADV4H;wEACN;sBADAwP;gFACA;wBADGvP;sFACgC;mEAH9C;;0BAFyBkjD;;oEAOK;WAANE;;oEAAM;kBAANA;;mEAE1B;;;;qBAEUjrD;wEACF;;gBADEA;yEACF;gBADEA;yEACF;gBADEA;yEAGA;;kCAFS4H;wEACN;sBADAwP;gFACA;wCADGvP;sFAEyB;mEAJvC;;0BAFsBqjD;;mEAQxB;WAD0BE;;mEAExB;;oCAFwBA;;cAGEC,cAAHC;oEACA;;oBADAA;kBAAGD;;oEAMxB;WAJkCvjD;WAAH6jD;WAAHJ;WAAHC;;qBAIPxrD;wEAAM;gCAAcA;mFAAM,OAANA,2DAAO;uBAA3BA,4DAA8B;qEAAhD;;oBAJkC8H;qEAGlC;;cAH+B6jD;qEAEhB;;cAFaJ;mEAE7B;;oBAF0BC;;;;;oEAOG;WAFHC;WAAHC;qEAEM;;cAFHD;qEAEG;qBAAdzrD;wEAAM,OAANA,2DAAO;mEAAtB;;0BAFuB0rD;;;oEAMtB;WAH8BK;WAAHH;WAAHC;qEAGxB;;8BAH8BE;qEAG9B;qBADkB/rD;wEAAM,OAANA,2DAAO;oEAAtB;kBAFqB6rD;4EAErB;0BAFwBD;;;oEAO3B;WAH8BI;WAAHF;qEAG3B;;cAH8BE;mEAE/B;;oBAF4BF;mFAGH;;+DAIhC;OAAoC6I;;+DAApC;cAAoCA,qEACQ;;+DAI5C;;iEAEI;;;mBAEU30D;sEACF;0EADEA;uEACF,GADEA;uEACF,GADEA;uEAGA;;gCAFS4H;sEACN;oBADAwP;8EACA;sBADGvP;oFAEsB;iEAJpC;;wBAFyBuP;gEAUvB;OAHyBvP;OAAHyP;iEAGtB;;0BAHyBzP;+DAE1B;;gBAFuByP;8EAGM;;+DAIpC;;iEASqC;;gEATrC;;;mEAEI;WAD0BF;;mEAExB;;qCAFwBA;;oEAGK;WAANE;;oEAAM;kBAANA;;oEAIrB;WAH2BzP;WAAH2P;qEAGxB;;+BAH2B3P;mEAE5B;;oBAFyB2P;;;mEAM5B;WAD0BkzC;;oEACA;;oBADAA;;oEAEI;WAANC;;oEAAM;kBAANA;;oEACQ;WAANE;;oEAAM;kBAANA;;oEACM;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD8BE;;mEAC9B;kBAD8BA;;mEAG9B;WADyBC;;mEAEvB;;qCAFuBA;;mEAIzB;WAD4BE;;mEAC5B;kBAD4BA;;mEAG5B;;;;qBAEUprD;wEACF;;gBADEA;yEACF;gBADEA;yEAGA;;kBAFM6H;wEACP;;wBADIuP;sFAEiB;mEAJ5B;;0BAFyBk0C;;oEAOM;WAANE;;oEAAM;kBAANA;;oEACK;WAANE;;oEAAM;kBAANA;;mEAE1B;WAD0BG;;mEAExB;;qCAFwBA;;cAGM7jD,cAAH8jD;oEAEtB;kBAFsBA;4EAEtB;qCAFyB9jD,iEAEO;0BAEPhI;gEAAM,OAANA,2DAAO;;+DAI3C;;;mEAEoD;UADlB6H;UAAHuP;oEACqB;;aADlBvP;mEACH;;mBADAuP;;;aAECpP,cAAHsP;mEACA;;mBADAA;iBAAGtP;;mEAEI;UAANwP;;mEAAM;iBAANA,gEAAkC;;+DAIhE;;iEAEI;SADsBJ;;kEACA;;kBADAA;UAEIvP,YAAHyP;gEACI;cADJA;wEACI;gBADDzP,8DAC8B;;+DAI5D;;iEAC+B;;gEAD/B;;;oEAEmC;WAANuP;;oEAAM;kBAANA;;;WACCvP;WAAHyP;;qBACsBtX;wEAAM,OAANA,2DAAO;oEAAzB;kBADJsX;4EACI;0BADDzP;;mEAG1B;WADwB2P;;oEACA;;oBADAA;;mEAGxB;WADuBkzC;;oEACA;;oBADAA,iEACc;;+DAIzC;;;;;;;;;gEAkBM;;UAdgCiH;+DAchC;QANQ3xD;kEACF;sEADEA;mEACF,GADEA;mEACF,GADEA;mEAGA;;4BAFS4H;kEACN;gBADAwP;0EACA;kCADGvP;gFAEyB;+DAJvC;;;gBARqC+pD;+DAQrC;QAFe5xD;kEAAM,OAANA,2DAAO;+DAAtB;cAR6B8xD;uEAQ7B;sBAP+BD;;6EAiBlC;0BAEU7xD;gEAAI;2BAAJA,4DAAwB;aCp1DnC40D,cACFvkB;sDADgB;;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,QAChBA;uDADgB,IAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,YAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,SAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,UAChBA;uDADgB,KAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,YAChBA;uDADgB,WAChBA;uDADgB;QAChBA;uDADgB;QAChBA;uDADgB,MAChBA;uDADgB,OACh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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDIhgEE;;;uE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA,qE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CJggEFA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;wC;;;;;;;;;;;;;;;;;;;;;;;mDIhgEE;0C;iBJggEFA,mE;;+CAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;yC,MAAAA;wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDIhgEE;;0C;iBJggEFA,oE;;cAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBMp7EEnkD;sC;;;;;wBAAAA;sC;;;;;wBAAAA;sC;;;;;wBAAAA;sC;;;;;wBAAAA;sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDZ5DJjL,0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDUgfI;;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;;;;;;;;;mD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAAA;kD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WJggEFovD;;;;;;;;;;;;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDIhgEE;;+C;;;;;;;;mBJggEFA;2C;eAAAA,uE;;WAAAA;;;;;;;;;;;;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDIhgEE;;+C;;;;;;;;mBJggEFA;2C;eAAAA,oE;;;;OAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0C;;;SAAAA;;;;;;0C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDIhgEE;;2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAAA;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAAA;6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBEpYAtjD;;8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDFoYA;uD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;awBjdF8+B;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDtB0IFp+B,iE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA7DIV,8D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oEApFJnB;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDFwdI;;;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAAA;;;yD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BEpbAM;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OyB6PJkkC;;;;kBAhFAd;kBAUAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4D3B6PI;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAAA;6D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;;;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAAA;;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sEAAA;;oE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAAA;;2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;;sD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DAAA;0D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA;wD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAAA;4D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kC2BjfJlC;;;;;wB,UAAAA;;;;wB,UAAAA;;;;wB,UAAAA;;;WA8jBAwH;;;;;2B,UA9jBAxH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wB;oCA8UAkD;;;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uD/BmqEE4f;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDIhgEE;iD;iBJggEFA,0E;;uDAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;iD,MAAAA;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDIhgEE;;iD;iBJggEFA,2E;;;;SAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;e+B7tEFtgB;eA1CAT;eA/EAJ;;;;;;;;;;uB;;;;;;;;;;;;;;;;QAmaA6F;;;;;wB;;;;;;;;;;;;;;;;iCAhPAtE;;;QA7CAN;;;;gD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Y/Bu/EAsgB;YAHAH;YACAC;YAgGAI;;;;;;;;;;;UA9FAF;UAHAH;UACAC;UAgGAI;;;;;;;;;;;;;;YA9FAF;YAHAH;YACAC;YAgGAI;;;;;;;;;;;UA9FAF;UAHAH;UACAC;UAgGAI;;;;;;4C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sources":["/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/stdlib.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/mlString.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/int64.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/ieee_754.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/fs.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/fs_fake.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/fs_node.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/bigarray.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/bigstring.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/jslib.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/marshal.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/jslib_js_of_ocaml.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/io.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/toplevel.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/gc.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/weak.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/parsing.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/unix.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/internalMod.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/lexing.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/polyfill/json2.js","/Users/anmonteiro/.opam/4.04.2/lib/js_of_ocaml-compiler/md5.js","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/lexing.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/camlinternalFormat.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/printexc.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/filename.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/ast_402.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/ast_403.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/ast_404.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/ast_405.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/ast_406.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_403_402_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/camlinternalFormatBasics.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/pervasives.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/list.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/char.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/bytes.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/string.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/sys.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/marshal.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/obj.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/array.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/int32.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/int64.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/nativeint.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/parsing.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/set.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/map.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/queue.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/camlinternalLazy.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/buffer.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/printf.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/digest.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/random.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/hashtbl.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/format.ml","/Users/anmonteiro/Documents/github/refmt-js/src/refmt.re","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/scanf.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/callback.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/camlinternalOO.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_402_403_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_402_403.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_403_402.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_403_404_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_404_403_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_403_404.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_404_403.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_404_405_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_405_404_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_404_405.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_405_404.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_405_406_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_406_405_migrate.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_405_406.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml-migrate-parsetree/migrate_parsetree_406_405.ml","/Users/anmonteiro/.opam/4.04.2/lib/ocaml/std_exit.ml"],"sourcesContent":["// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Core\n\n//Provides: raw_array_sub\nfunction raw_array_sub (a,i,l) {\n  var b = new Array(l);\n  for(var j = 0; j < l; j++) b[j] = a[i+j];\n  return b\n}\n\n//Provides: raw_array_copy\nfunction raw_array_copy (a) {\n  var l = a.length;\n  var b = new Array(l);\n  for(var i = 0; i < l; i++ ) b[i] = a[i];\n  return b\n}\n\n//Provides: raw_array_cons\nfunction raw_array_cons (a,x) {\n  var l = a.length;\n  var b = new Array(l+1);\n  b[0]=x;\n  for(var i = 1; i <= l; i++ ) b[i] = a[i-1];\n  return b\n}\n\n//Provides: raw_array_append_one\nfunction raw_array_append_one(a,x) {\n  var l = a.length;\n  var b = new Array(l+1);\n  var i = 0;\n  for(; i < l; i++ ) b[i] = a[i];\n  b[i]=x;\n  return b\n}\n\n//Provides: caml_call_gen (const, shallow)\n//Requires: raw_array_sub\n//Requires: raw_array_append_one\nfunction caml_call_gen(f, args) {\n  if(f.fun)\n    return caml_call_gen(f.fun, args);\n  var n = f.length;\n  var argsLen = args.length;\n  var d = n - argsLen;\n  if (d == 0)\n    return f.apply(null, args);\n  else if (d < 0)\n    return caml_call_gen(f.apply(null,\n                                 raw_array_sub(args,0,n)),\n                         raw_array_sub(args,n,argsLen - n));\n  else\n    return function (x){ return caml_call_gen(f, raw_array_append_one(args,x)); };\n}\n\n//Provides: caml_named_values\nvar caml_named_values = {};\n\n//Provides: caml_register_named_value (const,const)\n//Requires: caml_named_values, caml_bytes_of_string\nfunction caml_register_named_value(nm,v) {\n  caml_named_values[caml_bytes_of_string(nm)] = v;\n  return 0;\n}\n\n//Provides: caml_named_value\n//Requires: caml_named_values\nfunction caml_named_value(nm) {\n  return caml_named_values[nm]\n}\n\n//Provides: caml_global_data\nvar caml_global_data = [0];\n\n//Provides: caml_register_global (const, shallow, const)\n//Requires: caml_global_data\nfunction caml_register_global (n, v, name_opt) {\n  caml_global_data[n + 1] = v;\n  if(name_opt) caml_global_data[name_opt] = v;\n}\n\n//Provides: caml_get_global_data mutable\n//Requires: caml_global_data\nfunction caml_get_global_data () { return caml_global_data; }\n\n//Raise exception\n\n\n//Provides: caml_raise_constant (const)\n//Version: < 4.02\nfunction caml_raise_constant (tag) { throw [0, tag]; }\n\n//Provides: caml_raise_constant (const)\n//Version: >= 4.02\nfunction caml_raise_constant (tag) { throw tag; }\n\n//Provides: caml_return_exn_constant (const)\n//Version: < 4.02\nfunction caml_return_exn_constant (tag) { return [0, tag]; }\n\n//Provides: caml_return_exn_constant (const)\n//Version: >= 4.02\nfunction caml_return_exn_constant (tag) { return tag; }\n\n//Provides: caml_raise_with_arg (const, const)\nfunction caml_raise_with_arg (tag, arg) { throw [0, tag, arg]; }\n\n//Provides: caml_raise_with_string (const, const)\n//Requires: caml_raise_with_arg,caml_new_string\nfunction caml_raise_with_string (tag, msg) {\n  caml_raise_with_arg (tag, caml_new_string (msg));\n}\n\n//Provides: caml_raise_sys_error (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_raise_sys_error (msg) {\n  caml_raise_with_string(caml_global_data.Sys_error, msg);\n}\n\n//Provides: caml_failwith (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_failwith (msg) {\n  caml_raise_with_string(caml_global_data.Failure, msg);\n}\n\n//Provides: caml_wrap_exception const (const)\n//Requires: caml_global_data,caml_js_to_string,caml_named_value\n//Requires: caml_return_exn_constant\nfunction caml_wrap_exception(e) {\n  if(e instanceof Array) return e;\n  //Stack_overflow: chrome, safari\n  if(joo_global_object.RangeError\n     && e instanceof joo_global_object.RangeError\n     && e.message\n     && e.message.match(/maximum call stack/i))\n    return caml_return_exn_constant(caml_global_data.Stack_overflow);\n  //Stack_overflow: firefox\n  if(joo_global_object.InternalError\n     && e instanceof joo_global_object.InternalError\n     && e.message\n     && e.message.match(/too much recursion/i))\n    return caml_return_exn_constant(caml_global_data.Stack_overflow);\n  //Wrap Error in Js.Error exception\n  if(e instanceof joo_global_object.Error && caml_named_value(\"jsError\"))\n    return [0,caml_named_value(\"jsError\"),e];\n  //fallback: wrapped in Failure\n  return [0,caml_global_data.Failure,caml_js_to_string (String(e))];\n}\n\n// Experimental\n//Provides: caml_exn_with_js_backtrace\n//Requires: caml_global_data\nfunction caml_exn_with_js_backtrace(exn, force) {\n  if(!exn.js_error || force) exn.js_error = new joo_global_object.Error(\"Js exception containing backtrace\");\n  return exn;\n}\n//Provides: caml_js_error_of_exception\nfunction caml_js_error_of_exception(exn) {\n  if(exn.js_error) { return exn.js_error; }\n  return null;\n}\n\n//Provides: caml_invalid_argument (const)\n//Requires: caml_raise_with_string, caml_global_data\nfunction caml_invalid_argument (msg) {\n  caml_raise_with_string(caml_global_data.Invalid_argument, msg);\n}\n\n//Provides: caml_raise_end_of_file\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_end_of_file () {\n  caml_raise_constant(caml_global_data.End_of_file);\n}\n\n//Provides: caml_raise_zero_divide\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_zero_divide () {\n  caml_raise_constant(caml_global_data.Division_by_zero);\n}\n\n//Provides: caml_raise_not_found\n//Requires: caml_raise_constant, caml_global_data\nfunction caml_raise_not_found () {\n  caml_raise_constant(caml_global_data.Not_found); }\n\n\n//Provides: caml_array_bound_error\n//Requires: caml_invalid_argument\nfunction caml_array_bound_error () {\n  caml_invalid_argument(\"index out of bounds\");\n}\n\n//Provides: caml_update_dummy\nfunction caml_update_dummy (x, y) {\n  if( typeof y===\"function\" ) { x.fun = y; return 0; }\n  if( y.fun ) { x.fun = y.fun; return 0; }\n  var i = y.length; while (i--) x[i] = y[i]; return 0;\n}\n\n//Provides: caml_obj_is_block const (const)\nfunction caml_obj_is_block (x) { return +(x instanceof Array); }\n//Provides: caml_obj_tag const (const)\n//Requires: MlString\nfunction caml_obj_tag (x) { return (x instanceof Array)?x[0]:(x instanceof MlString)?252:1000; }\n//Provides: caml_obj_set_tag (mutable, const)\nfunction caml_obj_set_tag (x, tag) { x[0] = tag; return 0; }\n//Provides: caml_obj_block const (const,const)\nfunction caml_obj_block (tag, size) {\n  var o = new Array(size+1);\n  o[0]=tag;\n  for (var i = 1; i <= size; i++) o[i] = 0;\n  return o;\n}\n//Provides: caml_obj_dup mutable (const)\nfunction caml_obj_dup (x) {\n  var l = x.length;\n  var a = new Array(l);\n  for(var i = 0; i < l; i++ ) a[i] = x[i];\n  return a;\n}\n//Provides: caml_obj_truncate (mutable, const)\n//Requires: caml_invalid_argument\nfunction caml_obj_truncate (x, s) {\n  if (s<=0 || s + 1 > x.length)\n    caml_invalid_argument (\"Obj.truncate\");\n  if (x.length != s + 1) x.length = s + 1;\n  return 0;\n}\n\n//Provides: caml_lazy_make_forward const (const)\nfunction caml_lazy_make_forward (v) { return [250, v]; }\n\n//Provides: caml_mul const\nif (!Math.imul)\n  Math.imul =\n    function (x,y)\n    { y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; };\nvar caml_mul = Math.imul;\n\n//slightly slower\n// function mul32(x,y) {\n//   var xlo = x & 0xffff;\n//   var xhi = x - xlo;\n//   return (((xhi * y) |0) + xlo * y)|0;\n// }\n\n//Provides: caml_div\n//Requires: caml_raise_zero_divide\nfunction caml_div(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return (x/y)|0;\n}\n\n//Provides: caml_mod\n//Requires: caml_raise_zero_divide\nfunction caml_mod(x,y) {\n  if (y == 0) caml_raise_zero_divide ();\n  return x%y;\n}\n\n///////////// Pervasive\n//Provides: caml_array_set (mutable, const, const)\n//Requires: caml_array_bound_error\nfunction caml_array_set (array, index, newval) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  array[index+1]=newval; return 0;\n}\n\n//Provides: caml_array_get mutable (const, const)\n//Requires: caml_array_bound_error\nfunction caml_array_get (array, index) {\n  if ((index < 0) || (index >= array.length - 1)) caml_array_bound_error();\n  return array[index+1];\n}\n\n//Provides: caml_check_bound (const, const)\n//Requires: caml_array_bound_error\nfunction caml_check_bound (array, index) {\n  if (index >>> 0 >= array.length - 1) caml_array_bound_error();\n  return array;\n}\n\n//Provides: caml_make_vect const (const, const)\nfunction caml_make_vect (len, init) {\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=0;\n  for (var i = 1; i < len; i++) b[i] = init;\n  return b;\n}\n\n//Provides: caml_make_float_vect const (const)\nfunction caml_make_float_vect(len){\n  var len = len + 1 | 0;\n  var b = new Array(len);\n  b[0]=254;\n  for (var i = 1; i < len; i++) b[i] = 0;\n  return b\n}\n\n//Provides: caml_compare_val (const, const, const)\n//Requires: MlString, caml_int64_compare, caml_int_compare, caml_string_compare\n//Requires: caml_invalid_argument\nfunction caml_compare_val (a, b, total) {\n  var stack = [];\n  for(;;) {\n    if (!(total && a === b)) {\n      if (a instanceof MlString) {\n        if (b instanceof MlString) {\n            if (a !== b) {\n\t\tvar x = caml_string_compare(a, b);\n\t\tif (x != 0) return x;\n\t    }\n        } else\n          // Should not happen\n          return 1;\n      } else if (a instanceof Array && a[0] === (a[0]|0)) {\n        var ta = a[0];\n        // ignore double_array_tag\n        if (ta === 254) ta=0;\n        // Forward object\n        if (ta === 250) {\n          a = a[1];\n          continue;\n        } else if (b instanceof Array && b[0] === (b[0]|0)) {\n          var tb = b[0];\n          // ignore double_array_tag\n          if (tb === 254) tb=0;\n          // Forward object\n          if (tb === 250) {\n            b = b[1];\n            continue;\n          } else if (ta != tb) {\n            return (ta < tb)?-1:1;\n          } else {\n            switch (ta) {\n            case 248: {\n\t\t// Object\n\t\tvar x = caml_int_compare(a[2], b[2]);\n\t\tif (x != 0) return x;\n\t\tbreak;\n\t    }\n            case 251: {\n                caml_invalid_argument(\"equal: abstract value\");\n            }\n            case 255: {\n\t\t// Int64\n\t\tvar x = caml_int64_compare(a, b);\n\t\tif (x != 0) return x;\n\t\tbreak;\n\t    }\n            default:\n              if (a.length != b.length) return (a.length < b.length)?-1:1;\n              if (a.length > 1) stack.push(a, b, 1);\n            }\n          }\n        } else\n          return 1;\n      } else if (b instanceof MlString ||\n                 (b instanceof Array && b[0] === (b[0]|0))) {\n        return -1;\n      } else if (typeof a != \"number\" && a && a.compare) {\n        return a.compare(b,total);\n      } else if (typeof a == \"function\") {\n        caml_invalid_argument(\"compare: functional value\");\n      } else {\n        if (a < b) return -1;\n        if (a > b) return 1;\n        if (a != b) {\n          if (!total) return NaN;\n          if (a == a) return 1;\n          if (b == b) return -1;\n        }\n      }\n    }\n    if (stack.length == 0) return 0;\n    var i = stack.pop();\n    b = stack.pop();\n    a = stack.pop();\n    if (i + 1 < a.length) stack.push(a, b, i + 1);\n    a = a[i];\n    b = b[i];\n  }\n}\n//Provides: caml_compare (const, const)\n//Requires: caml_compare_val\nfunction caml_compare (a, b) { return caml_compare_val (a, b, true); }\n//Provides: caml_int_compare mutable (const, const)\nfunction caml_int_compare (a, b) {\n  if (a < b) return (-1); if (a == b) return 0; return 1;\n}\n//Provides: caml_equal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_equal (x, y) { return +(caml_compare_val(x,y,false) == 0); }\n//Provides: caml_notequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_notequal (x, y) { return +(caml_compare_val(x,y,false) != 0); }\n//Provides: caml_greaterequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterequal (x, y) { return +(caml_compare_val(x,y,false) >= 0); }\n//Provides: caml_greaterthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_greaterthan (x, y) { return +(caml_compare_val(x,y,false) > 0); }\n//Provides: caml_lessequal mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessequal (x, y) { return +(caml_compare_val(x,y,false) <= 0); }\n//Provides: caml_lessthan mutable (const, const)\n//Requires: caml_compare_val\nfunction caml_lessthan (x, y) { return +(caml_compare_val(x,y,false) < 0); }\n\n//Provides: caml_parse_sign_and_base\n//Requires: caml_string_unsafe_get, caml_ml_string_length\nfunction caml_parse_sign_and_base (s) {\n  var i = 0, len = caml_ml_string_length(s), base = 10,\n     sign = (len > 0 && caml_string_unsafe_get(s,0) == 45)?(i++,-1):1;\n  if (i + 1 < len && caml_string_unsafe_get(s, i) == 48)\n    switch (caml_string_unsafe_get(s, i + 1)) {\n    case 120: case 88: base = 16; i += 2; break;\n    case 111: case 79: base =  8; i += 2; break;\n    case  98: case 66: base =  2; i += 2; break;\n    }\n  return [i, sign, base];\n}\n\n//Provides: caml_parse_digit\nfunction caml_parse_digit(c) {\n  if (c >= 48 && c <= 57)  return c - 48;\n  if (c >= 65 && c <= 90)  return c - 55;\n  if (c >= 97 && c <= 122) return c - 87;\n  return -1;\n}\n\n//Provides: caml_int_of_string (const)\n//Requires: caml_ml_string_length, caml_string_unsafe_get\n//Requires: caml_parse_sign_and_base, caml_parse_digit, caml_failwith\nfunction caml_int_of_string (s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var len = caml_ml_string_length(s);\n  var threshold = -1 >>> 0;\n  var c = (i < len)?caml_string_unsafe_get(s, i):0;\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = d;\n  for (i++;i<len;i++) {\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    res = base * res + d;\n    if (res > threshold) caml_failwith(\"int_of_string\");\n  }\n  if (i != len) caml_failwith(\"int_of_string\");\n  // For base different from 10, we expect an unsigned representation,\n  // hence any value of 'res' (less than 'threshold') is acceptable.\n  // But we have to convert the result back to a signed integer.\n  res = sign * res;\n  if ((base == 10) && ((res | 0) != res))\n    /* Signed representation expected, allow -2^(nbits-1) to 2^(nbits-1) - 1 */\n    caml_failwith(\"int_of_string\");\n  return res | 0;\n}\n\n//Provides: caml_float_of_string (const)\n//Requires: caml_failwith, caml_bytes_of_string\nfunction caml_float_of_string(s) {\n  var res;\n  s = caml_bytes_of_string (s);\n  res = +s;\n  if ((s.length > 0) && (res === res)) return res;\n  s = s.replace(/_/g,\"\");\n  res = +s;\n  if (((s.length > 0) && (res === res)) || /^[+-]?nan$/i.test(s)) return res;\n  var m = /^ *([+-]?)0x([0-9a-f]+)\\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);\n//            1        2             3           4\n  if(m){\n    var m3 = m[3].replace(/0+$/,'');\n    var mantissa = parseInt(m[1] + m[2] + m3, 16);\n    var exponent = (m[4]|0) - 4*m3.length;\n    res = mantissa * Math.pow(2, exponent);\n    return res;\n  }\n  if(/^\\+?inf(inity)?$/i.test(s)) return Infinity;\n  if(/^-inf(inity)?$/i.test(s)) return -Infinity;\n  caml_failwith(\"float_of_string\");\n}\n\n//Provides: caml_is_printable const (const)\nfunction caml_is_printable(c) { return +(c > 31 && c < 127); }\n\n///////////// Format\n//Provides: caml_parse_format\n//Requires: caml_bytes_of_string, caml_invalid_argument\nfunction caml_parse_format (fmt) {\n  fmt = caml_bytes_of_string(fmt);\n  var len = fmt.length;\n  if (len > 31) caml_invalid_argument(\"format_int: format too long\");\n  var f =\n    { justify:'+', signstyle:'-', filler:' ', alternate:false,\n      base:0, signedconv:false, width:0, uppercase:false,\n      sign:1, prec:-1, conv:'f' };\n  for (var i = 0; i < len; i++) {\n    var c = fmt.charAt(i);\n    switch (c) {\n    case '-':\n      f.justify = '-'; break;\n    case '+': case ' ':\n      f.signstyle = c; break;\n    case '0':\n      f.filler = '0'; break;\n    case '#':\n      f.alternate = true; break;\n    case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      f.width = 0;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.width = f.width * 10 + c; i++\n      }\n      i--;\n     break;\n    case '.':\n      f.prec = 0;\n      i++;\n      while (c=fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {\n        f.prec = f.prec * 10 + c; i++\n      }\n      i--;\n    case 'd': case 'i':\n      f.signedconv = true; /* fallthrough */\n    case 'u':\n      f.base = 10; break;\n    case 'x':\n      f.base = 16; break;\n    case 'X':\n      f.base = 16; f.uppercase = true; break;\n    case 'o':\n      f.base = 8; break;\n    case 'e': case 'f': case 'g':\n      f.signedconv = true; f.conv = c; break;\n    case 'E': case 'F': case 'G':\n      f.signedconv = true; f.uppercase = true;\n      f.conv = c.toLowerCase (); break;\n    }\n  }\n  return f;\n}\n\n//Provides: caml_finish_formatting\n//Requires: caml_new_string\nfunction caml_finish_formatting(f, rawbuffer) {\n  if (f.uppercase) rawbuffer = rawbuffer.toUpperCase();\n  var len = rawbuffer.length;\n  /* Adjust len to reflect additional chars (sign, etc) */\n  if (f.signedconv && (f.sign < 0 || f.signstyle != '-')) len++;\n  if (f.alternate) {\n    if (f.base == 8) len += 1;\n    if (f.base == 16) len += 2;\n  }\n  /* Do the formatting */\n  var buffer = \"\";\n  if (f.justify == '+' && f.filler == ' ')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  if (f.signedconv) {\n    if (f.sign < 0) buffer += '-';\n    else if (f.signstyle != '-') buffer += f.signstyle;\n  }\n  if (f.alternate && f.base == 8) buffer += '0';\n  if (f.alternate && f.base == 16) buffer += \"0x\";\n  if (f.justify == '+' && f.filler == '0')\n    for (var i = len; i < f.width; i++) buffer += '0';\n  buffer += rawbuffer;\n  if (f.justify == '-')\n    for (var i = len; i < f.width; i++) buffer += ' ';\n  return caml_new_string (buffer);\n}\n\n//Provides: caml_format_int const (const, const)\n//Requires: caml_parse_format, caml_finish_formatting, caml_str_repeat\n//Requires: caml_new_string, caml_bytes_of_string\nfunction caml_format_int(fmt, i) {\n  if (caml_bytes_of_string(fmt) == \"%d\") return caml_new_string(\"\"+i);\n  var f = caml_parse_format(fmt);\n  if (i < 0) { if (f.signedconv) { f.sign = -1; i = -i; } else i >>>= 0; }\n  var s = i.toString(f.base);\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - s.length;\n    if (n > 0) s = caml_str_repeat (n, '0') + s;\n  }\n  return caml_finish_formatting(f, s);\n}\n\n//Provides: caml_format_float const\n//Requires: caml_parse_format, caml_finish_formatting\nfunction caml_format_float (fmt, x) {\n  var s, f = caml_parse_format(fmt);\n  var prec = (f.prec < 0)?6:f.prec;\n  if (x < 0 || (x == 0 && 1/x == -Infinity)) { f.sign = -1; x = -x; }\n  if (isNaN(x)) { s = \"nan\"; f.filler = ' '; }\n  else if (!isFinite(x)) { s = \"inf\"; f.filler = ' '; }\n  else\n    switch (f.conv) {\n    case 'e':\n      var s = x.toExponential(prec);\n      // exponent should be at least two digits\n      var i = s.length;\n      if (s.charAt(i - 3) == 'e')\n        s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n      break;\n    case 'f':\n      s = x.toFixed(prec); break;\n    case 'g':\n      prec = prec?prec:1;\n      s = x.toExponential(prec - 1);\n      var j = s.indexOf('e');\n      var exp = +s.slice(j + 1);\n      if (exp < -4 || x >= 1e21 || x.toFixed(0).length > prec) {\n        // remove trailing zeroes\n        var i = j - 1; while (s.charAt(i) == '0') i--;\n        if (s.charAt(i) == '.') i--;\n        s = s.slice(0, i + 1) + s.slice(j);\n        i = s.length;\n        if (s.charAt(i - 3) == 'e')\n          s = s.slice (0, i - 1) + '0' + s.slice (i - 1);\n        break;\n      } else {\n        var p = prec;\n        if (exp < 0) { p -= exp + 1; s = x.toFixed(p); }\n        else while (s = x.toFixed(p), s.length > prec + 1) p--;\n        if (p) {\n          // remove trailing zeroes\n          var i = s.length - 1; while (s.charAt(i) == '0') i--;\n          if (s.charAt(i) == '.') i--;\n          s = s.slice(0, i + 1);\n        }\n      }\n      break;\n    }\n  return caml_finish_formatting(f, s);\n}\n\n///////////// Hashtbl\n//Provides: caml_hash_univ_param mutable\n//Requires: MlString, caml_convert_string_to_bytes\n//Requires: caml_int64_to_bytes, caml_int64_bits_of_float\nfunction caml_hash_univ_param (count, limit, obj) {\n  var hash_accu = 0;\n  function hash_aux (obj) {\n    limit --;\n    if (count < 0 || limit < 0) return;\n    if (obj instanceof Array && obj[0] === (obj[0]|0)) {\n      switch (obj[0]) {\n      case 248:\n        // Object\n        count --;\n        hash_accu = (hash_accu * 65599 + obj[2]) | 0;\n        break;\n      case 250:\n        // Forward\n        limit++; hash_aux(obj); break;\n      case 255:\n        // Int64\n        count --;\n        hash_accu = (hash_accu * 65599 + obj[1] + (obj[2] << 24)) | 0;\n        break;\n      default:\n        count --;\n        hash_accu = (hash_accu * 19 + obj[0]) | 0;\n        for (var i = obj.length - 1; i > 0; i--) hash_aux (obj[i]);\n      }\n    } else if (obj instanceof MlString) {\n      count --;\n      switch (obj.t & 6) {\n      default: /* PARTIAL */\n        caml_convert_string_to_bytes(obj);\n      case 0: /* BYTES */\n        for (var b = obj.c, l = obj.l, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + b.charCodeAt(i)) | 0;\n        break;\n      case 2: /* ARRAY */\n        for (var a = obj.c, l = obj.l, i = 0; i < l; i++)\n          hash_accu = (hash_accu * 19 + a[i]) | 0;\n      }\n    } else if (obj === (obj|0)) {\n      // Integer\n      count --;\n      hash_accu = (hash_accu * 65599 + obj) | 0;\n    } else if (obj === +obj) {\n      // Float\n      count--;\n      var p = caml_int64_to_bytes (caml_int64_bits_of_float (obj));\n      for (var i = 7; i >= 0; i--) hash_accu = (hash_accu * 19 + p[i]) | 0;\n    }\n  }\n  hash_aux (obj);\n  return hash_accu & 0x3FFFFFFF;\n}\n\n//function ROTL32(x,n) { return ((x << n) | (x >>> (32-n))); }\n//Provides: caml_hash_mix_int\n//Requires: caml_mul\nfunction caml_hash_mix_int(h,d) {\n  d = caml_mul(d, 0xcc9e2d51|0);\n  d = ((d << 15) | (d >>> (32-15))); // ROTL32(d, 15);\n  d = caml_mul(d, 0x1b873593);\n  h ^= d;\n  h = ((h << 13) | (h >>> (32-13)));   //ROTL32(h, 13);\n  return (((h + (h << 2))|0) + (0xe6546b64|0))|0;\n}\n\n//Provides: caml_hash_mix_final\n//Requires: caml_mul\nfunction caml_hash_mix_final(h) {\n  h ^= h >>> 16;\n  h = caml_mul (h, 0x85ebca6b|0);\n  h ^= h >>> 13;\n  h = caml_mul (h, 0xc2b2ae35|0);\n  h ^= h >>> 16;\n  return h;\n}\n\n//Provides: caml_hash_mix_float\n//Requires: caml_hash_mix_int, caml_int64_bits_of_float\nfunction caml_hash_mix_float (h, v0) {\n  var v = caml_int64_bits_of_float (v0);\n  var lo = v[1] | (v[2] << 24);\n  var hi = (v[2] >>> 8) | (v[3] << 16);\n  h = caml_hash_mix_int(h, lo);\n  h = caml_hash_mix_int(h, hi);\n  return h;\n}\n//Provides: caml_hash_mix_int64\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_int64 (h, v) {\n  var lo = v[1] | (v[2] << 24);\n  var hi = (v[2] >>> 8) | (v[3] << 16);\n  h = caml_hash_mix_int(h, hi ^ lo);\n  return h;\n}\n\n//Provides: caml_hash_mix_string_str\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_string_str(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s.charCodeAt(i)\n        | (s.charCodeAt(i+1) << 8)\n        | (s.charCodeAt(i+2) << 16)\n        | (s.charCodeAt(i+3) << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s.charCodeAt(i+2) << 16;\n  case 2: w |= s.charCodeAt(i+1) << 8;\n  case 1: w |= s.charCodeAt(i);\n          h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_string_arr\n//Requires: caml_hash_mix_int\nfunction caml_hash_mix_string_arr(h, s) {\n  var len = s.length, i, w;\n  for (i = 0; i + 4 <= len; i += 4) {\n    w = s[i]\n      | (s[i+1] << 8)\n      | (s[i+2] << 16)\n      | (s[i+3] << 24);\n    h = caml_hash_mix_int(h, w);\n  }\n  w = 0;\n  switch (len & 3) {\n  case 3: w  = s[i+2] << 16;\n  case 2: w |= s[i+1] << 8;\n  case 1: w |= s[i];\n    h = caml_hash_mix_int(h, w);\n  default:\n  }\n  h ^= len;\n  return h;\n}\n\n//Provides: caml_hash_mix_string\n//Requires: caml_convert_string_to_bytes\n//Requires: caml_hash_mix_string_str\n//Requires: caml_hash_mix_string_arr\nfunction caml_hash_mix_string(h, v) {\n    switch (v.t & 6) {\n    default:\n        caml_convert_string_to_bytes (v);\n    case 0: /* BYTES */\n        h = caml_hash_mix_string_str(h, v.c);\n        break;\n    case 2: /* ARRAY */\n        h = caml_hash_mix_string_arr(h, v.c);\n    }\n    return h\n}\n\n\n//Provides: caml_hash mutable\n//Requires: MlString\n//Requires: caml_int64_bits_of_float, caml_hash_mix_int, caml_hash_mix_final\n//Requires: caml_hash_mix_int64, caml_hash_mix_float, caml_hash_mix_string\nvar HASH_QUEUE_SIZE = 256;\nfunction caml_hash (count, limit, seed, obj) {\n    var queue, rd, wr, sz, num, h, v, i, len;\n    sz = limit;\n    if (sz < 0 || sz > HASH_QUEUE_SIZE) sz = HASH_QUEUE_SIZE;\n    num = count;\n    h = seed;\n    queue = [obj]; rd = 0; wr = 1;\n    while (rd < wr && num > 0) {\n        v = queue[rd++];\n        if (v instanceof Array && v[0] === (v[0]|0)) {\n            switch (v[0]) {\n            case 248:\n                // Object\n                h = caml_hash_mix_int(h, v[2]);\n                num--;\n                break;\n            case 250:\n                // Forward\n                queue[--rd] = v[1];\n                break;\n            case 255:\n                // Int64\n                h = caml_hash_mix_int64 (h, v);\n                num --;\n                break;\n            default:\n                var tag = ((v.length - 1) << 10) | v[0];\n                h = caml_hash_mix_int(h, tag);\n                for (i = 1, len = v.length; i < len; i++) {\n                    if (wr >= sz) break;\n                    queue[wr++] = v[i];\n                }\n                break;\n            }\n        } else if (v instanceof MlString) {\n            h = caml_hash_mix_string(h,v)\n            num--;\n        } else if (v === (v|0)) {\n            // Integer\n            h = caml_hash_mix_int(h, v+v+1);\n            num--;\n        } else if (v === +v) {\n            // Float\n            h = caml_hash_mix_float(h,v);\n            num--;\n        }\n    }\n    h = caml_hash_mix_final(h);\n    return h & 0x3FFFFFFF;\n}\n\n///////////// Sys\n//Provides: caml_sys_time mutable\nvar caml_initial_time = new Date() * 0.001;\nfunction caml_sys_time () { return new Date() * 0.001 - caml_initial_time; }\n//Provides: caml_sys_get_config const\n//Requires: caml_new_string\nfunction caml_sys_get_config () {\n  return [0, caml_new_string(\"Unix\"), 32, 0];\n}\n\n//Provides: caml_sys_const_backend_type const\n//Requires: caml_new_string\nfunction caml_sys_const_backend_type () {\n  return [0, caml_new_string(\"js_of_ocaml\")];\n}\n\n\n//Provides: caml_sys_random_seed mutable\n//Version: < 4.00\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed () {\n  var x = new Date()^0xffffffff*Math.random();\n  return x;\n}\n\n//Provides: caml_sys_random_seed mutable\n//Version: >= 4.00\n//The function needs to return an array since OCaml 4.0...\nfunction caml_sys_random_seed () {\n  var x = new Date()^0xffffffff*Math.random();\n  return [0,x];\n}\n\n\n\n//Provides: caml_sys_const_big_endian const\nfunction caml_sys_const_big_endian () { return 0; }\n//Provides: caml_sys_const_word_size const\nfunction caml_sys_const_word_size () { return 32; }\n//Provides: caml_sys_const_int_size const\nfunction caml_sys_const_int_size () { return 32; }\n\n//Provides: caml_sys_const_max_wosize const\n// max_int / 4 so that the following does not overflow\n//let max_string_length = word_size / 8 * max_array_length - 1;;\nfunction caml_sys_const_max_wosize () { return (0x7FFFFFFF/4) | 0;}\n\n//Provides: caml_sys_const_ostype_cygwin const\nfunction caml_sys_const_ostype_cygwin () { return 0; }\n//Provides: caml_sys_const_ostype_unix const\nfunction caml_sys_const_ostype_unix () { return 1; }\n//Provides: caml_sys_const_ostype_win32 const\nfunction caml_sys_const_ostype_win32 () { return 0; }\n\n//Provides: caml_sys_system_command\nfunction caml_sys_system_command(cmd){\n  var cmd = cmd.toString();\n  joo_global_object.console.log(cmd);\n  if (typeof require != \"undefined\"\n      && require('child_process')\n      && require('child_process').execSync) {\n    try {require('child_process').execSync(cmd); return 0}\n    catch (e) {return 1}\n  }\n  else return 127;\n}\n\n///////////// Array\n//Provides: caml_array_sub mutable\nfunction caml_array_sub (a, i, len) {\n  var a2 = new Array(len+1);\n  a2[0]=0;\n  for(var i2 = 1, i1= i+1; i2 <= len; i2++,i1++ ){\n    a2[i2]=a[i1];\n  }\n  return a2;\n}\n\n//Provides: caml_array_append mutable\nfunction caml_array_append(a1, a2) {\n  var l1 = a1.length, l2 = a2.length;\n  var l = l1+l2-1\n  var a = new Array(l);\n  a[0] = 0;\n  var i = 1,j = 1;\n  for(;i<l1;i++) a[i]=a1[i];\n  for(;i<l;i++,j++) a[i]=a2[j];\n  return a;\n}\n\n//Provides: caml_array_concat mutable\nfunction caml_array_concat(l) {\n  var a = [0];\n  while (l !== 0) {\n    var b = l[1];\n    for (var i = 1; i < b.length; i++) a.push(b[i]);\n    l = l[2];\n  }\n  return a;\n}\n\n//Provides: caml_array_blit\nfunction caml_array_blit(a1, i1, a2, i2, len) {\n  if (i2 <= i1) {\n    for (var j = 1; j <= len; j++) a2[i2 + j] = a1[i1 + j];\n  } else {\n    for (var j = len; j >= 1; j--) a2[i2 + j] = a1[i1 + j];\n  };\n  return 0;\n}\n\n///////////// CamlinternalOO\n//Provides: caml_get_public_method const\nvar caml_method_cache = [];\nfunction caml_get_public_method (obj, tag, cacheid) {\n  var meths = obj[1];\n  var ofs = caml_method_cache[cacheid];\n  if (ofs === null) {\n    // Make sure the array is not sparse\n    for (var i = caml_method_cache.length; i < cacheid; i++)\n      caml_method_cache[i] = 0;\n  } else if (meths[ofs] === tag) {\n    return meths[ofs - 1];\n  }\n  var li = 3, hi = meths[1] * 2 + 1, mi;\n  while (li < hi) {\n    mi = ((li+hi) >> 1) | 1;\n    if (tag < meths[mi+1]) hi = mi-2;\n    else li = mi;\n  }\n  caml_method_cache[cacheid] = li + 1;\n  /* return 0 if tag is not there */\n  return (tag == meths[li+1] ? meths[li] : 0);\n}\n\n//Provides: caml_final_register const\nfunction caml_final_register () { return 0; }\n//Provides: caml_final_register_called_without_value const\nfunction caml_final_register_called_without_value () { return 0; }\n//Provides: caml_final_release const\nfunction caml_final_release () { return 0; }\n//Provides: caml_backtrace_status const\nfunction caml_backtrace_status () { return 0; }\n//Provides: caml_get_exception_backtrace const\nfunction caml_get_exception_backtrace () { return 0; }\n//Provides: caml_get_exception_raw_backtrace const\nfunction caml_get_exception_raw_backtrace () { return [0]; }\n//Provides: caml_record_backtrace\nfunction caml_record_backtrace () { return 0; }\n//Provides: caml_convert_raw_backtrace const\nfunction caml_convert_raw_backtrace () { return [0]; }\n//Provides: caml_raw_backtrace_length\nfunction caml_raw_backtrace_length() { return 0; }\n//Provides: caml_raw_backtrace_next_slot\nfunction caml_raw_backtrace_next_slot() { return 0 }\n//Provides: caml_raw_backtrace_slot\n//Requires: caml_invalid_argument\nfunction caml_raw_backtrace_slot () {\n  caml_invalid_argument(\"Printexc.get_raw_backtrace_slot: index out of bounds\");\n}\n//Provides: caml_get_current_callstack const\nfunction caml_get_current_callstack () { return [0]; }\n//Provides: caml_sys_getenv (const)\n//Requires: caml_raise_not_found\n//Requires: caml_js_to_string\nfunction caml_sys_getenv (name) {\n  var g = joo_global_object;\n  var n = name.toString();\n  //nodejs env\n  if(g.process\n     && g.process.env\n     && g.process.env[n] != undefined)\n    return caml_js_to_string(g.process.env[n]);\n  caml_raise_not_found ();\n}\n//Provides: caml_sys_exit\n//Requires: caml_invalid_argument\nfunction caml_sys_exit (code) {\n  var g = joo_global_object;\n  if(g.quit) g.quit(code);\n  //nodejs\n  if(g.process && g.process.exit)\n    g.process.exit(code);\n  caml_invalid_argument(\"Function 'exit' not implemented\");\n}\n\n//Provides: caml_sys_get_argv const\n//Requires: caml_js_to_string\n//Requires: raw_array_sub\nfunction caml_sys_get_argv () {\n  var g = joo_global_object;\n  var main = \"a.out\";\n  var args = []\n\n  if(g.process\n     && g.process.argv\n     && g.process.argv.length > 1) {\n    var argv = g.process.argv\n    //nodejs\n    main = argv[1];\n    args = raw_array_sub(argv,2,argv.length - 2);\n  }\n\n  var p = caml_js_to_string(main);\n  var args2 = [0, p];\n  for(var i = 0; i < args.length; i++)\n    args2.push(caml_js_to_string(args[i]));\n  return [0, p, args2];\n}\n\n//Provides: unix_inet_addr_of_string\nfunction unix_inet_addr_of_string () {return 0;}\n\n//Provides: caml_oo_last_id\nvar caml_oo_last_id = 0;\n\n//Provides: caml_set_oo_id\n//Requires: caml_oo_last_id\nfunction caml_set_oo_id (b) {\n  b[2]=caml_oo_last_id++;\n  return b;\n}\n\n//Provides: caml_fresh_oo_id\n//Requires: caml_oo_last_id\nfunction caml_fresh_oo_id() {\n  return caml_oo_last_id++;\n}\n\n//Provides: caml_install_signal_handler const\nfunction caml_install_signal_handler(){return 0}\n\n\n//Provides: caml_convert_raw_backtrace_slot\n//Requires: caml_failwith\nfunction caml_convert_raw_backtrace_slot(){\n  caml_failwith(\"caml_convert_raw_backtrace_slot\");\n}\n\n//Provides: caml_bswap16\nfunction caml_bswap16(x) {\n  return ((((x & 0x00FF) << 8) |\n           ((x & 0xFF00) >> 8)));\n}\n//Provides: caml_int32_bswap\nfunction caml_int32_bswap(x) {\n  return (((x & 0x000000FF) << 24) |\n          ((x & 0x0000FF00) << 8) |\n          ((x & 0x00FF0000) >>> 8) |\n          ((x & 0xFF000000) >>> 24));\n}\n//Provides: caml_int64_bswap\nfunction caml_int64_bswap(x) {\n  return [\n    255,\n    (((x[3] & 0x0000ff00) >> 8) |\n     ((x[3] & 0x000000ff) << 8) |\n     ((x[2] & 0x00ff0000))),\n    (((x[2] & 0x0000ff00) >> 8) |\n     ((x[2] & 0x000000ff) << 8) |\n     ((x[1] & 0x00ff0000))),\n    (((x[1] & 0x0000ff00) >> 8) |\n     ((x[1] & 0x000000ff) << 8))]\n}\n\n//Provides: caml_list_of_js_array const (const)\nfunction caml_list_of_js_array(a){\n  var l = 0;\n  for(var i=a.length - 1; i>=0; i--){\n    var e = a[i];\n    l = [0,e,l];\n  }\n  return l\n}\n\n//Provides: caml_runtime_warnings\nvar caml_runtime_warnings = 0;\n\n//Provides: caml_ml_enable_runtime_warnings\n//Requires: caml_runtime_warnings\nfunction caml_ml_enable_runtime_warnings (bool) {\n  caml_runtime_warnings = bool;\n  return 0;\n}\n\n//Provides: caml_ml_runtime_warnings_enabled\n//Requires: caml_runtime_warnings\nfunction caml_ml_runtime_warnings_enabled (_unit) {\n  return caml_runtime_warnings;\n}\n\n//Provides: caml_runtime_variant\n//Requires: caml_new_string\nfunction caml_runtime_variant(_unit) {\n  return caml_new_string(\"\");\n}\n//Provides: caml_runtime_parameters\n//Requires: caml_new_string\nfunction caml_runtime_parameters(_unit) {\n  return caml_new_string(\"\");\n}\n\n\n//Provides: caml_sys_isatty\nfunction caml_sys_isatty(_chan) {\n  return 0;\n}\n\n//Provides: caml_spacetime_enabled const (const)\nfunction caml_spacetime_enabled(_unit) {\n  return 0;\n}\n\n//Provides: caml_register_channel_for_spacetime const (const)\nfunction caml_register_channel_for_spacetime(_channel) {\n  return 0;\n}\n\n//Provides: caml_spacetime_only_works_for_native_code\n//Requires: caml_failwith\nfunction caml_spacetime_only_works_for_native_code() {\n  caml_failwith(\"Spacetime profiling only works for native code\");\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010-2014 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// An OCaml string is an object with three fields:\n// - tag 't'\n// - length 'l'\n// - contents 'c'\n//\n// The contents of the string can be either a JavaScript array or\n// a JavaScript string. The length of this string can be less than the\n// length of the OCaml string. In this case, remaining bytes are\n// assumed to be zeroes. Arrays are mutable but consumes more memory\n// than strings. A common pattern is to start from an empty string and\n// progressively fill it from the start. Partial strings makes it\n// possible to implement this efficiently.\n//\n// When converting to and from UTF-16, we keep track of whether the\n// string is composed only of ASCII characters (in which case, no\n// conversion needs to be performed) or not.\n//\n// The string tag can thus take the following values:\n//   full string     BYTE | UNKNOWN:      0\n//                   BYTE | ASCII:        9\n//                   BYTE | NOT_ASCII:    8\n//   string prefix   PARTIAL:             2\n//   array           ARRAY:               4\n//\n// One can use bit masking to discriminate these different cases:\n//   known_encoding(x) = x&8\n//   is_ascii(x) =       x&1\n//   kind(x) =           x&6\n\n//Provides: caml_str_repeat\nfunction caml_str_repeat(n, s) {\n  if (s.repeat) return s.repeat(n); // ECMAscript 6 and Firefox 24+\n  var r = \"\", l = 0;\n  if (n == 0) return r;\n  for(;;) {\n    if (n & 1) r += s;\n    n >>= 1;\n    if (n == 0) return r;\n    s += s;\n    l++;\n    if (l == 9) {\n      s.slice(0,1); // flatten the string\n      // then, the flattening of the whole string will be faster,\n      // as it will be composed of larger pieces\n    }\n  }\n}\n\n//Provides: caml_subarray_to_string\n//Requires: raw_array_sub\nfunction caml_subarray_to_string (a, i, len) {\n  var f = String.fromCharCode;\n  if (i == 0 && len <= 4096 && len == a.length) return f.apply (null, a);\n  var s = \"\";\n  for (; 0 < len; i += 1024,len-=1024)\n    s += f.apply (null, raw_array_sub(a,i, Math.min(len, 1024)));\n  return s;\n}\n\n//Provides: caml_utf8_of_utf16\nfunction caml_utf8_of_utf16(s) {\n  for (var b = \"\", t = b, c, d, i = 0, l = s.length; i < l; i++) {\n    c = s.charCodeAt(i);\n    if (c < 0x80) {\n      for (var j = i + 1; (j < l) && (c = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    if (c < 0x800) {\n      t += String.fromCharCode(0xc0 | (c >> 6));\n      t += String.fromCharCode(0x80 | (c & 0x3f));\n    } else if (c < 0xd800 || c >= 0xdfff) {\n      t += String.fromCharCode(0xe0 | (c >> 12),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    } else if (c >= 0xdbff || i + 1 == l ||\n               (d = s.charCodeAt(i + 1)) < 0xdc00 || d > 0xdfff) {\n      // Unmatched surrogate pair, replaced by \\ufffd (replacement character)\n      t += \"\\xef\\xbf\\xbd\";\n    } else {\n      i++;\n      c = (c << 10) + d - 0x35fdc00;\n      t += String.fromCharCode(0xf0 | (c >> 18),\n                               0x80 | ((c >> 12) & 0x3f),\n                               0x80 | ((c >> 6) & 0x3f),\n                               0x80 | (c & 0x3f));\n    }\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: caml_utf16_of_utf8\nfunction caml_utf16_of_utf8(s) {\n  for (var b = \"\", t = \"\", c, c1, c2, v, i = 0, l = s.length; i < l; i++) {\n    c1 = s.charCodeAt(i);\n    if (c1 < 0x80) {\n      for (var j = i + 1; (j < l) && (c1 = s.charCodeAt(j)) < 0x80; j++);\n      if (j - i > 512) { t.substr(0, 1); b += t; t = \"\"; b += s.slice(i, j) }\n      else t += s.slice(i, j);\n      if (j == l) break;\n      i = j;\n    }\n    v = 1;\n    if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n      c = c2 + (c1 << 6);\n      if (c1 < 0xe0) {\n        v = c - 0x3080;\n        if (v < 0x80) v = 1;\n      } else {\n        v = 2;\n        if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128)) {\n          c = c2 + (c << 6);\n          if (c1 < 0xf0) {\n            v = c - 0xe2080;\n            if ((v < 0x800) || ((v >= 0xd7ff) && (v < 0xe000))) v = 2;\n          } else {\n              v = 3;\n              if ((++i < l) && (((c2 = s.charCodeAt(i)) & -64) == 128) &&\n                  (c1 < 0xf5)) {\n                v = c2 - 0x3c82080 + (c << 6);\n                if (v < 0x10000 || v > 0x10ffff) v = 3;\n              }\n          }\n        }\n      }\n    }\n    if (v < 4) { // Invalid sequence\n      i -= v;\n      t += \"\\ufffd\";\n    } else if (v > 0xffff)\n      t += String.fromCharCode(0xd7c0 + (v >> 10), 0xdc00 + (v & 0x3FF))\n    else\n      t += String.fromCharCode(v);\n    if (t.length > 1024) {t.substr(0, 1); b += t; t = \"\";}\n  }\n  return b+t;\n}\n\n//Provides: caml_is_ascii\nfunction caml_is_ascii (s) {\n  // The regular expression gets better at around this point for all browsers\n  if (s.length < 24) {\n    // Spidermonkey gets much slower when s.length >= 24 (on 64 bit archs)\n    for (var i = 0; i < s.length; i++) if (s.charCodeAt(i) > 127) return false;\n    return true;\n  } else\n    return !/[^\\x00-\\x7f]/.test(s);\n}\n\n//Provides: caml_to_js_string\n//Requires: caml_convert_string_to_bytes, caml_is_ascii, caml_utf16_of_utf8\nfunction caml_to_js_string(s) {\n  switch (s.t) {\n  case 9: /*BYTES | ASCII*/\n    return s.c;\n  default:\n    caml_convert_string_to_bytes(s);\n  case 0: /*BYTES | UNKOWN*/\n    if (caml_is_ascii(s.c)) {\n      s.t = 9; /*BYTES | ASCII*/\n      return s.c;\n    }\n    s.t = 8; /*BYTES | NOT_ASCII*/\n  case 8: /*BYTES | NOT_ASCII*/\n    return caml_utf16_of_utf8(s.c);\n  }\n}\n\n//Provides: caml_string_unsafe_get mutable\nfunction caml_string_unsafe_get (s, i) {\n  switch (s.t & 6) {\n  default: /* PARTIAL */\n    if (i >= s.c.length) return 0;\n  case 0: /* BYTES */\n    return s.c.charCodeAt(i);\n  case 4: /* ARRAY */\n    return s.c[i]\n  }\n}\n\n//Provides: caml_bytes_unsafe_get mutable\nfunction caml_bytes_unsafe_get (s, i) {\n  switch (s.t & 6) {\n  default: /* PARTIAL */\n    if (i >= s.c.length) return 0;\n  case 0: /* BYTES */\n    return s.c.charCodeAt(i);\n  case 4: /* ARRAY */\n    return s.c[i]\n  }\n}\n\n//Provides: caml_string_unsafe_set\n//Requires: caml_convert_string_to_array\nfunction caml_string_unsafe_set (s, i, c) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t != 4 /* ARRAY */) {\n    if (i == s.c.length) {\n      s.c += String.fromCharCode (c);\n      if (i + 1 == s.l) s.t = 0; /*BYTES | UNKOWN*/\n      return 0;\n    }\n    caml_convert_string_to_array (s);\n  }\n  s.c[i] = c;\n  return 0;\n}\n\n//Provides: caml_bytes_unsafe_set\n//Requires: caml_convert_string_to_array\nfunction caml_bytes_unsafe_set (s, i, c) {\n  // The OCaml compiler uses Char.unsafe_chr on integers larger than 255!\n  c &= 0xff;\n  if (s.t != 4 /* ARRAY */) {\n    if (i == s.c.length) {\n      s.c += String.fromCharCode (c);\n      if (i + 1 == s.l) s.t = 0; /*BYTES | UNKOWN*/\n      return 0;\n    }\n    caml_convert_string_to_array (s);\n  }\n  s.c[i] = c;\n  return 0;\n}\n\n//Provides: caml_string_bound_error\n//Requires: caml_invalid_argument\nfunction caml_string_bound_error () {\n  caml_invalid_argument (\"index out of bounds\");\n}\n\n//Provides: caml_string_get\n//Requires: caml_string_bound_error, caml_string_unsafe_get\nfunction caml_string_get (s, i) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_get (s, i);\n}\n\n//Provides: caml_string_get16\n//Requires: caml_string_unsafe_get, caml_string_bound_error\nfunction caml_string_get16(s,i) {\n  if (i >>> 0 >= s.l + 1) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get (s, i),\n      b2 = caml_string_unsafe_get (s, i + 1);\n  return (b2 << 8 | b1);\n}\n\n//Provides: caml_string_get32\n//Requires: caml_string_unsafe_get, caml_string_bound_error\nfunction caml_string_get32(s,i) {\n  if (i >>> 0 >= s.l + 3) caml_string_bound_error();\n  var b1 = caml_string_unsafe_get (s, i),\n      b2 = caml_string_unsafe_get (s, i + 1),\n      b3 = caml_string_unsafe_get (s, i + 2),\n      b4 = caml_string_unsafe_get (s, i + 3);\n  return (b4 << 24 | b3 << 16 | b2 << 8 | b1);\n}\n\n//Provides: caml_string_get64\n//Requires: caml_string_unsafe_get, caml_string_bound_error\n//Requires: caml_int64_of_bytes\nfunction caml_string_get64(s,i) {\n  if (i >>> 0 >= s.l + 7) caml_string_bound_error();\n  var a = new Array(8);\n  for(var j = 0; j < 8; j++){\n    a[7 - j] = caml_string_unsafe_get (s, i + j);\n  }\n  return caml_int64_of_bytes(a);\n}\n\n//Provides: caml_bytes_get\n//Requires: caml_string_bound_error, caml_bytes_unsafe_get\nfunction caml_bytes_get (s, i) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_bytes_unsafe_get (s, i);\n}\n\n//Provides: caml_string_set\n//Requires: caml_string_bound_error, caml_string_unsafe_set\nfunction caml_string_set (s, i, c) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_string_unsafe_set (s, i, c);\n}\n\n//Provides: caml_string_set16\n//Requires: caml_string_bound_error, caml_string_unsafe_set\nfunction caml_string_set16(s,i,i16){\n  if (i >>> 0 >= s.l + 1) caml_string_bound_error();\n  var b2 = 0xFF & i16 >> 8,\n      b1 = 0xFF & i16;\n  caml_string_unsafe_set (s, i + 0, b1);\n  caml_string_unsafe_set (s, i + 1, b2);\n  return 0\n}\n\n//Provides: caml_string_set32\n//Requires: caml_string_bound_error, caml_string_unsafe_set\nfunction caml_string_set32(s,i,i32){\n  if (i >>> 0 >= s.l + 3) caml_string_bound_error();\n  var b4 = 0xFF & i32 >> 24,\n      b3 = 0xFF & i32 >> 16,\n      b2 = 0xFF & i32 >> 8,\n      b1 = 0xFF & i32;\n  caml_string_unsafe_set (s, i + 0, b1);\n  caml_string_unsafe_set (s, i + 1, b2);\n  caml_string_unsafe_set (s, i + 2, b3);\n  caml_string_unsafe_set (s, i + 3, b4);\n  return 0\n}\n\n//Provides: caml_string_set64\n//Requires: caml_string_bound_error, caml_string_unsafe_set\n//Requires: caml_int64_to_bytes\nfunction caml_string_set64(s,i,i64){\n  if (i >>> 0 >= s.l + 7) caml_string_bound_error();\n  var a = caml_int64_to_bytes(i64);\n  for(var j = 0; j < 8; j++) {\n    caml_string_unsafe_set (s, i + 7 - j, a[j]);\n  }\n  return 0\n}\n\n\n\n//Provides: caml_bytes_set\n//Requires: caml_string_bound_error, caml_bytes_unsafe_set\nfunction caml_bytes_set (s, i, c) {\n  if (i >>> 0 >= s.l) caml_string_bound_error();\n  return caml_bytes_unsafe_set (s, i, c);\n}\n\n//Provides: MlString\n//Requires: caml_to_js_string\nfunction MlString (tag, contents, length) {\n  this.t=tag; this.c=contents; this.l=length;\n}\nMlString.prototype.toString = function(){return caml_to_js_string(this)};\n\n//Provides: caml_convert_string_to_bytes\n//Requires: caml_str_repeat, caml_subarray_to_string\nfunction caml_convert_string_to_bytes (s) {\n  /* Assumes not BYTES */\n  if (s.t == 2 /* PARTIAL */)\n    s.c += caml_str_repeat(s.l - s.c.length, '\\0')\n  else\n    s.c = caml_subarray_to_string (s.c, 0, s.c.length);\n  s.t = 0; /*BYTES | UNKOWN*/\n}\n\n//Provides: caml_convert_string_to_array\nfunction caml_convert_string_to_array (s) {\n  /* Assumes not ARRAY */\n  if(joo_global_object.Uint8Array) {\n    var a = new joo_global_object.Uint8Array(s.l);\n  } else {\n    var a = new Array(s.l);\n  }\n  var b = s.c, l = b.length, i = 0;\n  for (; i < l; i++) a[i] = b.charCodeAt(i);\n  for (l = s.l; i < l; i++) a[i] = 0;\n  s.c = a;\n  s.t = 4; /* ARRAY */\n  return a;\n}\n\n//Provides: caml_array_of_string mutable\n//Requires: caml_convert_string_to_array\nfunction caml_array_of_string (s) {\n  if (s.t != 4 /* ARRAY */) caml_convert_string_to_array(s);\n  return s.c;\n}\n\n//Provides: caml_bytes_of_string mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_of_string (s) {\n  if ((s.t & 6) != 0 /* BYTES */) caml_convert_string_to_bytes(s);\n  return s.c;\n}\n\n//Provides: caml_js_to_string const\n//Requires: caml_is_ascii, caml_utf8_of_utf16, MlString\nfunction caml_js_to_string (s) {\n  var tag = 9 /* BYTES | ASCII */;\n  if (!caml_is_ascii(s))\n    tag = 8 /* BYTES | NOT_ASCII */, s = caml_utf8_of_utf16(s);\n  return new MlString(tag, s, s.length);\n}\n\n//Provides: caml_create_string const\n//Requires: MlString,caml_invalid_argument\nfunction caml_create_string(len) {\n  if (len < 0) caml_invalid_argument(\"String.create\");\n  return new MlString(len?2:9,\"\",len);\n}\n//Provides: caml_create_bytes const\n//Requires: MlString,caml_invalid_argument\nfunction caml_create_bytes(len) {\n  if (len < 0) caml_invalid_argument(\"Bytes.create\");\n  return new MlString(len?2:9,\"\",len);\n}\n\n//Provides: caml_new_string\n//Requires: MlString\nfunction caml_new_string (s) { return new MlString(0,s,s.length); }\n//Provides: caml_string_of_array\n//Requires: MlString\nfunction caml_string_of_array (a) { return new MlString(4,a,a.length); }\n\n//Provides: caml_string_compare mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_compare(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?-1:(s1.c > s2.c)?1:0;\n}\n\n\n//Provides: caml_bytes_compare mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_compare(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?-1:(s1.c > s2.c)?1:0;\n}\n\n//Provides: caml_string_equal mutable (const, const)\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_equal(s1, s2) {\n  if(s1 === s2) return 1;\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c == s2.c)?1:0;\n}\n\n//Provides: caml_bytes_equal mutable (const, const)\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_equal(s1, s2) {\n  if(s1 === s2) return 1;\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c == s2.c)?1:0;\n}\n\n//Provides: caml_string_notequal mutable (const, const)\n//Requires: caml_string_equal\nfunction caml_string_notequal(s1, s2) { return 1-caml_string_equal(s1, s2); }\n\n//Provides: caml_bytes_notequal mutable (const, const)\n//Requires: caml_string_equal\nfunction caml_bytes_notequal(s1, s2) { return 1-caml_string_equal(s1, s2); }\n\n//Provides: caml_string_lessequal mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_lessequal(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c <= s2.c)?1:0;\n}\n\n//Provides: caml_bytes_lessequal mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessequal(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c <= s2.c)?1:0;\n}\n\n//Provides: caml_string_lessthan mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_string_lessthan(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?1:0;\n}\n\n//Provides: caml_bytes_lessthan mutable\n//Requires: caml_convert_string_to_bytes\nfunction caml_bytes_lessthan(s1, s2) {\n  (s1.t & 6) && caml_convert_string_to_bytes(s1);\n  (s2.t & 6) && caml_convert_string_to_bytes(s2);\n  return (s1.c < s2.c)?1:0;\n}\n\n//Provides: caml_string_greaterequal\n//Requires: caml_string_lessequal\nfunction caml_string_greaterequal(s1, s2) {\n  return caml_string_lessequal(s2,s1);\n}\n//Provides: caml_bytes_greaterequal\n//Requires: caml_bytes_lessequal\nfunction caml_bytes_greaterequal(s1, s2) {\n  return caml_bytes_lessequal(s2,s1);\n}\n\n//Provides: caml_string_greaterthan\n//Requires: caml_string_lessthan\nfunction caml_string_greaterthan(s1, s2) {\n  return caml_string_lessthan(s2, s1);\n}\n\n//Provides: caml_bytes_greaterthan\n//Requires: caml_bytes_lessthan\nfunction caml_bytes_greaterthan(s1, s2) {\n  return caml_bytes_lessthan(s2, s1);\n}\n\n//Provides: caml_fill_string\n//Requires: caml_str_repeat, caml_convert_string_to_array\nfunction caml_fill_string(s, i, l, c) {\n  if (l > 0) {\n    if (i == 0 && (l >= s.l || (s.t == 2 /* PARTIAL */ && l >= s.c.length))) {\n      if (c == 0) {\n        s.c = \"\";\n        s.t = 2; /* PARTIAL */\n      } else {\n        s.c = caml_str_repeat (l, String.fromCharCode(c));\n        s.t = (l == s.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n      }\n    } else {\n      if (s.t != 4 /* ARRAY */) caml_convert_string_to_array(s);\n      for (l += i; i < l; i++) s.c[i] = c;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_fill_bytes\n//Requires: caml_fill_string\nvar caml_fill_bytes = caml_fill_string\n\n//Provides: caml_blit_string\n//Requires: caml_subarray_to_string, caml_convert_string_to_array\nfunction caml_blit_string(s1, i1, s2, i2, len) {\n  if (len == 0) return 0;\n  if ((i2 == 0) &&\n      (len >= s2.l || (s2.t == 2 /* PARTIAL */ && len >= s2.c.length))) {\n    s2.c = (s1.t == 4 /* ARRAY */)?\n             caml_subarray_to_string(s1.c, i1, len):\n             (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else if (s2.t == 2 /* PARTIAL */ && i2 == s2.c.length) {\n    s2.c += (s1.t == 4 /* ARRAY */)?\n             caml_subarray_to_string(s1.c, i1, len):\n             (i1 == 0 && s1.c.length == len)?s1.c:s1.c.substr(i1, len);\n    s2.t = (s2.c.length == s2.l)?0 /* BYTES | UNKOWN */ :2; /* PARTIAL */\n  } else {\n    if (s2.t != 4 /* ARRAY */) caml_convert_string_to_array(s2);\n    var c1 = s1.c, c2 = s2.c;\n    if (s1.t == 4 /* ARRAY */) {\n        if (i2 <= i1) {\n          for (var i = 0; i < len; i++) c2 [i2 + i] = c1 [i1 + i];\n        } else {\n          for (var i = len - 1; i >= 0; i--) c2 [i2 + i] = c1 [i1 + i];\n        }\n   } else {\n      var l = Math.min (len, c1.length - i1);\n      for (var i = 0; i < l; i++) c2 [i2 + i] = c1.charCodeAt(i1 + i);\n      for (; i < len; i++) c2 [i2 + i] = 0;\n    }\n  }\n  return 0;\n}\n\n//Provides: caml_blit_bytes\n//Requires: caml_blit_string\nvar caml_blit_bytes = caml_blit_string\n\n//Provides: caml_ml_string_length const\nfunction caml_ml_string_length(s) { return s.l }\n\n//Provides: caml_ml_bytes_length const\nfunction caml_ml_bytes_length(s) { return s.l }\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_int64_offset\nvar caml_int64_offset = Math.pow(2, -24);\n\n//Provides: caml_int64_ucompare const\nfunction caml_int64_ucompare(x,y) {\n  if (x[3] > y[3]) return 1;\n  if (x[3] < y[3]) return -1;\n  if (x[2] > y[2]) return 1;\n  if (x[2] < y[2]) return -1;\n  if (x[1] > y[1]) return 1;\n  if (x[1] < y[1]) return -1;\n  return 0;\n}\n\n//Provides: caml_int64_ult const\n//Requires: caml_int64_ucompare\nfunction caml_int64_ult(x,y) { return caml_int64_ucompare(x,y) < 0; }\n\n//Provides: caml_int64_compare const\nfunction caml_int64_compare(x,y) {\n  var x3 = x[3] << 16;\n  var y3 = y[3] << 16;\n  if (x3 > y3) return 1;\n  if (x3 < y3) return -1;\n  if (x[2] > y[2]) return 1;\n  if (x[2] < y[2]) return -1;\n  if (x[1] > y[1]) return 1;\n  if (x[1] < y[1]) return -1;\n  return 0;\n}\n\n//Provides: caml_int64_neg const\nfunction caml_int64_neg (x) {\n  var y1 = - x[1];\n  var y2 = - x[2] + (y1 >> 24);\n  var y3 = - x[3] + (y2 >> 24);\n  return [255, y1 & 0xffffff, y2 & 0xffffff, y3 & 0xffff];\n}\n\n//Provides: caml_int64_add const\nfunction caml_int64_add (x, y) {\n  var z1 = x[1] + y[1];\n  var z2 = x[2] + y[2] + (z1 >> 24);\n  var z3 = x[3] + y[3] + (z2 >> 24);\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_sub const\nfunction caml_int64_sub (x, y) {\n  var z1 = x[1] - y[1];\n  var z2 = x[2] - y[2] + (z1 >> 24);\n  var z3 = x[3] - y[3] + (z2 >> 24);\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_mul const\n//Requires: caml_int64_offset\nfunction caml_int64_mul(x,y) {\n  var z1 = x[1] * y[1];\n  var z2 = ((z1 * caml_int64_offset) | 0) + x[2] * y[1] + x[1] * y[2];\n  var z3 = ((z2 * caml_int64_offset) | 0) + x[3] * y[1] + x[2] * y[2] + x[1] * y[3];\n  return [255, z1 & 0xffffff, z2 & 0xffffff, z3 & 0xffff];\n}\n\n//Provides: caml_int64_is_zero const\nfunction caml_int64_is_zero(x) {\n  return (x[3]|x[2]|x[1]) == 0;\n}\n\n//Provides: caml_int64_is_negative const\nfunction caml_int64_is_negative(x) {\n  return (x[3] << 16) < 0;\n}\n\n//Provides: caml_int64_is_min_int const\nfunction caml_int64_is_min_int(x) {\n  return x[3] == 0x8000 && (x[1]|x[2]) == 0;\n}\n\n//Provides: caml_int64_is_minus_one const\nfunction caml_int64_is_minus_one(x) {\n  return x[3] == 0xffff && (x[1]&x[2]) == 0xffffff;\n}\n\n//Provides: caml_int64_and const\nfunction caml_int64_and (x, y) {\n  return [255, x[1]&y[1], x[2]&y[2], x[3]&y[3]];\n}\n\n//Provides: caml_int64_or const\nfunction caml_int64_or (x, y) {\n  return [255, x[1]|y[1], x[2]|y[2], x[3]|y[3]];\n}\n\n//Provides: caml_int64_xor const\nfunction caml_int64_xor (x, y) {\n  return [255, x[1]^y[1], x[2]^y[2], x[3]^y[3]];\n}\n\n//Provides: caml_int64_shift_left const\nfunction caml_int64_shift_left (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  if (s < 24)\n    return [255,\n            (x[1] << s) & 0xffffff,\n            ((x[2] << s) | (x[1] >> (24 - s))) & 0xffffff,\n            ((x[3] << s) | (x[2] >> (24 - s))) & 0xffff];\n  if (s < 48)\n    return [255, 0,\n            (x[1] << (s - 24)) & 0xffffff,\n            ((x[2] << (s - 24)) | (x[1] >> (48 - s))) & 0xffff];\n  return [255, 0, 0, (x[1] << (s - 48)) & 0xffff];\n}\n\n//Provides: caml_int64_shift_right_unsigned const\nfunction caml_int64_shift_right_unsigned (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  if (s < 24)\n    return [255,\n            ((x[1] >> s) | (x[2] << (24 - s))) & 0xffffff,\n            ((x[2] >> s) | (x[3] << (24 - s))) & 0xffffff,\n            (x[3] >> s)];\n  if (s < 48)\n    return [255,\n            ((x[2] >> (s - 24)) | (x[3] << (48 - s))) & 0xffffff,\n            (x[3] >> (s - 24)),\n            0];\n  return [255, (x[3] >> (s - 48)), 0, 0];\n}\n\n//Provides: caml_int64_shift_right const\nfunction caml_int64_shift_right (x, s) {\n  s = s & 63;\n  if (s == 0) return x;\n  var h = (x[3] << 16) >> 16;\n  if (s < 24)\n    return [255,\n            ((x[1] >> s) | (x[2] << (24 - s))) & 0xffffff,\n            ((x[2] >> s) | (h << (24 - s))) & 0xffffff,\n            ((x[3] << 16) >> s) >>> 16];\n  var sign = (x[3] << 16) >> 31;\n  if (s < 48)\n    return [255,\n            ((x[2] >> (s - 24)) | (x[3] << (48 - s))) & 0xffffff,\n            ((x[3] << 16) >> (s - 24) >> 16) & 0xffffff,\n            sign & 0xffff];\n  return [255,\n          ((x[3] << 16) >> (s - 32)) & 0xffffff,\n          sign & 0xffffff, sign & 0xffff];\n}\n\n//Provides: caml_int64_lsl1 const\nfunction caml_int64_lsl1 (x) {\n  x[3] = (x[3] << 1) | (x[2] >> 23);\n  x[2] = ((x[2] << 1) | (x[1] >> 23)) & 0xffffff;\n  x[1] = (x[1] << 1) & 0xffffff;\n}\n\n//Provides: caml_int64_lsr1 const\nfunction caml_int64_lsr1 (x) {\n  x[1] = ((x[1] >>> 1) | (x[2] << 23)) & 0xffffff;\n  x[2] = ((x[2] >>> 1) | (x[3] << 23)) & 0xffffff;\n  x[3] = x[3] >>> 1;\n}\n\n//Provides: caml_int64_udivmod const\n//Requires: caml_int64_ucompare, caml_int64_lsl1, caml_int64_lsr1\n//Requires: caml_int64_sub\n//Requires: caml_obj_dup\nfunction caml_int64_udivmod (x, y) {\n  var offset = 0;\n  var modulus = caml_obj_dup(x);\n  var divisor = caml_obj_dup(y);\n  var quotient = [255, 0, 0, 0];\n  while (caml_int64_ucompare (modulus, divisor) > 0) {\n    offset++;\n    caml_int64_lsl1 (divisor);\n  }\n  while (offset >= 0) {\n    offset --;\n    caml_int64_lsl1 (quotient);\n    if (caml_int64_ucompare (modulus, divisor) >= 0) {\n      quotient[1] ++;\n      modulus = caml_int64_sub (modulus, divisor);\n    }\n    caml_int64_lsr1 (divisor);\n  }\n  return [0,quotient, modulus];\n}\n\n//Provides: caml_int64_div const\n//Requires: caml_int64_is_zero, caml_raise_zero_divide\n//Requires: caml_int64_neg, caml_int64_udivmod\nfunction caml_int64_div (x, y)\n{\n  if (caml_int64_is_zero (y)) caml_raise_zero_divide ();\n  var sign = x[3] ^ y[3];\n  if (x[3] & 0x8000) x = caml_int64_neg(x);\n  if (y[3] & 0x8000) y = caml_int64_neg(y);\n  var q = caml_int64_udivmod(x, y)[1];\n  if (sign & 0x8000) q = caml_int64_neg(q);\n  return q;\n}\n\n//Provides: caml_int64_mod const\n//Requires: caml_int64_is_zero, caml_raise_zero_divide\n//Requires: caml_int64_neg, caml_int64_udivmod\nfunction caml_int64_mod (x, y)\n{\n  if (caml_int64_is_zero (y)) caml_raise_zero_divide ();\n  var sign = x[3];\n  if (x[3] & 0x8000) x = caml_int64_neg(x);\n  if (y[3] & 0x8000) y = caml_int64_neg(y);\n  var r = caml_int64_udivmod(x, y)[2];\n  if (sign & 0x8000) r = caml_int64_neg(r);\n  return r;\n}\n\n//Provides: caml_int64_of_int32 const\nfunction caml_int64_of_int32 (x) {\n  return [255, x & 0xffffff, (x >> 24) & 0xffffff, (x >> 31) & 0xffff]\n}\n\n//Provides: caml_int64_to_int32 const\nfunction caml_int64_to_int32 (x) {\n  return x[1] | (x[2] << 24);\n}\n\n//Provides: caml_int64_to_float const\nfunction caml_int64_to_float (x) {\n  return ((x[3] << 16) * Math.pow(2, 32) + x[2] * Math.pow(2, 24)) + x[1];\n}\n\n//Provides: caml_int64_of_float const\n//Requires: caml_int64_offset\nfunction caml_int64_of_float (x) {\n  if (x < 0) x = Math.ceil(x);\n  return [255,\n          x & 0xffffff,\n          Math.floor(x * caml_int64_offset) & 0xffffff,\n          Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff];\n}\n\n//Provides: caml_int64_format const\n//Requires: caml_parse_format, caml_finish_formatting\n//Requires: caml_int64_is_negative, caml_int64_neg\n//Requires: caml_int64_of_int32, caml_int64_udivmod, caml_int64_to_int32\n//Requires: caml_int64_is_zero, caml_str_repeat\nfunction caml_int64_format (fmt, x) {\n  var f = caml_parse_format(fmt);\n  if (f.signedconv && caml_int64_is_negative(x)) {\n    f.sign = -1; x = caml_int64_neg(x);\n  }\n  var buffer = \"\";\n  var wbase = caml_int64_of_int32(f.base);\n  var cvtbl = \"0123456789abcdef\";\n  do {\n    var p = caml_int64_udivmod(x, wbase);\n    x = p[1];\n    buffer = cvtbl.charAt(caml_int64_to_int32(p[2])) + buffer;\n  } while (! caml_int64_is_zero(x));\n  if (f.prec >= 0) {\n    f.filler = ' ';\n    var n = f.prec - buffer.length;\n    if (n > 0) buffer = caml_str_repeat (n, '0') + buffer;\n  }\n  return caml_finish_formatting(f, buffer);\n}\n\n//Provides: caml_int64_of_string\n//Requires: caml_parse_sign_and_base, caml_failwith, caml_parse_digit, MlString\n//Requires: caml_int64_of_int32, caml_int64_udivmod, caml_int64_ult\n//Requires: caml_int64_add, caml_int64_mul, caml_int64_neg\n//Requires: caml_ml_string_length,caml_string_unsafe_get\nfunction caml_int64_of_string(s) {\n  var r = caml_parse_sign_and_base (s);\n  var i = r[0], sign = r[1], base = r[2];\n  var base64 = caml_int64_of_int32(base);\n  var threshold =\n    caml_int64_udivmod([255, 0xffffff, 0xfffffff, 0xffff], base64)[1];\n  var c = caml_string_unsafe_get(s, i);\n  var d = caml_parse_digit(c);\n  if (d < 0 || d >= base) caml_failwith(\"int_of_string\");\n  var res = caml_int64_of_int32(d);\n  for (;;) {\n    i++;\n    c = caml_string_unsafe_get(s, i);\n    if (c == 95) continue;\n    d = caml_parse_digit(c);\n    if (d < 0 || d >= base) break;\n    /* Detect overflow in multiplication base * res */\n    if (caml_int64_ult(threshold, res)) caml_failwith(\"int_of_string\");\n    d = caml_int64_of_int32(d);\n    res = caml_int64_add(caml_int64_mul(base64, res), d);\n    /* Detect overflow in addition (base * res) + d */\n    if (caml_int64_ult(res, d)) caml_failwith(\"int_of_string\");\n  }\n  if (i != caml_ml_string_length(s)) caml_failwith(\"int_of_string\");\n  if (r[2] == 10 && caml_int64_ult([255, 0, 0, 0x8000], res))\n    caml_failwith(\"int_of_string\");\n  if (sign < 0) res = caml_int64_neg(res);\n  return res;\n}\n\n//Provides: caml_int64_of_bytes\nfunction caml_int64_of_bytes(a) {\n  return [255, a[7] | (a[6] << 8) | (a[5] << 16),\n          a[4] | (a[3] << 8) | (a[2] << 16), a[1] | (a[0] << 8)];\n}\n//Provides: caml_int64_to_bytes\nfunction caml_int64_to_bytes(x) {\n  return [x[3] >> 8, x[3] & 0xff, x[2] >> 16, (x[2] >> 8) & 0xff, x[2] & 0xff,\n          x[1] >> 16, (x[1] >> 8) & 0xff, x[1] & 0xff];\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: jsoo_floor_log2\nvar log2_ok = Math.log2 && Math.log2(1.1235582092889474E+307) == 1020\nfunction jsoo_floor_log2(x) {\n    if(log2_ok) return Math.floor(Math.log2(x))\n    var i = 0;\n    if (x == 0) return -Infinity;\n    if(x>=1) {while (x>=2) {x/=2; i++} }\n    else {while (x < 1) {x*=2; i--} };\n    return i;\n}\n\n//Provides: caml_int64_bits_of_float const\n//Requires: jsoo_floor_log2\nfunction caml_int64_bits_of_float (x) {\n  if (!isFinite(x)) {\n    if (isNaN(x)) return [255, 1, 0, 0x7ff0];\n    return (x > 0)?[255,0,0,0x7ff0]:[255,0,0,0xfff0];\n  }\n  var sign = (x==0 && 1/x == -Infinity)?0x8000:(x>=0)?0:0x8000;\n  if (sign) x = -x;\n  // Int64.bits_of_float 1.1235582092889474E+307 = 0x7fb0000000000000L\n  // using Math.LOG2E*Math.log(x) in place of Math.log2 result in precision lost\n  var exp = jsoo_floor_log2(x) + 1023;\n  if (exp <= 0) {\n    exp = 0;\n    x /= Math.pow(2,-1026);\n  } else {\n    x /= Math.pow(2,exp-1027);\n    if (x < 16) {\n      x *= 2; exp -=1; }\n    if (exp == 0) {\n      x /= 2; }\n  }\n  var k = Math.pow(2,24);\n  var r3 = x|0;\n  x = (x - r3) * k;\n  var r2 = x|0;\n  x = (x - r2) * k;\n  var r1 = x|0;\n  r3 = (r3 &0xf) | sign | exp << 4;\n  return [255, r1, r2, r3];\n}\n\n//Provides: caml_int32_bits_of_float const\n//Requires: jsoo_floor_log2\nfunction caml_int32_bits_of_float (x) {\n  var float32a = new joo_global_object.Float32Array(1);\n  float32a[0] = x;\n  var int32a = new joo_global_object.Int32Array(float32a.buffer);\n  return int32a[0] | 0;\n}\n\n//FP literals can be written using the hexadecimal\n//notation 0x<mantissa in hex>p<exponent> from ISO C99.\n//https://github.com/dankogai/js-hexfloat/blob/master/hexfloat.js\n//Provides: caml_hexstring_of_float const\n//Requires: caml_js_to_string, caml_str_repeat\nfunction caml_hexstring_of_float (x, prec, style) {\n  if (!isFinite(x)) {\n    if (isNaN(x)) return caml_js_to_string(\"nan\");\n    return caml_js_to_string ((x > 0)?\"infinity\":\"-infinity\");\n  }\n  var sign = (x==0 && 1/x == -Infinity)?1:(x>=0)?0:1;\n  if(sign) x = -x;\n  var exp = 0;\n  if (x == 0) { }\n  else if (x < 1) {\n    while (x < 1 && exp > -1022)  { x *= 2; exp-- }\n  } else {\n    while (x >= 2) { x /= 2; exp++ }\n  }\n  var exp_sign = exp < 0 ? '' : '+';\n  var sign_str = '';\n  if (sign) sign_str = '-'\n  else {\n    switch(style){\n    case 43 /* '+' */: sign_str = '+'; break;\n    case 32 /* ' ' */: sign_str = ' '; break;\n    default: break;\n    }\n  }\n  if (prec >= 0 && prec < 13) {\n    /* If a precision is given, and is small, round mantissa accordingly */\n      var cst = Math.pow(2,prec * 4);\n      x = Math.round(x * cst) / cst;\n  }\n  var x_str = x.toString(16);\n  if(prec >= 0){\n      var idx = x_str.indexOf('.');\n    if(idx<0) {\n      x_str += '.' + caml_str_repeat(prec, '0');\n    }\n    else {\n      var size = idx+1+prec;\n      if(x_str.length < size)\n        x_str += caml_str_repeat(size - x_str.length, '0');\n      else\n        x_str = x_str.substr(0,size);\n    }\n  }\n  return caml_js_to_string (sign_str + '0x' + x_str + 'p' + exp_sign + exp.toString(10));\n}\n\n//Provides: caml_int64_float_of_bits const\nfunction caml_int64_float_of_bits (x) {\n  var exp = (x[3] & 0x7fff) >> 4;\n  if (exp == 2047) {\n      if ((x[1]|x[2]|(x[3]&0xf)) == 0)\n        return (x[3] & 0x8000)?(-Infinity):Infinity;\n      else\n        return NaN;\n  }\n  var k = Math.pow(2,-24);\n  var res = (x[1]*k+x[2])*k+(x[3]&0xf);\n  if (exp > 0) {\n    res += 16;\n    res *= Math.pow(2,exp-1027);\n  } else\n    res *= Math.pow(2,-1026);\n  if (x[3] & 0x8000) res = - res;\n  return res;\n}\n\n//Provides: caml_int32_float_of_bits const\nfunction caml_int32_float_of_bits (x) {\n  var int32a = new joo_global_object.Int32Array(1);\n  int32a[0] = x;\n  var float32a = new joo_global_object.Float32Array(int32a.buffer);\n  return float32a[0];\n}\n\n//Provides: caml_classify_float const\nfunction caml_classify_float (x) {\n  if (isFinite (x)) {\n    if (Math.abs(x) >= 2.2250738585072014e-308) return 0;\n    if (x != 0) return 1;\n    return 2;\n  }\n  return isNaN(x)?4:3;\n}\n//Provides: caml_modf_float const\nfunction caml_modf_float (x) {\n  if (isFinite (x)) {\n    var neg = (1/x) < 0;\n    x = Math.abs(x);\n    var i = Math.floor (x);\n    var f = x - i;\n    if (neg) { i = -i; f = -f; }\n    return [0, f, i];\n  }\n  if (isNaN (x)) return [0, NaN, NaN];\n  return [0, 1/x, x];\n}\n//Provides: caml_ldexp_float const\nfunction caml_ldexp_float (x,exp) {\n  exp |= 0;\n  if (exp > 1023) {\n    exp -= 1023;\n    x *= Math.pow(2, 1023);\n    if (exp > 1023) {  // in case x is subnormal\n      exp -= 1023;\n      x *= Math.pow(2, 1023);\n    }\n  }\n  if (exp < -1023) {\n    exp += 1023;\n    x *= Math.pow(2, -1023);\n  }\n  x *= Math.pow(2, exp);\n  return x;\n}\n//Provides: caml_frexp_float const\n//Requires: jsoo_floor_log2\nfunction caml_frexp_float (x) {\n  if ((x == 0) || !isFinite(x)) return [0, x, 0];\n  var neg = x < 0;\n  if (neg) x = - x;\n  var exp = jsoo_floor_log2(x) + 1;\n  x *= Math.pow(2,-exp);\n  if (x < 0.5) { x *= 2; exp -= 1; }\n  if (neg) x = - x;\n  return [0, x, exp];\n}\n\n//Provides: caml_float_compare const\nfunction caml_float_compare (x, y) {\n  if (x === y) return 0;\n  if (x < y) return -1;\n  if (x > y) return 1;\n  if (x === x) return 1;\n  if (y === y) return -1;\n  return 0;\n}\n\n//Provides: caml_copysign_float const\nfunction caml_copysign_float (x, y) {\n  if (y == 0) y = 1 / y;\n  x = Math.abs(x);\n  return (y < 0)?(-x):x;\n}\n\n//Provides: caml_expm1_float const\nfunction caml_expm1_float (x) {\n  var y = Math.exp(x), z = y - 1;\n  return (Math.abs(x)>1?z:(z==0?x:x*z/Math.log(y)));\n}\n\n//Provides: caml_log1p_float const\nfunction caml_log1p_float (x) {\n  var y = 1 + x, z = y - 1;\n  return (z==0?x:x*Math.log(y)/z);\n}\n\n//Provides: caml_hypot_float const\nfunction caml_hypot_float (x, y) {\n  var x = Math.abs(x), y = Math.abs(y);\n  var a = Math.max(x, y), b = Math.min(x,y) / (a?a:1);\n  return (a * Math.sqrt(1 + b*b));\n}\n\n// FIX: these five functions only give approximate results.\n//Provides: caml_log10_float const\nfunction caml_log10_float (x) { return Math.LOG10E * Math.log(x); }\n//Provides: caml_cosh_float const\nfunction caml_cosh_float (x) { return (Math.exp(x) + Math.exp(-x)) / 2; }\n//Provides: caml_sinh_float const\nfunction caml_sinh_float (x) { return (Math.exp(x) - Math.exp(-x)) / 2; }\n//Provides: caml_tanh_float const\nfunction caml_tanh_float (x) {\n  var y = Math.exp(x), z = Math.exp(-x);\n  return (y - z) / (y + z);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Dummy filesystem\n\n//Provides: caml_current_dir\nif(joo_global_object.process && joo_global_object.process.cwd)\n  var caml_current_dir = joo_global_object.process.cwd();\nelse\n  var caml_current_dir =  \"/static\";\nif(caml_current_dir.slice(-1) !== \"/\") caml_current_dir += \"/\"\n//Provides: MlFile\nfunction MlFile(){  }\n\n//Provides: caml_make_path\n//Requires: caml_current_dir,MlString\nfunction caml_make_path (name) {\n  name=(name instanceof MlString)?name.toString():name;\n  if(name.charCodeAt(0) != 47)\n    name = caml_current_dir + name;\n  var comp = name.split(\"/\");\n  var ncomp = []\n  for(var i = 0; i<comp.length; i++){\n    switch(comp[i]){\n    case \"..\": if(ncomp.length>1) ncomp.pop(); break;\n    case \".\": break;\n    case \"\": if(ncomp.length == 0) ncomp.push(\"\"); break;\n    default: ncomp.push(comp[i]);break\n    }\n  }\n  ncomp.orig = name;\n  return ncomp;\n}\n\n//Provides:jsoo_mount_point\n//Requires: MlFakeDevice, MlNodeDevice\nvar jsoo_mount_point = []\nif (typeof require == \"undefined\") {\n    jsoo_mount_point.push({path:\"/\",device:new MlFakeDevice(\"/\")});\n} else {\n    jsoo_mount_point.push({path:\"/\",device:new MlNodeDevice(\"/\")});\n}\njsoo_mount_point.push({path:\"/static/\", device:new MlFakeDevice(\"/static/\")});\n\n//Provides:caml_list_mount_point\n//Requires: jsoo_mount_point, caml_new_string\nfunction caml_list_mount_point(){\n    var prev = 0\n    for(var i = 0; i < jsoo_mount_point.length; i++){\n        var old = prev;\n        prev = [0, caml_new_string(jsoo_mount_point[i].path), old]\n    }\n    return prev;\n}\n\n//Provides: resolve_fs_device\n//Requires: caml_make_path, jsoo_mount_point\nfunction resolve_fs_device(name){\n  var path = caml_make_path(name);\n  var name = path.join(\"/\");\n  var name_slash = name + \"/\";\n  var res;\n  for(var i = 0; i < jsoo_mount_point.length; i++) {\n    var m = jsoo_mount_point[i];\n    if(name_slash.search(m.path) == 0\n       && (!res || res.path.length < m.path.length))\n        res = {path:m.path,device:m.device,rest:name.substring(m.path.length,name.length)};\n  }\n  return res;\n}\n\n//Provides: caml_mount_autoload\n//Requires: MlFakeDevice, caml_make_path, jsoo_mount_point\nfunction caml_mount_autoload(name,f){\n  var path = caml_make_path(name);\n  var name = path.join(\"/\") + \"/\";\n  jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)})\n  return 0;\n}\n\n//Provides: caml_unmount\n//Requires: jsoo_mount_point, caml_make_path\nfunction caml_unmount(name){\n  var path = caml_make_path(name);\n  var name = path.join(\"/\") + \"/\";\n  var idx = -1;\n  for(var i = 0; i < jsoo_mount_point.length; i++)\n    if(jsoo_mount_point[i].path == name) idx = i;\n  if(idx > -1) jsoo_mount_point.splice(idx,1);\n  return 0\n}\n\n//Provides: caml_sys_getcwd\n//Requires: caml_current_dir, caml_new_string\nfunction caml_sys_getcwd() {\n  return caml_new_string(caml_current_dir);\n}\n\n//Provides: caml_sys_chdir\n//Requires: caml_current_dir, caml_raise_no_such_file, resolve_fs_device\nfunction caml_sys_chdir(dir) {\n  var root = resolve_fs_device(dir);\n  if(root.device.exists(root.rest)) {\n    caml_current_dir = root.base + dir.rest + \"/\"\n    return 0;\n  }\n  else {\n    caml_raise_no_such_file(dir);\n  }\n}\n\n//Provides: caml_raise_no_such_file\n//Requires: MlString, caml_raise_sys_error\nfunction caml_raise_no_such_file(name){\n  name = (name instanceof MlString)?name.toString():name;\n  caml_raise_sys_error (name + \": No such file or directory\");\n}\n\n//Provides: caml_raise_not_a_dir\n//Requires: MlString, caml_raise_sys_error\nfunction caml_raise_not_a_dir(name){\n  name = (name instanceof MlString)?name.toString():name;\n  caml_raise_sys_error (name + \": Not a directory\");\n}\n\n//Provides: caml_sys_file_exists\n//Requires: resolve_fs_device\nfunction caml_sys_file_exists (name) {\n  var root = resolve_fs_device(name);\n  return root.device.exists(root.rest);\n}\n\n//Provides: caml_sys_read_directory\n//Requires: caml_new_string\n//Requires: caml_raise_not_a_dir, resolve_fs_device\nfunction caml_sys_read_directory(name){\n  var root = resolve_fs_device(name);\n  var a = root.device.readdir(root.rest);\n  var l = new Array(a.length + 1);\n  l[0] = 0;\n  for(var i=0;i<a.length;i++)\n    l[i+1] = caml_new_string(a[i]);\n  return l;\n}\n\n//Provides: caml_sys_remove\n//Requires: caml_raise_no_such_file, resolve_fs_device\nfunction caml_sys_remove(name){\n  var root = resolve_fs_device(name);\n  var ok = root.device.unlink(root.rest);\n  if(ok == 0) caml_raise_no_such_file(name);\n  return 0;\n}\n\n//Provides: caml_sys_is_directory\n//Requires: resolve_fs_device\nfunction caml_sys_is_directory(name){\n  var root = resolve_fs_device(name);\n  var a = root.device.is_dir(root.rest);\n  return a?1:0;\n}\n\n//Provides: caml_sys_rename\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_sys_rename(o,n){\n  var o_root = resolve_fs_device(o);\n  var n_root = resolve_fs_device(n);\n  if(o_root.device != n_root.device)\n    caml_failwith(\"caml_sys_rename: cannot move file between two filesystem\");\n  if(!o_root.device.rename)\n    caml_failwith(\"caml_sys_rename: no implemented\");\n  o_root.device.rename(o_root.rest, n_root.rest);\n}\n\n\n//Provides: caml_ba_map_file\n//Requires: caml_failwith\nfunction caml_ba_map_file(vfd, kind, layout, shared, dims, pos) {\n  // var data = caml_global_data.fds[vfd];\n  caml_failwith(\"caml_ba_map_file not implemented\");\n}\n\n//Provides: caml_ba_map_file_bytecode\n//Requires: caml_ba_map_file\nfunction caml_ba_map_file_bytecode(argv,argn){\n  return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5]);\n}\n\n//Provides: caml_create_file_extern\nfunction caml_create_file_extern(name,content){\n  if(joo_global_object.caml_create_file)\n    joo_global_object.caml_create_file(name,content);\n  else {\n    if(!joo_global_object.caml_fs_tmp) joo_global_object.caml_fs_tmp = [];\n    joo_global_object.caml_fs_tmp.push({name:name,content:content});\n  }\n  return 0;\n}\n\n//Provides: caml_fs_init\n//Requires: caml_create_file\nfunction caml_fs_init (){\n  var tmp=joo_global_object.caml_fs_tmp\n  if(tmp){\n    for(var i = 0; i < tmp.length; i++){\n      caml_create_file(tmp[i].name,tmp[i].content);\n    }\n  }\n  joo_global_object.caml_create_file = caml_create_file;\n  return 0;\n}\n\n//Provides: caml_create_file\n//Requires: caml_failwith, resolve_fs_device\nfunction caml_create_file(name,content) {\n  var root = resolve_fs_device(name);\n  if(! root.device.register) caml_failwith(\"cannot register file\");\n  root.device.register(root.rest,content);\n  return 0;\n}\n\n//Provides: caml_read_file_content\n//Requires: resolve_fs_device, caml_raise_no_such_file, caml_create_string\nfunction caml_read_file_content (name) {\n  var root = resolve_fs_device(name);\n  if(root.device.exists(root.rest)) {\n    var file = root.device.open(root.rest,{rdonly:1});\n    var len  = file.length();\n    var buf  = caml_create_string(len);\n    file.read(0,buf,0,len);\n    return buf\n  }\n  caml_raise_no_such_file(name);\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: MlFakeDevice\n//Requires: MlFakeFile, caml_create_string\n//Requires: caml_raise_sys_error, caml_raise_no_such_file, caml_new_string, caml_string_of_array\n//Requires: MlString\nfunction MlFakeDevice (root, f) {\n  this.content={};\n  this.root = root;\n  this.lookupFun = f;\n}\nMlFakeDevice.prototype.nm = function(name) {\n  return (this.root + name);\n}\nMlFakeDevice.prototype.lookup = function(name) {\n  if(!this.content[name] && this.lookupFun) {\n    var res = this.lookupFun(caml_new_string(this.root), caml_new_string(name));\n    if(res != 0) this.content[name]=new MlFakeFile(res[1]);\n  }    \n}\nMlFakeDevice.prototype.exists = function(name) {\n  this.lookup(name);\n  return this.content[name]?1:0;\n}\nMlFakeDevice.prototype.readdir = function(name) {\n  var name_slash = (name == \"\")?\"\":(name + \"/\");\n  var r = new RegExp(\"^\" + name_slash + \"([^/]*)\");\n  var seen = {}\n  var a = [];\n  for(var n in this.content) {\n    var m = n.match(r);\n    if(m && !seen[m[1]]) {seen[m[1]] = true; a.push(m[1])}\n  }\n  return a;\n}\nMlFakeDevice.prototype.is_dir = function(name) {\n  var name_slash = (name == \"\")?\"\":(name + \"/\");\n  var r = new RegExp(\"^\" + name_slash + \"([^/]*)\");\n  var a = [];\n  for(var n in this.content) {\n    var m = n.match(r);\n    if(m) return 1\n  }\n  return 0\n}\nMlFakeDevice.prototype.unlink = function(name) {\n  var ok = this.content[name]?true:false;\n  delete this.content[name];\n  return ok;\n}\nMlFakeDevice.prototype.open = function(name, f) {\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(this.nm(name) + \" : flags Open_text and Open_binary are not compatible\");\n  this.lookup(name);\n  if (this.content[name]) {\n    if (this.is_dir(name)) caml_raise_sys_error(this.nm(name) + \" : is a directory\");\n    if (f.create && f.excl) caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n    var file = this.content[name];\n    if(f.truncate) file.truncate();\n    return file;\n  } else if (f.create) {\n    this.content[name] = new MlFakeFile(caml_create_string(0));\n    return this.content[name];\n  } else {\n    caml_raise_no_such_file (this.nm(name));\n  }\n}\n\nMlFakeDevice.prototype.register= function (name,content){\n  if(this.content[name]) caml_raise_sys_error(this.nm(name) + \" : file already exists\");\n  if(content instanceof MlString)\n    this.content[name] = new MlFakeFile(content);\n  else if(content instanceof Array)\n    this.content[name] = new MlFakeFile(caml_string_of_array(content));\n  else if(content.toString) {\n    var mlstring = caml_new_string(content.toString());\n    this.content[name] = new MlFakeFile(mlstring);\n  }\n}\n\nMlFakeDevice.prototype.constructor = MlFakeDevice\n\n//Provides: MlFakeFile\n//Requires: MlFile\n//Requires: caml_create_string, caml_ml_string_length,caml_blit_string\n//Requires: caml_string_get\nfunction MlFakeFile(content){\n  this.data = content;\n}\nMlFakeFile.prototype = new MlFile ();\nMlFakeFile.prototype.truncate = function(len){\n  var old = this.data;\n  this.data = caml_create_string(len|0);\n  caml_blit_string(old, 0, this.data, 0, len);\n}\nMlFakeFile.prototype.length = function () {\n  return caml_ml_string_length(this.data);\n}\nMlFakeFile.prototype.write = function(offset,buf,pos,len){\n  var clen = this.length();\n  if(offset + len >= clen) {\n    var new_str = caml_create_string(offset + len);\n    var old_data = this.data;\n    this.data = new_str;\n    caml_blit_string(old_data, 0, this.data, 0, clen);\n  }\n  caml_blit_string(buf, pos, this.data, offset, len);\n  return 0\n}\nMlFakeFile.prototype.read = function(offset,buf,pos,len){\n  var clen = this.length();\n  caml_blit_string(this.data, offset, buf, pos, len);\n  return 0\n}\nMlFakeFile.prototype.read_one = function(offset){\n  return caml_string_get(this.data, offset);\n}\nMlFakeFile.prototype.close = function(){\n\n}\nMlFakeFile.prototype.constructor = MlFakeFile\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: MlNodeDevice\n//Requires: MlNodeFile\nfunction MlNodeDevice(root) {\n  this.fs = require('fs');\n  this.root = root;\n}\nMlNodeDevice.prototype.nm = function(name) {\n  return (this.root + name);\n}\nMlNodeDevice.prototype.exists = function(name) {\n  return this.fs.existsSync(this.nm(name))?1:0;\n}\nMlNodeDevice.prototype.readdir = function(name) {\n  return this.fs.readdirSync(this.nm(name));\n}\nMlNodeDevice.prototype.is_dir = function(name) {\n  return this.fs.statSync(this.nm(name)).isDirectory()?1:0;\n}\nMlNodeDevice.prototype.unlink = function(name) {\n  var b = this.fs.existsSync(this.nm(name))?1:0;\n  this.fs.unlinkSync(this.nm(name));\n  return b\n}\nMlNodeDevice.prototype.open = function(name, f) {\n  var consts = require('constants');\n  var res = 0;\n  for(var key in f){\n    switch(key){\n    case \"rdonly\"  : res |= consts.O_RDONLY; break;\n    case \"wronly\"  : res |= consts.O_WRONLY; break;\n    case \"append\"  :\n      res |= consts.O_WRONLY | consts.O_APPEND;\n      break;\n    case \"create\"   : res |= consts.O_CREAT;    break;\n    case \"truncate\" : res |= consts.O_TRUNC;    break;\n    case \"excl\"     : res |= consts.O_EXCL;     break;\n    case \"binary\"   : res |= consts.O_BINARY;   break;\n    case \"text\"     : res |= consts.O_TEXT;     break;\n    case \"nonblock\" : res |= consts.O_NONBLOCK; break;\n    }\n  }\n  var fd = this.fs.openSync(this.nm(name), res);\n  return new MlNodeFile(fd);\n}\n\nMlNodeDevice.prototype.rename = function(o,n) {\n  this.fs.renameSync(this.nm(o), this.nm(n));\n}\n\nMlNodeDevice.prototype.constructor = MlNodeDevice\n\n//Provides: MlNodeFile\n//Requires: MlFile, caml_array_of_string, caml_string_get, caml_string_set\n\nvar Buffer = joo_global_object.Buffer\n\nfunction MlNodeFile(fd){\n  this.fs = require('fs');\n  this.fd = fd;\n}\nMlNodeFile.prototype = new MlFile ();\n\nMlNodeFile.prototype.truncate = function(len){\n  this.fs.ftruncateSync(this.fd,len|0)\n}\nMlNodeFile.prototype.length = function () {\n  return this.fs.fstatSync(this.fd).size;\n}\nMlNodeFile.prototype.write = function(offset,buf,buf_offset,len){\n  var a = caml_array_of_string(buf);\n  if(! a instanceof joo_global_object.Uint8Array)\n    a = new joo_global_object.Uint8Array(a);\n  var buffer = new Buffer (a);\n  this.fs.writeSync(this.fd, buffer, buf_offset, len, offset);\n  return 0;\n}\nMlNodeFile.prototype.read = function(offset,buf,buf_offset,len){\n  var a = caml_array_of_string(buf);\n  if(! (a instanceof joo_global_object.Uint8Array))\n    a = new joo_global_object.Uint8Array(a);\n  var buffer = new Buffer(a);\n  this.fs.readSync(this.fd, buffer, buf_offset, len, offset);\n  for(var i = 0; i < len; i++){\n    caml_string_set(buf,buf_offset + i,buffer[buf_offset+i]);\n  }\n  return 0\n}\nMlNodeFile.prototype.read_one = function(offset){\n  var a = new joo_global_object.Uint8Array(1);\n  var buffer = new Buffer(a);\n  this.fs.readSync(this.fd, buffer, 0, 1, offset);\n  return buffer[0];\n}\nMlNodeFile.prototype.close = function(){\n  this.fs.closeSync(this.fd);\n}\n\nMlNodeFile.prototype.constructor = MlNodeFile;\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard, Andy Ray\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n//\n// Bigarray.\n//\n// - all bigarray types including Int64 and Complex.\n// - fortran + c layouts\n// - sub/slice/reshape\n// - retain fast path for 1d array access\n//\n// Note; int64+complex support if provided by allocating a second TypedArray\n// Note; accessor functions are selected when the bigarray is created.  It is assumed\n//       that this results in just a function pointer and will thus be fast.\n\n//Provides: caml_ba_init const\nfunction caml_ba_init() {\n    return 0;\n}\n\n//Provides: caml_ba_init_views\n//Requires: caml_ba_views\nfunction caml_ba_init_views() {\n    if (!caml_ba_views) {\n        var g = joo_global_object;\n        caml_ba_views = [\n            [\n                g.Float32Array, g.Float64Array, g.Int8Array, g.Uint8Array,\n                g.Int16Array, g.Uint16Array, g.Int32Array, g.Int32Array,\n                g.Int32Array, g.Int32Array, g.Float32Array, g.Float64Array, g.Uint8Array],\n            [\n                0 /* General */, 0 /* General */, 0 /* General */, 0 /* General */,\n                0 /* General */, 0 /* General */, 0 /* General */, 1 /* Int64 */,\n                0 /* General */, 0 /* General */, 2 /* Complex */, 2 /* Complex */, 0 /* General */]\n        ];\n    }\n}\n\n//Provides: caml_ba_get_size\n//Requires: caml_invalid_argument\nfunction caml_ba_get_size(dims) {\n    var n_dims = dims.length;\n    var size = 1;\n    for (var i = 0; i < n_dims; i++) {\n        if (dims[i] < 0)\n            caml_invalid_argument(\"Bigarray.create: negative dimension\");\n        size = size * dims[i];\n    }\n    return size;\n}\n\n//Provides: caml_ba_views\nvar caml_ba_views;\n\n//Provides: caml_ba_create_from\n//Requires: caml_ba_get_size\n//Requires: caml_invalid_argument\n//Requires: caml_array_bound_error\nfunction caml_ba_create_from(data, data2, data_type, kind, layout, dims) {\n    var n_dims = dims.length;\n    var size = caml_ba_get_size(dims);\n\n    //\n    // Functions to compute the offsets for C or Fortran layout arrays\n    // from the given array of indices.\n    //\n    function offset_c(index) {\n        var ofs = 0;\n        if (n_dims != index.length)\n            caml_invalid_argument(\"Bigarray.get/set: bad number of dimensions\");\n        for (var i = 0; i < n_dims; i++) {\n            if (index[i] < 0 || index[i] >= dims[i])\n                caml_array_bound_error();\n            ofs = (ofs * dims[i]) + index[i];\n        }\n        return ofs;\n    }\n\n    function offset_fortran(index) {\n        var ofs = 0;\n        if (n_dims != index.length)\n            caml_invalid_argument(\"Bigarray.get/set: wrong number of indices\");\n        for (var i = n_dims - 1; i >= 0; i--) {\n            if (index[i] < 1 || index[i] > dims[i])\n                caml_array_bound_error();\n            ofs = (ofs * dims[i]) + (index[i] - 1);\n        }\n        return ofs;\n    }\n\n    var offset = layout == 0 ? offset_c : offset_fortran;\n\n    var dim0 = dims[0];\n\n    //\n    // Element get functions.\n    //\n    function get_std(index) {\n        var ofs = offset(index);\n        var v = data[ofs];\n        return v;\n    }\n\n    function get_int64(index) {\n        var off = offset(index);\n        var l = data[off];\n        var h = data2[off];\n        return [\n            255,\n            l & 0xffffff,\n            ((l >>> 24) & 0xff) | ((h & 0xffff) << 8),\n            (h >>> 16) & 0xffff];\n    }\n\n    function get_complex(index) {\n        var off = offset(index);\n        var r = data[off];\n        var i = data2[off];\n        return [254, r, i];\n    }\n\n    var get = data_type == 1 /* Int64 */ ? get_int64 : (data_type == 2 /* Complex */ ? get_complex : get_std);\n\n    function get1_c(i) {\n        if (i < 0 || i >= dim0)\n            caml_array_bound_error();\n        return data[i];\n    }\n    function get1_fortran(i) {\n        if (i < 1 || i > dim0)\n            caml_array_bound_error();\n        return data[i - 1];\n    }\n    function get1_any(i) {\n        return get([i]);\n    }\n\n    var get1 = data_type == 0 /* General */ ? (layout == 0 ? get1_c : get1_fortran) : get1_any;\n\n    //\n    // Element set functions\n    //\n    function set_std_raw(off, v) {\n        data[off] = v;\n    }\n\n    function set_int64_raw(off, v) {\n        data[off] = v[1] | ((v[2] & 0xff) << 24);\n        data2[off] = ((v[2] >>> 8) & 0xffff) | (v[3] << 16);\n    }\n\n    function set_complex_raw(off, v) {\n        data[off] = v[1];\n        data2[off] = v[2];\n    }\n\n    function set_std(index, v) {\n        var ofs = offset(index);\n        return set_std_raw(ofs, v);\n    }\n    function set_int64(index, v) {\n        return set_int64_raw(offset(index), v);\n    }\n    function set_complex(index, v) {\n        return set_complex_raw(offset(index), v);\n    }\n\n    var set = data_type == 1 /* Int64 */ ? set_int64 : (data_type == 2 /* Complex */ ? set_complex : set_std);\n\n    function set1_c(i, v) {\n        if (i < 0 || i >= dim0)\n            caml_array_bound_error();\n        data[i] = v;\n    }\n    function set1_fortran(i, v) {\n        if (i < 1 || i > dim0)\n            caml_array_bound_error();\n        data[i - 1] = v;\n    }\n    function set1_any(i, v) {\n        set([i], v);\n    }\n\n    var set1 = data_type == 0 /* General */ ? (layout == 0 ? set1_c : set1_fortran) : set1_any;\n\n    //\n    // other\n    //\n    function nth_dim(i) {\n        if (i < 0 || i >= n_dims)\n            caml_invalid_argument(\"Bigarray.dim\");\n        return dims[i];\n    }\n\n    function fill(v) {\n        if (data_type == 0 /* General */)\n            for (var i = 0; i < data.length; i++)\n                set_std_raw(i, v);\n        if (data_type == 1 /* Int64 */)\n            for (var i = 0; i < data.length; i++)\n                set_int64_raw(i, v);\n        if (data_type == 2 /* Complex */)\n            for (var i = 0; i < data.length; i++)\n                set_complex_raw(i, v);\n    }\n    function blit(from) {\n        if (n_dims != from.num_dims)\n            caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n        for (var i = 0; i < n_dims; i++)\n            if (dims[i] != from.nth_dim(i))\n                caml_invalid_argument(\"Bigarray.blit: dimension mismatch\");\n        data.set(from.data);\n        if (data_type != 0 /* General */)\n            data2.set(from.data2);\n    }\n\n    function sub(ofs, len) {\n        var changed_dim;\n        var mul = 1;\n\n        if (layout == 0) {\n            for (var i = 1; i < n_dims; i++)\n                mul = mul * dims[i];\n            changed_dim = 0;\n        } else {\n            for (var i = 0; i < (n_dims - 1); i++)\n                mul = mul * dims[i];\n            changed_dim = n_dims - 1;\n            ofs = ofs - 1;\n        }\n\n        if (ofs < 0 || len < 0 || (ofs + len) > dims[changed_dim])\n            caml_invalid_argument(\"Bigarray.sub: bad sub-array\");\n\n        var new_data = data.subarray(ofs * mul, (ofs + len) * mul);\n        var new_data2 = data_type == 0 /* General */ ? null : data2.subarray(ofs * mul, (ofs + len) * mul);\n\n        var new_dims = [];\n        for (var i = 0; i < n_dims; i++)\n            new_dims[i] = dims[i];\n        new_dims[changed_dim] = len;\n\n        return caml_ba_create_from(new_data, new_data2, data_type, kind, layout, new_dims);\n    }\n\n    function slice(vind) {\n        var num_inds = vind.length;\n        var index = [];\n        var sub_dims = [];\n        var ofs;\n\n        if (num_inds >= n_dims)\n            caml_invalid_argument(\"Bigarray.slice: too many indices\");\n\n        // Compute offset and check bounds\n        if (layout == 0) {\n            for (var i = 0; i < num_inds; i++)\n                index[i] = vind[i];\n            for (; i < n_dims; i++)\n                index[i] = 0;\n            ofs = offset(index);\n            sub_dims = dims.slice(num_inds);\n        } else {\n            for (var i = 0; i < num_inds; i++)\n                index[n_dims - num_inds + i] = vind[i];\n            for (var i = 0; i < n_dims - num_inds; i++)\n                index[i] = 1;\n            ofs = offset(index);\n            sub_dims = dims.slice(0, num_inds);\n        }\n\n        var size = caml_ba_get_size(sub_dims);\n        var new_data = data.subarray(ofs, ofs + size);\n        var new_data2 = data_type == 0 /* General */ ? null : data2.subarray(ofs, ofs + size);\n\n        return caml_ba_create_from(new_data, new_data2, data_type, kind, layout, sub_dims);\n    }\n\n    function reshape(vdim) {\n        var new_dim = [];\n        var num_dims = vdim.length;\n\n        if (num_dims < 1)\n            caml_invalid_argument(\"Bigarray.reshape: bad number of dimensions\");\n        var num_elts = 1;\n        for (var i = 0; i < num_dims; i++) {\n            new_dim[i] = vdim[i];\n            if (new_dim[i] < 0)\n                caml_invalid_argument(\"Bigarray.reshape: negative dimension\");\n            num_elts = num_elts * new_dim[i];\n        }\n\n        // Check that sizes agree\n        if (num_elts != size)\n            caml_invalid_argument(\"Bigarray.reshape: size mismatch\");\n\n        return caml_ba_create_from(data, data2, data_type, kind, layout, new_dim);\n    }\n\n    function compare(b, total) {\n        if (layout != b.layout)\n            return b.layout - layout;\n        if (n_dims != b.num_dims)\n            return b.num_dims - n_dims;\n        for (var i = 0; i < n_dims; i++)\n            if (nth_dim(i) != b.nth_dim(i))\n                return (nth_dim(i) < b.nth_dim(i)) ? -1 : 1;\n        switch (kind) {\n            case 0:\n            case 1:\n            case 10:\n            case 11:\n                var x, y;\n                for (var i = 0; i < data.length; i++) {\n                    x = data[i];\n                    y = b.data[i];\n\n                    //first array\n                    if (x < y)\n                        return -1;\n                    if (x > y)\n                        return 1;\n                    if (x != y) {\n                        if (x != y) {\n                            if (!total)\n                                return NaN;\n                            if (x == x)\n                                return 1;\n                            if (y == y)\n                                return -1;\n                        }\n                    }\n                    if (data2) {\n                        //second array\n                        x = data2[i];\n                        y = b.data2[i];\n                        if (x < y)\n                            return -1;\n                        if (x > y)\n                            return 1;\n                        if (x != y) {\n                            if (x != y) {\n                                if (!total)\n                                    return NaN;\n                                if (x == x)\n                                    return 1;\n                                if (y == y)\n                                    return -1;\n                            }\n                        }\n                    }\n                }\n                ;\n                break;\n\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 8:\n            case 9:\n            case 12:\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] < b.data[i])\n                        return -1;\n                    if (data[i] > b.data[i])\n                        return 1;\n                }\n                ;\n                break;\n\n            case 7:\n                for (var i = 0; i < data.length; i++) {\n                    if (data2[i] < b.data2[i])\n                        return -1;\n                    if (data2[i] > b.data2[i])\n                        return 1;\n                    if (data[i] < b.data[i])\n                        return -1;\n                    if (data[i] > b.data[i])\n                        return 1;\n                }\n                ;\n                break;\n        }\n        return 0;\n    }\n\n    return {\n        data: data,\n        data2: data2,\n        data_type: data_type,\n        num_dims: n_dims,\n        nth_dim: nth_dim,\n        kind: kind,\n        layout: layout,\n        size: size,\n        sub: sub,\n        slice: slice,\n        blit: blit,\n        fill: fill,\n        reshape: reshape,\n        get: get,\n        get1: get1,\n        set: set,\n        set1: set1,\n        compare: compare\n    };\n}\n\n//Provides: caml_ba_create\n//Requires: caml_ba_create_from\n//Requires: caml_js_from_array\n//Requires: caml_ba_views\n//Requires: caml_ba_init_views\n//Requires: caml_invalid_argument\n//Requires: caml_ba_get_size\nfunction caml_ba_create(kind, layout, dims_ml) {\n    // Initialize TypedArray views\n    caml_ba_init_views();\n\n    // set up dimensions and calculate size\n    var dims = caml_js_from_array(dims_ml);\n\n    //var n_dims = dims.length;\n    var size = caml_ba_get_size(dims);\n\n    // Allocate TypedArray\n    var view = caml_ba_views[0][kind];\n    if (!view)\n        caml_invalid_argument(\"Bigarray.create: unsupported kind\");\n    var data = new view(size);\n\n    // 2nd TypedArray for int64, complex32 and complex64\n    var data_type = caml_ba_views[1][kind];\n    var data2 = null;\n    if (data_type != 0 /* General */) {\n        data2 = new view(size);\n    }\n\n    return caml_ba_create_from(data, data2, data_type, kind, layout, dims);\n}\n\n//Provides: caml_ba_kind\nfunction caml_ba_kind(ba) {\n    return ba.kind;\n}\n\n//Provides: caml_ba_layout\nfunction caml_ba_layout(ba) {\n    return ba.layout;\n}\n\n//Provides: caml_ba_num_dims\nfunction caml_ba_num_dims(ba, _dim) {\n    return ba.num_dims;\n}\n\n//Provides: caml_ba_dim\nfunction caml_ba_dim(ba, dim) {\n    return ba.nth_dim(dim);\n}\n\n//Provides: caml_ba_dim_1\nfunction caml_ba_dim_1(ba) {\n    return ba.nth_dim(0);\n}\n\n//Provides: caml_ba_dim_2\nfunction caml_ba_dim_2(ba) {\n    return ba.nth_dim(1);\n}\n\n//Provides: caml_ba_dim_3\nfunction caml_ba_dim_3(ba) {\n    return ba.nth_dim(2);\n}\n\n//Provides: caml_ba_get_generic\n//Requires: caml_js_from_array\nfunction caml_ba_get_generic(ba, index) {\n    return ba.get(caml_js_from_array(index));\n}\n\n//Provides: caml_ba_uint8_get16\nfunction caml_ba_uint8_get16(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    return (b1 | b2);\n}\n\n//Provides: caml_ba_uint8_get32\nfunction caml_ba_uint8_get32(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    var b3 = ba.get1(i0+2) << 16;\n    var b4 = ba.get1(i0+3) << 24;\n    return (b1 | b2 | b3 | b4);\n}\n\n//Provides: caml_ba_uint8_get64\nfunction caml_ba_uint8_get64(ba, i0) {\n    var b1 = ba.get1(i0);\n    var b2 = ba.get1(i0+1) << 8;\n    var b3 = ba.get1(i0+2) << 16;\n    var b4 = ba.get1(i0+3);\n    var b5 = ba.get1(i0+4) << 8;\n    var b6 = ba.get1(i0+5) << 16;\n    var b7 = ba.get1(i0+6);\n    var b8 = ba.get1(i0+7) << 8;\n    return [255, b1 | b2 | b3, b4 | b5 | b6, b7 | b8 ];\n}\n\n//Provides: caml_ba_get_1\nfunction caml_ba_get_1(ba, i0) {\n    return ba.get1(i0);\n}\n\n//Provides: caml_ba_get_2\nfunction caml_ba_get_2(ba, i0, i1) {\n    return ba.get([i0, i1]);\n}\n\n//Provides: caml_ba_get_3\nfunction caml_ba_get_3(ba, i0, i1, i2) {\n    return ba.get([i0, i1, i2]);\n}\n\n//Provides: caml_ba_set_generic\n//Requires: caml_js_from_array\nfunction caml_ba_set_generic(ba, index, v) {\n    return ba.set(caml_js_from_array(index), v);\n}\n\n//Provides: caml_ba_uint8_set16\nfunction caml_ba_uint8_set16(ba, i0, v) {\n    ba.set1(i0, v & 0xff);\n    ba.set1(i0+1, (v >>> 8) & 0xff);\n    return 0;\n}\n\n//Provides: caml_ba_uint8_set32\nfunction caml_ba_uint8_set32(ba, i0, v) {\n    ba.set1(i0, v & 0xff);\n    ba.set1(i0+1, (v >>> 8) & 0xff);\n    ba.set1(i0+2, (v >>> 16) & 0xff);\n    ba.set1(i0+3, (v >>> 24) & 0xff);\n    return 0;\n}\n\n//Provides: caml_ba_uint8_set64\nfunction caml_ba_uint8_set64(ba, i0, v) {\n    ba.set1(i0, v[1] & 0xff);\n    ba.set1(i0+1, (v[1] >> 8) & 0xff);\n    ba.set1(i0+2, v[1] >> 16);\n    ba.set1(i0+3, v[2] & 0xff);\n    ba.set1(i0+4, (v[2] >> 8) & 0xff);\n    ba.set1(i0+5, v[2] >> 16);\n    ba.set1(i0+6, v[3] & 0xff);\n    ba.set1(i0+7, v[3] >> 8);\n    return 0;\n}\n\n//Provides: caml_ba_set_1\nfunction caml_ba_set_1(ba, i0, v) {\n    return ba.set1(i0, v);\n}\n\n//Provides: caml_ba_set_2\nfunction caml_ba_set_2(ba, i0, i1, v) {\n    return ba.set([i0, i1], v);\n}\n\n//Provides: caml_ba_set_3\nfunction caml_ba_set_3(ba, i0, i1, i2, v) {\n    return ba.set([i0, i1, i2], v);\n}\n\n//Provides: caml_ba_blit\nfunction caml_ba_blit(src, dst) {\n    dst.blit(src);\n    return 0;\n}\n\n//Provides: caml_ba_fill\nfunction caml_ba_fill(ba, init) {\n    ba.fill(init);\n    return 0;\n}\n\n//Provides: caml_ba_sub\nfunction caml_ba_sub(ba, ofs, len) {\n    return ba.sub(ofs, len);\n}\n\n//Provides: caml_ba_slice\n//Requires: caml_js_from_array\nfunction caml_ba_slice(ba, vind) {\n    return ba.slice(caml_js_from_array(vind));\n}\n\n//Provides: caml_ba_reshape\n//Requires: caml_js_from_array\nfunction caml_ba_reshape(ba, vind) {\n    return ba.reshape(caml_js_from_array(vind));\n}\n","///////// BIGSTRING\n//Provides: bigstring_alloc\n//Requires: caml_ba_create\nfunction bigstring_alloc(_,size){\n  return caml_ba_create(12, 0, [0,size]);\n}\n\n//Provides: bigstring_destroy_stub\nfunction bigstring_destroy_stub(_v) {\n  return 0; // noop\n}\n\n//Provides: bigstring_blit_bigstring_string_stub\n//Requires: caml_string_set, caml_ba_get_1\nfunction bigstring_blit_bigstring_string_stub(v_bstr, v_src_pos, v_str, v_dst_pos, v_len){\n  for(var i = 0; i < v_len; i++){\n    var c = caml_ba_get_1(v_bstr,v_src_pos + i);\n    caml_string_set(v_str,v_dst_pos + i,c);\n  }\n  return 0;\n}\n\n//Provides: caml_blit_bigstring_to_string\n//Requires: bigstring_blit_bigstring_string_stub\nvar caml_blit_bigstring_to_string = bigstring_blit_bigstring_string_stub\n\n//Provides: bigstring_blit_string_bigstring_stub\n//Requires: caml_string_get, caml_ba_set_1\nfunction bigstring_blit_string_bigstring_stub(v_str, v_src_pos, v_bstr, v_dst_pos, v_len){\n  for (var i = 0; i < v_len; i++) caml_ba_set_1(v_bstr,v_dst_pos + i,caml_string_get(v_str,v_src_pos + i));\n  return 0;\n}\n\n//Provides: caml_blit_string_to_bigstring\n//Requires: bigstring_blit_string_bigstring_stub\nvar caml_blit_string_to_bigstring = bigstring_blit_string_bigstring_stub\n\n//Provides: bigstring_blit_stub\n//Requires: caml_ba_get_1, caml_ba_set_1\nfunction bigstring_blit_stub(s1, i1, s2, i2, len){\n  for (var i = 0; i < len; i++) caml_ba_set_1(s2,i2 + i,caml_ba_get_1(s1,i1 + i));\n  return 0;\n}\n\n//Provides: bigstring_memcmp_stub\n//Requires: caml_ba_get_1\nfunction bigstring_memcmp_stub(v_s1, v_s1_pos, v_s2, v_s2_pos, v_len){\n  for (var i = 0; i < v_len; i++) {\n    var a = caml_ba_get_1(v_s1,v_s1_pos + i);\n    var b = caml_ba_get_1(v_s2,v_s2_pos + i);\n    if (a < b) return -1;\n    if (a > b) return 1;\n  }\n  return 0;\n}\n\n//Provides: bigstring_find\n//Requires: caml_ba_get_1\nfunction bigstring_find(bs, chr, pos, len){\n  while(len > 0){\n    if(caml_ba_get_1(bs,pos) == chr) return pos;\n    pos++;\n    len--;\n  }\n  return -1;\n}\n\n//Provides: bigstring_to_array_buffer mutable\nfunction bigstring_to_array_buffer(bs) {\n  return bs.data.buffer\n}\n\n//Provides: bigstring_of_array_buffer mutable\n//Requires: caml_ba_create_from\nfunction bigstring_of_array_buffer(ab) {\n  var ta = new joo_global_object.Uint8Array(ab);\n  return caml_ba_create_from(ta, null, 0, 12, 0, [ta.length])\n}\n\n//Provides: bigstring_marshal_data_size_stub mutable\n//Requires: caml_failwith, caml_ba_uint8_get32\nfunction bigstring_marshal_data_size_stub (s, ofs) {\n  if (caml_ba_uint8_get32(s, ofs) != (0x8495A6BE|0))\n    caml_failwith(\"Marshal.data_size: bad object\");\n  return (caml_ba_uint8_get32(s, ofs + 4));\n}\n\n//Provides: bigstring_unmarshal_stub mutable\n//Requires: BigStringReader, caml_input_value_from_reader\nfunction bigstring_unmarshal_stub(s,ofs) {\n  var reader = new BigStringReader (s, typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n\n//Provides: bigstring_marshal_stub mutable\n//Requires: caml_output_val, bigstring_alloc, caml_ba_set_1\nfunction bigstring_marshal_stub (v, _fl) {\n  /* ignores flags... */\n  var arr = caml_output_val (v);\n  var bs  = bigstring_alloc(0,arr.length);\n  for(var i = 0; i < arr.length; i++){\n    caml_ba_set_1(bs, i, arr[i]);\n  }\n  return bs;\n}\n\n//Provides: bigstring_marshal_blit_stub\n//Requires: caml_output_val, caml_failwith, caml_ba_set_1\nfunction bigstring_marshal_blit_stub (s, ofs, len, v, _fl) {\n  /* ignores flags... */\n  var t = caml_output_val (v);\n  if (t.length > len) caml_failwith (\"Marshal.to_buffer: buffer overflow\");\n  for(var i = 0; i < t.length; i++){\n    caml_ba_set_1(s, (i + ofs), t[i]);\n  }\n  return t.length;\n}\n\n//Provides: caml_hash_mix_bigstring\n//Requires: caml_hash_mix_string_arr\nfunction caml_hash_mix_bigstring(h, bs) {\n    return caml_hash_mix_string_arr(h,bs.data);\n}\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib\n\n//Provides: caml_js_pure_expr const\nfunction caml_js_pure_expr (f) { return f(); }\n\n//Provides: caml_js_set (mutable, const, const)\nfunction caml_js_set(o,f,v) { o[f]=v;return 0}\n//Provides: caml_js_get mutable (const, const)\nfunction caml_js_get(o,f) { return o[f]; }\n//Provides: caml_js_delete (mutable, const)\nfunction caml_js_delete(o,f) { delete o[f]; return 0}\n\n//Provides: caml_js_instanceof (const, const)\nfunction caml_js_instanceof(o,c) { return o instanceof c; }\n\n//Provides: caml_js_typeof (const)\nfunction caml_js_typeof(o) { return typeof o; }\n\n//Provides: caml_js_on_ie const\nfunction caml_js_on_ie () {\n  var ua =\n    joo_global_object.navigator?joo_global_object.navigator.userAgent:\"\";\n  return ua.indexOf(\"MSIE\") != -1 && ua.indexOf(\"Opera\") != 0;\n}\n\n//Provides: caml_js_html_escape const (const)\nvar caml_js_regexps = { amp:/&/g, lt:/</g, quot:/\\\"/g, all:/[&<\\\"]/ };\nfunction caml_js_html_escape (s) {\n  if (!caml_js_regexps.all.test(s)) return s;\n  return s.replace(caml_js_regexps.amp, \"&amp;\")\n          .replace(caml_js_regexps.lt, \"&lt;\")\n          .replace(caml_js_regexps.quot, \"&quot;\");\n}\n\n//Provides: caml_js_html_entities const (const)\nfunction caml_js_html_entities(s) {\n    var str, temp = document.createElement('p');\n    temp.innerHTML= s;\n    str= temp.textContent || temp.innerText;\n    temp=null;\n    return str;\n}\n\n/////////// Debugging console\n//Provides: caml_js_get_console const\nfunction caml_js_get_console () {\n  var c = joo_global_object.console?joo_global_object.console:{};\n  var m = [\"log\", \"debug\", \"info\", \"warn\", \"error\", \"assert\", \"dir\", \"dirxml\",\n           \"trace\", \"group\", \"groupCollapsed\", \"groupEnd\", \"time\", \"timeEnd\"];\n  function f () {}\n  for (var i = 0; i < m.length; i++) if (!c[m[i]]) c[m[i]]=f;\n  return c;\n}\n\n//Provides:caml_trampoline\nfunction caml_trampoline(res) {\n  var c = 1;\n  while(res && res.joo_tramp){\n    res = res.joo_tramp.apply(null, res.joo_args);\n    c++;\n  }\n  return res;\n}\n\n//Provides:caml_trampoline_return\nfunction caml_trampoline_return(f,args) {\n  return {joo_tramp:f,joo_args:args};\n}\n\n//Provides: js_print_stdout (const)\nfunction js_print_stdout(s) {\n  var g = joo_global_object;\n  if (g.process && g.process.stdout && g.process.stdout.write) {\n    g.process.stdout.write(s)\n  } else {\n  // Do not output the last \\n if present\n  // as console logging display a newline at the end\n  if(s.charCodeAt(s.length - 1) == 10)\n    s = s.substr(0,s.length - 1 );\n  var v = g.console;\n  v  && v.log && v.log(s);\n  }\n}\n//Provides: js_print_stderr (const)\nfunction js_print_stderr(s) {\n  var g = joo_global_object;\n  if (g.process && g.process.stdout && g.process.stdout.write) {\n    g.process.stderr.write(s)\n  } else {\n  // Do not output the last \\n if present\n  // as console logging display a newline at the end\n  if(s.charCodeAt(s.length - 1) == 10)\n    s = s.substr(0,s.length - 1 );\n  var v = g.console;\n  v && v.error && v.error(s);\n  }\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_marshal_constants\nvar caml_marshal_constants = {\n  PREFIX_SMALL_BLOCK:         0x80,\n  PREFIX_SMALL_INT:           0x40,\n  PREFIX_SMALL_STRING:        0x20,\n  CODE_INT8:                  0x00,\n  CODE_INT16:                 0x01,\n  CODE_INT32:                 0x02,\n  CODE_INT64:                 0x03,\n  CODE_SHARED8:               0x04,\n  CODE_SHARED16:              0x05,\n  CODE_SHARED32:              0x06,\n  CODE_BLOCK32:               0x08,\n  CODE_BLOCK64:               0x13,\n  CODE_STRING8:               0x09,\n  CODE_STRING32:              0x0A,\n  CODE_DOUBLE_BIG:            0x0B,\n  CODE_DOUBLE_LITTLE:         0x0C,\n  CODE_DOUBLE_ARRAY8_BIG:     0x0D,\n  CODE_DOUBLE_ARRAY8_LITTLE:  0x0E,\n  CODE_DOUBLE_ARRAY32_BIG:    0x0F,\n  CODE_DOUBLE_ARRAY32_LITTLE: 0x07,\n  CODE_CODEPOINTER:           0x10,\n  CODE_INFIXPOINTER:          0x11,\n  CODE_CUSTOM:                0x12\n}\n\n\n//Provides: MlStringReader\n//Requires: caml_new_string, caml_bytes_of_string\nfunction MlStringReader (s, i) { this.s = caml_bytes_of_string(s); this.i = i; }\nMlStringReader.prototype = {\n  read8u:function () { return this.s.charCodeAt(this.i++); },\n  read8s:function () { return this.s.charCodeAt(this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 8) | s.charCodeAt(i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (s.charCodeAt(i) << 24 >> 16) | s.charCodeAt(i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return ((s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n            (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3)) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (s.charCodeAt(i) << 24) | (s.charCodeAt(i+1) << 16) |\n      (s.charCodeAt(i+2) << 8) | s.charCodeAt(i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    this.i = i + len;\n    return caml_new_string(this.s.substring(i, i + len));\n  }\n}\n\n//Provides: BigStringReader\n//Requires: caml_string_of_array, caml_ba_get_1\nfunction BigStringReader (bs, i) { this.s = bs; this.i = i; }\nBigStringReader.prototype = {\n  read8u:function () { return caml_ba_get_1(this.s,this.i++); },\n  read8s:function () { return caml_ba_get_1(this.s,this.i++) << 24 >> 24; },\n  read16u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 8) | caml_ba_get_1(s,i + 1)\n  },\n  read16s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 2;\n    return (caml_ba_get_1(s,i) << 24 >> 16) | caml_ba_get_1(s,i + 1);\n  },\n  read32u:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (caml_ba_get_1((s,i) << 24) | (caml_ba_get_1(s,i+1) << 16) |\n            (caml_ba_get_1(s,i+2) << 8) | caml_ba_get_1(s,i+3)) >>> 0;\n  },\n  read32s:function () {\n    var s = this.s, i = this.i;\n    this.i = i + 4;\n    return (caml_ba_get_1(s,i) << 24) | (caml_ba_get_1(s,i+1) << 16) |\n      (caml_ba_get_1(s,i+2) << 8) | caml_ba_get_1(s,i+3);\n  },\n  readstr:function (len) {\n    var i = this.i;\n    var arr = new Array(len)\n    for(var j = 0; j < len; j++){\n      arr[j] = caml_ba_get_1(this.s, i+j);\n    }\n    this.i = i + len;\n    return caml_string_of_array(arr);\n  }\n}\n\n\n\n//Provides: caml_float_of_bytes\n//Requires: caml_int64_float_of_bits, caml_int64_of_bytes\nfunction caml_float_of_bytes (a) {\n  return caml_int64_float_of_bits (caml_int64_of_bytes (a));\n}\n\n//Provides: caml_input_value_from_string mutable\n//Requires: MlStringReader, caml_input_value_from_reader\nfunction caml_input_value_from_string(s,ofs) {\n  var reader = new MlStringReader (s, typeof ofs==\"number\"?ofs:ofs[0]);\n  return caml_input_value_from_reader(reader, ofs)\n}\n\n//Provides: caml_input_value_from_reader mutable\n//Requires: caml_failwith\n//Requires: caml_float_of_bytes, caml_int64_of_bytes\n\nfunction caml_input_value_from_reader(reader, ofs) {\n  var _magic = reader.read32u ()\n  var _block_len = reader.read32u ();\n  var num_objects = reader.read32u ();\n  var _size_32 = reader.read32u ();\n  var _size_64 = reader.read32u ();\n  var stack = [];\n  var intern_obj_table = (num_objects > 0)?[]:null;\n  var obj_counter = 0;\n  function intern_rec () {\n    var code = reader.read8u ();\n    if (code >= 0x40 /*cst.PREFIX_SMALL_INT*/) {\n      if (code >= 0x80 /*cst.PREFIX_SMALL_BLOCK*/) {\n        var tag = code & 0xF;\n        var size = (code >> 4) & 0x7;\n        var v = [tag];\n        if (size == 0) return v;\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        stack.push(v, size);\n        return v;\n      } else\n        return (code & 0x3F);\n    } else {\n      if (code >= 0x20/*cst.PREFIX_SMALL_STRING */) {\n        var len = code & 0x1F;\n        var v = reader.readstr (len);\n        if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n        return v;\n      } else {\n        switch(code) {\n        case 0x00: //cst.CODE_INT8:\n          return reader.read8s ();\n        case 0x01: //cst.CODE_INT16:\n          return reader.read16s ();\n        case 0x02: //cst.CODE_INT32:\n          return reader.read32s ();\n        case 0x03: //cst.CODE_INT64:\n          caml_failwith(\"input_value: integer too large\");\n          break;\n        case 0x04: //cst.CODE_SHARED8:\n          var offset = reader.read8u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x05: //cst.CODE_SHARED16:\n          var offset = reader.read16u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x06: //cst.CODE_SHARED32:\n          var offset = reader.read32u ();\n          return intern_obj_table[obj_counter - offset];\n        case 0x08: //cst.CODE_BLOCK32:\n          var header = reader.read32u ();\n          var tag = header & 0xFF;\n          var size = header >> 10;\n          var v = [tag];\n          if (size == 0) return v;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          stack.push(v, size);\n          return v;\n        case 0x13: //cst.CODE_BLOCK64:\n          caml_failwith (\"input_value: data block too large\");\n          break;\n        case 0x09: //cst.CODE_STRING8:\n          var len = reader.read8u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0A: //cst.CODE_STRING32:\n          var len = reader.read32u();\n          var v = reader.readstr (len);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0C: //cst.CODE_DOUBLE_LITTLE:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[7 - i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0B: //cst.CODE_DOUBLE_BIG:\n          var t = new Array(8);;\n          for (var i = 0;i < 8;i++) t[i] = reader.read8u ();\n          var v = caml_float_of_bytes (t);\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          return v;\n        case 0x0E: //cst.CODE_DOUBLE_ARRAY8_LITTLE:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0D: //cst.CODE_DOUBLE_ARRAY8_BIG:\n          var len = reader.read8u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x07: //cst.CODE_DOUBLE_ARRAY32_LITTLE:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[7 - j] = reader.read8u();\n            v[i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x0F: //cst.CODE_DOUBLE_ARRAY32_BIG:\n          var len = reader.read32u();\n          var v = new Array(len+1);\n          v[0] = 254;\n          var t = new Array(8);;\n          for (var i = 1;i <= len;i++) {\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            v [i] = caml_float_of_bytes (t);\n          }\n          return v;\n        case 0x10: //cst.CODE_CODEPOINTER:\n        case 0x11: //cst.CODE_INFIXPOINTER:\n          caml_failwith (\"input_value: code pointer\");\n          break;\n        case 0x12: //cst.CODE_CUSTOM:\n          var c, s = \"\";\n          while ((c = reader.read8u ()) != 0) s += String.fromCharCode (c);\n          switch(s) {\n          case \"_j\":\n            // Int64\n            var t = new Array(8);;\n            for (var j = 0;j < 8;j++) t[j] = reader.read8u();\n            var v = caml_int64_of_bytes (t);\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case \"_i\":\n            // Int32\n            var v = reader.read32s ();\n            if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n            return v;\n          case \"_n\":\n            // Nativeint\n            switch (reader.read8u ()) {\n            case 1:\n              var v = reader.read32s ();\n              if (intern_obj_table) intern_obj_table[obj_counter++] = v;\n              return v;\n            case 2:\n              caml_failwith(\"input_value: native integer value too large\");\n            default:\n              caml_failwith(\"input_value: ill-formed native integer\");\n            }\n          default:\n            caml_failwith(\"input_value: unknown custom block identifier\");\n          }\n        default:\n          caml_failwith (\"input_value: ill-formed message\");\n        }\n      }\n    }\n  }\n  var res = intern_rec ();\n  while (stack.length > 0) {\n    var size = stack.pop();\n    var v = stack.pop();\n    var d = v.length;\n    if (d < size) stack.push(v, size);\n    v[d] = intern_rec ();\n  }\n  if (typeof ofs!=\"number\") ofs[0] = reader.i;\n  return res;\n}\n\n//Provides: caml_marshal_data_size mutable\n//Requires: caml_failwith, caml_string_unsafe_get\nfunction caml_marshal_data_size (s, ofs) {\n  function get32(s,i) {\n    return (caml_string_unsafe_get(s, i) << 24) |\n           (caml_string_unsafe_get(s, i + 1) << 16) |\n           (caml_string_unsafe_get(s, i + 2) << 8) |\n            caml_string_unsafe_get(s, i + 3);\n  }\n  if (get32(s, ofs) != (0x8495A6BE|0))\n    caml_failwith(\"Marshal.data_size: bad object\");\n  return (get32(s, ofs + 4));\n}\n\n//Provides: caml_output_val\n//Requires: caml_int64_to_bytes, caml_failwith\n//Requires: caml_int64_bits_of_float\n//Requires: MlString, caml_ml_string_length, caml_string_unsafe_get\nvar caml_output_val = function (){\n  function Writer () { this.chunk = []; }\n  Writer.prototype = {\n    chunk_idx:20, block_len:0, obj_counter:0, size_32:0, size_64:0,\n    write:function (size, value) {\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    write_code:function (size, code, value) {\n      this.chunk[this.chunk_idx++] = code;\n      for (var i = size - 8;i >= 0;i -= 8)\n        this.chunk[this.chunk_idx++] = (value >> i) & 0xFF;\n    },\n    finalize:function () {\n      this.block_len = this.chunk_idx - 20;\n      this.chunk_idx = 0;\n      this.write (32, 0x8495A6BE);\n      this.write (32, this.block_len);\n      this.write (32, this.obj_counter);\n      this.write (32, this.size_32);\n      this.write (32, this.size_64);\n      return this.chunk;\n    }\n  }\n  return function (v) {\n    var writer = new Writer ();\n    var stack = [];\n    function extern_rec (v) {\n      if (v instanceof Array && v[0] === (v[0]|0)) {\n        if (v[0] == 255) {\n          // Int64\n          writer.write (8, 0x12 /*cst.CODE_CUSTOM*/);\n          for (var i = 0; i < 3; i++) writer.write (8, \"_j\\0\".charCodeAt(i));\n          var b = caml_int64_to_bytes (v);\n          for (var i = 0; i < 8; i++) writer.write (8, b[i]);\n          writer.size_32 += 4;\n          writer.size_64 += 3;\n          return;\n        }\n        if (v[0] == 251) {\n          caml_failwith(\"output_value: abstract value (Abstract)\");\n        }\n        if (v[0] < 16 && v.length - 1 < 8)\n          writer.write (8, 0x80 /*cst.PREFIX_SMALL_BLOCK*/ + v[0] + ((v.length - 1)<<4));\n        else\n          writer.write_code(32, 0x08 /*cst.CODE_BLOCK32*/, ((v.length-1) << 10) | v[0]);\n        writer.size_32 += v.length;\n        writer.size_64 += v.length;\n        if (v.length > 1) stack.push (v, 1);\n      } else if (v instanceof MlString) {\n        var len = caml_ml_string_length(v);\n        if (len < 0x20)\n          writer.write (8, 0x20 /*cst.PREFIX_SMALL_STRING*/ + len);\n        else if (len < 0x100)\n          writer.write_code (8, 0x09/*cst.CODE_STRING8*/, len);\n        else\n          writer.write_code (32, 0x0A /*cst.CODE_STRING32*/, len);\n        for (var i = 0;i < len;i++)\n          writer.write (8, caml_string_unsafe_get(v,i));\n        writer.size_32 += 1 + (((len + 4) / 4)|0);\n        writer.size_64 += 1 + (((len + 8) / 8)|0);\n      } else {\n        if (v != (v|0)){\n          var type_of_v = typeof v;\n//\n// If a float happens to be an integer it is serialized as an integer\n// (Js_of_ocaml cannot tell whether the type of an integer number is\n// float or integer.) This can result in unexpected crashes when\n// unmarshalling using the standard runtime. It seems better to\n// systematically fail on marshalling.\n//\n//          if(type_of_v != \"number\")\n          caml_failwith(\"output_value: abstract value (\"+type_of_v+\")\");\n//          var t = caml_int64_to_bytes(caml_int64_bits_of_float(v));\n//          writer.write (8, 0x0B /*cst.CODE_DOUBLE_BIG*/);\n//          for(var i = 0; i<8; i++){writer.write(8,t[i])}\n        }\n        else if (v >= 0 && v < 0x40) {\n          writer.write (8, 0X40 /*cst.PREFIX_SMALL_INT*/ + v);\n        } else {\n          if (v >= -(1 << 7) && v < (1 << 7))\n            writer.write_code(8, 0x00 /*cst.CODE_INT8*/, v);\n          else if (v >= -(1 << 15) && v < (1 << 15))\n            writer.write_code(16, 0x01 /*cst.CODE_INT16*/, v);\n          else\n            writer.write_code(32, 0x02 /*cst.CODE_INT32*/, v);\n        }\n      }\n    }\n    extern_rec (v);\n    while (stack.length > 0) {\n      var i = stack.pop ();\n      var v = stack.pop ();\n      if (i + 1 < v.length) stack.push (v, i + 1);\n      extern_rec (v[i]);\n    }\n    writer.finalize ();\n    return writer.chunk;\n  }\n} ();\n\n//Provides: caml_output_value_to_string mutable\n//Requires: caml_output_val, caml_string_of_array\nfunction caml_output_value_to_string (v, _fl) {\n  /* ignores flags... */\n  return caml_string_of_array (caml_output_val (v));\n}\n\n//Provides: caml_output_value_to_buffer\n//Requires: caml_output_val, caml_failwith, caml_blit_string\nfunction caml_output_value_to_buffer (s, ofs, len, v, _fl) {\n  /* ignores flags... */\n  var t = caml_output_val (v);\n  if (t.length > len) caml_failwith (\"Marshal.to_buffer: buffer overflow\");\n  caml_blit_string(t, 0, s, ofs, t.length);\n  return 0;\n}\n","// Js_of_ocaml library\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Jslib: code specific to Js_of_ocaml\n\n//Provides: caml_js_from_bool const (const)\nfunction caml_js_from_bool(x) { return !!x; }\n//Provides: caml_js_to_bool const (const)\nfunction caml_js_to_bool(x) { return +x; }\n//Provides: caml_js_from_float const (const)\nfunction caml_js_from_float(x) { return x; }\n//Provides: caml_js_to_float const (const)\nfunction caml_js_to_float(x) { return x; }\n//Provides: caml_js_from_string mutable (const)\n//Requires: MlString\nfunction caml_js_from_string(s) { return s.toString(); }\n//Provides: caml_js_from_array mutable (shallow)\n//Requires: raw_array_sub\nfunction caml_js_from_array(a) { return raw_array_sub(a,1,a.length-1); }\n//Provides: caml_js_to_array mutable (shallow)\n//Requires: raw_array_cons\nfunction caml_js_to_array(a) { return raw_array_cons(a,0); }\n\n//Provides: caml_js_var mutable (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_js_var(x) {\n  var x = x.toString();\n  //Checks that x has the form ident[.ident]*\n  if(!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/)){\n    js_print_stderr(\"caml_js_var: \\\"\" + x + \"\\\" is not a valid JavaScript variable. continuing ..\");\n    //joo_global_object.console.error(\"Js.Unsafe.eval_string\")\n  }\n  return eval(x);\n}\n//Provides: caml_js_call (const, mutable, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_call(f, o, args) { return f.apply(o, caml_js_from_array(args)); }\n//Provides: caml_js_fun_call (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_fun_call(f, a) {\n  switch (a.length) {\n  case 1: return f();\n  case 2: return f (a[1]);\n  case 3: return f (a[1],a[2]);\n  case 4: return f (a[1],a[2],a[3]);\n  case 5: return f (a[1],a[2],a[3],a[4]);\n  case 6: return f (a[1],a[2],a[3],a[4],a[5]);\n  case 7: return f (a[1],a[2],a[3],a[4],a[5],a[6]);\n  case 8: return f (a[1],a[2],a[3],a[4],a[5],a[6],a[7]);\n  }\n  return f.apply(null, caml_js_from_array(a));\n}\n//Provides: caml_js_meth_call (mutable, const, shallow)\n//Requires: MlString\n//Requires: caml_js_from_array\nfunction caml_js_meth_call(o, f, args) {\n  return o[f.toString()].apply(o, caml_js_from_array(args));\n}\n//Provides: caml_js_new (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_js_new(c, a) {\n  switch (a.length) {\n  case 1: return new c;\n  case 2: return new c (a[1]);\n  case 3: return new c (a[1],a[2]);\n  case 4: return new c (a[1],a[2],a[3]);\n  case 5: return new c (a[1],a[2],a[3],a[4]);\n  case 6: return new c (a[1],a[2],a[3],a[4],a[5]);\n  case 7: return new c (a[1],a[2],a[3],a[4],a[5],a[6]);\n  case 8: return new c (a[1],a[2],a[3],a[4],a[5],a[6],a[7]);\n  }\n  function F() { return c.apply(this, caml_js_from_array(a)); }\n  F.prototype = c.prototype;\n  return new F;\n}\n//Provides: caml_ojs_new_arr (const, shallow)\n//Requires: caml_js_from_array\nfunction caml_ojs_new_arr(c, a) {\n  switch (a.length) {\n  case 1: return new c;\n  case 2: return new c (a[0]);\n  case 3: return new c (a[0],a[1]);\n  case 4: return new c (a[0],a[1],a[2]);\n  case 5: return new c (a[0],a[1],a[2],a[3]);\n  case 6: return new c (a[0],a[1],a[2],a[3],a[4]);\n  case 7: return new c (a[0],a[1],a[2],a[3],a[4],a[5]);\n  case 8: return new c (a[0],a[1],a[2],a[3],a[4],a[5],a[6]);\n  }\n  function F() { return c.apply(this, a); }\n  F.prototype = c.prototype;\n  return new F;\n}\n//Provides: caml_js_wrap_callback const (const)\n//Requires: caml_call_gen\nfunction caml_js_wrap_callback(f) {\n  return function () {\n    if(arguments.length > 0){\n      return caml_call_gen(f, arguments);\n    } else {\n      return caml_call_gen(f, [undefined]);\n    }\n  }\n}\n\n//Provides: caml_js_wrap_callback_arguments\n//Requires: caml_js_wrap_callback\nfunction caml_js_wrap_callback_arguments(f) {\n  return function() {\n    return caml_js_wrap_callback(f)(arguments);\n  }\n}\n//Provides: caml_js_wrap_callback_strict const\n//Requires: caml_call_gen\nfunction caml_js_wrap_callback_strict(arity, f) {\n  return function () {\n    var n = arguments.length;\n    if(n == arity) return caml_call_gen(f, arguments);\n    var args = new Array(arity);\n    for (var i = 0; i < n && i < arity; i++) args[i] = arguments[i];\n    return caml_call_gen(f, args);\n  };\n}\n//Provides: caml_js_wrap_meth_callback const (const)\n//Requires: caml_call_gen,raw_array_cons\nfunction caml_js_wrap_meth_callback(f) {\n  return function () {\n    return caml_call_gen(f,raw_array_cons(arguments,this));\n  }\n}\n//Provides: caml_js_wrap_meth_callback_arguments const (const)\n//Requires: caml_call_gen,raw_array_cons\nfunction caml_js_wrap_meth_callback_arguments(f) {\n  return function () {\n    return caml_call_gen(f,[this,arguments]);\n  }\n}\n//Provides: caml_js_wrap_meth_callback_strict const\n//Requires: caml_call_gen, raw_array_cons\nfunction caml_js_wrap_meth_callback_strict(arity, f) {\n  return function () {\n    var n = arguments.length;\n    if(n == arity) return caml_call_gen(f, raw_array_cons(arguments,this));\n    var args = new Array(arity + 1);\n    args[0] = this;\n    for (var i = 1; i < n && i <= arity; i++) args[i] = arguments[i];\n    return caml_call_gen(f, args);\n  };\n}\n//Provides: caml_js_wrap_meth_callback_unsafe const (const)\n//Requires: caml_call_gen,raw_array_cons\nfunction caml_js_wrap_meth_callback_unsafe(f) {\n  return function () { f.apply(null, raw_array_cons(arguments,this)); }\n}\n//Provides: caml_js_equals mutable (const, const)\nfunction caml_js_equals (x, y) { return +(x == y); }\n//Provides: caml_js_to_byte_string const\n//Requires: caml_new_string\nfunction caml_js_to_byte_string (s) {return caml_new_string (s);}\n\n//Provides: caml_js_eval_string (const)\n//Requires: MlString\nfunction caml_js_eval_string (s) {return eval(s.toString());}\n\n//Provides: caml_js_expr (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_js_expr(s) {\n  js_print_stderr(\"caml_js_expr: fallback to runtime evaluation\");\n  return eval(s.toString());}\n\n//Provides: caml_pure_js_expr const (const)\n//Requires: js_print_stderr\n//Requires: MlString\nfunction caml_pure_js_expr (s){\n  js_print_stderr(\"caml_pure_js_expr: fallback to runtime evaluation\");\n  return eval(s.toString());}\n\n//Provides: caml_js_object (object_literal)\n//Requires: MlString\nfunction caml_js_object (a) {\n  var o = {};\n  for (var i = 1; i < a.length; i++) {\n    var p = a[i];\n    o[p[1].toString()] = p[2];\n  }\n  return o;\n}\n\n\n//Provides: caml_js_export_var\nfunction caml_js_export_var (){\n  if(typeof module !== 'undefined' && module && module.exports)\n    return module.exports\n  else\n    return joo_global_object;\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n///////////// Io\n\n//Provides: caml_sys_close\n//Requires: caml_global_data\nfunction caml_sys_close(fd) {\n  delete caml_global_data.fds[fd];\n  return 0;\n}\n\n//Provides: caml_std_output\n//Requires: caml_new_string, caml_ml_string_length, caml_ml_channels\nfunction caml_std_output(chanid,s){\n  var chan = caml_ml_channels[chanid];\n  var str = caml_new_string(s);\n  var slen = caml_ml_string_length(str);\n  chan.file.write(chan.offset, str, 0, slen);\n  chan.offset += slen;\n  return 0;\n}\n\n//Provides: caml_sys_open\n//Requires: caml_raise_sys_error, caml_global_data\n//Requires: caml_create_string,MlFakeFile\n//Requires: js_print_stderr, js_print_stdout\n//Requires: caml_std_output\n//Requires: resolve_fs_device\nfunction caml_sys_open_internal(idx,output,file,flags) {\n  if(caml_global_data.fds === undefined) caml_global_data.fds = new Array();\n  flags=flags?flags:{};\n  var info = {};\n  info.file = file;\n  info.offset = flags.append?file.length():0;\n  info.flags = flags;\n  info.output = output;\n  caml_global_data.fds[idx] = info;\n  if(!caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)\n    caml_global_data.fd_last_idx = idx;\n  return idx;\n}\nfunction caml_sys_open (name, flags, _perms) {\n  var f = {};\n  while(flags){\n    switch(flags[1]){\n    case 0: f.rdonly = 1;break;\n    case 1: f.wronly = 1;break;\n    case 2: f.append = 1;break;\n    case 3: f.create = 1;break;\n    case 4: f.truncate = 1;break;\n    case 5: f.excl = 1; break;\n    case 6: f.binary = 1;break;\n    case 7: f.text = 1;break;\n    case 8: f.nonblock = 1;break;\n    }\n    flags=flags[2];\n  }\n  if(f.rdonly && f.wronly)\n    caml_raise_sys_error(name.toString() + \" : flags Open_rdonly and Open_wronly are not compatible\");\n  if(f.text && f.binary)\n    caml_raise_sys_error(name.toString() + \" : flags Open_text and Open_binary are not compatible\");\n  var root = resolve_fs_device(name);\n  var file = root.device.open(root.rest,f);\n  var idx = caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;\n  return caml_sys_open_internal (idx+1,caml_std_output,file,f);\n}\ncaml_sys_open_internal(0,caml_std_output, new MlFakeFile(caml_create_string(0))); //stdin\ncaml_sys_open_internal(1,js_print_stdout, new MlFakeFile(caml_create_string(0))); //stdout\ncaml_sys_open_internal(2,js_print_stderr, new MlFakeFile(caml_create_string(0))); //stderr\n\n\n// ocaml Channels\n\n//Provides: caml_ml_set_channel_name\nfunction caml_ml_set_channel_name() {\n  return 0\n}\n\n//Provides: caml_ml_channels\nvar caml_ml_channels = new Array();\n\n//Provides: caml_ml_out_channels_list\n//Requires: caml_ml_channels\nfunction caml_ml_out_channels_list () {\n  var l = 0;\n  for(var c = 0; c < caml_ml_channels.length; c++){\n    if(caml_ml_channels[c] && caml_ml_channels[c].opened && caml_ml_channels[c].out)\n      l=[0,caml_ml_channels[c],l];\n  }\n  return l;\n}\n\n\n//Provides: caml_ml_open_descriptor_out\n//Requires: caml_ml_channels, caml_global_data\n//Requires: caml_raise_sys_error\nfunction caml_ml_open_descriptor_out (fd) {\n  var data = caml_global_data.fds[fd];\n  if(data.flags.rdonly) caml_raise_sys_error(\"fd \"+ fd + \" is readonly\");\n  var channel = {\n    file:data.file,\n    offset:data.offset,\n    fd:fd,\n    opened:true,\n    out:true,\n    buffer:\"\"\n  };\n  caml_ml_channels[channel.fd]=channel;\n  return channel.fd;\n}\n\n//Provides: caml_ml_open_descriptor_in\n//Requires: caml_global_data,caml_sys_open,caml_raise_sys_error, caml_ml_channels\nfunction caml_ml_open_descriptor_in (fd)  {\n  var data = caml_global_data.fds[fd];\n  if(data.flags.wronly) caml_raise_sys_error(\"fd \"+ fd + \" is writeonly\");\n\n  var channel = {\n    file:data.file,\n    offset:data.offset,\n    fd:fd,\n    opened:true,\n    out: false,\n    refill:null\n  };\n  caml_ml_channels[channel.fd]=channel;\n  return channel.fd;\n}\n\n\n//Provides: caml_ml_set_binary_mode\n//Requires: caml_global_data, caml_ml_channels\nfunction caml_ml_set_binary_mode(chanid,mode){\n  var chan = caml_ml_channels[chanid];\n  var data = caml_global_data.fds[chan.fd];\n  data.flags.text = !mode\n  data.flags.binary = mode\n  return 0;\n}\n\n//Input from in_channel\n\n//Provides: caml_ml_close_channel\n//Requires: caml_ml_flush, caml_ml_channels\n//Requires: caml_sys_close\nfunction caml_ml_close_channel (chanid) {\n  var chan = caml_ml_channels[chanid];\n  caml_ml_flush(chanid);\n  chan.opened = false;\n  chan.file.close();\n  caml_sys_close(chan.fd)\n  return 0;\n}\n\n//Provides: caml_ml_channel_size\n//Requires: caml_ml_string_length, caml_ml_channels\nfunction caml_ml_channel_size(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return chan.file.length();\n}\n\n//Provides: caml_ml_channel_size_64\n//Requires: caml_ml_channel_size,caml_int64_of_float,caml_ml_string_length, caml_ml_channels\nfunction caml_ml_channel_size_64(chanid) {\n  var chan = caml_ml_channels[chanid];\n  return caml_int64_of_float(chan.file.length ());\n}\n\n//Provides: caml_ml_set_channel_output\n//Requires: caml_ml_channels, caml_global_data\nfunction caml_ml_set_channel_output(chanid,f) {\n  var chan = caml_ml_channels[chanid];\n  caml_global_data.fds[chan.fd].output = f;\n  return 0;\n}\n\n//Provides: caml_ml_set_channel_refill\n//Requires: caml_ml_channels, caml_global_data\nfunction caml_ml_set_channel_refill(chanid,f) {\n  caml_ml_channels[chanid].refill = f;\n  return 0;\n}\n\n//Provides: caml_ml_refill_input\n//Requires: caml_ml_string_length\nfunction caml_ml_refill_input (chan) {\n  var str = chan.refill();\n  var str_len = caml_ml_string_length(str);\n  if (str_len == 0) chan.refill = null;\n  chan.file.write(chan.file.length(), str, 0, str_len);\n  return str_len;\n}\n\n//Provides: caml_ml_may_refill_input\n//Requires: caml_ml_string_length, caml_ml_refill_input, caml_ml_channels\nfunction caml_ml_may_refill_input (chanid) {\n  var chan = caml_ml_channels[chanid];\n  if (chan.refill == null) return;\n  if (chan.file.length() != chan.offset) return;\n  caml_ml_refill_input (chan);\n}\n\n//Provides: caml_ml_input\n//Requires: caml_ml_refill_input, caml_ml_channels\nfunction caml_ml_input (chanid, s, i, l) {\n  var chan = caml_ml_channels[chanid];\n  var l2 = chan.file.length() - chan.offset;\n  if (l2 == 0 && chan.refill != null) l2 = caml_ml_refill_input(chan);\n  if (l2 < l) l = l2;\n  chan.file.read(chan.offset, s, i, l);\n  chan.offset += l;\n  return l;\n}\n\n//Provides: caml_input_value\n//Requires: caml_marshal_data_size, caml_input_value_from_string, caml_create_string, caml_ml_channels\nfunction caml_input_value (chanid) {\n  var chan = caml_ml_channels[chanid];\n\n  var buf = caml_create_string(8);\n  chan.file.read(chan.offset,buf,0,8);\n\n  // Header is 20 bytes\n  var len = caml_marshal_data_size (buf, 0) + 20;\n\n  var buf = caml_create_string(len);\n  chan.file.read(chan.offset,buf,0,len);\n\n  var offset = [0];\n  var res = caml_input_value_from_string(buf, offset);\n  chan.offset = chan.offset + offset[0];\n  return res;\n}\n\n//Provides: caml_ml_input_char\n//Requires: caml_raise_end_of_file, caml_array_bound_error\n//Requires: caml_ml_string_length, caml_string_get, caml_ml_may_refill_input, caml_ml_channels, caml_create_string\nfunction caml_ml_input_char (chanid) {\n  var chan = caml_ml_channels[chanid];\n  caml_ml_may_refill_input(chanid);\n  if (chan.offset >= chan.file.length())\n    caml_raise_end_of_file();\n  var res = chan.file.read_one(chan.offset);\n  chan.offset++;\n  return res;\n}\n\n//Provides: caml_ml_input_int\n//Requires: caml_raise_end_of_file\n//Requires: caml_ml_string_length, caml_string_unsafe_get, caml_ml_refill_input, caml_ml_channels\n//Requires: caml_create_string\nfunction caml_ml_input_int (chanid) {\n  var chan = caml_ml_channels[chanid];\n  var file = chan.file;\n  while ((chan.offset + 3) >= file.length()) {\n    var l = caml_ml_refill_input(chan);\n    if (l == 0) caml_raise_end_of_file();\n  }\n  var o = chan.offset;\n  var r =(file.read_one(o  ) << 24)\n      |  (file.read_one(o+1) << 16)\n      |  (file.read_one(o+2) << 8)\n      |  (file.read_one(o+3));\n  chan.offset+=4;\n  return r;\n}\n\n//Provides: caml_ml_seek_in\n//Requires: caml_raise_sys_error, caml_ml_channels\nfunction caml_ml_seek_in(chanid,pos){\n  var chan = caml_ml_channels[chanid];\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  chan.offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_in_64\n//Requires: caml_int64_to_float, caml_raise_sys_error, caml_ml_channels\nfunction caml_ml_seek_in_64(chanid,pos){\n  var chan = caml_ml_channels[chanid];\n  if (chan.refill != null) caml_raise_sys_error(\"Illegal seek\");\n  chan.offset = caml_int64_to_float(pos);\n  return 0;\n}\n\n//Provides: caml_ml_pos_in\n//Requires: caml_ml_channels\nfunction caml_ml_pos_in(chanid) {return caml_ml_channels[chanid].offset}\n\n//Provides: caml_ml_pos_in_64\n//Requires: caml_int64_of_float, caml_ml_channels\nfunction caml_ml_pos_in_64(chanid) {return caml_int64_of_float(caml_ml_channels[chanid].offset)}\n\n//Provides: caml_ml_input_scan_line\n//Requires: caml_array_bound_error, caml_ml_string_length, caml_string_get\n//Requires: caml_ml_may_refill_input, caml_ml_channels, caml_create_string\nfunction caml_ml_input_scan_line(chanid){\n  var chan = caml_ml_channels[chanid];\n  caml_ml_may_refill_input(chanid);\n  var p = chan.offset;\n  var len = chan.file.length();\n  if(p >= len) { return 0;}\n  while(true) {\n    if(p >= len) return - (p - chan.offset);\n    if(chan.file.read_one(p) == 10) return p - chan.offset + 1;\n    p++;\n  }\n}\n\n//Provides: caml_ml_flush\n//Requires: caml_raise_sys_error, caml_global_data, caml_ml_channels\nfunction caml_ml_flush (chanid) {\n    var chan = caml_ml_channels[chanid];\n    if(! chan.opened) caml_raise_sys_error(\"Cannot flush a closed channel\");\n    if(!chan.buffer || chan.buffer == \"\") return 0;\n    if(chan.fd\n       && caml_global_data.fds[chan.fd]\n       && caml_global_data.fds[chan.fd].output) {\n      var output = caml_global_data.fds[chan.fd].output;\n      switch(output.length){\n      case 2: output(chanid,chan.buffer);break;\n      default: output(chan.buffer)\n      };\n    }\n    chan.buffer = \"\";\n    return 0;\n}\n\n//output to out_channel\n\n//Provides: caml_ml_output\n//Requires: caml_ml_flush,caml_ml_string_length\n//Requires: caml_create_string, caml_blit_string, caml_raise_sys_error, caml_ml_channels\nfunction caml_ml_output (chanid,buffer,offset,len) {\n    var chan = caml_ml_channels[chanid];\n    if(! chan.opened) caml_raise_sys_error(\"Cannot output to a closed channel\");\n    var string;\n    if(offset == 0 && caml_ml_string_length(buffer) == len)\n        string = buffer;\n    else {\n        string = caml_create_string(len);\n        caml_blit_string(buffer,offset,string,0,len);\n    }\n    var jsstring = string.toString();\n    var id = jsstring.lastIndexOf(\"\\n\");\n    if(id < 0)\n        chan.buffer+=jsstring;\n    else {\n        chan.buffer+=jsstring.substr(0,id+1);\n        caml_ml_flush (chanid);\n        chan.buffer += jsstring.substr(id+1);\n    }\n    return 0;\n}\n\n//Provides: caml_ml_output_bytes\n//Requires: caml_ml_output\nvar caml_ml_output_bytes = caml_ml_output\n\n//Provides: caml_ml_output_char\n//Requires: caml_ml_output\n//Requires: caml_new_string, caml_ml_channels\nfunction caml_ml_output_char (chanid,c) {\n    var s = caml_new_string(String.fromCharCode(c));\n    caml_ml_output(chanid,s,0,1);\n    return 0;\n}\n\n//Provides: caml_output_value\n//Requires: caml_output_value_to_string, caml_ml_output,caml_ml_string_length, caml_ml_channels\nfunction caml_output_value (chanid,v,_flags) {\n  var s = caml_output_value_to_string(v);\n  caml_ml_output(chanid,s,0,caml_ml_string_length(s));\n  return 0;\n}\n\n\n//Provides: caml_ml_seek_out\n//Requires: caml_ml_channels\nfunction caml_ml_seek_out(chanid,pos){\n  caml_ml_channels[chanid].offset = pos;\n  return 0;\n}\n\n//Provides: caml_ml_seek_out_64\n//Requires: caml_int64_to_float, caml_ml_channels\nfunction caml_ml_seek_out_64(chanid,pos){\n  caml_ml_channels[chanid].offset = caml_int64_to_float(pos);\n  return 0;\n}\n\n//Provides: caml_ml_pos_out\n//Requires: caml_ml_channels\nfunction caml_ml_pos_out(chanid) {return caml_ml_channels[chanid].offset}\n\n//Provides: caml_ml_pos_out_64\n//Requires: caml_int64_of_float, caml_ml_channels\nfunction caml_ml_pos_out_64(chanid) {\n  return caml_int64_of_float (caml_ml_channels[chanid].offset);\n}\n\n//Provides: caml_ml_output_int\n//Requires: caml_ml_output\n//Requires: caml_string_of_array\nfunction caml_ml_output_int (chanid,i) {\n  var arr = [(i>>24) & 0xFF,(i>>16) & 0xFF,(i>>8) & 0xFF,i & 0xFF ];\n  var s = caml_string_of_array(arr);\n  caml_ml_output(chanid,s,0,4);\n  return 0\n}\n","// Js_of_ocaml toplevel runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2011 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_terminfo_setup\nfunction caml_terminfo_setup () { return 1; } // Bad_term\n//Provides: caml_terminfo_backup\nfunction caml_terminfo_backup () { return 0; }\n//Provides: caml_terminfo_standout\nfunction caml_terminfo_standout () { return 0; }\n//Provides: caml_terminfo_resume\nfunction caml_terminfo_resume () { return 0; }\n//Provides: caml_invoke_traced_function\n//Requires: caml_invalid_argument\nfunction caml_invoke_traced_function() {\n  caml_invalid_argument(\"Meta.invoke_traced_function\");\n}\n//Provides: caml_get_current_environment\n//Requires: caml_failwith\nfunction caml_get_current_environment() {\n  caml_failwith(\"caml_get_current_environment not Implemented\");\n}\n//////////////////////////////////////////////////////////////////////\n\n//Provides: caml_get_section_table\n//Requires: caml_global_data, caml_failwith\nfunction caml_get_section_table () {\n  if(!caml_global_data.toc)\n    caml_failwith(\"Program not compiled with --toplevel\");\n  return caml_global_data.toc;\n}\n\n\n//Provides: caml_reify_bytecode\n//Requires: caml_failwith\nfunction caml_reify_bytecode (code, _sz) {\n  if(joo_global_object.toplevelCompile)\n    return joo_global_object.toplevelCompile(code);\n  else caml_failwith(\"Toplevel not initialized (toplevelCompile)\")\n}\n\n//Provides: caml_static_release_bytecode\nfunction caml_static_release_bytecode () { return 0; }\n\n//Provides: caml_static_alloc\n//Requires: caml_create_string\nfunction caml_static_alloc (len) { return caml_create_string (len); }\n\n//Provides: caml_static_free\nfunction caml_static_free () { return 0; }\n\n//Provides: caml_realloc_global\n//Requires: caml_global_data\nfunction caml_realloc_global (len) {\n  if (len + 1 > caml_global_data.length) caml_global_data.length = len + 1;\n  return 0;\n}\n","\n\n//Provides: caml_gc_minor\nfunction caml_gc_minor(){ return 0}\n//Provides: caml_gc_major\nfunction caml_gc_major(){ return 0}\n//Provides: caml_gc_full_major\nfunction caml_gc_full_major(){ return 0}\n//Provides: caml_gc_compaction\nfunction caml_gc_compaction(){ return 0}\n//Provides: caml_gc_counters\nfunction caml_gc_counters() { return [254,0,0,0] }\n//Provides: caml_gc_quick_stat\nfunction caml_gc_quick_stat(){\n  return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n}\n//Provides: caml_gc_stat\nfunction caml_gc_stat() {\n  return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n}\n\n//Provides: caml_gc_set\nfunction caml_gc_set(_control) {\n  return 0;\n}\n\n//Provides: caml_gc_get\nfunction caml_gc_get(){\n  return [0,0,0,0,0,0,0,0,0]\n}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n// Weak API, but without the weak semantics\n\n//Provides: caml_ephe_key_offset\n//Version: < 4.03\nvar caml_ephe_key_offset = 2\n\n//Provides: caml_ephe_key_offset\n//Version: >= 4.03\nvar caml_ephe_key_offset = 3\n\n//Provides: caml_ephe_data_offset\n//Version: >= 4.03\nvar caml_ephe_data_offset = 2\n\n//Provides: caml_weak_create\n//Requires: caml_ephe_key_offset, caml_invalid_argument\nfunction caml_weak_create (n) {\n  if (n < 0) caml_invalid_argument (\"Weak.create\");\n  var x = [251,\"caml_ephe_list_head\"];\n  x.length = caml_ephe_key_offset + n;\n  return x;\n}\n//Provides: caml_weak_set\n//Requires: caml_ephe_key_offset, caml_invalid_argument\nfunction caml_weak_set(x, i, v) {\n    if(i < 0 || caml_ephe_key_offset + i >= x.length)\n      caml_invalid_argument (\"Weak.set\");\n    x[caml_ephe_key_offset + i] = v;\n    return 0;\n}\n//Provides: caml_weak_get\n//Requires: caml_ephe_key_offset, caml_invalid_argument\nfunction caml_weak_get(x, i) {\n    if(i < 0 || caml_ephe_key_offset + i >= x.length)\n      caml_invalid_argument (\"Weak.get_key\");\n    return (x[caml_ephe_key_offset + i ]===undefined)?0:x[caml_ephe_key_offset + i];\n}\n//Provides: caml_weak_get_copy\n//Requires: caml_weak_get,caml_ephe_key_offset\n//Requires: caml_obj_dup, caml_invalid_argument\nfunction caml_weak_get_copy(x, i) {\n  if(i < 0 || caml_ephe_key_offset + i >= x.length)\n    caml_invalid_argument (\"Weak.get_copy\");\n  var y = caml_weak_get(x, i);\n  if (y === 0) return y;\n  var z = y[1];\n  if (z instanceof Array) return [0, caml_obj_dup(z)];\n  return y;\n}\n//Provides: caml_weak_check mutable\n//Requires: caml_ephe_key_offset\nfunction caml_weak_check(x, i) {\n  if(x[caml_ephe_key_offset + i]!==undefined && x[caml_ephe_key_offset + i] !==0)\n    return 1;\n  else\n    return 0;\n}\n\n//Provides: caml_weak_blit\n//Requires: caml_array_blit\n//Requires: caml_ephe_key_offset\nfunction caml_weak_blit(a1, i1, a2, i2, len) {\n  // minus one because caml_array_blit works on ocaml array\n  caml_array_blit(a1, caml_ephe_key_offset + i1 - 1,\n                  a2, caml_ephe_key_offset + i2 - 1,\n                  len);\n  return 0;\n}\n\n//Provides: caml_ephe_create\n//Requires: caml_weak_create\nvar caml_ephe_create = caml_weak_create\n\n//Provides: caml_ephe_blit_key\n//Requires: caml_weak_blit\nvar caml_ephe_blit_key = caml_weak_blit\n\n//Provides: caml_ephe_get_key\n//Requires: caml_weak_get\nvar caml_ephe_get_key = caml_weak_get\n\n//Provides: caml_ephe_get_key_copy\n//Requires: caml_weak_get_copy\nvar caml_ephe_get_key_copy = caml_weak_get_copy\n\n//Provides: caml_ephe_check_key\n//Requires: caml_weak_check\nvar caml_ephe_check_key = caml_weak_check\n\n//Provides: caml_ephe_set_key\n//Requires: caml_weak_set\nfunction caml_ephe_set_key(x, i, v) {\n  return caml_weak_set(x, i, [0, v])\n}\n\n//Provides: caml_ephe_unset_key\n//Requires: caml_weak_set\nfunction caml_ephe_unset_key(x, i) {\n  return caml_weak_set(x, i, 0)\n}\n\n//Provides: caml_ephe_blit_data\n//Requires: caml_ephe_data_offset\n//Version: >= 4.03\nfunction caml_ephe_blit_data(src, dst){\n  dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];\n  return 0;\n}\n\n//Provides: caml_ephe_get_data\n//Requires: caml_ephe_data_offset\n//Version: >= 4.03\nfunction caml_ephe_get_data(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return [0, x[caml_ephe_data_offset]];\n}\n\n//Provides: caml_ephe_get_data_copy\n//Requires: caml_ephe_data_offset\n//Requires: caml_obj_dup\n//Version: >= 4.03\nfunction caml_ephe_get_data_copy(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return [0, caml_obj_dup(x[caml_ephe_data_offset])];\n}\n\n//Provides: caml_ephe_set_data\n//Requires: caml_ephe_data_offset\n//Version: >= 4.03\nfunction caml_ephe_set_data(x, data){\n  x[caml_ephe_data_offset] = data;\n  return 0;\n}\n\n//Provides: caml_ephe_unset_data\n//Requires: caml_ephe_data_offset\n//Version: >= 4.03\nfunction caml_ephe_unset_data(x, data){\n  x[caml_ephe_data_offset] = undefined;\n  return 0;\n}\n\n//Provides: caml_ephe_check_data\n//Requires: caml_ephe_data_offset\n//Version: >= 4.03\nfunction caml_ephe_check_data(x){\n  if(x[caml_ephe_data_offset] === undefined)\n    return 0;\n  else\n    return 1;\n}\n","/***********************************************************************/\n/*                                                                     */\n/*                           Objective Caml                            */\n/*                                                                     */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */\n/*                                                                     */\n/*  Copyright 1996 Institut National de Recherche en Informatique et   */\n/*  en Automatique.  All rights reserved.  This file is distributed    */\n/*  under the terms of the GNU Lesser General Public License, with     */\n/*  the special exception on linking described in file ../LICENSE.     */\n/*                                                                     */\n/***********************************************************************/\n\n/* $Id: parsing.c 8983 2008-08-06 09:38:25Z xleroy $ */\n\n/* The PDA automaton for parsers generated by camlyacc */\n\n/* The pushdown automata */\n\n//Provides: caml_parse_engine\n//Requires: caml_lex_array\nfunction caml_parse_engine(tables, env, cmd, arg)\n{\n  var ERRCODE = 256;\n\n  //var START = 0;\n  //var TOKEN_READ = 1;\n  //var STACKS_GROWN_1 = 2;\n  //var STACKS_GROWN_2 = 3;\n  //var SEMANTIC_ACTION_COMPUTED = 4;\n  //var ERROR_DETECTED = 5;\n  var loop = 6;\n  var testshift = 7;\n  var shift = 8;\n  var shift_recover = 9;\n  var reduce = 10;\n\n  var READ_TOKEN = 0;\n  var RAISE_PARSE_ERROR = 1;\n  var GROW_STACKS_1 = 2;\n  var GROW_STACKS_2 = 3;\n  var COMPUTE_SEMANTIC_ACTION = 4;\n  var CALL_ERROR_FUNCTION = 5;\n\n  var env_s_stack = 1;\n  var env_v_stack = 2;\n  var env_symb_start_stack = 3;\n  var env_symb_end_stack = 4;\n  var env_stacksize = 5;\n  var env_stackbase = 6;\n  var env_curr_char = 7;\n  var env_lval = 8;\n  var env_symb_start = 9;\n  var env_symb_end = 10;\n  var env_asp = 11;\n  var env_rule_len = 12;\n  var env_rule_number = 13;\n  var env_sp = 14;\n  var env_state = 15;\n  var env_errflag = 16;\n\n  // var _tbl_actions = 1;\n  var tbl_transl_const = 2;\n  var tbl_transl_block = 3;\n  var tbl_lhs = 4;\n  var tbl_len = 5;\n  var tbl_defred = 6;\n  var tbl_dgoto = 7;\n  var tbl_sindex = 8;\n  var tbl_rindex = 9;\n  var tbl_gindex = 10;\n  var tbl_tablesize = 11;\n  var tbl_table = 12;\n  var tbl_check = 13;\n  // var _tbl_error_function = 14;\n  // var _tbl_names_const = 15;\n  // var _tbl_names_block = 16;\n\n  if (!tables.dgoto) {\n    tables.defred = caml_lex_array (tables[tbl_defred]);\n    tables.sindex = caml_lex_array (tables[tbl_sindex]);\n    tables.check  = caml_lex_array (tables[tbl_check]);\n    tables.rindex = caml_lex_array (tables[tbl_rindex]);\n    tables.table  = caml_lex_array (tables[tbl_table]);\n    tables.len    = caml_lex_array (tables[tbl_len]);\n    tables.lhs    = caml_lex_array (tables[tbl_lhs]);\n    tables.gindex = caml_lex_array (tables[tbl_gindex]);\n    tables.dgoto  = caml_lex_array (tables[tbl_dgoto]);\n  }\n\n  var res = 0, n, n1, n2, state1;\n\n  // RESTORE\n  var sp = env[env_sp];\n  var state = env[env_state];\n  var errflag = env[env_errflag];\n\n  exit:for (;;) {\n    switch(cmd) {\n    case 0://START:\n      state = 0;\n      errflag = 0;\n      // Fall through\n\n    case 6://loop:\n      n = tables.defred[state];\n      if (n != 0) { cmd = reduce; break; }\n      if (env[env_curr_char] >= 0) { cmd = testshift; break; }\n      res = READ_TOKEN;\n      break exit;\n                                  /* The ML code calls the lexer and updates */\n                                  /* symb_start and symb_end */\n    case 1://TOKEN_READ:\n      if (arg instanceof Array) {\n        env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];\n        env[env_lval] = arg[1];\n      } else {\n        env[env_curr_char] = tables[tbl_transl_const][arg + 1];\n        env[env_lval] = 0;\n      }\n      // Fall through\n\n    case 7://testshift:\n      n1 = tables.sindex[state];\n      n2 = n1 + env[env_curr_char];\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == env[env_curr_char]) {\n        cmd = shift; break;\n      }\n      n1 = tables.rindex[state];\n      n2 = n1 + env[env_curr_char];\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == env[env_curr_char]) {\n        n = tables.table[n2];\n        cmd = reduce; break;\n      }\n      if (errflag <= 0) {\n        res = CALL_ERROR_FUNCTION;\n        break exit;\n      }\n      // Fall through\n                                  /* The ML code calls the error function */\n    case 5://ERROR_DETECTED:\n      if (errflag < 3) {\n        errflag = 3;\n        for (;;) {\n          state1 = env[env_s_stack][sp + 1];\n          n1 = tables.sindex[state1];\n          n2 = n1 + ERRCODE;\n          if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n              tables.check[n2] == ERRCODE) {\n            cmd = shift_recover; break;\n          } else {\n            if (sp <= env[env_stackbase]) return RAISE_PARSE_ERROR;\n                                    /* The ML code raises Parse_error */\n            sp--;\n          }\n        }\n      } else {\n        if (env[env_curr_char] == 0) return RAISE_PARSE_ERROR;\n                                    /* The ML code raises Parse_error */\n        env[env_curr_char] = -1;\n        cmd = loop; break;\n      }\n      // Fall through\n    case 8://shift:\n      env[env_curr_char] = -1;\n      if (errflag > 0) errflag--;\n      // Fall through\n    case 9://shift_recover:\n      state = tables.table[n2];\n      sp++;\n      if (sp >= env[env_stacksize]) {\n        res = GROW_STACKS_1;\n        break exit;\n      }\n      // Fall through\n                                   /* The ML code resizes the stacks */\n    case 2://STACKS_GROWN_1:\n      env[env_s_stack][sp + 1] = state;\n      env[env_v_stack][sp + 1] = env[env_lval];\n      env[env_symb_start_stack][sp + 1] = env[env_symb_start];\n      env[env_symb_end_stack][sp + 1] = env[env_symb_end];\n      cmd = loop;\n      break;\n\n    case 10://reduce:\n      var m = tables.len[n];\n      env[env_asp] = sp;\n      env[env_rule_number] = n;\n      env[env_rule_len] = m;\n      sp = sp - m + 1;\n      m = tables.lhs[n];\n      state1 = env[env_s_stack][sp];\n      n1 = tables.gindex[m];\n      n2 = n1 + state1;\n      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] &&\n          tables.check[n2] == state1)\n        state = tables.table[n2];\n      else\n        state = tables.dgoto[m];\n      if (sp >= env[env_stacksize]) {\n        res = GROW_STACKS_2;\n        break exit;\n      }\n      // Fall through\n                                  /* The ML code resizes the stacks */\n    case 3://STACKS_GROWN_2:\n      res = COMPUTE_SEMANTIC_ACTION;\n      break exit;\n                                  /* The ML code calls the semantic action */\n    case 4://SEMANTIC_ACTION_COMPUTED:\n      env[env_s_stack][sp + 1] = state;\n      env[env_v_stack][sp + 1] = arg;\n      var asp = env[env_asp];\n      env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];\n      if (sp > asp) {\n        /* This is an epsilon production. Take symb_start equal to symb_end. */\n        env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];\n      }\n      cmd = loop; break;\n                                  /* Should not happen */\n    default:\n      return RAISE_PARSE_ERROR;\n    }\n  }\n  // SAVE\n  env[env_sp] = sp;\n  env[env_state] = state;\n  env[env_errflag] = errflag;\n  return res;\n}\n\n//Provides: caml_set_parser_trace const\n//Dummy function!\nfunction caml_set_parser_trace() { return 0; }\n","//Provides: unix_gettimeofday\nfunction unix_gettimeofday () {\n  return (new Date()).getTime() / 1000;\n}\n\n//Provides: unix_time\n//Requires: unix_gettimeofday\nfunction unix_time () {\n  return Math.floor(unix_gettimeofday ());\n}\n\n//Provides: unix_gmtime\nfunction unix_gmtime (t) {\n  var d = new Date (t * 1000);\n  var januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n  var doy = Math.floor((d - januaryfirst) / 86400000);\n  return [0, d.getUTCSeconds(), d.getUTCMinutes(), d.getUTCHours(),\n          d.getUTCDate(), d.getUTCMonth(), d.getUTCFullYear() - 1900,\n          d.getUTCDay(), doy,\n          false | 0 /* for UTC daylight savings time is false */]\n}\n\n//Provides: unix_localtime\nfunction unix_localtime (t) {\n  var d = new Date (t * 1000);\n  var januaryfirst = new Date(d.getFullYear(), 0, 1);\n  var doy = Math.floor((d - januaryfirst) / 86400000);\n  var jan = new Date(d.getFullYear(), 0, 1);\n  var jul = new Date(d.getFullYear(), 6, 1);\n  var stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n  return [0, d.getSeconds(), d.getMinutes(), d.getHours(),\n  d.getDate(), d.getMonth(), d.getFullYear() - 1900,\n  d.getDay(), doy,\n  (d.getTimezoneOffset() < stdTimezoneOffset) | 0 /* daylight savings time  field. */]\n}\n\n//Provides: unix_mktime\n//Requires: unix_localtime\nfunction unix_mktime(tm){\n    var d = new Date(tm[6]+1900,tm[5],tm[4],tm[3],tm[2],tm[1]);\n    var t = Math.floor(d.getTime() / 1000);\n    var tm2 = unix_localtime(t);\n    return [0,t,tm2];\n}\n\n//Provides: win_startup const\nfunction win_startup() {}\n\n//Provides: win_cleanup const\nfunction win_cleanup() {}\n\n//Provides: win_handle_fd const\nfunction win_handle_fd(x) {return x;}\n","// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2014 Jérôme Vouillon, Hugo Heuzard\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n//Provides: caml_CamlinternalMod_init_mod\n//Requires: caml_raise_with_arg, caml_global_data\nfunction caml_CamlinternalMod_init_mod(loc,shape) {\n  function undef_module (_x) {\n    caml_raise_with_arg(caml_global_data.Undefined_recursive_module, loc);\n  }\n  function loop (shape,struct,idx){\n    if(typeof shape === \"number\")\n      switch(shape){\n      case 0://function\n        struct[idx]={fun:undef_module};\n        break;\n      case 1://lazy\n        struct[idx]=[246, undef_module];\n        break;\n      default://case 2://class\n        struct[idx]=[];\n      }\n    else\n      switch(shape[0]){\n      case 0://module\n        struct[idx] = [0];\n        for(var i=1;i<shape[1].length;i++)\n          loop(shape[1][i],struct[idx],i);\n        break;\n      default://case 1://Value\n        struct[idx] = shape[1];\n      }\n  }\n  var res = [];\n  loop(shape,res,0);\n  return res[0]\n}\n//Provides: caml_CamlinternalMod_update_mod\n//Requires: caml_update_dummy\nfunction caml_CamlinternalMod_update_mod(shape,real,x) {\n  if(typeof shape === \"number\")\n    switch(shape){\n    case 0://function\n      real.fun = x;\n      break;\n    case 1://lazy\n    default://case 2://class\n      caml_update_dummy(real,x);\n    }\n  else\n    switch(shape[0]){\n    case 0://module\n      for(var i=1;i<shape[1].length;i++)\n        caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);\n      break;\n    //case 1://Value\n    default:\n    };\n  return 0\n}\n","/***********************************************************************/\n/*                                                                     */\n/*                           Objective Caml                            */\n/*                                                                     */\n/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */\n/*                                                                     */\n/*  Copyright 1996 Institut National de Recherche en Informatique et   */\n/*  en Automatique.  All rights reserved.  This file is distributed    */\n/*  under the terms of the GNU Lesser General Public License, with     */\n/*  the special exception on linking described in file ../LICENSE.     */\n/*                                                                     */\n/***********************************************************************/\n\n/* $Id: lexing.c 6045 2004-01-01 16:42:43Z doligez $ */\n\n/* The table-driven automaton for lexers generated by camllex. */\n\n//Provides: caml_lex_array\n//Requires: caml_bytes_of_string\nfunction caml_lex_array(s) {\n  s = caml_bytes_of_string(s);\n  var l = s.length / 2;\n  var a = new Array(l);\n  for (var i = 0; i < l; i++)\n    a[i] = (s.charCodeAt(2 * i) | (s.charCodeAt(2 * i + 1) << 8)) << 16 >> 16;\n  return a;\n}\n\n//Provides: caml_lex_engine\n//Requires: caml_failwith, caml_lex_array, caml_array_of_string\nfunction caml_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n\n  var c, state = start_state;\n\n  var buffer = caml_array_of_string(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) return -base-1;\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n       */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n\n/***********************************************/\n/* New lexer engine, with memory of positions  */\n/***********************************************/\n\n//Provides: caml_new_lex_engine\n//Requires: caml_failwith, caml_lex_array\n//Requires: caml_bytes_of_string, caml_array_of_string\nfunction caml_lex_run_mem(s, i, mem, curr_pos) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = curr_pos;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_lex_run_tag(s, i, mem) {\n  for (;;) {\n    var dst = s.charCodeAt(i); i++;\n    if (dst == 0xff) return ;\n    var src = s.charCodeAt(i); i++;\n    if (src == 0xff)\n      mem [dst + 1] = -1;\n    else\n      mem [dst + 1] = mem [src + 1];\n  }\n}\n\nfunction caml_new_lex_engine(tbl, start_state, lexbuf) {\n  var lex_buffer = 2;\n  var lex_buffer_len = 3;\n  var lex_start_pos = 5;\n  var lex_curr_pos = 6;\n  var lex_last_pos = 7;\n  var lex_last_action = 8;\n  var lex_eof_reached = 9;\n  var lex_mem = 10;\n  var lex_base = 1;\n  var lex_backtrk = 2;\n  var lex_default = 3;\n  var lex_trans = 4;\n  var lex_check = 5;\n  var lex_base_code = 6;\n  var lex_backtrk_code = 7;\n  var lex_default_code = 8;\n  var lex_trans_code = 9;\n  var lex_check_code = 10;\n  var lex_code = 11;\n\n  if (!tbl.lex_default) {\n    tbl.lex_base =    caml_lex_array (tbl[lex_base]);\n    tbl.lex_backtrk = caml_lex_array (tbl[lex_backtrk]);\n    tbl.lex_check =   caml_lex_array (tbl[lex_check]);\n    tbl.lex_trans =   caml_lex_array (tbl[lex_trans]);\n    tbl.lex_default = caml_lex_array (tbl[lex_default]);\n  }\n  if (!tbl.lex_default_code) {\n    tbl.lex_base_code =    caml_lex_array (tbl[lex_base_code]);\n    tbl.lex_backtrk_code = caml_lex_array (tbl[lex_backtrk_code]);\n    tbl.lex_check_code =   caml_lex_array (tbl[lex_check_code]);\n    tbl.lex_trans_code =   caml_lex_array (tbl[lex_trans_code]);\n    tbl.lex_default_code = caml_lex_array (tbl[lex_default_code]);\n  }\n  if (tbl.lex_code == null) tbl.lex_code = caml_bytes_of_string(tbl[lex_code]);\n\n  var c, state = start_state;\n\n  var buffer = caml_array_of_string(lexbuf[lex_buffer]);\n\n  if (state >= 0) {\n    /* First entry */\n    lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];\n    lexbuf[lex_last_action] = -1;\n  } else {\n    /* Reentry after refill */\n    state = -state - 1;\n  }\n  for(;;) {\n    /* Lookup base address or action number for current state */\n    var base = tbl.lex_base[state];\n    if (base < 0) {\n      var pc_off = tbl.lex_base_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      return -base-1;\n    }\n    /* See if it's a backtrack point */\n    var backtrk = tbl.lex_backtrk[state];\n    if (backtrk >= 0) {\n      var pc_off = tbl.lex_backtrk_code[state];\n      caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);\n      lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];\n      lexbuf[lex_last_action] = backtrk;\n    }\n    /* See if we need a refill */\n    if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len]){\n      if (lexbuf[lex_eof_reached] == 0)\n        return -state - 1;\n      else\n        c = 256;\n    }else{\n      /* Read next input char */\n      c = buffer[lexbuf[lex_curr_pos]];\n      lexbuf[lex_curr_pos] ++;\n    }\n    /* Determine next state */\n    var pstate = state ;\n    if (tbl.lex_check[base + c] == state)\n      state = tbl.lex_trans[base + c];\n    else\n      state = tbl.lex_default[state];\n    /* If no transition on this char, return to last backtrack point */\n    if (state < 0) {\n      lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];\n      if (lexbuf[lex_last_action] == -1)\n        caml_failwith(\"lexing: empty token\");\n      else\n        return lexbuf[lex_last_action];\n    }else{\n      /* If some transition, get and perform memory moves */\n      var base_code = tbl.lex_base_code[pstate], pc_off;\n      if (tbl.lex_check_code[base_code + c] == pstate)\n        pc_off = tbl.lex_trans_code[base_code + c];\n      else\n        pc_off = tbl.lex_default_code[pstate];\n      if (pc_off > 0)\n        caml_lex_run_mem\n          (tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);\n      /* Erase the EOF condition only if the EOF pseudo-character was\n         consumed by the automaton (i.e. there was no backtrack above)\n       */\n      if (c == 256) lexbuf[lex_eof_reached] = 0;\n    }\n  }\n}\n\n",null,"// Js_of_ocaml runtime support\n// http://www.ocsigen.org/js_of_ocaml/\n// Copyright (C) 2010 Jérôme Vouillon\n// Laboratoire PPS - CNRS Université Paris Diderot\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, with linking exception;\n// either version 2.1 of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n\n//Provides: caml_md5_chan\n//Requires: caml_md5_string, caml_string_of_array,caml_ml_string_length, caml_ml_channels\n//Requires: caml_raise_end_of_file, caml_create_string  \nfunction caml_md5_chan(chanid,len){\n  var chan = caml_ml_channels[chanid];\n  var chan_len = chan.file.length();\n  if(len<0) len = chan_len - chan.offset;\n  if(chan.offset + len >= chan_len) caml_raise_end_of_file;\n  var buf = caml_create_string(len);\n  chan.file.read(chan.offset,buf,0,len);\n  return caml_md5_string(buf,0,len);\n}\n\n//Provides: caml_md5_string\n//Requires: caml_string_of_array, caml_convert_string_to_bytes\nvar caml_md5_string =\nfunction () {\n  function add (x, y) { return (x + y) | 0; }\n  function xx(q,a,b,x,s,t) {\n    a = add(add(a, q), add(x, t));\n    return add((a << s) | (a >>> (32 - s)), b);\n  }\n  function ff(a,b,c,d,x,s,t) {\n    return xx((b & c) | ((~b) & d), a, b, x, s, t);\n  }\n  function gg(a,b,c,d,x,s,t) {\n    return xx((b & d) | (c & (~d)), a, b, x, s, t);\n  }\n  function hh(a,b,c,d,x,s,t) { return xx(b ^ c ^ d, a, b, x, s, t); }\n  function ii(a,b,c,d,x,s,t) { return xx(c ^ (b | (~d)), a, b, x, s, t); }\n\n  function md5(buffer, length) {\n    var i = length;\n    buffer[i >> 2] |= 0x80 << (8 * (i & 3));\n    for (i = (i & ~0x3) + 8;(i & 0x3F) < 60 ;i += 4)\n      buffer[(i >> 2) - 1] = 0;\n    buffer[(i >> 2) -1] = length << 3;\n    buffer[i >> 2] = (length >> 29) & 0x1FFFFFFF;\n\n    var w = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];\n\n    for(i = 0; i < buffer.length; i += 16) {\n      var a = w[0], b = w[1], c = w[2], d = w[3];\n\n      a = ff(a, b, c, d, buffer[i+ 0], 7, 0xD76AA478);\n      d = ff(d, a, b, c, buffer[i+ 1], 12, 0xE8C7B756);\n      c = ff(c, d, a, b, buffer[i+ 2], 17, 0x242070DB);\n      b = ff(b, c, d, a, buffer[i+ 3], 22, 0xC1BDCEEE);\n      a = ff(a, b, c, d, buffer[i+ 4], 7, 0xF57C0FAF);\n      d = ff(d, a, b, c, buffer[i+ 5], 12, 0x4787C62A);\n      c = ff(c, d, a, b, buffer[i+ 6], 17, 0xA8304613);\n      b = ff(b, c, d, a, buffer[i+ 7], 22, 0xFD469501);\n      a = ff(a, b, c, d, buffer[i+ 8], 7, 0x698098D8);\n      d = ff(d, a, b, c, buffer[i+ 9], 12, 0x8B44F7AF);\n      c = ff(c, d, a, b, buffer[i+10], 17, 0xFFFF5BB1);\n      b = ff(b, c, d, a, buffer[i+11], 22, 0x895CD7BE);\n      a = ff(a, b, c, d, buffer[i+12], 7, 0x6B901122);\n      d = ff(d, a, b, c, buffer[i+13], 12, 0xFD987193);\n      c = ff(c, d, a, b, buffer[i+14], 17, 0xA679438E);\n      b = ff(b, c, d, a, buffer[i+15], 22, 0x49B40821);\n\n      a = gg(a, b, c, d, buffer[i+ 1], 5, 0xF61E2562);\n      d = gg(d, a, b, c, buffer[i+ 6], 9, 0xC040B340);\n      c = gg(c, d, a, b, buffer[i+11], 14, 0x265E5A51);\n      b = gg(b, c, d, a, buffer[i+ 0], 20, 0xE9B6C7AA);\n      a = gg(a, b, c, d, buffer[i+ 5], 5, 0xD62F105D);\n      d = gg(d, a, b, c, buffer[i+10], 9, 0x02441453);\n      c = gg(c, d, a, b, buffer[i+15], 14, 0xD8A1E681);\n      b = gg(b, c, d, a, buffer[i+ 4], 20, 0xE7D3FBC8);\n      a = gg(a, b, c, d, buffer[i+ 9], 5, 0x21E1CDE6);\n      d = gg(d, a, b, c, buffer[i+14], 9, 0xC33707D6);\n      c = gg(c, d, a, b, buffer[i+ 3], 14, 0xF4D50D87);\n      b = gg(b, c, d, a, buffer[i+ 8], 20, 0x455A14ED);\n      a = gg(a, b, c, d, buffer[i+13], 5, 0xA9E3E905);\n      d = gg(d, a, b, c, buffer[i+ 2], 9, 0xFCEFA3F8);\n      c = gg(c, d, a, b, buffer[i+ 7], 14, 0x676F02D9);\n      b = gg(b, c, d, a, buffer[i+12], 20, 0x8D2A4C8A);\n\n      a = hh(a, b, c, d, buffer[i+ 5], 4, 0xFFFA3942);\n      d = hh(d, a, b, c, buffer[i+ 8], 11, 0x8771F681);\n      c = hh(c, d, a, b, buffer[i+11], 16, 0x6D9D6122);\n      b = hh(b, c, d, a, buffer[i+14], 23, 0xFDE5380C);\n      a = hh(a, b, c, d, buffer[i+ 1], 4, 0xA4BEEA44);\n      d = hh(d, a, b, c, buffer[i+ 4], 11, 0x4BDECFA9);\n      c = hh(c, d, a, b, buffer[i+ 7], 16, 0xF6BB4B60);\n      b = hh(b, c, d, a, buffer[i+10], 23, 0xBEBFBC70);\n      a = hh(a, b, c, d, buffer[i+13], 4, 0x289B7EC6);\n      d = hh(d, a, b, c, buffer[i+ 0], 11, 0xEAA127FA);\n      c = hh(c, d, a, b, buffer[i+ 3], 16, 0xD4EF3085);\n      b = hh(b, c, d, a, buffer[i+ 6], 23, 0x04881D05);\n      a = hh(a, b, c, d, buffer[i+ 9], 4, 0xD9D4D039);\n      d = hh(d, a, b, c, buffer[i+12], 11, 0xE6DB99E5);\n      c = hh(c, d, a, b, buffer[i+15], 16, 0x1FA27CF8);\n      b = hh(b, c, d, a, buffer[i+ 2], 23, 0xC4AC5665);\n\n      a = ii(a, b, c, d, buffer[i+ 0], 6, 0xF4292244);\n      d = ii(d, a, b, c, buffer[i+ 7], 10, 0x432AFF97);\n      c = ii(c, d, a, b, buffer[i+14], 15, 0xAB9423A7);\n      b = ii(b, c, d, a, buffer[i+ 5], 21, 0xFC93A039);\n      a = ii(a, b, c, d, buffer[i+12], 6, 0x655B59C3);\n      d = ii(d, a, b, c, buffer[i+ 3], 10, 0x8F0CCC92);\n      c = ii(c, d, a, b, buffer[i+10], 15, 0xFFEFF47D);\n      b = ii(b, c, d, a, buffer[i+ 1], 21, 0x85845DD1);\n      a = ii(a, b, c, d, buffer[i+ 8], 6, 0x6FA87E4F);\n      d = ii(d, a, b, c, buffer[i+15], 10, 0xFE2CE6E0);\n      c = ii(c, d, a, b, buffer[i+ 6], 15, 0xA3014314);\n      b = ii(b, c, d, a, buffer[i+13], 21, 0x4E0811A1);\n      a = ii(a, b, c, d, buffer[i+ 4], 6, 0xF7537E82);\n      d = ii(d, a, b, c, buffer[i+11], 10, 0xBD3AF235);\n      c = ii(c, d, a, b, buffer[i+ 2], 15, 0x2AD7D2BB);\n      b = ii(b, c, d, a, buffer[i+ 9], 21, 0xEB86D391);\n\n      w[0] = add(a, w[0]);\n      w[1] = add(b, w[1]);\n      w[2] = add(c, w[2]);\n      w[3] = add(d, w[3]);\n    }\n\n    var t = new Array(16);\n    for (var i = 0; i < 4; i++)\n      for (var j = 0; j < 4; j++)\n        t[i * 4 + j] = (w[i] >> (8 * j)) & 0xFF;\n    return t;\n  }\n\n  return function (s, ofs, len) {\n    // FIX: maybe we should perform the computation by chunk of 64 bytes\n    // as in http://www.myersdaily.org/joseph/javascript/md5.js\n    var buf = [];\n    switch (s.t & 6) {\n    default:\n      caml_convert_string_to_bytes(s);\n    case 0: /* BYTES */\n      var b = s.c;\n      for (var i = 0; i < len; i+=4) {\n        var j = i + ofs;\n        buf[i>>2] =\n          b.charCodeAt(j) | (b.charCodeAt(j+1) << 8) |\n          (b.charCodeAt(j+2) << 16) | (b.charCodeAt(j+3) << 24);\n      }\n      for (; i < len; i++) buf[i>>2] |= b.charCodeAt(i + ofs) << (8 * (i & 3));\n      break;\n    case 4: /* ARRAY */\n      var a = s.c;\n      for (var i = 0; i < len; i+=4) {\n        var j = i + ofs;\n        buf[i>>2] = a[j] | (a[j+1] << 8) | (a[j+2] << 16) | (a[j+3] << 24);\n      }\n      for (; i < len; i++) buf[i>>2] |= a[i + ofs] << (8 * (i & 3));\n    }\n    return caml_string_of_array(md5(buf, len));\n  }\n} ();\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* The run-time library for lexers generated by camllex *)\n\ntype position = {\n  pos_fname : string;\n  pos_lnum : int;\n  pos_bol : int;\n  pos_cnum : int;\n}\n\nlet dummy_pos = {\n  pos_fname = \"\";\n  pos_lnum = 0;\n  pos_bol = 0;\n  pos_cnum = -1;\n}\n\ntype lexbuf =\n  { refill_buff : lexbuf -> unit;\n    mutable lex_buffer : bytes;\n    mutable lex_buffer_len : int;\n    mutable lex_abs_pos : int;\n    mutable lex_start_pos : int;\n    mutable lex_curr_pos : int;\n    mutable lex_last_pos : int;\n    mutable lex_last_action : int;\n    mutable lex_eof_reached : bool;\n    mutable lex_mem : int array;\n    mutable lex_start_p : position;\n    mutable lex_curr_p : position;\n  }\n\ntype lex_tables =\n  { lex_base: string;\n    lex_backtrk: string;\n    lex_default: string;\n    lex_trans: string;\n    lex_check: string;\n    lex_base_code : string;\n    lex_backtrk_code : string;\n    lex_default_code : string;\n    lex_trans_code : string;\n    lex_check_code : string;\n    lex_code: string;}\n\nexternal c_engine : lex_tables -> int -> lexbuf -> int = \"caml_lex_engine\"\nexternal c_new_engine : lex_tables -> int -> lexbuf -> int\n                      = \"caml_new_lex_engine\"\n\nlet engine tbl state buf =\n  let result = c_engine tbl state buf in\n  if result >= 0 then begin\n    buf.lex_start_p <- buf.lex_curr_p;\n    buf.lex_curr_p <- {buf.lex_curr_p\n                       with pos_cnum = buf.lex_abs_pos + buf.lex_curr_pos};\n  end;\n  result\n\n\nlet new_engine tbl state buf =\n  let result = c_new_engine tbl state buf in\n  if result >= 0 then begin\n    buf.lex_start_p <- buf.lex_curr_p;\n    buf.lex_curr_p <- {buf.lex_curr_p\n                       with pos_cnum = buf.lex_abs_pos + buf.lex_curr_pos};\n  end;\n  result\n\n\nlet lex_refill read_fun aux_buffer lexbuf =\n  let read =\n    read_fun aux_buffer (Bytes.length aux_buffer) in\n  let n =\n    if read > 0\n    then read\n    else (lexbuf.lex_eof_reached <- true; 0) in\n  (* Current state of the buffer:\n        <-------|---------------------|----------->\n        |  junk |      valid data     |   junk    |\n        ^       ^                     ^           ^\n        0    start_pos             buffer_end    Bytes.length buffer\n  *)\n  if lexbuf.lex_buffer_len + n > Bytes.length lexbuf.lex_buffer then begin\n    (* There is not enough space at the end of the buffer *)\n    if lexbuf.lex_buffer_len - lexbuf.lex_start_pos + n\n       <= Bytes.length lexbuf.lex_buffer\n    then begin\n      (* But there is enough space if we reclaim the junk at the beginning\n         of the buffer *)\n      Bytes.blit lexbuf.lex_buffer lexbuf.lex_start_pos\n                  lexbuf.lex_buffer 0\n                  (lexbuf.lex_buffer_len - lexbuf.lex_start_pos)\n    end else begin\n      (* We must grow the buffer.  Doubling its size will provide enough\n         space since n <= String.length aux_buffer <= String.length buffer.\n         Watch out for string length overflow, though. *)\n      let newlen =\n        min (2 * Bytes.length lexbuf.lex_buffer) Sys.max_string_length in\n      if lexbuf.lex_buffer_len - lexbuf.lex_start_pos + n > newlen\n      then failwith \"Lexing.lex_refill: cannot grow buffer\";\n      let newbuf = Bytes.create newlen in\n      (* Copy the valid data to the beginning of the new buffer *)\n      Bytes.blit lexbuf.lex_buffer lexbuf.lex_start_pos\n                  newbuf 0\n                  (lexbuf.lex_buffer_len - lexbuf.lex_start_pos);\n      lexbuf.lex_buffer <- newbuf\n    end;\n    (* Reallocation or not, we have shifted the data left by\n       start_pos characters; update the positions *)\n    let s = lexbuf.lex_start_pos in\n    lexbuf.lex_abs_pos <- lexbuf.lex_abs_pos + s;\n    lexbuf.lex_curr_pos <- lexbuf.lex_curr_pos - s;\n    lexbuf.lex_start_pos <- 0;\n    lexbuf.lex_last_pos <- lexbuf.lex_last_pos - s;\n    lexbuf.lex_buffer_len <- lexbuf.lex_buffer_len - s ;\n    let t = lexbuf.lex_mem in\n    for i = 0 to Array.length t-1 do\n      let v = t.(i) in\n      if v >= 0 then\n        t.(i) <- v-s\n    done\n  end;\n  (* There is now enough space at the end of the buffer *)\n  Bytes.blit aux_buffer 0 lexbuf.lex_buffer lexbuf.lex_buffer_len n;\n  lexbuf.lex_buffer_len <- lexbuf.lex_buffer_len + n\n\nlet zero_pos = {\n  pos_fname = \"\";\n  pos_lnum = 1;\n  pos_bol = 0;\n  pos_cnum = 0;\n}\n\nlet from_function f =\n  { refill_buff = lex_refill f (Bytes.create 512);\n    lex_buffer = Bytes.create 1024;\n    lex_buffer_len = 0;\n    lex_abs_pos = 0;\n    lex_start_pos = 0;\n    lex_curr_pos = 0;\n    lex_last_pos = 0;\n    lex_last_action = 0;\n    lex_mem = [||];\n    lex_eof_reached = false;\n    lex_start_p = zero_pos;\n    lex_curr_p = zero_pos;\n  }\n\nlet from_channel ic =\n  from_function (fun buf n -> input ic buf 0 n)\n\nlet from_string s =\n  { refill_buff = (fun lexbuf -> lexbuf.lex_eof_reached <- true);\n    lex_buffer = Bytes.of_string s; (* have to make a copy for compatibility\n                                       with unsafe-string mode *)\n    lex_buffer_len = String.length s;\n    lex_abs_pos = 0;\n    lex_start_pos = 0;\n    lex_curr_pos = 0;\n    lex_last_pos = 0;\n    lex_last_action = 0;\n    lex_mem = [||];\n    lex_eof_reached = true;\n    lex_start_p = zero_pos;\n    lex_curr_p = zero_pos;\n  }\n\nlet lexeme lexbuf =\n  let len = lexbuf.lex_curr_pos - lexbuf.lex_start_pos in\n  Bytes.sub_string lexbuf.lex_buffer lexbuf.lex_start_pos len\n\nlet sub_lexeme lexbuf i1 i2 =\n  let len = i2-i1 in\n  Bytes.sub_string lexbuf.lex_buffer i1 len\n\nlet sub_lexeme_opt lexbuf i1 i2 =\n  if i1 >= 0 then begin\n    let len = i2-i1 in\n    Some (Bytes.sub_string lexbuf.lex_buffer i1 len)\n  end else begin\n    None\n  end\n\nlet sub_lexeme_char lexbuf i = Bytes.get lexbuf.lex_buffer i\n\nlet sub_lexeme_char_opt lexbuf i =\n  if i >= 0 then\n    Some (Bytes.get lexbuf.lex_buffer i)\n  else\n    None\n\n\nlet lexeme_char lexbuf i =\n  Bytes.get lexbuf.lex_buffer (lexbuf.lex_start_pos + i)\n\nlet lexeme_start lexbuf = lexbuf.lex_start_p.pos_cnum\nlet lexeme_end lexbuf = lexbuf.lex_curr_p.pos_cnum\n\nlet lexeme_start_p lexbuf = lexbuf.lex_start_p\nlet lexeme_end_p lexbuf = lexbuf.lex_curr_p\n\nlet new_line lexbuf =\n  let lcp = lexbuf.lex_curr_p in\n  lexbuf.lex_curr_p <- { lcp with\n    pos_lnum = lcp.pos_lnum + 1;\n    pos_bol = lcp.pos_cnum;\n  }\n\n\n\n(* Discard data left in lexer buffer. *)\n\nlet flush_input lb =\n  lb.lex_curr_pos <- 0;\n  lb.lex_abs_pos <- 0;\n  lb.lex_curr_p <- {lb.lex_curr_p with pos_cnum = 0};\n  lb.lex_buffer_len <- 0;\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\n\n(******************************************************************************)\n           (* Tools to manipulate scanning set of chars (see %[...]) *)\n\ntype mutable_char_set = bytes\n\n(* Create a fresh, empty, mutable char set. *)\nlet create_char_set () = Bytes.make 32 '\\000'\n\n(* Add a char in a mutable char set. *)\nlet add_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  Bytes.set char_set str_ind\n    (char_of_int (int_of_char (Bytes.get char_set str_ind) lor mask))\n\nlet freeze_char_set char_set =\n  Bytes.to_string char_set\n\n(* Compute the complement of a char set. *)\nlet rev_char_set char_set =\n  let char_set' = create_char_set () in\n  for i = 0 to 31 do\n    Bytes.set char_set' i\n      (char_of_int (int_of_char (String.get char_set i) lxor 0xFF));\n  done;\n  Bytes.unsafe_to_string char_set'\n\n(* Return true if a `c' is in `char_set'. *)\nlet is_in_char_set char_set c =\n  let ind = int_of_char c in\n  let str_ind = ind lsr 3 and mask = 1 lsl (ind land 0b111) in\n  (int_of_char (String.get char_set str_ind) land mask) <> 0\n\n\n(******************************************************************************)\n                         (* Ignored param conversion *)\n\n(* GADT used to abstract an existential type parameter. *)\n(* See param_format_of_ignored_format. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb = Param_format_EBB :\n    ('x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    ('a, 'b, 'c, 'd, 'e, 'f) param_format_ebb\n\n(* Compute a padding associated to a pad_option (see \"%_42d\"). *)\nlet pad_of_pad_opt pad_opt = match pad_opt with\n  | None -> No_padding\n  | Some width -> Lit_padding (Right, width)\n\n(* Compute a precision associated to a prec_option (see \"%_.42f\"). *)\nlet prec_of_prec_opt prec_opt = match prec_opt with\n  | None -> No_precision\n  | Some ndec -> Lit_precision ndec\n\n(* Turn an ignored param into its equivalent not-ignored format node. *)\n(* Used for format pretty-printing and Scanf. *)\nlet param_format_of_ignored_format : type a b c d e f x y .\n    (a, b, c, d, y, x) ignored -> (x, b, c, y, e, f) fmt ->\n      (a, b, c, d, e, f) param_format_ebb =\nfun ign fmt -> match ign with\n  | Ignored_char ->\n    Param_format_EBB (Char fmt)\n  | Ignored_caml_char ->\n    Param_format_EBB (Caml_char fmt)\n  | Ignored_string pad_opt ->\n    Param_format_EBB (String (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_caml_string pad_opt ->\n    Param_format_EBB (Caml_string (pad_of_pad_opt pad_opt, fmt))\n  | Ignored_int (iconv, pad_opt) ->\n    Param_format_EBB (Int (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int32 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int32 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_nativeint (iconv, pad_opt) ->\n    Param_format_EBB\n      (Nativeint (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_int64 (iconv, pad_opt) ->\n    Param_format_EBB\n      (Int64 (iconv, pad_of_pad_opt pad_opt, No_precision, fmt))\n  | Ignored_float (pad_opt, prec_opt) ->\n    Param_format_EBB\n      (Float (Float_f, pad_of_pad_opt pad_opt, prec_of_prec_opt prec_opt, fmt))\n  | Ignored_bool ->\n    Param_format_EBB (Bool fmt)\n  | Ignored_format_arg (pad_opt, fmtty) ->\n    Param_format_EBB (Format_arg (pad_opt, fmtty, fmt))\n  | Ignored_format_subst (pad_opt, fmtty) ->\n    Param_format_EBB\n      (Format_subst (pad_opt, fmtty, fmt))\n  | Ignored_reader ->\n    Param_format_EBB (Reader fmt)\n  | Ignored_scan_char_set (width_opt, char_set) ->\n    Param_format_EBB (Scan_char_set (width_opt, char_set, fmt))\n  | Ignored_scan_get_counter counter ->\n    Param_format_EBB (Scan_get_counter (counter, fmt))\n  | Ignored_scan_next_char ->\n    Param_format_EBB (Scan_next_char fmt)\n\n\n(******************************************************************************)\n                                 (* Types *)\n\ntype ('b, 'c) acc_formatting_gen =\n  | Acc_open_tag of ('b, 'c) acc\n  | Acc_open_box of ('b, 'c) acc\n\n(* Reversed list of printing atoms. *)\n(* Used to accumulate printf arguments. *)\nand ('b, 'c) acc =\n  | Acc_formatting_lit of ('b, 'c) acc * formatting_lit\n      (* Special fmtting (box) *)\n  | Acc_formatting_gen of ('b, 'c) acc * ('b, 'c) acc_formatting_gen\n      (* Special fmtting (box) *)\n  | Acc_string_literal of ('b, 'c) acc * string     (* Literal string *)\n  | Acc_char_literal   of ('b, 'c) acc * char       (* Literal char *)\n  | Acc_data_string    of ('b, 'c) acc * string     (* Generated string *)\n  | Acc_data_char      of ('b, 'c) acc * char       (* Generated char *)\n  | Acc_delay          of ('b, 'c) acc * ('b -> 'c)\n                                                (* Delayed printing (%a, %t) *)\n  | Acc_flush          of ('b, 'c) acc              (* Flush *)\n  | Acc_invalid_arg    of ('b, 'c) acc * string\n      (* Raise Invalid_argument msg *)\n  | End_of_acc\n\n(* List of heterogeneous values. *)\n(* Used to accumulate scanf callback arguments. *)\ntype ('a, 'b) heter_list =\n  | Cons : 'c * ('a, 'b) heter_list -> ('c -> 'a, 'b) heter_list\n  | Nil : ('b, 'b) heter_list\n\n(* Existential Black Boxes. *)\n(* Used to abstract some existential type parameters. *)\n\n(* GADT type associating a padding and an fmtty. *)\n(* See the type_padding function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb = Padding_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padding_fmtty_ebb\n\n(* GADT type associating a padding, a precision and an fmtty. *)\n(* See the type_padprec function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb = Padprec_fmtty_EBB :\n     ('x, 'y) padding * ('y, 'z) precision * ('z, 'b, 'c, 'd, 'e, 'f) fmtty ->\n     ('x, 'b, 'c, 'd, 'e, 'f) padprec_fmtty_ebb\n\n(* GADT type associating a padding and an fmt. *)\n(* See make_padding_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) padding_fmt_ebb = Padding_fmt_EBB :\n     (_, 'x -> 'a) padding *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) padding_fmt_ebb\n\n(* GADT type associating a precision and an fmt. *)\n(* See make_precision_fmt_ebb and parse_format functions. *)\ntype ('a, 'b, 'c, 'e, 'f) precision_fmt_ebb = Precision_fmt_EBB :\n     (_, 'x -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('x, 'b, 'c, 'e, 'f) precision_fmt_ebb\n\n(* GADT type associating a padding, a precision and an fmt. *)\n(* See make_padprec_fmt_ebb and parse_format functions. *)\ntype ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb = Padprec_fmt_EBB :\n     ('x, 'y) padding * ('y, 'p -> 'a) precision *\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('p, 'b, 'c, 'e, 'f) padprec_fmt_ebb\n\n(* Abstract the 'a and 'd parameters of an fmt. *)\n(* Output type of the format parsing function. *)\ntype ('b, 'c, 'e, 'f) fmt_ebb = Fmt_EBB :\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n     ('b, 'c, 'e, 'f) fmt_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_format_gen function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb = Fmt_fmtty_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmt *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmtty ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmt_fmtty_ebb\n\n(* GADT type associating an fmtty and an fmt. *)\n(* See the type_ignored_format_substitution function. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb = Fmtty_fmt_EBB :\n     ('a, 'b, 'c, 'd, 'y, 'x) fmtty *\n     ('x, 'b, 'c, 'y, 'e, 'f) fmt_fmtty_ebb ->\n     ('a, 'b, 'c, 'd, 'e, 'f) fmtty_fmt_ebb\n\n(* Abstract all fmtty type parameters. *)\n(* Used to compare format types. *)\ntype fmtty_ebb = Fmtty_EBB : ('a, 'b, 'c, 'd, 'e, 'f) fmtty -> fmtty_ebb\n\n(* Abstract all padding type parameters. *)\n(* Used to compare paddings. *)\ntype padding_ebb = Padding_EBB : ('a, 'b) padding -> padding_ebb\n\n(* Abstract all precision type parameters. *)\n(* Used to compare precisions. *)\ntype precision_ebb = Precision_EBB : ('a, 'b) precision -> precision_ebb\n\n(******************************************************************************)\n                               (* Constants *)\n\n(* Default precision for float printing. *)\nlet default_float_precision = -6\n  (* For %h and %H formats, a negative precision means \"as many digits as\n     necessary\".  For the other FP formats, we take the absolute value\n     of the precision, hence 6 digits by default. *)\n\n(******************************************************************************)\n                               (* Externals *)\n\nexternal format_float: string -> float -> string\n  = \"caml_format_float\"\nexternal format_int: string -> int -> string\n  = \"caml_format_int\"\nexternal format_int32: string -> int32 -> string\n  = \"caml_int32_format\"\nexternal format_nativeint: string -> nativeint -> string\n  = \"caml_nativeint_format\"\nexternal format_int64: string -> int64 -> string\n  = \"caml_int64_format\"\nexternal hexstring_of_float: float -> int -> char -> string\n  = \"caml_hexstring_of_float\"\n\n(******************************************************************************)\n                     (* Tools to pretty-print formats *)\n\n(* Type of extensible character buffers. *)\ntype buffer = {\n  mutable ind : int;\n  mutable bytes : bytes;\n}\n\n(* Create a fresh buffer. *)\nlet buffer_create init_size = { ind = 0; bytes = Bytes.create init_size }\n\n(* Check size of the buffer and grow it if needed. *)\nlet buffer_check_size buf overhead =\n  let len = Bytes.length buf.bytes in\n  let min_len = buf.ind + overhead in\n  if min_len > len then (\n    let new_len = max (len * 2) min_len in\n    let new_str = Bytes.create new_len in\n    Bytes.blit buf.bytes 0 new_str 0 len;\n    buf.bytes <- new_str;\n  )\n\n(* Add the character `c' to the buffer `buf'. *)\nlet buffer_add_char buf c =\n  buffer_check_size buf 1;\n  Bytes.set buf.bytes buf.ind c;\n  buf.ind <- buf.ind + 1\n\n(* Add the string `s' to the buffer `buf'. *)\nlet buffer_add_string buf s =\n  let str_len = String.length s in\n  buffer_check_size buf str_len;\n  String.blit s 0 buf.bytes buf.ind str_len;\n  buf.ind <- buf.ind + str_len\n\n(* Get the content of the buffer. *)\nlet buffer_contents buf =\n  Bytes.sub_string buf.bytes 0 buf.ind\n\n(***)\n\n(* Convert an integer conversion to char. *)\nlet char_of_iconv iconv = match iconv with\n  | Int_d | Int_pd | Int_sd -> 'd' | Int_i | Int_pi | Int_si -> 'i'\n  | Int_x | Int_Cx -> 'x' | Int_X | Int_CX -> 'X' | Int_o | Int_Co -> 'o'\n  | Int_u -> 'u'\n\n(* Convert a float conversion to char. *)\nlet char_of_fconv fconv = match fconv with\n  | Float_f | Float_pf | Float_sf -> 'f' | Float_e | Float_pe | Float_se -> 'e'\n  | Float_E | Float_pE | Float_sE -> 'E' | Float_g | Float_pg | Float_sg -> 'g'\n  | Float_G | Float_pG | Float_sG -> 'G' | Float_F -> 'F'\n  | Float_h | Float_ph | Float_sh -> 'h' | Float_H | Float_pH | Float_sH -> 'H'\n\n\n(* Convert a scanning counter to char. *)\nlet char_of_counter counter = match counter with\n  | Line_counter  -> 'l'\n  | Char_counter  -> 'n'\n  | Token_counter -> 'N'\n\n(***)\n\n(* Print a char_set in a buffer with the OCaml format lexical convention. *)\nlet bprint_char_set buf char_set =\n  let rec print_start set =\n    let is_alone c =\n      let before, after = Char.(chr (code c - 1), chr (code c + 1)) in\n      is_in_char_set set c\n      && not (is_in_char_set set before && is_in_char_set set after) in\n    if is_alone ']' then buffer_add_char buf ']';\n    print_out set 1;\n    if is_alone '-' then buffer_add_char buf '-';\n  and print_out set i =\n    if i < 256 then\n      if is_in_char_set set (char_of_int i) then print_first set i\n      else print_out set (i + 1)\n  and print_first set i =\n    match char_of_int i with\n    | '\\255' -> print_char buf 255;\n    | ']' | '-' -> print_out set (i + 1);\n    | _ -> print_second set (i + 1);\n  and print_second set i =\n    if is_in_char_set set (char_of_int i) then\n      match char_of_int i with\n      | '\\255' ->\n        print_char buf 254;\n        print_char buf 255;\n      | ']' | '-' when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_out set (i + 1);\n      | _ when not (is_in_char_set set (char_of_int (i + 1))) ->\n        print_char buf (i - 1);\n        print_char buf i;\n        print_out set (i + 2);\n      | _ ->\n        print_in set (i - 1) (i + 2);\n    else (\n      print_char buf (i - 1);\n      print_out set (i + 1);\n    )\n  and print_in set i j =\n    if j = 256 || not (is_in_char_set set (char_of_int j)) then (\n      print_char buf i;\n      print_char buf (int_of_char '-');\n      print_char buf (j - 1);\n      if j < 256 then print_out set (j + 1);\n    ) else\n      print_in set i (j + 1);\n  and print_char buf i = match char_of_int i with\n    | '%' -> buffer_add_char buf '%'; buffer_add_char buf '%';\n    | '@' -> buffer_add_char buf '%'; buffer_add_char buf '@';\n    | c   -> buffer_add_char buf c;\n  in\n  buffer_add_char buf '[';\n  print_start (\n    if is_in_char_set char_set '\\000'\n    then ( buffer_add_char buf '^'; rev_char_set char_set )\n    else char_set\n  );\n  buffer_add_char buf ']'\n\n(***)\n\n(* Print a padty in a buffer with the format-like syntax. *)\nlet bprint_padty buf padty = match padty with\n  | Left  -> buffer_add_char buf '-'\n  | Right -> ()\n  | Zeros -> buffer_add_char buf '0'\n\n(* Print the '_' of an ignored flag if needed. *)\nlet bprint_ignored_flag buf ign_flag =\n  if ign_flag then buffer_add_char buf '_'\n\n(***)\n\nlet bprint_pad_opt buf pad_opt = match pad_opt with\n  | None -> ()\n  | Some width -> buffer_add_string buf (string_of_int width)\n\n(***)\n\n(* Print padding in a buffer with the format-like syntax. *)\nlet bprint_padding : type a b . buffer -> (a, b) padding -> unit =\nfun buf pad -> match pad with\n  | No_padding -> ()\n  | Lit_padding (padty, n) ->\n    bprint_padty buf padty;\n    buffer_add_string buf (string_of_int n);\n  | Arg_padding padty ->\n    bprint_padty buf padty;\n    buffer_add_char buf '*'\n\n(* Print precision in a buffer with the format-like syntax. *)\nlet bprint_precision : type a b . buffer -> (a, b) precision -> unit =\n  fun buf prec -> match prec with\n  | No_precision -> ()\n  | Lit_precision n ->\n    buffer_add_char buf '.';\n    buffer_add_string buf (string_of_int n);\n  | Arg_precision ->\n    buffer_add_string buf \".*\"\n\n(***)\n\n(* Print the optionnal '+', ' ' or '#' associated to an int conversion. *)\nlet bprint_iconv_flag buf iconv = match iconv with\n  | Int_pd | Int_pi -> buffer_add_char buf '+'\n  | Int_sd | Int_si -> buffer_add_char buf ' '\n  | Int_Cx | Int_CX | Int_Co -> buffer_add_char buf '#'\n  | Int_d | Int_i | Int_x | Int_X | Int_o | Int_u -> ()\n\n(* Print an complete int format in a buffer (ex: \"%3.*d\"). *)\nlet bprint_int_fmt buf ign_flag iconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(* Print a complete int32, nativeint or int64 format in a buffer. *)\nlet bprint_altint_fmt buf ign_flag iconv pad prec c =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_iconv_flag buf iconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf c;\n  buffer_add_char buf (char_of_iconv iconv)\n\n(***)\n\n(* Print the optionnal '+' associated to a float conversion. *)\nlet bprint_fconv_flag buf fconv = match fconv with\n  | Float_pf | Float_pe | Float_pE\n  | Float_pg | Float_pG | Float_ph | Float_pH ->\n    buffer_add_char buf '+'\n  | Float_sf | Float_se | Float_sE\n  | Float_sg | Float_sG | Float_sh | Float_sH ->\n    buffer_add_char buf ' '\n  | Float_f | Float_e | Float_E\n  | Float_g | Float_G | Float_F | Float_h | Float_H ->\n    ()\n\n(* Print a complete float format in a buffer (ex: \"%+*.3f\"). *)\nlet bprint_float_fmt buf ign_flag fconv pad prec =\n  buffer_add_char buf '%';\n  bprint_ignored_flag buf ign_flag;\n  bprint_fconv_flag buf fconv;\n  bprint_padding buf pad;\n  bprint_precision buf prec;\n  buffer_add_char buf (char_of_fconv fconv)\n\n(* Compute the literal string representation of a formatting_lit. *)\n(* Also used by Printf and Scanf where formatting is not interpreted. *)\nlet string_of_formatting_lit formatting_lit = match formatting_lit with\n  | Close_box            -> \"@]\"\n  | Close_tag            -> \"@}\"\n  | Break (str, _, _)    -> str\n  | FFlush               -> \"@?\"\n  | Force_newline        -> \"@\\n\"\n  | Flush_newline        -> \"@.\"\n  | Magic_size (str, _)  -> str\n  | Escaped_at           -> \"@@\"\n  | Escaped_percent      -> \"@%\"\n  | Scan_indic c -> \"@\" ^ (String.make 1 c)\n\n(* Compute the literal string representation of a formatting. *)\n(* Also used by Printf and Scanf where formatting is not interpreted. *)\nlet string_of_formatting_gen : type a b c d e f .\n    (a, b, c, d, e, f) formatting_gen -> string =\n  fun formatting_gen -> match formatting_gen with\n  | Open_tag (Format (_, str)) -> str\n  | Open_box (Format (_, str)) -> str\n\n(***)\n\n(* Print a literal char in a buffer, escape '%' by \"%%\". *)\nlet bprint_char_literal buf chr = match chr with\n  | '%' -> buffer_add_string buf \"%%\"\n  | _ -> buffer_add_char buf chr\n\n(* Print a literal string in a buffer, escape all '%' by \"%%\". *)\nlet bprint_string_literal buf str =\n  for i = 0 to String.length str - 1 do\n    bprint_char_literal buf str.[i]\n  done\n\n(******************************************************************************)\n                          (* Format pretty-printing *)\n\n(* Print a complete format type (an fmtty) in a buffer. *)\nlet rec bprint_fmtty : type a b c d e f g h i j k l .\n    buffer -> (a, b, c, d, e, f, g, h, i, j, k, l) fmtty_rel -> unit =\nfun buf fmtty -> match fmtty with\n  | Char_ty rest      -> buffer_add_string buf \"%c\";  bprint_fmtty buf rest;\n  | String_ty rest    -> buffer_add_string buf \"%s\";  bprint_fmtty buf rest;\n  | Int_ty rest       -> buffer_add_string buf \"%i\";  bprint_fmtty buf rest;\n  | Int32_ty rest     -> buffer_add_string buf \"%li\"; bprint_fmtty buf rest;\n  | Nativeint_ty rest -> buffer_add_string buf \"%ni\"; bprint_fmtty buf rest;\n  | Int64_ty rest     -> buffer_add_string buf \"%Li\"; bprint_fmtty buf rest;\n  | Float_ty rest     -> buffer_add_string buf \"%f\";  bprint_fmtty buf rest;\n  | Bool_ty rest      -> buffer_add_string buf \"%B\";  bprint_fmtty buf rest;\n  | Alpha_ty rest     -> buffer_add_string buf \"%a\";  bprint_fmtty buf rest;\n  | Theta_ty rest     -> buffer_add_string buf \"%t\";  bprint_fmtty buf rest;\n  | Any_ty rest       -> buffer_add_string buf \"%?\";  bprint_fmtty buf rest;\n  | Reader_ty rest    -> buffer_add_string buf \"%r\";  bprint_fmtty buf rest;\n\n  | Ignored_reader_ty rest ->\n    buffer_add_string buf \"%_r\";\n    bprint_fmtty buf rest;\n\n  | Format_arg_ty (sub_fmtty, rest) ->\n    buffer_add_string buf \"%{\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%}\"; bprint_fmtty buf rest;\n  | Format_subst_ty (sub_fmtty, _, rest) ->\n    buffer_add_string buf \"%(\"; bprint_fmtty buf sub_fmtty;\n    buffer_add_string buf \"%)\"; bprint_fmtty buf rest;\n\n  | End_of_fmtty -> ()\n\n(***)\n\nlet rec int_of_custom_arity : type a b c .\n  (a, b, c) custom_arity -> int =\n  function\n  | Custom_zero -> 0\n  | Custom_succ x -> 1 + int_of_custom_arity x\n\n(* Print a complete format in a buffer. *)\nlet bprint_fmt buf fmt =\n  let rec fmtiter : type a b c d e f .\n      (a, b, c, d, e, f) fmt -> bool -> unit =\n  fun fmt ign_flag -> match fmt with\n    | String (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 's';\n      fmtiter rest false;\n    | Caml_string (pad, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_padding buf pad; buffer_add_char buf 'S';\n      fmtiter rest false;\n\n    | Int (iconv, pad, prec, rest) ->\n      bprint_int_fmt buf ign_flag iconv pad prec;\n      fmtiter rest false;\n    | Int32 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'l';\n      fmtiter rest false;\n    | Nativeint (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'n';\n      fmtiter rest false;\n    | Int64 (iconv, pad, prec, rest) ->\n      bprint_altint_fmt buf ign_flag iconv pad prec 'L';\n      fmtiter rest false;\n    | Float (fconv, pad, prec, rest) ->\n      bprint_float_fmt buf ign_flag fconv pad prec;\n      fmtiter rest false;\n\n    | Char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'c'; fmtiter rest false;\n    | Caml_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'C'; fmtiter rest false;\n    | Bool rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'B'; fmtiter rest false;\n    | Alpha rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'a'; fmtiter rest false;\n    | Theta rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 't'; fmtiter rest false;\n    | Custom (arity, _, rest) ->\n      for _i = 1 to int_of_custom_arity arity do\n        buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n        buffer_add_char buf '?';\n      done;\n      fmtiter rest false;\n    | Reader rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf 'r'; fmtiter rest false;\n    | Flush rest ->\n      buffer_add_string buf \"%!\";\n      fmtiter rest ign_flag;\n\n    | String_literal (str, rest) ->\n      bprint_string_literal buf str;\n      fmtiter rest ign_flag;\n    | Char_literal (chr, rest) ->\n      bprint_char_literal buf chr;\n      fmtiter rest ign_flag;\n\n    | Format_arg (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '{';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf '}';\n      fmtiter rest false;\n    | Format_subst (pad_opt, fmtty, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf pad_opt; buffer_add_char buf '(';\n      bprint_fmtty buf fmtty; buffer_add_char buf '%'; buffer_add_char buf ')';\n      fmtiter rest false;\n\n    | Scan_char_set (width_opt, char_set, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_pad_opt buf width_opt; bprint_char_set buf char_set;\n      fmtiter rest false;\n    | Scan_get_counter (counter, rest) ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      buffer_add_char buf (char_of_counter counter);\n      fmtiter rest false;\n    | Scan_next_char rest ->\n      buffer_add_char buf '%'; bprint_ignored_flag buf ign_flag;\n      bprint_string_literal buf \"0c\"; fmtiter rest false;\n\n    | Ignored_param (ign, rest) ->\n      let Param_format_EBB fmt' = param_format_of_ignored_format ign rest in\n      fmtiter fmt' true;\n\n    | Formatting_lit (fmting_lit, rest) ->\n      bprint_string_literal buf (string_of_formatting_lit fmting_lit);\n      fmtiter rest ign_flag;\n    | Formatting_gen (fmting_gen, rest) ->\n      bprint_string_literal buf \"@{\";\n      bprint_string_literal buf (string_of_formatting_gen fmting_gen);\n      fmtiter rest ign_flag;\n\n    | End_of_format -> ()\n\n  in fmtiter fmt false\n\n(***)\n\n(* Convert a format to string. *)\nlet string_of_fmt fmt =\n  let buf = buffer_create 16 in\n  bprint_fmt buf fmt;\n  buffer_contents buf\n\n(******************************************************************************)\n                          (* Type extraction *)\n\ntype (_, _) eq = Refl : ('a, 'a) eq\n\n(* Invariant: this function is the identity on values.\n\n   In particular, if (ty1, ty2) have equal values, then\n   (trans (symm ty1) ty2) respects the 'trans' precondition. *)\nlet rec symm : type a1 b1 c1 d1 e1 f1 a2 b2 c2 d2 e2 f2 .\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a1, b1, c1, d1, e1, f1) fmtty_rel\n= function\n  | Char_ty rest -> Char_ty (symm rest)\n  | Int_ty rest -> Int_ty (symm rest)\n  | Int32_ty rest -> Int32_ty (symm rest)\n  | Int64_ty rest -> Int64_ty (symm rest)\n  | Nativeint_ty rest -> Nativeint_ty (symm rest)\n  | Float_ty rest -> Float_ty (symm rest)\n  | Bool_ty rest -> Bool_ty (symm rest)\n  | String_ty rest -> String_ty (symm rest)\n  | Theta_ty rest -> Theta_ty (symm rest)\n  | Alpha_ty rest -> Alpha_ty (symm rest)\n  | Any_ty rest -> Any_ty (symm rest)\n  | Reader_ty rest -> Reader_ty (symm rest)\n  | Ignored_reader_ty rest -> Ignored_reader_ty (symm rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, symm rest)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty2, ty1, symm rest)\n  | End_of_fmtty -> End_of_fmtty\n\nlet rec fmtty_rel_det : type a1 b c d1 e1 f1 a2 d2 e2 f2 .\n  (a1, b, c, d1, e1, f1,\n   a2, b, c, d2, e2, f2) fmtty_rel ->\n    ((f1, f2) eq -> (a1, a2) eq)\n  * ((a1, a2) eq -> (f1, f2) eq)\n  * ((e1, e2) eq -> (d1, d2) eq)\n  * ((d1, d2) eq -> (e1, e2) eq)\n= function\n  | End_of_fmtty ->\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl),\n    (fun Refl -> Refl)\n  | Char_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | String_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int32_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Int64_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Nativeint_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Float_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Bool_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n\n  | Theta_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Alpha_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Any_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Ignored_reader_ty rest ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in Refl),\n    (fun Refl -> let Refl = de Refl in Refl)\n  | Format_arg_ty (_ty, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    (fun Refl -> let Refl = fa Refl in Refl),\n    (fun Refl -> let Refl = af Refl in Refl),\n    ed, de\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let fa, af, ed, de = fmtty_rel_det rest in\n    let ty = trans (symm ty1) ty2 in\n    let ag, ga, dj, jd = fmtty_rel_det ty in\n    (fun Refl -> let Refl = fa Refl in let Refl = ag Refl in Refl),\n    (fun Refl -> let Refl = ga Refl in let Refl = af Refl in Refl),\n    (fun Refl -> let Refl = ed Refl in let Refl = dj Refl in Refl),\n    (fun Refl -> let Refl = jd Refl in let Refl = de Refl in Refl)\n\n(* Precondition: we assume that the two fmtty_rel arguments have equal\n   values (at possibly distinct types); this invariant comes from the way\n   fmtty_rel witnesses are produced by the type-checker\n\n   The code below uses (assert false) when this assumption is broken. The\n   code pattern is the following:\n\n     | Foo x, Foo y ->\n       (* case where indeed both values\n          start with constructor Foo *)\n     | Foo _, _\n     | _, Foo _ ->\n       (* different head constructors: broken precondition *)\n       assert false\n*)\nand trans : type\n  a1 b1 c1 d1 e1 f1\n  a2 b2 c2 d2 e2 f2\n  a3 b3 c3 d3 e3 f3\n.\n   (a1, b1, c1, d1, e1, f1,\n    a2, b2, c2, d2, e2, f2) fmtty_rel\n-> (a2, b2, c2, d2, e2, f2,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n-> (a1, b1, c1, d1, e1, f1,\n    a3, b3, c3, d3, e3, f3) fmtty_rel\n= fun ty1 ty2 -> match ty1, ty2 with\n  | Char_ty rest1, Char_ty rest2 -> Char_ty (trans rest1 rest2)\n  | String_ty rest1, String_ty rest2 -> String_ty (trans rest1 rest2)\n  | Bool_ty rest1, Bool_ty rest2 -> Bool_ty (trans rest1 rest2)\n  | Int_ty rest1, Int_ty rest2 -> Int_ty (trans rest1 rest2)\n  | Int32_ty rest1, Int32_ty rest2 -> Int32_ty (trans rest1 rest2)\n  | Int64_ty rest1, Int64_ty rest2 -> Int64_ty (trans rest1 rest2)\n  | Nativeint_ty rest1, Nativeint_ty rest2 -> Nativeint_ty (trans rest1 rest2)\n  | Float_ty rest1, Float_ty rest2 -> Float_ty (trans rest1 rest2)\n\n  | Alpha_ty rest1, Alpha_ty rest2 -> Alpha_ty (trans rest1 rest2)\n  | Alpha_ty _, _ -> assert false\n  | _, Alpha_ty _ -> assert false\n\n  | Theta_ty rest1, Theta_ty rest2 -> Theta_ty (trans rest1 rest2)\n  | Theta_ty _, _ -> assert false\n  | _, Theta_ty _ -> assert false\n\n  | Any_ty rest1, Any_ty rest2 -> Any_ty (trans rest1 rest2)\n  | Any_ty _, _ -> assert false\n  | _, Any_ty _ -> assert false\n\n  | Reader_ty rest1, Reader_ty rest2 -> Reader_ty (trans rest1 rest2)\n  | Reader_ty _, _ -> assert false\n  | _, Reader_ty _ -> assert false\n\n  | Ignored_reader_ty rest1, Ignored_reader_ty rest2 ->\n    Ignored_reader_ty (trans rest1 rest2)\n  | Ignored_reader_ty _, _ -> assert false\n  | _, Ignored_reader_ty _ -> assert false\n\n  | Format_arg_ty (ty1, rest1), Format_arg_ty (ty2, rest2) ->\n    Format_arg_ty (trans ty1 ty2, trans rest1 rest2)\n  | Format_arg_ty _, _ -> assert false\n  | _, Format_arg_ty _ -> assert false\n\n  | Format_subst_ty (ty11, ty12, rest1),\n    Format_subst_ty (ty21, ty22, rest2) ->\n    let ty = trans (symm ty12) ty21 in\n    let _, f2, _, f4 = fmtty_rel_det ty in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    Format_subst_ty (ty11, ty22, trans rest1 rest2)\n  | Format_subst_ty _, _ -> assert false\n  | _, Format_subst_ty _ -> assert false\n\n  | End_of_fmtty, End_of_fmtty -> End_of_fmtty\n  | End_of_fmtty, _ -> assert false\n  | _, End_of_fmtty -> assert false\n\nlet rec fmtty_of_formatting_gen : type a b c d e f .\n  (a, b, c, d, e, f) formatting_gen ->\n    (a, b, c, d, e, f) fmtty =\nfun formatting_gen -> match formatting_gen with\n  | Open_tag (Format (fmt, _)) -> fmtty_of_fmt fmt\n  | Open_box (Format (fmt, _)) -> fmtty_of_fmt fmt\n\n(* Extract the type representation (an fmtty) of a format. *)\nand fmtty_of_fmt : type a b c d e f .\n  (a, b, c, d, e, f) fmt -> (a, b, c, d, e, f) fmtty =\nfun fmtty -> match fmtty with\n  | String (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n  | Caml_string (pad, rest) ->\n    fmtty_of_padding_fmtty pad (String_ty (fmtty_of_fmt rest))\n\n  | Int (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int32 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int32_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Nativeint (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Nativeint_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Int64 (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Int64_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n  | Float (_, pad, prec, rest) ->\n    let ty_rest = fmtty_of_fmt rest in\n    let prec_ty = fmtty_of_precision_fmtty prec (Float_ty ty_rest) in\n    fmtty_of_padding_fmtty pad prec_ty\n\n  | Char rest                  -> Char_ty (fmtty_of_fmt rest)\n  | Caml_char rest             -> Char_ty (fmtty_of_fmt rest)\n  | Bool rest                  -> Bool_ty (fmtty_of_fmt rest)\n  | Alpha rest                 -> Alpha_ty (fmtty_of_fmt rest)\n  | Theta rest                 -> Theta_ty (fmtty_of_fmt rest)\n  | Custom (arity, _, rest)    -> fmtty_of_custom arity (fmtty_of_fmt rest)\n  | Reader rest                -> Reader_ty (fmtty_of_fmt rest)\n\n  | Format_arg (_, ty, rest) ->\n    Format_arg_ty (ty, fmtty_of_fmt rest)\n  | Format_subst (_, ty, rest) ->\n    Format_subst_ty (ty, ty, fmtty_of_fmt rest)\n\n  | Flush rest                 -> fmtty_of_fmt rest\n  | String_literal (_, rest)   -> fmtty_of_fmt rest\n  | Char_literal (_, rest)     -> fmtty_of_fmt rest\n\n  | Scan_char_set (_, _, rest) -> String_ty (fmtty_of_fmt rest)\n  | Scan_get_counter (_, rest) -> Int_ty (fmtty_of_fmt rest)\n  | Scan_next_char rest        -> Char_ty (fmtty_of_fmt rest)\n  | Ignored_param (ign, rest)  -> fmtty_of_ignored_format ign rest\n  | Formatting_lit (_, rest)   -> fmtty_of_fmt rest\n  | Formatting_gen (fmting_gen, rest)  ->\n    concat_fmtty (fmtty_of_formatting_gen fmting_gen) (fmtty_of_fmt rest)\n\n  | End_of_format              -> End_of_fmtty\n\nand fmtty_of_custom : type x y a b c d e f .\n  (a, x, y) custom_arity -> (a, b, c, d, e, f) fmtty ->\n  (y, b, c, d, e, f) fmtty =\nfun arity fmtty -> match arity with\n  | Custom_zero -> fmtty\n  | Custom_succ arity -> Any_ty (fmtty_of_custom arity fmtty)\n\n(* Extract the fmtty of an ignored parameter followed by the rest of\n   the format. *)\nand fmtty_of_ignored_format : type x y a b c d e f .\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt ->\n    (a, b, c, d, e, f) fmtty =\nfun ign fmt -> match ign with\n  | Ignored_char                    -> fmtty_of_fmt fmt\n  | Ignored_caml_char               -> fmtty_of_fmt fmt\n  | Ignored_string _                -> fmtty_of_fmt fmt\n  | Ignored_caml_string _           -> fmtty_of_fmt fmt\n  | Ignored_int (_, _)              -> fmtty_of_fmt fmt\n  | Ignored_int32 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_nativeint (_, _)        -> fmtty_of_fmt fmt\n  | Ignored_int64 (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_float (_, _)            -> fmtty_of_fmt fmt\n  | Ignored_bool                    -> fmtty_of_fmt fmt\n  | Ignored_format_arg _            -> fmtty_of_fmt fmt\n  | Ignored_format_subst (_, fmtty) -> concat_fmtty fmtty (fmtty_of_fmt fmt)\n  | Ignored_reader                  -> Ignored_reader_ty (fmtty_of_fmt fmt)\n  | Ignored_scan_char_set _         -> fmtty_of_fmt fmt\n  | Ignored_scan_get_counter _      -> fmtty_of_fmt fmt\n  | Ignored_scan_next_char          -> fmtty_of_fmt fmt\n\n(* Add an Int_ty node if padding is taken as an extra argument (ex: \"%*s\"). *)\nand fmtty_of_padding_fmtty : type x a b c d e f .\n    (x, a) padding -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun pad fmtty -> match pad with\n    | No_padding    -> fmtty\n    | Lit_padding _ -> fmtty\n    | Arg_padding _ -> Int_ty fmtty\n\n(* Add an Int_ty node if precision is taken as an extra argument (ex: \"%.*f\").*)\nand fmtty_of_precision_fmtty : type x a b c d e f .\n    (x, a) precision -> (a, b, c, d, e, f) fmtty -> (x, b, c, d, e, f) fmtty =\n  fun prec fmtty -> match prec with\n    | No_precision    -> fmtty\n    | Lit_precision _ -> fmtty\n    | Arg_precision   -> Int_ty fmtty\n\n(******************************************************************************)\n                            (* Format typing *)\n\n(* Exception raised when a format does not match a given format type. *)\nexception Type_mismatch\n\n(* Type a padding. *)\n(* Take an Int_ty from the fmtty if the integer should be kept as argument. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padding : type a b c d e f x y .\n    (x, y) padding -> (a, b, c, d, e, f) fmtty ->\n      (a, b, c, d, e, f) padding_fmtty_ebb =\nfun pad fmtty -> match pad, fmtty with\n  | No_padding, _ -> Padding_fmtty_EBB (No_padding, fmtty)\n  | Lit_padding (padty, w), _ -> Padding_fmtty_EBB (Lit_padding (padty,w),fmtty)\n  | Arg_padding padty, Int_ty rest -> Padding_fmtty_EBB (Arg_padding padty,rest)\n  | _ -> raise Type_mismatch\n\n(* Convert a (upadding, uprecision) to a (padding, precision). *)\n(* Take one or two Int_ty from the fmtty if needed. *)\n(* Raise Type_mismatch in case of type mismatch. *)\nlet type_padprec : type a b c d e f x y z .\n  (x, y) padding -> (y, z) precision -> (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) padprec_fmtty_ebb =\nfun pad prec fmtty -> match prec, type_padding pad fmtty with\n  | No_precision, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, No_precision, rest)\n  | Lit_precision p, Padding_fmtty_EBB (pad, rest) ->\n    Padprec_fmtty_EBB (pad, Lit_precision p, rest)\n  | Arg_precision, Padding_fmtty_EBB (pad, Int_ty rest) ->\n    Padprec_fmtty_EBB (pad, Arg_precision, rest)\n  | _, Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n\n(* Type a format according to an fmtty. *)\n(* If typing succeed, generate a copy of the format with the same\n    type parameters as the fmtty. *)\n(* Raise a Failure with an error message in case of type mismatch. *)\nlet rec type_format :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty -> match type_format_gen fmt fmtty with\n  | Fmt_fmtty_EBB (fmt', End_of_fmtty) -> fmt'\n  | _ -> raise Type_mismatch\n\nand type_format_gen :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a2, b2, c2, d2, e2, f2) fmtty\n  -> (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun fmt fmtty -> match fmt, fmtty with\n  | Char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char fmt', fmtty')\n  | Caml_char fmt_rest, Char_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Caml_char fmt', fmtty')\n  | String (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (String (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Caml_string (pad, fmt_rest), _ -> (\n    match type_padding pad fmtty with\n    | Padding_fmtty_EBB (pad, String_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Caml_string (pad, fmt'), fmtty')\n    | Padding_fmtty_EBB (_, _) -> raise Type_mismatch\n  )\n  | Int (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int32 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int32_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int32 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Nativeint (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Nativeint_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Nativeint (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Int64 (iconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Int64_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Int64 (iconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Float (fconv, pad, prec, fmt_rest), _ -> (\n    match type_padprec pad prec fmtty with\n    | Padprec_fmtty_EBB (pad, prec, Float_ty fmtty_rest) ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n      Fmt_fmtty_EBB (Float (fconv, pad, prec, fmt'), fmtty')\n    | Padprec_fmtty_EBB (_, _, _) -> raise Type_mismatch\n  )\n  | Bool fmt_rest, Bool_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Bool fmt', fmtty')\n  | Flush fmt_rest, fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Flush fmt', fmtty')\n\n  | String_literal (str, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (String_literal (str, fmt'), fmtty')\n  | Char_literal (chr, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Char_literal (chr, fmt'), fmtty')\n\n  | Format_arg (pad_opt, sub_fmtty, fmt_rest),\n    Format_arg_ty (sub_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub_fmtty <> Fmtty_EBB sub_fmtty' then raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Format_arg (pad_opt, sub_fmtty', fmt'), fmtty')\n  | Format_subst (pad_opt, sub_fmtty, fmt_rest),\n    Format_subst_ty (sub_fmtty1, _sub_fmtty2, fmtty_rest) ->\n    if Fmtty_EBB (erase_rel sub_fmtty) <> Fmtty_EBB (erase_rel sub_fmtty1) then\n      raise Type_mismatch;\n    let Fmt_fmtty_EBB (fmt', fmtty') =\n      type_format_gen fmt_rest (erase_rel fmtty_rest)\n    in\n    Fmt_fmtty_EBB (Format_subst (pad_opt, sub_fmtty1, fmt'), fmtty')\n  (* Printf and Format specific constructors: *)\n  | Alpha fmt_rest, Alpha_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Alpha fmt', fmtty')\n  | Theta fmt_rest, Theta_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Theta fmt', fmtty')\n\n  (* Format specific constructors: *)\n  | Formatting_lit (formatting_lit, fmt_rest), fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Formatting_lit (formatting_lit, fmt'), fmtty')\n  | Formatting_gen (formatting_gen, fmt_rest), fmtty_rest ->\n    type_formatting_gen formatting_gen fmt_rest fmtty_rest\n\n  (* Scanf specific constructors: *)\n  | Reader fmt_rest, Reader_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Reader fmt', fmtty')\n  | Scan_char_set (width_opt, char_set, fmt_rest), String_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_char_set (width_opt, char_set, fmt'), fmtty')\n  | Scan_get_counter (counter, fmt_rest), Int_ty fmtty_rest ->\n    let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt_rest fmtty_rest in\n    Fmt_fmtty_EBB (Scan_get_counter (counter, fmt'), fmtty')\n  | Ignored_param (ign, rest), fmtty_rest ->\n    type_ignored_param ign rest fmtty_rest\n\n  | End_of_format, fmtty_rest -> Fmt_fmtty_EBB (End_of_format, fmtty_rest)\n\n  | _ -> raise Type_mismatch\n\nand type_formatting_gen : type a1 a3 b1 b3 c1 c3 d1 d3 e1 e2 e3 f1 f2 f3 .\n    (a1, b1, c1, d1, e1, f1) formatting_gen ->\n    (f1, b1, c1, e1, e2, f2) fmt ->\n    (a3, b3, c3, d3, e3, f3) fmtty ->\n    (a3, b3, c3, d3, e3, f3) fmt_fmtty_ebb =\nfun formatting_gen fmt0 fmtty0 -> match formatting_gen with\n  | Open_tag (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_tag (Format (fmt2, str)), fmt3), fmtty3)\n  | Open_box (Format (fmt1, str)) ->\n    let Fmt_fmtty_EBB (fmt2, fmtty2) = type_format_gen fmt1 fmtty0 in\n    let Fmt_fmtty_EBB (fmt3, fmtty3) = type_format_gen fmt0 fmtty2 in\n    Fmt_fmtty_EBB (Formatting_gen (Open_box (Format (fmt2, str)), fmt3), fmtty3)\n\n(* Type an Ignored_param node according to an fmtty. *)\nand type_ignored_param : type p q x y z t u v a b c d e f .\n    (x, y, z, t, q, p) ignored ->\n    (p, y, z, q, u, v) fmt ->\n    (a, b, c, d, e, f) fmtty ->\n    (a, b, c, d, e, f) fmt_fmtty_ebb =\nfun ign fmt fmtty -> match ign with\n  | Ignored_char               as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_char          as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_string _           as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_caml_string _      as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int _              as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int32 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_nativeint _        as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_int64 _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_float _            as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_bool               as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_char_set _    as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_get_counter _ as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_scan_next_char     as ign' -> type_ignored_param_one ign' fmt fmtty\n  | Ignored_format_arg (pad_opt, sub_fmtty) ->\n    type_ignored_param_one (Ignored_format_arg (pad_opt, sub_fmtty)) fmt fmtty\n  | Ignored_format_subst (pad_opt, sub_fmtty) ->\n    let Fmtty_fmt_EBB (sub_fmtty', Fmt_fmtty_EBB (fmt', fmtty')) =\n      type_ignored_format_substitution sub_fmtty fmt fmtty in\n    Fmt_fmtty_EBB (Ignored_param (Ignored_format_subst (pad_opt, sub_fmtty'),\n                                  fmt'),\n                   fmtty')\n  | Ignored_reader -> (\n    match fmtty with\n    | Ignored_reader_ty fmtty_rest ->\n      let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty_rest in\n      Fmt_fmtty_EBB (Ignored_param (Ignored_reader, fmt'), fmtty')\n    | _ -> raise Type_mismatch\n  )\n\nand type_ignored_param_one : type a1 a2 b1 b2 c1 c2 d1 d2 e1 e2 f1 f2 .\n    (a2, b2, c2, d2, d2, a2) ignored ->\n    (a1, b1, c1, d1, e1, f1) fmt ->\n    (a2, b2, c2, d2, e2, f2) fmtty ->\n    (a2, b2, c2, d2, e2, f2) fmt_fmtty_ebb\n= fun ign fmt fmtty ->\n  let Fmt_fmtty_EBB (fmt', fmtty') = type_format_gen fmt fmtty in\n  Fmt_fmtty_EBB (Ignored_param (ign, fmt'), fmtty')\n\n(* Typing of the complex case: \"%_(...%)\". *)\nand type_ignored_format_substitution : type w x y z p s t u a b c d e f .\n    (w, x, y, z, s, p) fmtty ->\n    (p, x, y, s, t, u) fmt ->\n    (a, b, c, d, e, f) fmtty -> (a, b, c, d, e, f) fmtty_fmt_ebb =\nfun sub_fmtty fmt fmtty -> match sub_fmtty, fmtty with\n  | Char_ty sub_fmtty_rest, Char_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Char_ty sub_fmtty_rest', fmt')\n  | String_ty sub_fmtty_rest, String_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (String_ty sub_fmtty_rest', fmt')\n  | Int_ty sub_fmtty_rest, Int_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int_ty sub_fmtty_rest', fmt')\n  | Int32_ty sub_fmtty_rest, Int32_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int32_ty sub_fmtty_rest', fmt')\n  | Nativeint_ty sub_fmtty_rest, Nativeint_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Nativeint_ty sub_fmtty_rest', fmt')\n  | Int64_ty sub_fmtty_rest, Int64_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Int64_ty sub_fmtty_rest', fmt')\n  | Float_ty sub_fmtty_rest, Float_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Float_ty sub_fmtty_rest', fmt')\n  | Bool_ty sub_fmtty_rest, Bool_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Bool_ty sub_fmtty_rest', fmt')\n  | Alpha_ty sub_fmtty_rest, Alpha_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Alpha_ty sub_fmtty_rest', fmt')\n  | Theta_ty sub_fmtty_rest, Theta_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Theta_ty sub_fmtty_rest', fmt')\n  | Reader_ty sub_fmtty_rest, Reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Reader_ty sub_fmtty_rest', fmt')\n  | Ignored_reader_ty sub_fmtty_rest, Ignored_reader_ty fmtty_rest ->\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Ignored_reader_ty sub_fmtty_rest', fmt')\n\n  | Format_arg_ty (sub2_fmtty, sub_fmtty_rest),\n    Format_arg_ty (sub2_fmtty', fmtty_rest) ->\n    if Fmtty_EBB sub2_fmtty <> Fmtty_EBB sub2_fmtty' then raise Type_mismatch;\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution sub_fmtty_rest fmt fmtty_rest in\n    Fmtty_fmt_EBB (Format_arg_ty (sub2_fmtty', sub_fmtty_rest'), fmt')\n  | Format_subst_ty (sub1_fmtty,  sub2_fmtty,  sub_fmtty_rest),\n    Format_subst_ty (sub1_fmtty', sub2_fmtty', fmtty_rest) ->\n    (* TODO define Fmtty_rel_EBB to remove those erase_rel *)\n    if Fmtty_EBB (erase_rel sub1_fmtty) <> Fmtty_EBB (erase_rel sub1_fmtty')\n    then raise Type_mismatch;\n    if Fmtty_EBB (erase_rel sub2_fmtty) <> Fmtty_EBB (erase_rel sub2_fmtty')\n    then raise Type_mismatch;\n    let sub_fmtty' = trans (symm sub1_fmtty') sub2_fmtty' in\n    let _, f2, _, f4 = fmtty_rel_det sub_fmtty' in\n    let Refl = f2 Refl in\n    let Refl = f4 Refl in\n    let Fmtty_fmt_EBB (sub_fmtty_rest', fmt') =\n      type_ignored_format_substitution (erase_rel sub_fmtty_rest) fmt fmtty_rest\n    in\n    Fmtty_fmt_EBB (Format_subst_ty (sub1_fmtty', sub2_fmtty',\n                                    symm sub_fmtty_rest'),\n                   fmt')\n  | End_of_fmtty, fmtty ->\n    Fmtty_fmt_EBB (End_of_fmtty, type_format_gen fmt fmtty)\n  | _ -> raise Type_mismatch\n\n(* This implementation of `recast` is a bit disappointing. The\n   invariant provided by the type are very strong: the input format's\n   type is in relation to the output type's as witnessed by the\n   fmtty_rel argument. One would at first expect this function to be\n   total, and implementable by exhaustive pattern matching. Instead,\n   we reuse the highly partial and much less well-defined function\n   `type_format` that has lost all knowledge of the correspondence\n   between the argument's types.\n\n   Besides the fact that this function reuses a lot of the\n   `type_format` logic (eg.: seeing Int_ty in the fmtty parameter does\n   not let you match on Int only, as you may in fact have Float\n   (Arg_padding, ...) (\"%.*d\") beginning with an Int_ty), it is also\n   a partial function, because the typing information in a format is\n   not quite enough to reconstruct it unambiguously. For example, the\n   format types of \"%d%_r\" and \"%_r%d\" have the same format6\n   parameters, but they are not at all exchangeable, and putting one\n   in place of the other must result in a dynamic failure.\n\n   Given that:\n   - we'd have to duplicate a lot of non-trivial typing logic from type_format\n   - this wouldn't even eliminate (all) the dynamic failures\n   we decided to just reuse type_format directly for now.\n*)\nlet recast :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n  .\n     (a1, b1, c1, d1, e1, f1) fmt\n  -> (a1, b1, c1, d1, e1, f1,\n      a2, b2, c2, d2, e2, f2) fmtty_rel\n  -> (a2, b2, c2, d2, e2, f2) fmt\n= fun fmt fmtty ->\n  type_format fmt (erase_rel (symm fmtty))\n\n(******************************************************************************)\n                             (* Printing tools *)\n\n(* Add padding spaces arround a string. *)\nlet fix_padding padty width str =\n  let len = String.length str in\n  let width, padty =\n    abs width,\n    (* while literal padding widths are always non-negative,\n       dynamically-set widths (Arg_padding, eg. %*d) may be negative;\n       we interpret those as specifying a padding-to-the-left; this\n       means that '0' may get dropped even if it was explicitly set,\n       but:\n       - this is what the legacy implementation does, and\n         we preserve compatibility if possible\n       - we could only signal this issue by failing at runtime,\n         which is not very nice... *)\n    if width < 0 then Left else padty in\n  if width <= len then str else\n    let res = Bytes.make width (if padty = Zeros then '0' else ' ') in\n    begin match padty with\n    | Left  -> String.blit str 0 res 0 len\n    | Right -> String.blit str 0 res (width - len) len\n    | Zeros when len > 0 && (str.[0] = '+' || str.[0] = '-' || str.[0] = ' ') ->\n      Bytes.set res 0 str.[0];\n      String.blit str 1 res (width - len + 1) (len - 1)\n    | Zeros when len > 1 && str.[0] = '0' && (str.[1] = 'x' || str.[1] = 'X') ->\n      Bytes.set res 1 str.[1];\n      String.blit str 2 res (width - len + 2) (len - 2)\n    | Zeros ->\n      String.blit str 0 res (width - len) len\n    end;\n    Bytes.unsafe_to_string res\n\n(* Add '0' padding to int, int32, nativeint or int64 string representation. *)\nlet fix_int_precision prec str =\n  let prec = abs prec in\n  let len = String.length str in\n  match str.[0] with\n  | ('+' | '-' | ' ') as c when prec + 1 > len ->\n    let res = Bytes.make (prec + 1) '0' in\n    Bytes.set res 0 c;\n    String.blit str 1 res (prec - len + 2) (len - 1);\n    Bytes.unsafe_to_string res\n  | '0' when prec + 2 > len && len > 1 && (str.[1] = 'x' || str.[1] = 'X') ->\n    let res = Bytes.make (prec + 2) '0' in\n    Bytes.set res 1 str.[1];\n    String.blit str 2 res (prec - len + 4) (len - 2);\n    Bytes.unsafe_to_string res\n  | '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' when prec > len ->\n    let res = Bytes.make prec '0' in\n    String.blit str 0 res (prec - len) len;\n    Bytes.unsafe_to_string res\n  | _ ->\n    str\n\n(* Escape a string according to the OCaml lexing convention. *)\nlet string_to_caml_string str =\n  let str = String.escaped str in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\\"' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Generate the format_int/int32/nativeint/int64 first argument\n   from an int_conv. *)\nlet format_of_iconv = function\n  | Int_d -> \"%d\" | Int_pd -> \"%+d\" | Int_sd -> \"% d\"\n  | Int_i -> \"%i\" | Int_pi -> \"%+i\" | Int_si -> \"% i\"\n  | Int_x -> \"%x\" | Int_Cx -> \"%#x\"\n  | Int_X -> \"%X\" | Int_CX -> \"%#X\"\n  | Int_o -> \"%o\" | Int_Co -> \"%#o\"\n  | Int_u -> \"%u\"\n\nlet format_of_iconvL = function\n  | Int_d -> \"%Ld\" | Int_pd -> \"%+Ld\" | Int_sd -> \"% Ld\"\n  | Int_i -> \"%Li\" | Int_pi -> \"%+Li\" | Int_si -> \"% Li\"\n  | Int_x -> \"%Lx\" | Int_Cx -> \"%#Lx\"\n  | Int_X -> \"%LX\" | Int_CX -> \"%#LX\"\n  | Int_o -> \"%Lo\" | Int_Co -> \"%#Lo\"\n  | Int_u -> \"%Lu\"\n\nlet format_of_iconvl = function\n  | Int_d -> \"%ld\" | Int_pd -> \"%+ld\" | Int_sd -> \"% ld\"\n  | Int_i -> \"%li\" | Int_pi -> \"%+li\" | Int_si -> \"% li\"\n  | Int_x -> \"%lx\" | Int_Cx -> \"%#lx\"\n  | Int_X -> \"%lX\" | Int_CX -> \"%#lX\"\n  | Int_o -> \"%lo\" | Int_Co -> \"%#lo\"\n  | Int_u -> \"%lu\"\n\nlet format_of_iconvn = function\n  | Int_d -> \"%nd\" | Int_pd -> \"%+nd\" | Int_sd -> \"% nd\"\n  | Int_i -> \"%ni\" | Int_pi -> \"%+ni\" | Int_si -> \"% ni\"\n  | Int_x -> \"%nx\" | Int_Cx -> \"%#nx\"\n  | Int_X -> \"%nX\" | Int_CX -> \"%#nX\"\n  | Int_o -> \"%no\" | Int_Co -> \"%#no\"\n  | Int_u -> \"%nu\"\n\n(* Generate the format_float first argument form a float_conv. *)\nlet format_of_fconv fconv prec =\n  if fconv = Float_F then \"%.12g\" else\n    let prec = abs prec in\n    let symb = char_of_fconv fconv in\n    let buf = buffer_create 16 in\n    buffer_add_char buf '%';\n    bprint_fconv_flag buf fconv;\n    buffer_add_char buf '.';\n    buffer_add_string buf (string_of_int prec);\n    buffer_add_char buf symb;\n    buffer_contents buf\n\n(* Convert an integer to a string according to a conversion. *)\nlet convert_int iconv n = format_int (format_of_iconv iconv) n\nlet convert_int32 iconv n = format_int32 (format_of_iconvl iconv) n\nlet convert_nativeint iconv n = format_nativeint (format_of_iconvn iconv) n\nlet convert_int64 iconv n = format_int64 (format_of_iconvL iconv) n\n\n(* Convert a float to string. *)\n(* Fix special case of \"OCaml float format\". *)\nlet convert_float fconv prec x =\n  match fconv with\n  | Float_h | Float_ph | Float_sh | Float_H | Float_pH | Float_sH ->\n    let sign =\n      match fconv with\n      | Float_ph | Float_pH -> '+'\n      | Float_sh | Float_sH -> ' '\n      | _ -> '-' in\n    let str = hexstring_of_float x prec sign in\n    begin match fconv with\n    | Float_H | Float_pH | Float_sH -> String.uppercase_ascii str\n    | _ -> str\n    end\n  | _ ->\n    let str = format_float (format_of_fconv fconv prec) x in\n    if fconv <> Float_F then str else\n      let len = String.length str in\n      let rec is_valid i =\n        if i = len then false else\n          match str.[i] with\n          | '.' | 'e' | 'E' -> true\n          | _ -> is_valid (i + 1)\n      in\n      match classify_float x with\n      | FP_normal | FP_subnormal | FP_zero ->\n        if is_valid 0 then str else str ^ \".\"\n      | FP_infinite ->\n        if x < 0.0 then \"neg_infinity\" else \"infinity\"\n      | FP_nan -> \"nan\"\n\n(* Convert a char to a string according to the OCaml lexical convention. *)\nlet format_caml_char c =\n  let str = Char.escaped c in\n  let l = String.length str in\n  let res = Bytes.make (l + 2) '\\'' in\n  String.unsafe_blit str 0 res 1 l;\n  Bytes.unsafe_to_string res\n\n(* Convert a format type to string *)\nlet string_of_fmtty fmtty =\n  let buf = buffer_create 16 in\n  bprint_fmtty buf fmtty;\n  buffer_contents buf\n\n(******************************************************************************)\n                        (* Generic printing function *)\n\n(* Make a generic printing function. *)\n(* Used to generate Printf and Format printing functions. *)\n(* Parameters:\n     k: a continuation finally applied to the output stream and the accumulator.\n     o: the output stream (see k, %a and %t).\n     acc: rev list of printing entities (string, char, flush, formatting, ...).\n     fmt: the format. *)\nlet rec make_printf : type a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k o acc fmt -> match fmt with\n  | Char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k o new_acc rest\n  | Caml_char rest ->\n    fun c ->\n      let new_acc = Acc_data_string (acc, format_caml_char c) in\n      make_printf k o new_acc rest\n  | String (pad, rest) ->\n    make_string_padding k o acc rest pad (fun str -> str)\n  | Caml_string (pad, rest) ->\n    make_string_padding k o acc rest pad string_to_caml_string\n  | Int (iconv, pad, prec, rest) ->\n    make_int_padding_precision k o acc rest pad prec convert_int iconv\n  | Int32 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k o acc rest pad prec convert_int32 iconv\n  | Nativeint (iconv, pad, prec, rest) ->\n    make_int_padding_precision k o acc rest pad prec convert_nativeint iconv\n  | Int64 (iconv, pad, prec, rest) ->\n    make_int_padding_precision k o acc rest pad prec convert_int64 iconv\n  | Float (fconv, pad, prec, rest) ->\n    make_float_padding_precision k o acc rest pad prec fconv\n  | Bool rest ->\n    fun b -> make_printf k o (Acc_data_string (acc, string_of_bool b)) rest\n  | Alpha rest ->\n    fun f x -> make_printf k o (Acc_delay (acc, fun o -> f o x)) rest\n  | Theta rest ->\n    fun f -> make_printf k o (Acc_delay (acc, f)) rest\n  | Custom (arity, f, rest) ->\n    make_custom k o acc rest arity (f ())\n  | Reader _ ->\n    (* This case is impossible, by typing of formats. *)\n    (* Indeed, since printf and co. take a format4 as argument, the 'd and 'e\n       type parameters of fmt are obviously equals. The Reader is the\n       only constructor which touch 'd and 'e type parameters of the format\n       type, it adds an (->) to the 'd parameters. Consequently, a format4\n       cannot contain a Reader node, except in the sub-format associated to\n       an %{...%}. It's not a problem because make_printf do not call\n       itself recursively on the sub-format associated to %{...%}. *)\n    assert false\n  | Flush rest ->\n    make_printf k o (Acc_flush acc) rest\n\n  | String_literal (str, rest) ->\n    make_printf k o (Acc_string_literal (acc, str)) rest\n  | Char_literal (chr, rest) ->\n    make_printf k o (Acc_char_literal (acc, chr)) rest\n\n  | Format_arg (_, sub_fmtty, rest) ->\n    let ty = string_of_fmtty sub_fmtty in\n    (fun str ->\n      ignore str;\n      make_printf k o (Acc_data_string (acc, ty)) rest)\n  | Format_subst (_, fmtty, rest) ->\n    fun (Format (fmt, _)) -> make_printf k o acc\n      (concat_fmt (recast fmt fmtty) rest)\n\n  | Scan_char_set (_, _, rest) ->\n    let new_acc = Acc_invalid_arg (acc, \"Printf: bad conversion %[\") in\n    fun _ -> make_printf k o new_acc rest\n  | Scan_get_counter (_, rest) ->\n    (* This case should be refused for Printf. *)\n    (* Accepted for backward compatibility. *)\n    (* Interpret %l, %n and %L as %u. *)\n    fun n ->\n      let new_acc = Acc_data_string (acc, format_int \"%u\" n) in\n      make_printf k o new_acc rest\n  | Scan_next_char rest ->\n    fun c ->\n      let new_acc = Acc_data_char (acc, c) in\n      make_printf k o new_acc rest\n  | Ignored_param (ign, rest) ->\n    make_ignored_param k o acc ign rest\n\n  | Formatting_lit (fmting_lit, rest) ->\n    make_printf k o (Acc_formatting_lit (acc, fmting_lit)) rest\n  | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n    let k' koc kacc =\n      make_printf k koc (Acc_formatting_gen (acc, Acc_open_tag kacc)) rest in\n    make_printf k' o End_of_acc fmt'\n  | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n    let k' koc kacc =\n      make_printf k koc (Acc_formatting_gen (acc, Acc_open_box kacc)) rest in\n    make_printf k' o End_of_acc fmt'\n\n  | End_of_format ->\n    k o acc\n\n(* Delay the error (Invalid_argument \"Printf: bad conversion %_\"). *)\n(* Generate functions to take remaining arguments (after the \"%_\"). *)\nand make_ignored_param : type x y a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, y, x) ignored ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k o acc ign fmt -> match ign with\n  | Ignored_char                    -> make_invalid_arg k o acc fmt\n  | Ignored_caml_char               -> make_invalid_arg k o acc fmt\n  | Ignored_string _                -> make_invalid_arg k o acc fmt\n  | Ignored_caml_string _           -> make_invalid_arg k o acc fmt\n  | Ignored_int (_, _)              -> make_invalid_arg k o acc fmt\n  | Ignored_int32 (_, _)            -> make_invalid_arg k o acc fmt\n  | Ignored_nativeint (_, _)        -> make_invalid_arg k o acc fmt\n  | Ignored_int64 (_, _)            -> make_invalid_arg k o acc fmt\n  | Ignored_float (_, _)            -> make_invalid_arg k o acc fmt\n  | Ignored_bool                    -> make_invalid_arg k o acc fmt\n  | Ignored_format_arg _            -> make_invalid_arg k o acc fmt\n  | Ignored_format_subst (_, fmtty) -> make_from_fmtty k o acc fmtty fmt\n  | Ignored_reader                  -> assert false\n  | Ignored_scan_char_set _         -> make_invalid_arg k o acc fmt\n  | Ignored_scan_get_counter _      -> make_invalid_arg k o acc fmt\n  | Ignored_scan_next_char          -> make_invalid_arg k o acc fmt\n\n\n(* Special case of printf \"%_(\". *)\nand make_from_fmtty : type x y a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, y, x) fmtty ->\n    (x, b, c, y, e, f) fmt -> a =\nfun k o acc fmtty fmt -> match fmtty with\n  | Char_ty rest            -> fun _ -> make_from_fmtty k o acc rest fmt\n  | String_ty rest          -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Int_ty rest             -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Int32_ty rest           -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Nativeint_ty rest       -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Int64_ty rest           -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Float_ty rest           -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Bool_ty rest            -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Alpha_ty rest           -> fun _ _ -> make_from_fmtty k o acc rest fmt\n  | Theta_ty rest           -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Any_ty rest             -> fun _ -> make_from_fmtty k o acc rest fmt\n  | Reader_ty _             -> assert false\n  | Ignored_reader_ty _     -> assert false\n  | Format_arg_ty (_, rest) -> fun _ -> make_from_fmtty k o acc rest fmt\n  | End_of_fmtty            -> make_invalid_arg k o acc fmt\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let ty = trans (symm ty1) ty2 in\n    fun _ -> make_from_fmtty k o acc (concat_fmtty ty rest) fmt\n\n(* Insert an Acc_invalid_arg in the accumulator and continue to generate\n   closures to get the remaining arguments. *)\nand make_invalid_arg : type a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt -> a =\nfun k o acc fmt ->\n  make_printf k o (Acc_invalid_arg (acc, \"Printf: bad conversion %_\")) fmt\n\n(* Fix padding, take it as an extra integer argument if needed. *)\nand make_string_padding : type x z a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, z -> a) padding -> (z -> string) -> x =\n  fun k o acc fmt pad trans -> match pad with\n  | No_padding ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, trans x) in\n      make_printf k o new_acc fmt\n  | Lit_padding (padty, width) ->\n    fun x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty width (trans x)) in\n      make_printf k o new_acc fmt\n  | Arg_padding padty ->\n    fun w x ->\n      let new_acc = Acc_data_string (acc, fix_padding padty w (trans x)) in\n      make_printf k o new_acc fmt\n\n(* Fix padding and precision for int, int32, nativeint or int64. *)\n(* Take one or two extra integer arguments if needed. *)\nand make_int_padding_precision : type x y z a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, z -> a) precision -> (int_conv -> z -> string) ->\n    int_conv -> x =\n  fun k o acc fmt pad prec trans iconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = trans iconv x in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = fix_int_precision p (trans iconv x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = fix_padding padty w (trans iconv x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (fix_int_precision p (trans iconv x)) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n\n(* Convert a float, fix padding and precision if needed. *)\n(* Take the float argument and one or two extra integer arguments if needed. *)\nand make_float_padding_precision : type x y a b c d e f .\n    (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n    (a, b, c, d, e, f) fmt ->\n    (x, y) padding -> (y, float -> a) precision -> float_conv -> x =\n  fun k o acc fmt pad prec fconv -> match pad, prec with\n  | No_padding, No_precision ->\n    fun x ->\n      let str = convert_float fconv default_float_precision x in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | No_padding, Lit_precision p ->\n    fun x ->\n      let str = convert_float fconv p x in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | No_padding, Arg_precision ->\n    fun p x ->\n      let str = convert_float fconv p x in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), No_precision ->\n    fun x ->\n      let str = convert_float fconv default_float_precision x in\n      let str' = fix_padding padty w str in\n      make_printf k o (Acc_data_string (acc, str')) fmt\n  | Lit_padding (padty, w), Lit_precision p ->\n    fun x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Lit_padding (padty, w), Arg_precision ->\n    fun p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, No_precision ->\n    fun w x ->\n      let str = convert_float fconv default_float_precision x in\n      let str' = fix_padding padty w str in\n      make_printf k o (Acc_data_string (acc, str')) fmt\n  | Arg_padding padty, Lit_precision p ->\n    fun w x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\n  | Arg_padding padty, Arg_precision ->\n    fun w p x ->\n      let str = fix_padding padty w (convert_float fconv p x) in\n      make_printf k o (Acc_data_string (acc, str)) fmt\nand make_custom : type x y a b c d e f .\n  (b -> (b, c) acc -> f) -> b -> (b, c) acc ->\n  (a, b, c, d, e, f) fmt ->\n  (a, x, y) custom_arity -> x -> y =\n  fun k o acc rest arity f -> match arity with\n  | Custom_zero -> make_printf k o (Acc_data_string (acc, f)) rest\n  | Custom_succ arity ->\n    fun x ->\n      make_custom k o acc rest arity (f x)\n\nlet const x _ = x\n\nlet rec make_iprintf : type a b c d e f.\n  (b -> f) -> b -> (a, b, c, d, e, f) fmt -> a =\n  fun k o fmt -> match fmt with\n    | Char rest ->\n        const (make_iprintf k o rest)\n    | Caml_char rest ->\n        const (make_iprintf k o rest)\n    | String (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | String (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | String (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Caml_string (No_padding, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Lit_padding _, rest) ->\n        const (make_iprintf k o rest)\n    | Caml_string (Arg_padding _, rest) ->\n        const (const (make_iprintf k o rest))\n    | Int (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int32 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Nativeint (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Int64 (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Float (_, pad, prec, rest) ->\n        fn_of_padding_precision k o rest pad prec\n    | Bool rest ->\n        const (make_iprintf k o rest)\n    | Alpha rest ->\n        const (const (make_iprintf k o rest))\n    | Theta rest ->\n        const (make_iprintf k o rest)\n    | Custom (arity, _, rest) ->\n        fn_of_custom_arity k o rest arity\n    | Reader _ ->\n        (* This case is impossible, by typing of formats.  See the\n           note in the corresponding case for make_printf. *)\n        assert false\n    | Flush rest ->\n        make_iprintf k o rest\n    | String_literal (_, rest) ->\n        make_iprintf k o rest\n    | Char_literal (_, rest) ->\n        make_iprintf k o rest\n    | Format_arg (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Format_subst (_, fmtty, rest) ->\n        fun (Format (fmt, _)) ->\n          make_iprintf k o\n            (concat_fmt (recast fmt fmtty) rest)\n    | Scan_char_set (_, _, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_get_counter (_, rest) ->\n        const (make_iprintf k o rest)\n    | Scan_next_char rest ->\n        const (make_iprintf k o rest)\n    | Ignored_param (ign, rest) ->\n        make_ignored_param (fun x _ -> k x) o (End_of_acc) ign rest\n    | Formatting_lit (_, rest) ->\n        make_iprintf k o rest\n    | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n        make_iprintf (fun koc -> make_iprintf k koc rest) o fmt'\n    | End_of_format ->\n        k o\nand fn_of_padding_precision :\n  type x y z a b c d e f.\n  (b -> f) -> b -> (a, b, c, d, e, f) fmt ->\n  (x, y) padding -> (y, z -> a) precision -> x =\n  fun k o fmt pad prec -> match pad, prec with\n    | No_padding   , No_precision    ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | No_padding   , Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Lit_padding _, No_precision    ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Lit_precision _ ->\n        const (make_iprintf k o fmt)\n    | Lit_padding _, Arg_precision   ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, No_precision    ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Lit_precision _ ->\n        const (const (make_iprintf k o fmt))\n    | Arg_padding _, Arg_precision   ->\n        const (const (const (make_iprintf k o fmt)))\nand fn_of_custom_arity : type x y a b c d e f .\n  (b -> f) -> b -> (a, b, c, d, e, f) fmt -> (a, x, y) custom_arity -> y =\n  fun k o fmt -> function\n    | Custom_zero ->\n        make_iprintf k o fmt\n    | Custom_succ arity ->\n        const (fn_of_custom_arity k o fmt arity)\n\n(******************************************************************************)\n                          (* Continuations for make_printf *)\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Used as a continuation of make_printf. *)\nlet rec output_acc o acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    output_acc o p; output_string o s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc o p; output_string o \"@{\"; output_acc o acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc o p; output_string o \"@[\"; output_acc o acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc o p; output_string o s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc o p; output_char o c\n  | Acc_delay (p, f)         -> output_acc o p; f o\n  | Acc_flush p              -> output_acc o p; flush o\n  | Acc_invalid_arg (p, msg) -> output_acc o p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Used as a continuation of make_printf. *)\nlet rec bufput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    bufput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    bufput_acc b p; Buffer.add_string b \"@{\"; bufput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    bufput_acc b p; Buffer.add_string b \"@[\"; bufput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> bufput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> bufput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> bufput_acc b p; f b\n  | Acc_flush p              -> bufput_acc b p;\n  | Acc_invalid_arg (p, msg) -> bufput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from bufput_acc by the interpretation of %a and %t. *)\n(* Used as a continuation of make_printf. *)\nlet rec strput_acc b acc = match acc with\n  | Acc_formatting_lit (p, fmting_lit) ->\n    let s = string_of_formatting_lit fmting_lit in\n    strput_acc b p; Buffer.add_string b s;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc b p; Buffer.add_string b \"@{\"; strput_acc b acc';\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc b p; Buffer.add_string b \"@[\"; strput_acc b acc';\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc b p; Buffer.add_string b s\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc b p; Buffer.add_char b c\n  | Acc_delay (p, f)         -> strput_acc b p; Buffer.add_string b (f ())\n  | Acc_flush p              -> strput_acc b p;\n  | Acc_invalid_arg (p, msg) -> strput_acc b p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(******************************************************************************)\n                          (* Error managment *)\n\n(* Raise a Failure with a pretty-printed error message. *)\nlet failwith_message (Format (fmt, _)) =\n  let buf = Buffer.create 256 in\n  let k () acc = strput_acc buf acc; failwith (Buffer.contents buf) in\n  make_printf k () End_of_acc fmt\n\n(******************************************************************************)\n                            (* Formatting tools *)\n\n(* Convert a string to an open block description (indent, block_type) *)\nlet open_box_of_string str =\n  if str = \"\" then (0, Pp_box) else\n    let len = String.length str in\n    let invalid_box () = failwith_message \"invalid box description %S\" str in\n    let rec parse_spaces i =\n      if i = len then i else\n        match str.[i] with\n        | ' ' | '\\t' -> parse_spaces (i + 1)\n        | _ -> i\n    and parse_lword i j =\n      if j = len then j else\n        match str.[j] with\n        | 'a' .. 'z' -> parse_lword i (j + 1)\n        | _ -> j\n    and parse_int i j =\n      if j = len then j else\n        match str.[j] with\n        | '0' .. '9' | '-' -> parse_int i (j + 1)\n        | _ -> j in\n    let wstart = parse_spaces 0 in\n    let wend = parse_lword wstart wstart in\n    let box_name = String.sub str wstart (wend - wstart) in\n    let nstart = parse_spaces wend in\n    let nend = parse_int nstart nstart in\n    let indent =\n      if nstart = nend then 0 else\n        try int_of_string (String.sub str nstart (nend - nstart))\n        with Failure _ -> invalid_box () in\n    let exp_end = parse_spaces nend in\n    if exp_end <> len then invalid_box ();\n    let box_type = match box_name with\n      | \"\" | \"b\" -> Pp_box\n      | \"h\"      -> Pp_hbox\n      | \"v\"      -> Pp_vbox\n      | \"hv\"     -> Pp_hvbox\n      | \"hov\"    -> Pp_hovbox\n      | _        -> invalid_box () in\n    (indent, box_type)\n\n(******************************************************************************)\n                            (* Parsing tools *)\n\n(* Create a padding_fmt_ebb from a padding and a format. *)\n(* Copy the padding to disjoin the type parameters of argument and result. *)\nlet make_padding_fmt_ebb : type x y .\n    (x, y) padding -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) padding_fmt_ebb =\nfun pad fmt -> match pad with\n  | No_padding         -> Padding_fmt_EBB (No_padding, fmt)\n  | Lit_padding (s, w) -> Padding_fmt_EBB (Lit_padding (s, w), fmt)\n  | Arg_padding s      -> Padding_fmt_EBB (Arg_padding s, fmt)\n\n(* Create a precision_fmt_ebb from a precision and a format. *)\n(* Copy the precision to disjoin the type parameters of argument and result. *)\nlet make_precision_fmt_ebb : type x y .\n    (x, y) precision -> (_, _, _, _, _, _) fmt ->\n      (_, _, _, _, _) precision_fmt_ebb =\nfun prec fmt -> match prec with\n  | No_precision    -> Precision_fmt_EBB (No_precision, fmt)\n  | Lit_precision p -> Precision_fmt_EBB (Lit_precision p, fmt)\n  | Arg_precision   -> Precision_fmt_EBB (Arg_precision, fmt)\n\n(* Create a padprec_fmt_ebb forma a padding, a precision and a format. *)\n(* Copy the padding and the precision to disjoin type parameters of arguments\n   and result. *)\nlet make_padprec_fmt_ebb : type x y z t .\n    (x, y) padding -> (z, t) precision ->\n    (_, _, _, _, _, _) fmt ->\n    (_, _, _, _, _) padprec_fmt_ebb =\nfun pad prec fmt ->\n  let Precision_fmt_EBB (prec, fmt') = make_precision_fmt_ebb prec fmt in\n  match pad with\n  | No_padding         -> Padprec_fmt_EBB (No_padding, prec, fmt')\n  | Lit_padding (s, w) -> Padprec_fmt_EBB (Lit_padding (s, w), prec, fmt')\n  | Arg_padding s      -> Padprec_fmt_EBB (Arg_padding s, prec, fmt')\n\n(******************************************************************************)\n                             (* Format parsing *)\n\n(* Parse a string representing a format and create a fmt_ebb. *)\n(* Raise an Failure exception in case of invalid format. *)\nlet fmt_ebb_of_string ?legacy_behavior str =\n  (* Parameters naming convention:                                    *)\n  (*   - lit_start: start of the literal sequence.                    *)\n  (*   - str_ind: current index in the string.                        *)\n  (*   - end_ind: end of the current (sub-)format.                    *)\n  (*   - pct_ind: index of the '%' in the current micro-format.       *)\n  (*   - zero:  is the '0' flag defined in the current micro-format.  *)\n  (*   - minus: is the '-' flag defined in the current micro-format.  *)\n  (*   - plus:  is the '+' flag defined in the current micro-format.  *)\n  (*   - hash:  is the '#' flag defined in the current micro-format.  *)\n  (*   - space: is the ' ' flag defined in the current micro-format.  *)\n  (*   - ign:   is the '_' flag defined in the current micro-format.  *)\n  (*   - pad: padding of the current micro-format.                    *)\n  (*   - prec: precision of the current micro-format.                 *)\n  (*   - symb: char representing the conversion ('c', 's', 'd', ...). *)\n  (*   - char_set: set of characters as bitmap (see scanf %[...]).    *)\n\n  let legacy_behavior = match legacy_behavior with\n    | Some flag -> flag\n    | None -> true\n  (*  When this flag is enabled, the format parser tries to behave as\n      the <4.02 implementations, in particular it ignores most benine\n      nonsensical format. When the flag is disabled, it will reject any\n      format that is not accepted by the specification.\n\n      A typical example would be \"%+ d\": specifying both '+' (if the\n      number is positive, pad with a '+' to get the same width as\n      negative numbres) and ' ' (if the number is positive, pad with\n      a space) does not make sense, but the legacy (< 4.02)\n      implementation was happy to just ignore the space.\n  *)\n  in\n\n  (* Raise a Failure with a friendly error message. *)\n  let invalid_format_message str_ind msg =\n    failwith_message\n      \"invalid format %S: at character number %d, %s\"\n      str str_ind msg;\n  in\n\n  (* Used when the end of the format (or the current sub-format) was encoutered\n      unexpectedly. *)\n  let unexpected_end_of_format end_ind =\n    invalid_format_message end_ind\n      \"unexpected end of format\"\n  in\n\n  (* Used for %0c: no other widths are implemented *)\n  let invalid_nonnull_char_width str_ind =\n    invalid_format_message str_ind\n      \"non-zero widths are unsupported for %c conversions\"\n  in\n  (* Raise Failure with a friendly error message about an option dependencie\n     problem. *)\n  let invalid_format_without str_ind c s =\n    failwith_message\n      \"invalid format %S: at character number %d, '%c' without %s\"\n      str str_ind c s\n  in\n\n  (* Raise Failure with a friendly error message about an unexpected\n     character. *)\n  let expected_character str_ind expected read =\n    failwith_message\n     \"invalid format %S: at character number %d, %s expected, read %C\"\n      str str_ind expected read\n  in\n\n  (* Parse the string from beg_ind (included) to end_ind (excluded). *)\n  let rec parse : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun beg_ind end_ind -> parse_literal beg_ind beg_ind end_ind\n\n  (* Read literal characters up to '%' or '@' special characters. *)\n  and parse_literal : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind end_ind ->\n    if str_ind = end_ind then add_literal lit_start str_ind End_of_format else\n      match str.[str_ind] with\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse_format str_ind end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse_after_at (str_ind + 1) end_ind in\n        add_literal lit_start str_ind fmt_rest\n      | _ ->\n        parse_literal lit_start (str_ind + 1) end_ind\n\n  (* Parse a format after '%' *)\n  and parse_format : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind end_ind -> parse_ign pct_ind (pct_ind + 1) end_ind\n\n  and parse_ign : type e f . int -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n      | '_' -> parse_flags pct_ind (str_ind+1) end_ind true\n      | _ -> parse_flags pct_ind str_ind end_ind false\n\n  and parse_flags : type e f . int -> int -> int -> bool -> (_, _, e, f) fmt_ebb\n  =\n  fun pct_ind str_ind end_ind ign ->\n    let zero = ref false and minus = ref false\n    and plus = ref false and space = ref false\n    and hash = ref false in\n    let set_flag str_ind flag =\n      (* in legacy mode, duplicate flags are accepted *)\n      if !flag && not legacy_behavior then\n        failwith_message\n          \"invalid format %S: at character number %d, duplicate flag %C\"\n          str str_ind str.[str_ind];\n      flag := true;\n    in\n    let rec read_flags str_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      begin match str.[str_ind] with\n      | '0' -> set_flag str_ind zero;  read_flags (str_ind + 1)\n      | '-' -> set_flag str_ind minus; read_flags (str_ind + 1)\n      | '+' -> set_flag str_ind plus;  read_flags (str_ind + 1)\n      | '#' -> set_flag str_ind hash; read_flags (str_ind + 1)\n      | ' ' -> set_flag str_ind space; read_flags (str_ind + 1)\n      | _ ->\n        parse_padding pct_ind str_ind end_ind\n          !zero !minus !plus !hash !space ign\n      end\n    in\n    read_flags str_ind\n\n  (* Try to read a digital or a '*' padding. *)\n  and parse_padding : type e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool -> bool ->\n        (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind zero minus plus hash space ign ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let padty = match zero, minus with\n      | false, false -> Right\n      | false, true  -> Left\n      |  true, false -> Zeros\n      |  true, true  ->\n        if legacy_behavior then Left\n        else incompatible_flag pct_ind str_ind '-' \"0\" in\n    match str.[str_ind] with\n    | '0' .. '9' ->\n      let new_ind, width = parse_positive str_ind end_ind 0 in\n      parse_after_padding pct_ind new_ind end_ind minus plus hash space ign\n        (Lit_padding (padty, width))\n    | '*' ->\n      parse_after_padding pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign (Arg_padding padty)\n    | _ ->\n      begin match padty with\n      | Left  ->\n        if not legacy_behavior then\n          invalid_format_without (str_ind - 1) '-' \"padding\";\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      | Zeros ->\n         (* a '0' padding indication not followed by anything should\n           be interpreted as a Right padding of width 0. This is used\n           by scanning conversions %0s and %0c *)\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          (Lit_padding (Right, 0))\n      | Right ->\n        parse_after_padding pct_ind str_ind end_ind minus plus hash space ign\n          No_padding\n      end\n\n  (* Is precision defined? *)\n  and parse_after_padding : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '.' ->\n      parse_precision pct_ind (str_ind + 1) end_ind minus plus hash space ign\n        pad\n    | symb ->\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        No_precision pad symb\n\n  (* Read the digital or '*' precision. *)\n  and parse_precision : type x e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, _) padding -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_literal minus str_ind =\n      let new_ind, prec = parse_positive str_ind end_ind 0 in\n      parse_after_precision pct_ind new_ind end_ind minus plus hash space ign\n        pad (Lit_precision prec) in\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_literal minus str_ind\n    | ('+' | '-') as symb when legacy_behavior ->\n      (* Legacy mode would accept and ignore '+' or '-' before the\n         integer describing the desired precision; not that this\n         cannot happen for padding width, as '+' and '-' already have\n         a semantics there.\n\n         That said, the idea (supported by this tweak) that width and\n         precision literals are \"integer literals\" in the OCaml sense is\n         still blatantly wrong, as 123_456 or 0xFF are rejected. *)\n      parse_literal (minus || symb = '-') (str_ind + 1)\n    | '*' ->\n      parse_after_precision pct_ind (str_ind + 1) end_ind minus plus hash space\n        ign pad Arg_precision\n    | _ ->\n      if legacy_behavior then\n        (* note that legacy implementation did not ignore '.' without\n           a number (as it does for padding indications), but\n           interprets it as '.0' *)\n        parse_after_precision pct_ind str_ind end_ind minus plus hash space ign\n          pad (Lit_precision 0)\n      else\n        invalid_format_without (str_ind - 1) '.' \"precision\"\n\n  (* Try to read the conversion. *)\n  and parse_after_precision : type x y z t e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> bool ->\n        (x, y) padding -> (z, t) precision -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind minus plus hash space ign pad prec ->\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    let parse_conv (type u) (type v) (padprec : (u, v) padding) =\n      parse_conversion pct_ind (str_ind + 1) end_ind plus hash space ign pad\n        prec padprec str.[str_ind] in\n    (* in legacy mode, some formats (%s and %S) accept a weird mix of\n       padding and precision, which is merged as a single padding\n       information. For example, in %.10s the precision is implicitly\n       understood as padding %10s, but the left-padding component may\n       be specified either as a left padding or a negative precision:\n       %-.3s and %.-3s are equivalent to %-3s *)\n    match pad with\n    | No_padding -> (\n      match minus, prec with\n        | _, No_precision -> parse_conv No_padding\n        | false, Lit_precision n -> parse_conv (Lit_padding (Right, n))\n        | true, Lit_precision n -> parse_conv (Lit_padding (Left, n))\n        | false, Arg_precision -> parse_conv (Arg_padding Right)\n        | true, Arg_precision -> parse_conv (Arg_padding Left)\n    )\n    | pad -> parse_conv pad\n\n  (* Case analysis on conversion. *)\n  and parse_conversion : type x y z t u v e f .\n      int -> int -> int -> bool -> bool -> bool -> bool -> (x, y) padding ->\n        (z, t) precision -> (u, v) padding -> char -> (_, _, e, f) fmt_ebb =\n  fun pct_ind str_ind end_ind plus hash space ign pad prec padprec symb ->\n    (* Flags used to check option usages/compatibilities. *)\n    let plus_used  = ref false and hash_used = ref false\n    and space_used = ref false and ign_used   = ref false\n    and pad_used   = ref false and prec_used  = ref false in\n\n    (* Access to options, update flags. *)\n    let get_plus    () = plus_used  := true; plus\n    and get_hash   () = hash_used := true; hash\n    and get_space   () = space_used := true; space\n    and get_ign     () = ign_used   := true; ign\n    and get_pad     () = pad_used   := true; pad\n    and get_prec    () = prec_used  := true; prec\n    and get_padprec () = pad_used   := true; padprec in\n\n    let get_int_pad () =\n      (* %5.3d is accepted and meaningful: pad to length 5 with\n         spaces, but first pad with zeros upto length 3 (0-padding\n         is the interpretation of \"precision\" for integer formats).\n\n         %05.3d is redundant: pad to length 5 *with zeros*, but\n         first pad with zeros... To add insult to the injury, the\n         legacy implementation ignores the 0-padding indication and\n         does the 5 padding with spaces instead. We reuse this\n         interpretation for compatiblity, but statically reject this\n         format when the legacy mode is disabled, to protect strict\n         users from this corner case. *)\n       match get_pad (), get_prec () with\n         | pad, No_precision -> pad\n         | No_padding, _     -> No_padding\n         | Lit_padding (Zeros, n), _ ->\n           if legacy_behavior then Lit_padding (Right, n)\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Arg_padding Zeros, _ ->\n           if legacy_behavior then Arg_padding Right\n           else incompatible_flag pct_ind str_ind '0' \"precision\"\n         | Lit_padding _ as pad, _ -> pad\n         | Arg_padding _ as pad, _ -> pad in\n\n    (* Check that padty <> Zeros. *)\n    let check_no_0 symb (type a) (type b) (pad : (a, b) padding) =\n      match pad with\n      | No_padding -> pad\n      | Lit_padding ((Left | Right), _) -> pad\n      | Arg_padding (Left | Right) -> pad\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Lit_padding (Right, width)\n        else incompatible_flag pct_ind str_ind symb \"0\"\n      | Arg_padding Zeros ->\n        if legacy_behavior then Arg_padding Right\n        else incompatible_flag pct_ind str_ind symb \"0\"\n    in\n\n    (* Get padding as a pad_option (see \"%_\", \"%{\", \"%(\" and \"%[\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let opt_of_pad c (type a) (type b) (pad : (a, b) padding) = match pad with\n      | No_padding -> None\n      | Lit_padding (Right, width) -> Some width\n      | Lit_padding (Zeros, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'0'\"\n      | Lit_padding (Left, width) ->\n        if legacy_behavior then Some width\n        else incompatible_flag pct_ind str_ind c \"'-'\"\n      | Arg_padding _ -> incompatible_flag pct_ind str_ind c \"'*'\"\n    in\n    let get_pad_opt c = opt_of_pad c (get_pad ()) in\n    let get_padprec_opt c = opt_of_pad c (get_padprec ()) in\n\n    (* Get precision as a prec_option (see \"%_f\").\n       (no need for legacy mode tweaking, those were rejected by the\n       legacy parser as well) *)\n    let get_prec_opt () = match get_prec () with\n      | No_precision       -> None\n      | Lit_precision ndec -> Some ndec\n      | Arg_precision      -> incompatible_flag pct_ind str_ind '_' \"'*'\"\n    in\n\n    let fmt_result = match symb with\n    | ',' ->\n      parse str_ind end_ind\n    | 'c' ->\n      let char_format fmt_rest = (* %c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_char, fmt_rest))\n        else Fmt_EBB (Char fmt_rest)\n      in\n      let scan_format fmt_rest = (* %0c *)\n        if get_ign ()\n        then Fmt_EBB (Ignored_param (Ignored_scan_next_char, fmt_rest))\n        else Fmt_EBB (Scan_next_char fmt_rest)\n      in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      begin match get_pad_opt 'c' with\n        | None -> char_format fmt_rest\n        | Some 0 -> scan_format fmt_rest\n        | Some _n ->\n           if not legacy_behavior\n           then invalid_nonnull_char_width str_ind\n           else (* legacy ignores %c widths *) char_format fmt_rest\n      end\n    | 'C' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_caml_char,fmt_rest))\n      else Fmt_EBB (Caml_char fmt_rest)\n    | 's' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (String (pad', fmt_rest'))\n    | 'S' ->\n      let pad = check_no_0 symb (get_padprec ()) in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_caml_string (get_padprec_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padding_fmt_EBB (pad', fmt_rest') =\n          make_padding_fmt_ebb pad fmt_rest in\n        Fmt_EBB (Caml_string (pad', fmt_rest'))\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' ->\n      let iconv = compute_int_conv pct_ind str_ind (get_plus ()) (get_hash ())\n        (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_int (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int (iconv, pad', prec', fmt_rest'))\n    | 'N' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = Token_counter in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' | 'n' | 'L' when str_ind=end_ind || not (is_int_base str.[str_ind]) ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let counter = counter_of_char symb in\n      if get_ign () then\n        let ignored = Ignored_scan_get_counter counter in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_get_counter (counter, fmt_rest))\n    | 'l' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int32 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int32 (iconv, pad', prec', fmt_rest'))\n    | 'n' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ())\n          (get_hash ()) (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_nativeint (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Nativeint (iconv, pad', prec', fmt_rest'))\n    | 'L' ->\n      let iconv =\n        compute_int_conv pct_ind (str_ind + 1) (get_plus ()) (get_hash ())\n          (get_space ()) str.[str_ind] in\n      let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n      if get_ign () then\n        let ignored = Ignored_int64 (iconv, get_pad_opt '_') in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_int_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Int64 (iconv, pad', prec', fmt_rest'))\n    | 'f' | 'e' | 'E' | 'g' | 'G' | 'F' | 'h' | 'H' ->\n      let fconv = compute_float_conv pct_ind str_ind (get_plus ())\n        (get_space ()) symb in\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_float (get_pad_opt '_', get_prec_opt ()) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        let Padprec_fmt_EBB (pad', prec', fmt_rest') =\n          make_padprec_fmt_ebb (get_pad ()) (get_prec ()) fmt_rest in\n        Fmt_EBB (Float (fconv, pad', prec', fmt_rest'))\n    | 'b' | 'B' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_bool, fmt_rest))\n      else Fmt_EBB (Bool fmt_rest)\n    | 'a' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Alpha fmt_rest)\n    | 't' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Theta fmt_rest)\n    | 'r' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      if get_ign () then Fmt_EBB (Ignored_param (Ignored_reader, fmt_rest))\n      else Fmt_EBB (Reader fmt_rest)\n    | '!' ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Flush fmt_rest)\n    | ('%' | '@') as c ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Char_literal (c, fmt_rest))\n    | '{' ->\n      let sub_end = search_subformat_end str_ind end_ind '}' in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_arg (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_arg (get_pad_opt '{', sub_fmtty, fmt_rest))\n    | '(' ->\n      let sub_end = search_subformat_end str_ind end_ind ')' in\n      let Fmt_EBB fmt_rest = parse (sub_end + 2) end_ind in\n      let Fmt_EBB sub_fmt = parse str_ind sub_end in\n      let sub_fmtty = fmtty_of_fmt sub_fmt in\n      if get_ign () then\n        let ignored = Ignored_format_subst (get_pad_opt '_', sub_fmtty) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Format_subst (get_pad_opt '(', sub_fmtty, fmt_rest))\n    | '[' ->\n      let next_ind, char_set = parse_char_set str_ind end_ind in\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      if get_ign () then\n        let ignored = Ignored_scan_char_set (get_pad_opt '_', char_set) in\n        Fmt_EBB (Ignored_param (ignored, fmt_rest))\n      else\n        Fmt_EBB (Scan_char_set (get_pad_opt '[', char_set, fmt_rest))\n    | '-' | '+' | '#' | ' ' | '_' ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         flag %C is only allowed after the '%%', before padding and precision\"\n        str pct_ind symb\n    | _ ->\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         invalid conversion \\\"%%%c\\\"\" str (str_ind - 1) symb\n    in\n    (* Check for unused options, and reject them as incompatible.\n\n       Such checks need to be disabled in legacy mode, as the legacy\n       parser silently ignored incompatible flags. *)\n    if not legacy_behavior then begin\n    if not !plus_used && plus then\n      incompatible_flag pct_ind str_ind symb \"'+'\";\n    if not !hash_used && hash then\n      incompatible_flag pct_ind str_ind symb \"'#'\";\n    if not !space_used && space then\n      incompatible_flag pct_ind str_ind symb \"' '\";\n    if not !pad_used  && Padding_EBB pad <> Padding_EBB No_padding then\n      incompatible_flag pct_ind str_ind symb \"`padding'\";\n    if not !prec_used && Precision_EBB prec <> Precision_EBB No_precision then\n      incompatible_flag pct_ind str_ind (if ign then '_' else symb)\n        \"`precision'\";\n    if ign && plus then incompatible_flag pct_ind str_ind '_' \"'+'\";\n    end;\n    (* this last test must not be disabled in legacy mode,\n       as ignoring it would typically result in a different typing\n       than what the legacy parser used *)\n    if not !ign_used && ign then\n      begin match symb with\n        (* argument-less formats can safely be ignored in legacy mode *)\n        | ('@' | '%' | '!' | ',') when legacy_behavior -> ()\n        | _ ->\n          incompatible_flag pct_ind str_ind symb \"'_'\"\n      end;\n    fmt_result\n\n  (* Parse formatting informations (after '@'). *)\n  and parse_after_at : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    if str_ind = end_ind then Fmt_EBB (Char_literal ('@', End_of_format))\n    else\n      match str.[str_ind] with\n      | '[' ->\n        parse_tag false (str_ind + 1) end_ind\n      | ']' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_box, fmt_rest))\n      | '{' ->\n        parse_tag true (str_ind + 1) end_ind\n      | '}' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Close_tag, fmt_rest))\n      | ',' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@,\", 0, 0), fmt_rest))\n      | ' ' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Break (\"@ \", 1, 0), fmt_rest))\n      | ';' ->\n        parse_good_break (str_ind + 1) end_ind\n      | '?' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (FFlush, fmt_rest))\n      | '\\n' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Force_newline, fmt_rest))\n      | '.' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Flush_newline, fmt_rest))\n      | '<' ->\n        parse_magic_size (str_ind + 1) end_ind\n      | '@' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_at, fmt_rest))\n      | '%' when str_ind + 1 < end_ind && str.[str_ind + 1] = '%' ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 2) end_ind in\n        Fmt_EBB (Formatting_lit (Escaped_percent, fmt_rest))\n      | '%' ->\n        let Fmt_EBB fmt_rest = parse str_ind end_ind in\n        Fmt_EBB (Char_literal ('@', fmt_rest))\n      | c ->\n        let Fmt_EBB fmt_rest = parse (str_ind + 1) end_ind in\n        Fmt_EBB (Formatting_lit (Scan_indic c, fmt_rest))\n\n  and check_open_box : type a b c d e f . (a, b, c, d, e, f) fmt -> unit =\n  fun fmt -> match fmt with\n    | String_literal (str, End_of_format) -> (\n      try ignore (open_box_of_string str) with Failure _ ->\n        ((* Emit warning: invalid open box *))\n    )\n    | _ -> ()\n\n  (* Try to read the optionnal <name> after \"@{\" or \"@[\". *)\n  and parse_tag : type e f . bool -> int -> int -> (_, _, e, f) fmt_ebb =\n  fun is_open_tag str_ind end_ind ->\n    try\n      if str_ind = end_ind then raise Not_found;\n      match str.[str_ind] with\n      | '<' ->\n        let ind = String.index_from str (str_ind + 1) '>' in\n        if ind >= end_ind then raise Not_found;\n        let sub_str = String.sub str str_ind (ind - str_ind + 1) in\n        let Fmt_EBB fmt_rest = parse (ind + 1) end_ind in\n        let Fmt_EBB sub_fmt = parse str_ind (ind + 1) in\n        let sub_format = Format (sub_fmt, sub_str) in\n        let formatting = if is_open_tag then Open_tag sub_format else (\n          check_open_box sub_fmt;\n          Open_box sub_format) in\n        Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n      | _ ->\n        raise Not_found\n    with Not_found ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      let sub_format = Format (End_of_format, \"\") in\n      let formatting =\n        if is_open_tag then Open_tag sub_format else Open_box sub_format in\n      Fmt_EBB (Formatting_gen (formatting, fmt_rest))\n\n  (* Try to read the optionnal <width offset> after \"@;\". *)\n  and parse_good_break : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    let next_ind, formatting_lit =\n      try\n        if str_ind = end_ind || str.[str_ind] <> '<' then raise Not_found;\n        let str_ind_1 = parse_spaces (str_ind + 1) end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' -> (\n          let str_ind_2, width = parse_integer str_ind_1 end_ind in\n            let str_ind_3 = parse_spaces str_ind_2 end_ind in\n            match str.[str_ind_3] with\n              | '>' ->\n                let s = String.sub str (str_ind-2) (str_ind_3-str_ind+3) in\n                str_ind_3 + 1, Break (s, width, 0)\n              | '0' .. '9' | '-' ->\n                let str_ind_4, offset = parse_integer str_ind_3 end_ind in\n                let str_ind_5 = parse_spaces str_ind_4 end_ind in\n                if str.[str_ind_5] <> '>' then raise Not_found;\n                let s = String.sub str (str_ind-2) (str_ind_5-str_ind+3) in\n                str_ind_5 + 1, Break (s, width, offset)\n              | _ -> raise Not_found\n        )\n        | _ -> raise Not_found\n      with Not_found | Failure _ ->\n        str_ind, Break (\"@;\", 1, 0)\n    in\n    let Fmt_EBB fmt_rest = parse next_ind end_ind in\n    Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n\n  (* Parse the size in a <n>. *)\n  and parse_magic_size : type e f . int -> int -> (_, _, e, f) fmt_ebb =\n  fun str_ind end_ind ->\n    match\n      try\n        let str_ind_1 = parse_spaces str_ind end_ind in\n        match str.[str_ind_1] with\n        | '0' .. '9' | '-' ->\n          let str_ind_2, size = parse_integer str_ind_1 end_ind in\n          let str_ind_3 = parse_spaces str_ind_2 end_ind in\n          if str.[str_ind_3] <> '>' then raise Not_found;\n          let s = String.sub str (str_ind - 2) (str_ind_3 - str_ind + 3) in\n          Some (str_ind_3 + 1, Magic_size (s, size))\n        | _ -> None\n      with Not_found | Failure _ ->\n        None\n    with\n    | Some (next_ind, formatting_lit) ->\n      let Fmt_EBB fmt_rest = parse next_ind end_ind in\n      Fmt_EBB (Formatting_lit (formatting_lit, fmt_rest))\n    | None ->\n      let Fmt_EBB fmt_rest = parse str_ind end_ind in\n      Fmt_EBB (Formatting_lit (Scan_indic '<', fmt_rest))\n\n  (* Parse and construct a char set. *)\n  and parse_char_set str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n\n    let char_set = create_char_set () in\n    let add_char c =\n      add_in_char_set char_set c;\n    in\n    let add_range c c' =\n      for i = int_of_char c to int_of_char c' do\n        add_in_char_set char_set (char_of_int i);\n      done;\n    in\n\n    let fail_single_percent str_ind =\n      failwith_message\n        \"invalid format %S: '%%' alone is not accepted in character sets, \\\n         use %%%% instead at position %d.\" str str_ind;\n    in\n\n    (* Parse the first character of a char set. *)\n    let rec parse_char_set_start str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      let c = str.[str_ind] in\n      parse_char_set_after_char (str_ind + 1) end_ind c;\n\n    (* Parse the content of a char set until the first ']'. *)\n    and parse_char_set_content str_ind end_ind =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        str_ind + 1\n      | '-' ->\n        add_char '-';\n        parse_char_set_content (str_ind + 1) end_ind;\n      | c ->\n        parse_char_set_after_char (str_ind + 1) end_ind c;\n\n    (* Test for range in char set. *)\n    and parse_char_set_after_char str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        str_ind + 1\n      | '-' ->\n        parse_char_set_after_minus (str_ind + 1) end_ind c\n      | ('%' | '@') as c' when c = '%' ->\n        add_char c';\n        parse_char_set_content (str_ind + 1) end_ind\n      | c' ->\n        if c = '%' then fail_single_percent str_ind;\n        (* note that '@' alone is accepted, as done by the legacy\n           implementation; the documentation specifically requires %@\n           so we could warn on that *)\n        add_char c;\n        parse_char_set_after_char (str_ind + 1) end_ind c'\n\n    (* Manage range in char set (except if the '-' the last char before ']') *)\n    and parse_char_set_after_minus str_ind end_ind c =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n      | ']' ->\n        add_char c;\n        add_char '-';\n        str_ind + 1\n      | '%' ->\n        if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n        begin match str.[str_ind + 1] with\n          | ('%' | '@') as c' ->\n            add_range c c';\n            parse_char_set_content (str_ind + 2) end_ind\n          | _ -> fail_single_percent str_ind\n        end\n      | c' ->\n        add_range c c';\n        parse_char_set_content (str_ind + 1) end_ind\n    in\n    let str_ind, reverse =\n      if str_ind = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind] with\n        | '^' -> str_ind + 1, true\n        | _ -> str_ind, false in\n    let next_ind = parse_char_set_start str_ind end_ind in\n    let char_set = freeze_char_set char_set in\n    next_ind, (if reverse then rev_char_set char_set else char_set)\n\n  (* Consume all next spaces, raise an Failure if end_ind is reached. *)\n  and parse_spaces str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    if str.[str_ind] = ' ' then parse_spaces (str_ind + 1) end_ind else str_ind\n\n  (* Read a positive integer from the string, raise a Failure if end_ind is\n     reached. *)\n  and parse_positive str_ind end_ind acc =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' as c ->\n      let new_acc = acc * 10 + (int_of_char c - int_of_char '0') in\n      if new_acc > Sys.max_string_length then\n        failwith_message\n          \"invalid format %S: integer %d is greater than the limit %d\"\n          str new_acc Sys.max_string_length\n      else\n        parse_positive (str_ind + 1) end_ind new_acc\n    | _ -> str_ind, acc\n\n  (* Read a positive or negative integer from the string, raise a Failure\n     if end_ind is reached. *)\n  and parse_integer str_ind end_ind =\n    if str_ind = end_ind then unexpected_end_of_format end_ind;\n    match str.[str_ind] with\n    | '0' .. '9' -> parse_positive str_ind end_ind 0\n    | '-' -> (\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      match str.[str_ind + 1] with\n      | '0' .. '9' ->\n        let next_ind, n = parse_positive (str_ind + 1) end_ind 0 in\n        next_ind, -n\n      | c ->\n        expected_character (str_ind + 1) \"digit\" c\n    )\n    | _ -> assert false\n\n  (* Add a literal to a format from a literal character sub-sequence. *)\n  and add_literal : type a d e f .\n      int -> int -> (a, _, _, d, e, f) fmt ->\n      (_, _, e, f) fmt_ebb =\n  fun lit_start str_ind fmt -> match str_ind - lit_start with\n    | 0    -> Fmt_EBB fmt\n    | 1    -> Fmt_EBB (Char_literal (str.[lit_start], fmt))\n    | size -> Fmt_EBB (String_literal (String.sub str lit_start size, fmt))\n\n  (* Search the end of the current sub-format\n     (i.e. the corresponding \"%}\" or \"%)\") *)\n  and search_subformat_end str_ind end_ind c =\n    if str_ind = end_ind then\n      failwith_message\n        \"invalid format %S: unclosed sub-format, \\\n         expected \\\"%%%c\\\" at character number %d\" str c end_ind;\n    match str.[str_ind] with\n    | '%' ->\n      if str_ind + 1 = end_ind then unexpected_end_of_format end_ind;\n      if str.[str_ind + 1] = c then (* End of format found *) str_ind else\n        begin match str.[str_ind + 1] with\n        | '_' ->\n          (* Search for \"%_(\" or \"%_{\". *)\n          if str_ind + 2 = end_ind then unexpected_end_of_format end_ind;\n          begin match str.[str_ind + 2] with\n          | '{' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind '}' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | '(' ->\n            let sub_end = search_subformat_end (str_ind + 3) end_ind ')' in\n            search_subformat_end (sub_end + 2) end_ind c\n          | _ -> search_subformat_end (str_ind + 3) end_ind c\n          end\n        | '{' ->\n          (* %{...%} sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind '}' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '(' ->\n          (* %(...%) sub-format found. *)\n          let sub_end = search_subformat_end (str_ind + 2) end_ind ')' in\n          search_subformat_end (sub_end + 2) end_ind c\n        | '}' ->\n          (* Error: %(...%}. *)\n          expected_character (str_ind + 1) \"character ')'\" '}';\n        | ')' ->\n          (* Error: %{...%). *)\n          expected_character (str_ind + 1) \"character '}'\" ')';\n        | _ ->\n          search_subformat_end (str_ind + 2) end_ind c\n        end\n    | _ -> search_subformat_end (str_ind + 1) end_ind c\n\n  (* Check if symb is a valid int conversion after \"%l\", \"%n\" or \"%L\" *)\n  and is_int_base symb = match symb with\n    | 'd' | 'i' | 'x' | 'X' | 'o' | 'u' -> true\n    | _ -> false\n\n  (* Convert a char (l, n or L) to its associated counter. *)\n  and counter_of_char symb = match symb with\n    | 'l' -> Line_counter  | 'n' -> Char_counter\n    | 'L' -> Token_counter | _ -> assert false\n\n  (* Convert (plus, symb) to its associated int_conv. *)\n  and compute_int_conv pct_ind str_ind plus hash space symb =\n    match plus, hash, space, symb with\n    | false, false, false, 'd' -> Int_d  | false, false, false, 'i' -> Int_i\n    | false, false,  true, 'd' -> Int_sd | false, false,  true, 'i' -> Int_si\n    |  true, false, false, 'd' -> Int_pd |  true, false, false, 'i' -> Int_pi\n    | false, false, false, 'x' -> Int_x  | false, false, false, 'X' -> Int_X\n    | false,  true, false, 'x' -> Int_Cx | false,  true, false, 'X' -> Int_CX\n    | false, false, false, 'o' -> Int_o\n    | false,  true, false, 'o' -> Int_Co\n    | false, false, false, 'u' -> Int_u\n    | _, true, _, 'x' when legacy_behavior -> Int_Cx\n    | _, true, _, 'X' when legacy_behavior -> Int_CX\n    | _, true, _, 'o' when legacy_behavior -> Int_Co\n    | _, true, _, ('d' | 'i' | 'u') ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus false space symb\n      else incompatible_flag pct_ind str_ind symb \"'#'\"\n    | true, _, true, _ ->\n      if legacy_behavior then\n        (* plus and space: legacy implementation prefers plus *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\"\n    | false, _, true, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind plus hash false symb\n      else incompatible_flag pct_ind str_ind symb \"' '\"\n    | true, _, false, _    ->\n      if legacy_behavior then (* ignore *)\n        compute_int_conv pct_ind str_ind false hash space symb\n      else incompatible_flag pct_ind str_ind symb \"'+'\"\n    | false, _, false, _ -> assert false\n\n  (* Convert (plus, symb) to its associated float_conv. *)\n  and compute_float_conv pct_ind str_ind plus space symb =\n  match plus, space, symb with\n    | false, false, 'f' -> Float_f  | false, false, 'e' -> Float_e\n    | false,  true, 'f' -> Float_sf | false,  true, 'e' -> Float_se\n    |  true, false, 'f' -> Float_pf |  true, false, 'e' -> Float_pe\n    | false, false, 'E' -> Float_E  | false, false, 'g' -> Float_g\n    | false,  true, 'E' -> Float_sE | false,  true, 'g' -> Float_sg\n    |  true, false, 'E' -> Float_pE |  true, false, 'g' -> Float_pg\n    | false, false, 'G' -> Float_G\n    | false,  true, 'G' -> Float_sG\n    |  true, false, 'G' -> Float_pG\n    | false, false, 'h' -> Float_h\n    | false,  true, 'h' -> Float_sh\n    |  true, false, 'h' -> Float_ph\n    | false, false, 'H' -> Float_H\n    | false,  true, 'H' -> Float_sH\n    |  true, false, 'H' -> Float_pH\n    | false, false, 'F' -> Float_F\n    |  true,  true, _ ->\n      if legacy_behavior then\n        (* plus and space: legacy implementation prefers plus *)\n        compute_float_conv pct_ind str_ind plus false symb\n      else incompatible_flag pct_ind str_ind ' ' \"'+'\"\n    | false,  true, _ ->\n      if legacy_behavior then (* ignore *)\n        compute_float_conv pct_ind str_ind plus false symb\n      else incompatible_flag pct_ind str_ind symb \"' '\"\n    |  true, false, _ ->\n      if legacy_behavior then (* ignore *)\n        compute_float_conv pct_ind str_ind false space symb\n      else incompatible_flag pct_ind str_ind symb \"'+'\"\n    | false, false, _ -> assert false\n\n  (* Raise a Failure with a friendly error message about incompatible options.*)\n  and incompatible_flag : type a . int -> int -> char -> string -> a =\n    fun pct_ind str_ind symb option ->\n      let subfmt = String.sub str pct_ind (str_ind - pct_ind) in\n      failwith_message\n        \"invalid format %S: at character number %d, \\\n         %s is incompatible with '%c' in sub-format %S\"\n        str pct_ind option symb subfmt;\n\n  in parse 0 (String.length str)\n\n(******************************************************************************)\n                  (* Guarded string to format conversions *)\n\n(* Convert a string to a format according to an fmtty. *)\n(* Raise a Failure with an error message in case of type mismatch. *)\nlet format_of_string_fmtty str fmtty =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt fmtty, str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\"\n      str (string_of_fmtty fmtty)\n\n(* Convert a string to a format compatible with an other format. *)\n(* Raise a Failure with an error message in case of type mismatch. *)\nlet format_of_string_format str (Format (fmt', str')) =\n  let Fmt_EBB fmt = fmt_ebb_of_string str in\n  try Format (type_format fmt (fmtty_of_fmt fmt'), str)\n  with Type_mismatch ->\n    failwith_message\n      \"bad input: format type mismatch between %S and %S\" str str'\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen Printf\n\nlet printers = ref []\n\nlet locfmt = format_of_string \"File \\\"%s\\\", line %d, characters %d-%d: %s\"\n\nlet field x i =\n  let f = Obj.field x i in\n  if not (Obj.is_block f) then\n    sprintf \"%d\" (Obj.magic f : int)           (* can also be a char *)\n  else if Obj.tag f = Obj.string_tag then\n    sprintf \"%S\" (Obj.magic f : string)\n  else if Obj.tag f = Obj.double_tag then\n    string_of_float (Obj.magic f : float)\n  else\n    \"_\"\n\nlet rec other_fields x i =\n  if i >= Obj.size x then \"\"\n  else sprintf \", %s%s\" (field x i) (other_fields x (i+1))\n\nlet fields x =\n  match Obj.size x with\n  | 0 -> \"\"\n  | 1 -> \"\"\n  | 2 -> sprintf \"(%s)\" (field x 1)\n  | _ -> sprintf \"(%s%s)\" (field x 1) (other_fields x 2)\n\nlet to_string x =\n  let rec conv = function\n    | hd :: tl ->\n        (match try hd x with _ -> None with\n        | Some s -> s\n        | None -> conv tl)\n    | [] ->\n        match x with\n        | Out_of_memory -> \"Out of memory\"\n        | Stack_overflow -> \"Stack overflow\"\n        | Match_failure(file, line, char) ->\n            sprintf locfmt file line char (char+5) \"Pattern matching failed\"\n        | Assert_failure(file, line, char) ->\n            sprintf locfmt file line char (char+6) \"Assertion failed\"\n        | Undefined_recursive_module(file, line, char) ->\n            sprintf locfmt file line char (char+6) \"Undefined recursive module\"\n        | _ ->\n            let x = Obj.repr x in\n            if Obj.tag x <> 0 then\n              (Obj.magic (Obj.field x 0) : string)\n            else\n              let constructor =\n                (Obj.magic (Obj.field (Obj.field x 0) 0) : string) in\n              constructor ^ (fields x) in\n  conv !printers\n\nlet print fct arg =\n  try\n    fct arg\n  with x ->\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    flush stderr;\n    raise x\n\nlet catch fct arg =\n  try\n    fct arg\n  with x ->\n    flush stdout;\n    eprintf \"Uncaught exception: %s\\n\" (to_string x);\n    exit 2\n\ntype raw_backtrace_slot\ntype raw_backtrace\n\nexternal get_raw_backtrace:\n  unit -> raw_backtrace = \"caml_get_exception_raw_backtrace\"\n\ntype backtrace_slot =\n  | Known_location of {\n      is_raise    : bool;\n      filename    : string;\n      line_number : int;\n      start_char  : int;\n      end_char    : int;\n      is_inline   : bool;\n    }\n  | Unknown_location of {\n      is_raise : bool\n    }\n\n(* to avoid warning *)\nlet _ = [Known_location { is_raise = false; filename = \"\";\n                          line_number = 0; start_char = 0; end_char = 0;\n                          is_inline = false };\n         Unknown_location { is_raise = false }]\n\nexternal convert_raw_backtrace_slot:\n  raw_backtrace_slot -> backtrace_slot = \"caml_convert_raw_backtrace_slot\"\n\nexternal convert_raw_backtrace:\n  raw_backtrace -> backtrace_slot array = \"caml_convert_raw_backtrace\"\n\nlet convert_raw_backtrace bt =\n  try Some (convert_raw_backtrace bt)\n  with Failure _ -> None\n\nlet format_backtrace_slot pos slot =\n  let info is_raise =\n    if is_raise then\n      if pos = 0 then \"Raised at\" else \"Re-raised at\"\n    else\n      if pos = 0 then \"Raised by primitive operation at\" else \"Called from\"\n  in\n  match slot with\n  | Unknown_location l ->\n      if l.is_raise then\n        (* compiler-inserted re-raise, skipped *) None\n      else\n        Some (sprintf \"%s unknown location\" (info false))\n  | Known_location l ->\n      Some (sprintf \"%s file \\\"%s\\\"%s, line %d, characters %d-%d\"\n              (info l.is_raise) l.filename\n              (if l.is_inline then \" (inlined)\" else \"\")\n              l.line_number l.start_char l.end_char)\n\nlet print_exception_backtrace outchan backtrace =\n  match backtrace with\n  | None ->\n      fprintf outchan\n        \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> fprintf outchan \"%s\\n\" str\n      done\n\nlet print_raw_backtrace outchan raw_backtrace =\n  print_exception_backtrace outchan (convert_raw_backtrace raw_backtrace)\n\n(* confusingly named: prints the global current backtrace *)\nlet print_backtrace outchan =\n  print_raw_backtrace outchan (get_raw_backtrace ())\n\nlet backtrace_to_string backtrace =\n  match backtrace with\n  | None ->\n     \"(Program not linked with -g, cannot print stack backtrace)\\n\"\n  | Some a ->\n      let b = Buffer.create 1024 in\n      for i = 0 to Array.length a - 1 do\n        match format_backtrace_slot i a.(i) with\n          | None -> ()\n          | Some str -> bprintf b \"%s\\n\" str\n      done;\n      Buffer.contents b\n\nlet raw_backtrace_to_string raw_backtrace =\n  backtrace_to_string (convert_raw_backtrace raw_backtrace)\n\nlet backtrace_slot_is_raise = function\n  | Known_location l -> l.is_raise\n  | Unknown_location l -> l.is_raise\n\nlet backtrace_slot_is_inline = function\n  | Known_location l -> l.is_inline\n  | Unknown_location _ -> false\n\ntype location = {\n  filename : string;\n  line_number : int;\n  start_char : int;\n  end_char : int;\n}\n\nlet backtrace_slot_location = function\n  | Unknown_location _ -> None\n  | Known_location l ->\n    Some {\n      filename    = l.filename;\n      line_number = l.line_number;\n      start_char  = l.start_char;\n      end_char    = l.end_char;\n    }\n\nlet backtrace_slots raw_backtrace =\n  (* The documentation of this function guarantees that Some is\n     returned only if a part of the trace is usable. This gives us\n     a bit more work than just convert_raw_backtrace, but it makes the\n     API more user-friendly -- otherwise most users would have to\n     reimplement the \"Program not linked with -g, sorry\" logic\n     themselves. *)\n  match convert_raw_backtrace raw_backtrace with\n    | None -> None\n    | Some backtrace ->\n      let usable_slot = function\n        | Unknown_location _ -> false\n        | Known_location _ -> true in\n      let rec exists_usable = function\n        | (-1) -> false\n        | i -> usable_slot backtrace.(i) || exists_usable (i - 1) in\n      if exists_usable (Array.length backtrace - 1)\n      then Some backtrace\n      else None\n\nmodule Slot = struct\n  type t = backtrace_slot\n  let format = format_backtrace_slot\n  let is_raise = backtrace_slot_is_raise\n  let is_inline = backtrace_slot_is_inline\n  let location = backtrace_slot_location\nend\n\nexternal raw_backtrace_length :\n  raw_backtrace -> int = \"caml_raw_backtrace_length\" [@@noalloc]\n\nexternal get_raw_backtrace_slot :\n  raw_backtrace -> int -> raw_backtrace_slot = \"caml_raw_backtrace_slot\"\n\nexternal get_raw_backtrace_next_slot :\n  raw_backtrace_slot -> raw_backtrace_slot option\n  = \"caml_raw_backtrace_next_slot\"\n\n(* confusingly named:\n   returns the *string* corresponding to the global current backtrace *)\nlet get_backtrace () =\n  backtrace_to_string (convert_raw_backtrace (get_raw_backtrace ()))\n\nexternal record_backtrace: bool -> unit = \"caml_record_backtrace\"\nexternal backtrace_status: unit -> bool = \"caml_backtrace_status\"\n\nlet register_printer fn =\n  printers := fn :: !printers\n\nexternal get_callstack: int -> raw_backtrace = \"caml_get_current_callstack\"\n\nlet exn_slot x =\n  let x = Obj.repr x in\n  if Obj.tag x = 0 then Obj.field x 0 else x\n\nlet exn_slot_id x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 1) : int)\n\nlet exn_slot_name x =\n  let slot = exn_slot x in\n  (Obj.obj (Obj.field slot 0) : string)\n\n\nlet uncaught_exception_handler = ref None\n\nlet set_uncaught_exception_handler fn = uncaught_exception_handler := Some fn\n\nlet empty_backtrace : raw_backtrace = Obj.obj (Obj.new_block Obj.abstract_tag 0)\n\nlet try_get_raw_backtrace () =\n  try\n    get_raw_backtrace ()\n  with _ (* Out_of_memory? *) ->\n    empty_backtrace\n\nlet handle_uncaught_exception' exn debugger_in_use =\n  try\n    (* Get the backtrace now, in case one of the [at_exit] function\n       destroys it. *)\n    let raw_backtrace =\n      if debugger_in_use (* Same test as in [byterun/printexc.c] *) then\n        empty_backtrace\n      else\n        try_get_raw_backtrace ()\n    in\n    (try Pervasives.do_at_exit () with _ -> ());\n    match !uncaught_exception_handler with\n    | None ->\n        eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n        print_raw_backtrace stderr raw_backtrace;\n        flush stderr\n    | Some handler ->\n        try\n          handler exn raw_backtrace\n        with exn' ->\n          let raw_backtrace' = try_get_raw_backtrace () in\n          eprintf \"Fatal error: exception %s\\n\" (to_string exn);\n          print_raw_backtrace stderr raw_backtrace;\n          eprintf \"Fatal error in uncaught exception handler: exception %s\\n\"\n            (to_string exn');\n          print_raw_backtrace stderr raw_backtrace';\n          flush stderr\n  with\n    | Out_of_memory ->\n        prerr_endline\n          \"Fatal error: out of memory in uncaught exception handler\"\n\n(* This function is called by [caml_fatal_uncaught_exception] in\n   [byterun/printexc.c] which expects no exception is raised. *)\nlet handle_uncaught_exception exn debugger_in_use =\n  try\n    handle_uncaught_exception' exn debugger_in_use\n  with _ ->\n    (* There is not much we can do at this point *)\n    ()\n\nexternal register_named_value : string -> 'a -> unit\n  = \"caml_register_named_value\"\n\nlet () =\n  register_named_value \"Printexc.handle_uncaught_exception\"\n    handle_uncaught_exception\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*           Xavier Leroy and Damien Doligez, INRIA Rocquencourt          *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nlet generic_quote quotequote s =\n  let l = String.length s in\n  let b = Buffer.create (l + 20) in\n  Buffer.add_char b '\\'';\n  for i = 0 to l - 1 do\n    if s.[i] = '\\''\n    then Buffer.add_string b quotequote\n    else Buffer.add_char b  s.[i]\n  done;\n  Buffer.add_char b '\\'';\n  Buffer.contents b\n\n(* This function implements the Open Group specification found here:\n  [[1]] http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html\n  In step 1 of [[1]], we choose to return \".\" for empty input.\n    (for compatibility with previous versions of OCaml)\n  In step 2, we choose to process \"//\" normally.\n  Step 6 is not implemented: we consider that the [suffix] operand is\n    always absent.  Suffixes are handled by [chop_suffix] and [chop_extension].\n*)\nlet generic_basename is_dir_sep current_dir_name name =\n  let rec find_end n =\n    if n < 0 then String.sub name 0 1\n    else if is_dir_sep name n then find_end (n - 1)\n    else find_beg n (n + 1)\n  and find_beg n p =\n    if n < 0 then String.sub name 0 p\n    else if is_dir_sep name n then String.sub name (n + 1) (p - n - 1)\n    else find_beg (n - 1) p\n  in\n  if name = \"\"\n  then current_dir_name\n  else find_end (String.length name - 1)\n\n(* This function implements the Open Group specification found here:\n  [[2]] http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html\n  In step 6 of [[2]], we choose to process \"//\" normally.\n*)\nlet generic_dirname is_dir_sep current_dir_name name =\n  let rec trailing_sep n =\n    if n < 0 then String.sub name 0 1\n    else if is_dir_sep name n then trailing_sep (n - 1)\n    else base n\n  and base n =\n    if n < 0 then current_dir_name\n    else if is_dir_sep name n then intermediate_sep n\n    else base (n - 1)\n  and intermediate_sep n =\n    if n < 0 then String.sub name 0 1\n    else if is_dir_sep name n then intermediate_sep (n - 1)\n    else String.sub name 0 (n + 1)\n  in\n  if name = \"\"\n  then current_dir_name\n  else trailing_sep (String.length name - 1)\n\nmodule Unix = struct\n  let current_dir_name = \".\"\n  let parent_dir_name = \"..\"\n  let dir_sep = \"/\"\n  let is_dir_sep s i = s.[i] = '/'\n  let is_relative n = String.length n < 1 || n.[0] <> '/'\n  let is_implicit n =\n    is_relative n\n    && (String.length n < 2 || String.sub n 0 2 <> \"./\")\n    && (String.length n < 3 || String.sub n 0 3 <> \"../\")\n  let check_suffix name suff =\n    String.length name >= String.length suff &&\n    String.sub name (String.length name - String.length suff)\n                    (String.length suff) = suff\n  let temp_dir_name =\n    try Sys.getenv \"TMPDIR\" with Not_found -> \"/tmp\"\n  let quote = generic_quote \"'\\\\''\"\n  let basename = generic_basename is_dir_sep current_dir_name\n  let dirname = generic_dirname is_dir_sep current_dir_name\nend\n\nmodule Win32 = struct\n  let current_dir_name = \".\"\n  let parent_dir_name = \"..\"\n  let dir_sep = \"\\\\\"\n  let is_dir_sep s i = let c = s.[i] in c = '/' || c = '\\\\' || c = ':'\n  let is_relative n =\n    (String.length n < 1 || n.[0] <> '/')\n    && (String.length n < 1 || n.[0] <> '\\\\')\n    && (String.length n < 2 || n.[1] <> ':')\n  let is_implicit n =\n    is_relative n\n    && (String.length n < 2 || String.sub n 0 2 <> \"./\")\n    && (String.length n < 2 || String.sub n 0 2 <> \".\\\\\")\n    && (String.length n < 3 || String.sub n 0 3 <> \"../\")\n    && (String.length n < 3 || String.sub n 0 3 <> \"..\\\\\")\n  let check_suffix name suff =\n   String.length name >= String.length suff &&\n   (let s = String.sub name (String.length name - String.length suff)\n                            (String.length suff) in\n    String.lowercase_ascii s = String.lowercase_ascii suff)\n  let temp_dir_name =\n    try Sys.getenv \"TEMP\" with Not_found -> \".\"\n  let quote s =\n    let l = String.length s in\n    let b = Buffer.create (l + 20) in\n    Buffer.add_char b '\\\"';\n    let rec loop i =\n      if i = l then Buffer.add_char b '\\\"' else\n      match s.[i] with\n      | '\\\"' -> loop_bs 0 i;\n      | '\\\\' -> loop_bs 0 i;\n      | c    -> Buffer.add_char b c; loop (i+1);\n    and loop_bs n i =\n      if i = l then begin\n        Buffer.add_char b '\\\"';\n        add_bs n;\n      end else begin\n        match s.[i] with\n        | '\\\"' -> add_bs (2*n+1); Buffer.add_char b '\\\"'; loop (i+1);\n        | '\\\\' -> loop_bs (n+1) (i+1);\n        | _    -> add_bs n; loop i\n      end\n    and add_bs n = for _j = 1 to n do Buffer.add_char b '\\\\'; done\n    in\n    loop 0;\n    Buffer.contents b\n  let has_drive s =\n    let is_letter = function\n      | 'A' .. 'Z' | 'a' .. 'z' -> true\n      | _ -> false\n    in\n    String.length s >= 2 && is_letter s.[0] && s.[1] = ':'\n  let drive_and_path s =\n    if has_drive s\n    then (String.sub s 0 2, String.sub s 2 (String.length s - 2))\n    else (\"\", s)\n  let dirname s =\n    let (drive, path) = drive_and_path s in\n    let dir = generic_dirname is_dir_sep current_dir_name path in\n    drive ^ dir\n  let basename s =\n    let (_drive, path) = drive_and_path s in\n    generic_basename is_dir_sep current_dir_name path\nend\n\nmodule Cygwin = struct\n  let current_dir_name = \".\"\n  let parent_dir_name = \"..\"\n  let dir_sep = \"/\"\n  let is_dir_sep = Win32.is_dir_sep\n  let is_relative = Win32.is_relative\n  let is_implicit = Win32.is_implicit\n  let check_suffix = Win32.check_suffix\n  let temp_dir_name = Unix.temp_dir_name\n  let quote = Unix.quote\n  let basename = generic_basename is_dir_sep current_dir_name\n  let dirname = generic_dirname is_dir_sep current_dir_name\nend\n\nlet (current_dir_name, parent_dir_name, dir_sep, is_dir_sep,\n     is_relative, is_implicit, check_suffix, temp_dir_name, quote, basename,\n     dirname) =\n  match Sys.os_type with\n  | \"Win32\" ->\n      (Win32.current_dir_name, Win32.parent_dir_name, Win32.dir_sep,\n       Win32.is_dir_sep,\n       Win32.is_relative, Win32.is_implicit, Win32.check_suffix,\n       Win32.temp_dir_name, Win32.quote, Win32.basename, Win32.dirname)\n  | \"Cygwin\" ->\n      (Cygwin.current_dir_name, Cygwin.parent_dir_name, Cygwin.dir_sep,\n       Cygwin.is_dir_sep,\n       Cygwin.is_relative, Cygwin.is_implicit, Cygwin.check_suffix,\n       Cygwin.temp_dir_name, Cygwin.quote, Cygwin.basename, Cygwin.dirname)\n  | _ -> (* normally \"Unix\" *)\n      (Unix.current_dir_name, Unix.parent_dir_name, Unix.dir_sep,\n       Unix.is_dir_sep,\n       Unix.is_relative, Unix.is_implicit, Unix.check_suffix,\n       Unix.temp_dir_name, Unix.quote, Unix.basename, Unix.dirname)\n\nlet concat dirname filename =\n  let l = String.length dirname in\n  if l = 0 || is_dir_sep dirname (l-1)\n  then dirname ^ filename\n  else dirname ^ dir_sep ^ filename\n\nlet chop_suffix name suff =\n  let n = String.length name - String.length suff in\n  if n < 0 then invalid_arg \"Filename.chop_suffix\" else String.sub name 0 n\n\nlet extension_len name =\n  let rec check i0 i =\n    if i < 0 || is_dir_sep name i then 0\n    else if name.[i] = '.' then check i0 (i - 1)\n    else String.length name - i0\n  in\n  let rec search_dot i =\n    if i < 0 || is_dir_sep name i then 0\n    else if name.[i] = '.' then check i (i - 1)\n    else search_dot (i - 1)\n  in\n  search_dot (String.length name - 1)\n\nlet extension name =\n  let l = extension_len name in\n  if l = 0 then \"\" else String.sub name (String.length name - l) l\n\nlet chop_extension name =\n  let l = extension_len name in\n  if l = 0 then invalid_arg \"Filename.chop_extension\"\n  else String.sub name 0 (String.length name - l)\n\nlet remove_extension name =\n  let l = extension_len name in\n  if l = 0 then name else String.sub name 0 (String.length name - l)\n\nexternal open_desc: string -> open_flag list -> int -> int = \"caml_sys_open\"\nexternal close_desc: int -> unit = \"caml_sys_close\"\n\nlet prng = lazy(Random.State.make_self_init ())\n\nlet temp_file_name temp_dir prefix suffix =\n  let rnd = (Random.State.bits (Lazy.force prng)) land 0xFFFFFF in\n  concat temp_dir (Printf.sprintf \"%s%06x%s\" prefix rnd suffix)\n\n\nlet current_temp_dir_name = ref temp_dir_name\n\nlet set_temp_dir_name s = current_temp_dir_name := s\nlet get_temp_dir_name () = !current_temp_dir_name\n\nlet temp_file ?(temp_dir = !current_temp_dir_name) prefix suffix =\n  let rec try_name counter =\n    let name = temp_file_name temp_dir prefix suffix in\n    try\n      close_desc(open_desc name [Open_wronly; Open_creat; Open_excl] 0o600);\n      name\n    with Sys_error _ as e ->\n      if counter >= 1000 then raise e else try_name (counter + 1)\n  in try_name 0\n\nlet open_temp_file ?(mode = [Open_text]) ?(perms = 0o600)\n                   ?(temp_dir = !current_temp_dir_name) prefix suffix =\n  let rec try_name counter =\n    let name = temp_file_name temp_dir prefix suffix in\n    try\n      (name,\n       open_out_gen (Open_wronly::Open_creat::Open_excl::mode) perms name)\n    with Sys_error _ as e ->\n      if counter >= 1000 then raise e else try_name (counter + 1)\n  in try_name 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*            Jérémie Dimino and Leo White, Jane Street Europe            *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)\n(*                         Alain Frisch, LexiFi                           *)\n(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Location = Location\nmodule Longident = Longident\n\nmodule Asttypes = struct\n  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)\n\n  type constant (*IF_CURRENT = Asttypes.constant *) =\n      Const_int of int\n    | Const_char of char\n    | Const_string of string * string option\n    | Const_float of string\n    | Const_int32 of int32\n    | Const_int64 of int64\n    | Const_nativeint of nativeint\n\n  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive\n\n  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto\n\n  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public\n\n  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable\n\n  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete\n\n  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh\n\n  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open\n\n  type label = string\n\n  type 'a loc = 'a Location.loc = {\n    txt : 'a;\n    loc : Location.t;\n  }\n\n\n  type variance (*IF_CURRENT = Asttypes.variance *) =\n    | Covariant\n    | Contravariant\n    | Invariant\nend\n\nmodule Parsetree = struct\n  (** Abstract syntax tree produced by parsing *)\n\n  open Asttypes\n\n  (** {2 Extension points} *)\n\n  type attribute = string loc * payload\n         (* [@id ARG]\n            [@@id ARG]\n\n            Metadata containers passed around within the AST.\n            The compiler ignores unknown attributes.\n         *)\n\n  and extension = string loc * payload\n        (* [%id ARG]\n           [%%id ARG]\n\n           Sub-language placeholder -- rejected by the typechecker.\n        *)\n\n  and attributes = attribute list\n\n  and payload (*IF_CURRENT = Parsetree.payload *) =\n    | PStr of structure\n    | PTyp of core_type  (* : T *)\n    | PPat of pattern * expression option  (* ? P  or  ? P when E *)\n\n  (** {2 Core language} *)\n\n  (* Type expressions *)\n\n  and core_type (*IF_CURRENT = Parsetree.core_type *) =\n      {\n       ptyp_desc: core_type_desc;\n       ptyp_loc: Location.t;\n       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =\n    | Ptyp_any\n          (*  _ *)\n    | Ptyp_var of string\n          (* 'a *)\n    | Ptyp_arrow of label * core_type * core_type\n          (* T1 -> T2       (label = \"\")\n             ~l:T1 -> T2    (label = \"l\")\n             ?l:T1 -> T2    (label = \"?l\")\n           *)\n    | Ptyp_tuple of core_type list\n          (* T1 * ... * Tn\n\n             Invariant: n >= 2\n          *)\n    | Ptyp_constr of Longident.t loc * core_type list\n          (* tconstr\n             T tconstr\n             (T1, ..., Tn) tconstr\n           *)\n    | Ptyp_object of (string * attributes * core_type) list * closed_flag\n          (* < l1:T1; ...; ln:Tn >     (flag = Closed)\n             < l1:T1; ...; ln:Tn; .. > (flag = Open)\n           *)\n    | Ptyp_class of Longident.t loc * core_type list\n          (* #tconstr\n             T #tconstr\n             (T1, ..., Tn) #tconstr\n           *)\n    | Ptyp_alias of core_type * string\n          (* T as 'a *)\n    | Ptyp_variant of row_field list * closed_flag * label list option\n          (* [ `A|`B ]         (flag = Closed; labels = None)\n             [> `A|`B ]        (flag = Open;   labels = None)\n             [< `A|`B ]        (flag = Closed; labels = Some [])\n             [< `A|`B > `X `Y ](flag = Closed; labels = Some [\"X\";\"Y\"])\n           *)\n    | Ptyp_poly of string list * core_type\n          (* 'a1 ... 'an. T\n\n             Can only appear in the following context:\n\n             - As the core_type of a Ppat_constraint node corresponding\n               to a constraint on a let-binding: let x : 'a1 ... 'an. T\n               = e ...\n\n             - Under Cfk_virtual for methods (not values).\n\n             - As the core_type of a Pctf_method node.\n\n             - As the core_type of a Pexp_poly node.\n\n             - As the pld_type field of a label_declaration.\n\n             - As a core_type of a Ptyp_object node.\n           *)\n\n    | Ptyp_package of package_type\n          (* (module S) *)\n    | Ptyp_extension of extension\n          (* [%id] *)\n\n  and package_type = Longident.t loc * (Longident.t loc * core_type) list\n        (*\n          (module S)\n          (module S with type t1 = T1 and ... and tn = Tn)\n         *)\n\n  and row_field (*IF_CURRENT = Parsetree.row_field *) =\n    | Rtag of label * attributes * bool * core_type list\n          (* [`A]                   ( true,  [] )\n             [`A of T]              ( false, [T] )\n             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )\n             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )\n\n            - The 2nd field is true if the tag contains a\n              constant (empty) constructor.\n            - '&' occurs when several types are used for the same constructor\n              (see 4.2 in the manual)\n\n            - TODO: switch to a record representation, and keep location\n          *)\n    | Rinherit of core_type\n          (* [ T ] *)\n\n  (* Patterns *)\n\n  and pattern (*IF_CURRENT = Parsetree.pattern *) =\n      {\n       ppat_desc: pattern_desc;\n       ppat_loc: Location.t;\n       ppat_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =\n    | Ppat_any\n          (* _ *)\n    | Ppat_var of string loc\n          (* x *)\n    | Ppat_alias of pattern * string loc\n          (* P as 'a *)\n    | Ppat_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Ppat_interval of constant * constant\n          (* 'a'..'z'\n\n             Other forms of interval are recognized by the parser\n             but rejected by the type-checker. *)\n    | Ppat_tuple of pattern list\n          (* (P1, ..., Pn)\n\n             Invariant: n >= 2\n          *)\n    | Ppat_construct of Longident.t loc * pattern option\n          (* C                None\n             C P              Some P\n             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])\n           *)\n    | Ppat_variant of label * pattern option\n          (* `A             (None)\n             `A P           (Some P)\n           *)\n    | Ppat_record of (Longident.t loc * pattern) list * closed_flag\n          (* { l1=P1; ...; ln=Pn }     (flag = Closed)\n             { l1=P1; ...; ln=Pn; _}   (flag = Open)\n\n             Invariant: n > 0\n           *)\n    | Ppat_array of pattern list\n          (* [| P1; ...; Pn |] *)\n    | Ppat_or of pattern * pattern\n          (* P1 | P2 *)\n    | Ppat_constraint of pattern * core_type\n          (* (P : T) *)\n    | Ppat_type of Longident.t loc\n          (* #tconst *)\n    | Ppat_lazy of pattern\n          (* lazy P *)\n    | Ppat_unpack of string loc\n          (* (module P)\n             Note: (module P : S) is represented as\n             Ppat_constraint(Ppat_unpack, Ptyp_package)\n           *)\n    | Ppat_exception of pattern\n          (* exception P *)\n    | Ppat_extension of extension\n          (* [%id] *)\n\n  (* Value expressions *)\n\n  and expression (*IF_CURRENT = Parsetree.expression *) =\n      {\n       pexp_desc: expression_desc;\n       pexp_loc: Location.t;\n       pexp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =\n    | Pexp_ident of Longident.t loc\n          (* x\n             M.x\n           *)\n    | Pexp_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Pexp_let of rec_flag * value_binding list * expression\n          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)\n           *)\n    | Pexp_function of case list\n          (* function P1 -> E1 | ... | Pn -> En *)\n    | Pexp_fun of label * expression option * pattern * expression\n          (* fun P -> E1                          (lab = \"\", None)\n             fun ~l:P -> E1                       (lab = \"l\", None)\n             fun ?l:P -> E1                       (lab = \"?l\", None)\n             fun ?l:(P = E0) -> E1                (lab = \"?l\", Some E0)\n\n             Notes:\n             - If E0 is provided, lab must start with '?'.\n             - \"fun P1 P2 .. Pn -> E1\" is represented as nested Pexp_fun.\n             - \"let f P = E\" is represented using Pexp_fun.\n           *)\n    | Pexp_apply of expression * (label * expression) list\n          (* E0 ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pexp_match of expression * case list\n          (* match E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_try of expression * case list\n          (* try E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_tuple of expression list\n          (* (E1, ..., En)\n\n             Invariant: n >= 2\n          *)\n    | Pexp_construct of Longident.t loc * expression option\n          (* C                None\n             C E              Some E\n             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])\n          *)\n    | Pexp_variant of label * expression option\n          (* `A             (None)\n             `A E           (Some E)\n           *)\n    | Pexp_record of (Longident.t loc * expression) list * expression option\n          (* { l1=P1; ...; ln=Pn }     (None)\n             { E0 with l1=P1; ...; ln=Pn }   (Some E0)\n\n             Invariant: n > 0\n           *)\n    | Pexp_field of expression * Longident.t loc\n          (* E.l *)\n    | Pexp_setfield of expression * Longident.t loc * expression\n          (* E1.l <- E2 *)\n    | Pexp_array of expression list\n          (* [| E1; ...; En |] *)\n    | Pexp_ifthenelse of expression * expression * expression option\n          (* if E1 then E2 else E3 *)\n    | Pexp_sequence of expression * expression\n          (* E1; E2 *)\n    | Pexp_while of expression * expression\n          (* while E1 do E2 done *)\n    | Pexp_for of\n        pattern *  expression * expression * direction_flag * expression\n          (* for i = E1 to E2 do E3 done      (flag = Upto)\n             for i = E1 downto E2 do E3 done  (flag = Downto)\n           *)\n    | Pexp_constraint of expression * core_type\n          (* (E : T) *)\n    | Pexp_coerce of expression * core_type option * core_type\n          (* (E :> T)        (None, T)\n             (E : T0 :> T)   (Some T0, T)\n           *)\n    | Pexp_send of expression * string\n          (*  E # m *)\n    | Pexp_new of Longident.t loc\n          (* new M.c *)\n    | Pexp_setinstvar of string loc * expression\n          (* x <- 2 *)\n    | Pexp_override of (string loc * expression) list\n          (* {< x1 = E1; ...; Xn = En >} *)\n    | Pexp_letmodule of string loc * module_expr * expression\n          (* let module M = ME in E *)\n    | Pexp_assert of expression\n          (* assert E\n             Note: \"assert false\" is treated in a special way by the\n             type-checker. *)\n    | Pexp_lazy of expression\n          (* lazy E *)\n    | Pexp_poly of expression * core_type option\n          (* Used for method bodies.\n\n             Can only be used as the expression under Cfk_concrete\n             for methods (not values). *)\n    | Pexp_object of class_structure\n          (* object ... end *)\n    | Pexp_newtype of string * expression\n          (* fun (type t) -> E *)\n    | Pexp_pack of module_expr\n          (* (module ME)\n\n             (module ME : S) is represented as\n             Pexp_constraint(Pexp_pack, Ptyp_package S) *)\n    | Pexp_open of override_flag * Longident.t loc * expression\n          (* let open M in E\n             let! open M in E\n          *)\n    | Pexp_extension of extension\n          (* [%id] *)\n\n  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)\n      {\n       pc_lhs: pattern;\n       pc_guard: expression option;\n       pc_rhs: expression;\n      }\n\n  (* Value descriptions *)\n\n  and value_description (*IF_CURRENT = Parsetree.value_description *) =\n      {\n       pval_name: string loc;\n       pval_type: core_type;\n       pval_prim: string list;\n       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n       pval_loc: Location.t;\n      }\n\n  (*\n    val x: T                            (prim = [])\n    external x: T = \"s1\" ... \"sn\"       (prim = [\"s1\";...\"sn\"])\n\n    Note: when used under Pstr_primitive, prim cannot be empty\n  *)\n\n  (* Type declarations *)\n\n  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =\n      {\n       ptype_name: string loc;\n       ptype_params: (core_type * variance) list;\n             (* ('a1,...'an) t; None represents  _*)\n       ptype_cstrs: (core_type * core_type * Location.t) list;\n             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)\n       ptype_kind: type_kind;\n       ptype_private: private_flag;   (* = private ... *)\n       ptype_manifest: core_type option;  (* = T *)\n       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n       ptype_loc: Location.t;\n      }\n\n  (*\n    type t                     (abstract, no manifest)\n    type t = T0                (abstract, manifest=T0)\n    type t = C of T | ...      (variant,  no manifest)\n    type t = T0 = C of T | ... (variant,  manifest=T0)\n    type t = {l: T; ...}       (record,   no manifest)\n    type t = T0 = {l : T; ...} (record,   manifest=T0)\n    type t = ..                (open,     no manifest)\n  *)\n\n  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =\n    | Ptype_abstract\n    | Ptype_variant of constructor_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_record of label_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_open\n\n  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =\n      {\n       pld_name: string loc;\n       pld_mutable: mutable_flag;\n       pld_type: core_type;\n       pld_loc: Location.t;\n       pld_attributes: attributes; (* l [@id1] [@id2] : T *)\n      }\n\n  (*  { ...; l: T; ... }            (mutable=Immutable)\n      { ...; mutable l: T; ... }    (mutable=Mutable)\n\n      Note: T can be a Ptyp_poly.\n  *)\n\n  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =\n      {\n       pcd_name: string loc;\n       pcd_args: core_type list;\n       pcd_res: core_type option;\n       pcd_loc: Location.t;\n       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n  (*\n    | C of T1 * ... * Tn     (res = None)\n    | C: T0                  (args = [], res = Some T0)\n    | C: T1 * ... * Tn -> T0 (res = Some T0)\n  *)\n\n  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =\n      {\n       ptyext_path: Longident.t loc;\n       ptyext_params: (core_type * variance) list;\n       ptyext_constructors: extension_constructor list;\n       ptyext_private: private_flag;\n       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n      }\n  (*\n    type t += ...\n  *)\n\n  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =\n      {\n       pext_name: string loc;\n       pext_kind : extension_constructor_kind;\n       pext_loc : Location.t;\n       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =\n      Pext_decl of core_type list * core_type option\n        (*\n           | C of T1 * ... * Tn     ([T1; ...; Tn], None)\n           | C: T0                  ([], Some T0)\n           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)\n         *)\n    | Pext_rebind of Longident.t loc\n        (*\n           | C = D\n         *)\n\n  (** {2 Class language} *)\n\n  (* Type expressions for the class language *)\n\n  and class_type (*IF_CURRENT = Parsetree.class_type *) =\n      {\n       pcty_desc: class_type_desc;\n       pcty_loc: Location.t;\n       pcty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =\n    | Pcty_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcty_signature of class_signature\n          (* object ... end *)\n    | Pcty_arrow of label * core_type * class_type\n          (* T -> CT       (label = \"\")\n             ~l:T -> CT    (label = \"l\")\n             ?l:T -> CT    (label = \"?l\")\n           *)\n    | Pcty_extension of extension\n          (* [%id] *)\n\n  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =\n      {\n       pcsig_self: core_type;\n       pcsig_fields: class_type_field list;\n      }\n  (* object('selfpat) ... end\n     object ... end             (self = Ptyp_any)\n   *)\n\n  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =\n      {\n       pctf_desc: class_type_field_desc;\n       pctf_loc: Location.t;\n       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =\n    | Pctf_inherit of class_type\n          (* inherit CT *)\n    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)\n          (* val x: T *)\n    | Pctf_method  of (string * private_flag * virtual_flag * core_type)\n          (* method x: T\n\n             Note: T can be a Ptyp_poly.\n           *)\n    | Pctf_constraint  of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pctf_attribute of attribute\n          (* [@@@id] *)\n    | Pctf_extension of extension\n          (* [%%id] *)\n\n  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =\n      {\n       pci_virt: virtual_flag;\n       pci_params: (core_type * variance) list;\n       pci_name: string loc;\n       pci_expr: 'a;\n       pci_loc: Location.t;\n       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n      }\n  (* class c = ...\n     class ['a1,...,'an] c = ...\n     class virtual c = ...\n\n     Also used for \"class type\" declaration.\n  *)\n\n  and class_description = class_type class_infos\n\n  and class_type_declaration = class_type class_infos\n\n  (* Value expressions for the class language *)\n\n  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =\n      {\n       pcl_desc: class_expr_desc;\n       pcl_loc: Location.t;\n       pcl_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =\n    | Pcl_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcl_structure of class_structure\n          (* object ... end *)\n    | Pcl_fun of label * expression option * pattern * class_expr\n          (* fun P -> CE                          (lab = \"\", None)\n             fun ~l:P -> CE                       (lab = \"l\", None)\n             fun ?l:P -> CE                       (lab = \"?l\", None)\n             fun ?l:(P = E0) -> CE                (lab = \"?l\", Some E0)\n           *)\n    | Pcl_apply of class_expr * (label * expression) list\n          (* CE ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pcl_let of rec_flag * value_binding list * class_expr\n          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)\n           *)\n    | Pcl_constraint of class_expr * class_type\n          (* (CE : CT) *)\n    | Pcl_extension of extension\n          (* [%id] *)\n\n  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =\n      {\n       pcstr_self: pattern;\n       pcstr_fields: class_field list;\n      }\n  (* object(selfpat) ... end\n     object ... end           (self = Ppat_any)\n   *)\n\n  and class_field (*IF_CURRENT = Parsetree.class_field *) =\n      {\n       pcf_desc: class_field_desc;\n       pcf_loc: Location.t;\n       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =\n    | Pcf_inherit of override_flag * class_expr * string option\n          (* inherit CE\n             inherit CE as x\n             inherit! CE\n             inherit! CE as x\n           *)\n    | Pcf_val of (string loc * mutable_flag * class_field_kind)\n          (* val x = E\n             val virtual x: T\n           *)\n    | Pcf_method of (string loc * private_flag * class_field_kind)\n          (* method x = E            (E can be a Pexp_poly)\n             method virtual x: T     (T can be a Ptyp_poly)\n           *)\n    | Pcf_constraint of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pcf_initializer of expression\n          (* initializer E *)\n    | Pcf_attribute of attribute\n          (* [@@@id] *)\n    | Pcf_extension of extension\n          (* [%%id] *)\n\n  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =\n    | Cfk_virtual of core_type\n    | Cfk_concrete of override_flag * expression\n\n  and class_declaration = class_expr class_infos\n\n  (** {2 Module language} *)\n\n  (* Type expressions for the module language *)\n\n  and module_type (*IF_CURRENT = Parsetree.module_type *) =\n      {\n       pmty_desc: module_type_desc;\n       pmty_loc: Location.t;\n       pmty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =\n    | Pmty_ident of Longident.t loc\n          (* S *)\n    | Pmty_signature of signature\n          (* sig ... end *)\n    | Pmty_functor of string loc * module_type option * module_type\n          (* functor(X : MT1) -> MT2 *)\n    | Pmty_with of module_type * with_constraint list\n          (* MT with ... *)\n    | Pmty_typeof of module_expr\n          (* module type of ME *)\n    | Pmty_extension of extension\n          (* [%id] *)\n    | Pmty_alias of Longident.t loc\n          (* (module M) *)\n\n  and signature = signature_item list\n\n  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =\n      {\n       psig_desc: signature_item_desc;\n       psig_loc: Location.t;\n      }\n\n  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =\n    | Psig_value of value_description\n          (*\n            val x: T\n            external x: T = \"s1\" ... \"sn\"\n           *)\n    | Psig_type of type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Psig_typext of type_extension\n          (* type t1 += ... *)\n    | Psig_exception of extension_constructor\n          (* exception C of T *)\n    | Psig_module of module_declaration\n          (* module X : MT *)\n    | Psig_recmodule of module_declaration list\n          (* module rec X1 : MT1 and ... and Xn : MTn *)\n    | Psig_modtype of module_type_declaration\n          (* module type S = MT\n             module type S *)\n    | Psig_open of open_description\n          (* open X *)\n    | Psig_include of include_description\n          (* include MT *)\n    | Psig_class of class_description list\n          (* class c1 : ... and ... and cn : ... *)\n    | Psig_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Psig_attribute of attribute\n          (* [@@@id] *)\n    | Psig_extension of extension * attributes\n          (* [%%id] *)\n\n  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =\n      {\n       pmd_name: string loc;\n       pmd_type: module_type;\n       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmd_loc: Location.t;\n      }\n  (* S : MT *)\n\n  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =\n      {\n       pmtd_name: string loc;\n       pmtd_type: module_type option;\n       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmtd_loc: Location.t;\n      }\n  (* S = MT\n     S       (abstract module type declaration, pmtd_type = None)\n  *)\n\n  and open_description (*IF_CURRENT = Parsetree.open_description *) =\n      {\n       popen_lid: Longident.t loc;\n       popen_override: override_flag;\n       popen_loc: Location.t;\n       popen_attributes: attributes;\n      }\n  (* open! X - popen_override = Override (silences the 'used identifier\n                                shadowing' warning)\n     open  X - popen_override = Fresh\n   *)\n\n  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =\n      {\n       pincl_mod: 'a;\n       pincl_loc: Location.t;\n       pincl_attributes: attributes;\n      }\n\n  and include_description = module_type include_infos\n  (* include MT *)\n\n  and include_declaration = module_expr include_infos\n  (* include ME *)\n\n  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =\n    | Pwith_type of Longident.t loc * type_declaration\n          (* with type X.t = ...\n\n             Note: the last component of the longident must match\n             the name of the type_declaration. *)\n    | Pwith_module of Longident.t loc * Longident.t loc\n          (* with module X.Y = Z *)\n    | Pwith_typesubst of type_declaration\n          (* with type t := ... *)\n    | Pwith_modsubst of string loc * Longident.t loc\n          (* with module X := Z *)\n\n  (* Value expressions for the module language *)\n\n  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =\n      {\n       pmod_desc: module_expr_desc;\n       pmod_loc: Location.t;\n       pmod_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =\n    | Pmod_ident of Longident.t loc\n          (* X *)\n    | Pmod_structure of structure\n          (* struct ... end *)\n    | Pmod_functor of string loc * module_type option * module_expr\n          (* functor(X : MT1) -> ME *)\n    | Pmod_apply of module_expr * module_expr\n          (* ME1(ME2) *)\n    | Pmod_constraint of module_expr * module_type\n          (* (ME : MT) *)\n    | Pmod_unpack of expression\n          (* (val E) *)\n    | Pmod_extension of extension\n          (* [%id] *)\n\n  and structure = structure_item list\n\n  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =\n      {\n       pstr_desc: structure_item_desc;\n       pstr_loc: Location.t;\n      }\n\n  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =\n    | Pstr_eval of expression * attributes\n          (* E *)\n    | Pstr_value of rec_flag * value_binding list\n          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)\n           *)\n    | Pstr_primitive of value_description\n          (* external x: T = \"s1\" ... \"sn\" *)\n    | Pstr_type of type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Pstr_typext of type_extension\n          (* type t1 += ... *)\n    | Pstr_exception of extension_constructor\n          (* exception C of T\n             exception C = M.X *)\n    | Pstr_module of module_binding\n          (* module X = ME *)\n    | Pstr_recmodule of module_binding list\n          (* module rec X1 = ME1 and ... and Xn = MEn *)\n    | Pstr_modtype of module_type_declaration\n          (* module type S = MT *)\n    | Pstr_open of open_description\n          (* open X *)\n    | Pstr_class of class_declaration list\n          (* class c1 = ... and ... and cn = ... *)\n    | Pstr_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Pstr_include of include_declaration\n          (* include ME *)\n    | Pstr_attribute of attribute\n          (* [@@@id] *)\n    | Pstr_extension of extension * attributes\n          (* [%%id] *)\n\n  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =\n    {\n      pvb_pat: pattern;\n      pvb_expr: expression;\n      pvb_attributes: attributes;\n      pvb_loc: Location.t;\n    }\n\n  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =\n      {\n       pmb_name: string loc;\n       pmb_expr: module_expr;\n       pmb_attributes: attributes;\n       pmb_loc: Location.t;\n      }\n  (* X = ME *)\n\n  (** {2 Toplevel} *)\n\n  (* Toplevel phrases *)\n\n  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =\n    | Ptop_def of structure\n    | Ptop_dir of string * directive_argument\n       (* #use, #load ... *)\n\n  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =\n    | Pdir_none\n    | Pdir_string of string\n    | Pdir_int of int\n    | Pdir_ident of Longident.t\n    | Pdir_bool of bool\nend\n\nmodule Docstrings : sig\n  (** {3 Docstrings} *)\n\n  (** Documentation comments *)\n  type docstring\n\n  (** Create a docstring *)\n  val docstring : string -> Location.t -> docstring\n\n  (** Get the text of a docstring *)\n  val docstring_body : docstring -> string\n\n  (** Get the location of a docstring *)\n  val docstring_loc : docstring -> Location.t\n\n  (** {3 Items}\n\n      The {!docs} type represents documentation attached to an item. *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  val empty_docs : docs\n\n  val docs_attr : docstring -> Parsetree.attribute\n\n  (** Convert item documentation to attributes and add them to an\n      attribute list *)\n  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Fields and constructors}\n\n      The {!info} type represents documentation attached to a field or\n      constructor. *)\n\n  type info = docstring option\n\n  val empty_info : info\n\n  val info_attr : docstring -> Parsetree.attribute\n\n  (** Convert field info to attributes and add them to an\n      attribute list *)\n  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Unattached comments}\n\n      The {!text} type represents documentation which is not attached to\n      anything. *)\n\n  type text = docstring list\n\n  val empty_text : text\n\n  val text_attr : docstring -> Parsetree.attribute\n\n  (** Convert text to attributes and add them to an attribute list *)\n  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes\n\nend = struct\n  open Location\n\n  (* Docstrings *)\n\n  type docstring =\n    { ds_body: string;\n      ds_loc: Location.t; }\n\n  (* Docstring constructors and destructors *)\n\n  let docstring body loc =\n    let ds =\n      { ds_body = body;\n        ds_loc = loc; }\n    in\n    ds\n\n  let docstring_body ds = ds.ds_body\n\n  let docstring_loc ds = ds.ds_loc\n\n  (* Docstrings attached to items *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  let empty_docs = { docs_pre = None; docs_post = None }\n\n  let doc_loc = {txt = \"ocaml.doc\"; loc = Location.none}\n\n  let docs_attr ds =\n    let open Asttypes in\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (doc_loc, PStr [item])\n\n  let add_docs_attrs docs attrs =\n    let attrs =\n      match docs.docs_pre with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> docs_attr ds :: attrs\n    in\n    let attrs =\n      match docs.docs_post with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> attrs @ [docs_attr ds]\n    in\n    attrs\n\n  (* Docstrings attached to constructors or fields *)\n\n  type info = docstring option\n\n  let empty_info = None\n\n  let info_attr = docs_attr\n\n  let add_info_attrs info attrs =\n    match info with\n    | None | Some {ds_body=\"\"; _} -> attrs\n    | Some ds -> attrs @ [info_attr ds]\n\n  (* Docstrings not attached to a specific item *)\n\n  type text = docstring list\n\n  let empty_text = []\n\n  let text_loc = {txt = \"ocaml.text\"; loc = Location.none}\n\n  let text_attr ds =\n    let open Asttypes in\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (text_loc, PStr [item])\n\n  let add_text_attrs dsl attrs =\n    let fdsl = List.filter (function {ds_body=\"\"; _} -> false| _ ->true) dsl in\n    (List.map text_attr fdsl) @ attrs\n\nend\n\nmodule Ast_helper : sig\n  (** Helpers to produce Parsetree fragments *)\n\n  open Parsetree\n  open Asttypes\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  (** {2 Default locations} *)\n\n  val default_loc: loc ref\n      (** Default value for all optional location arguments. *)\n\n  val with_default_loc: loc -> (unit -> 'a) -> 'a\n      (** Set the [default_loc] within the scope of the execution\n          of the provided function. *)\n\n  (** {2 Core language} *)\n\n  (** Type expressions *)\n  module Typ :\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type\n      val attr: core_type -> attribute -> core_type\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type\n      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> core_type\n                 -> core_type\n      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val object_: ?loc:loc -> ?attrs:attrs ->\n                    (string * attributes * core_type) list -> closed_flag ->\n                    core_type\n      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type\n      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag\n                   -> label list option -> core_type\n      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type\n      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list\n                   -> core_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type\n\n      val force_poly: core_type -> core_type\n    end\n\n  (** Patterns *)\n  module Pat:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern\n      val attr:pattern -> attribute -> pattern\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern\n      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern\n      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern\n      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag\n                  -> pattern\n      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern\n      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern\n      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern\n      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern\n    end\n\n  (** Expressions *)\n  module Exp:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression\n      val attr: expression -> attribute -> expression\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list\n                -> expression -> expression\n      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern\n                -> expression -> expression\n      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression\n      val apply: ?loc:loc -> ?attrs:attrs -> expression\n                 -> (label * expression) list -> expression\n      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list\n                  -> expression\n      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression\n      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option\n                     -> expression\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option\n                   -> expression\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list\n                  -> expression option -> expression\n      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n                    -> expression\n      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                      -> expression option -> expression\n      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                    -> expression\n      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                  -> expression\n      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression\n                -> direction_flag -> expression -> expression\n      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                  -> core_type -> expression\n      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type\n                       -> expression\n      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression\n      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list\n                    -> expression\n      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression\n                     -> expression\n      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option -> expression\n      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression\n      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression\n      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression -> expression\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression\n\n      val case: pattern -> ?guard:expression -> expression -> case\n    end\n\n  (** Value declarations *)\n  module Val:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        ?prim:string list -> str -> core_type -> value_description\n    end\n\n  (** Type declarations *)\n  module Type:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?params:(core_type * variance) list -> ?cstrs:(core_type * core_type * loc) list ->\n        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->\n        type_declaration\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?args:core_type list -> ?res:core_type -> str -> constructor_declaration\n      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?mut:mutable_flag -> str -> core_type -> label_declaration\n    end\n\n  (** Type extensions *)\n  module Te:\n    sig\n      val mk: ?attrs:attrs -> ?docs:docs ->\n        ?params:(core_type * variance) list -> ?priv:private_flag ->\n        lid -> extension_constructor list -> type_extension\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> extension_constructor_kind -> extension_constructor\n\n      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        ?args:core_type list -> ?res:core_type -> str -> extension_constructor\n      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> lid -> extension_constructor\n    end\n\n  (** {2 Module language} *)\n\n  (** Module type expressions *)\n  module Mty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type\n      val attr: module_type -> attribute -> module_type\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_type -> module_type\n      val with_: ?loc:loc -> ?attrs:attrs -> module_type -> with_constraint list -> module_type\n      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type\n    end\n\n  (** Module expressions *)\n  module Mod:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr\n      val attr: module_expr -> attribute -> module_expr\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_expr -> module_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr -> module_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type -> module_expr\n      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr\n    end\n\n  (** Signature items *)\n  module Sig:\n    sig\n      val mk: ?loc:loc -> signature_item_desc -> signature_item\n\n      val value: ?loc:loc -> value_description -> signature_item\n      val type_: ?loc:loc -> type_declaration list -> signature_item\n      val type_extension: ?loc:loc -> type_extension -> signature_item\n      val exception_: ?loc:loc -> extension_constructor -> signature_item\n      val module_: ?loc:loc -> module_declaration -> signature_item\n      val rec_module: ?loc:loc -> module_declaration list -> signature_item\n      val modtype: ?loc:loc -> module_type_declaration -> signature_item\n      val open_: ?loc:loc -> open_description -> signature_item\n      val include_: ?loc:loc -> include_description -> signature_item\n      val class_: ?loc:loc -> class_description list -> signature_item\n      val class_type: ?loc:loc -> class_type_declaration list -> signature_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item\n      val attribute: ?loc:loc -> attribute -> signature_item\n      val text: text -> signature_item list\n    end\n\n  (** Structure items *)\n  module Str:\n    sig\n      val mk: ?loc:loc -> structure_item_desc -> structure_item\n\n      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item\n      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item\n      val primitive: ?loc:loc -> value_description -> structure_item\n      val type_: ?loc:loc -> type_declaration list -> structure_item\n      val type_extension: ?loc:loc -> type_extension -> structure_item\n      val exception_: ?loc:loc -> extension_constructor -> structure_item\n      val module_: ?loc:loc -> module_binding -> structure_item\n      val rec_module: ?loc:loc -> module_binding list -> structure_item\n      val modtype: ?loc:loc -> module_type_declaration -> structure_item\n      val open_: ?loc:loc -> open_description -> structure_item\n      val class_: ?loc:loc -> class_declaration list -> structure_item\n      val class_type: ?loc:loc -> class_type_declaration list -> structure_item\n      val include_: ?loc:loc -> include_declaration -> structure_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item\n      val attribute: ?loc:loc -> attribute -> structure_item\n      val text: text -> structure_item list\n    end\n\n  (** Module declarations *)\n  module Md:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_type -> module_declaration\n    end\n\n  (** Module type declarations *)\n  module Mtd:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?typ:module_type -> str -> module_type_declaration\n    end\n\n  (** Module bindings *)\n  module Mb:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_expr -> module_binding\n    end\n\n  (* Opens *)\n  module Opn:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->\n        ?override:override_flag -> lid -> open_description\n    end\n\n  (* Includes *)\n  module Incl:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos\n    end\n\n  (** Value bindings *)\n\n  module Vb:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        pattern -> expression -> value_binding\n    end\n\n\n  (** {2 Class language} *)\n\n  (** Class type expressions *)\n  module Cty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type\n      val attr: class_type -> attribute -> class_type\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type\n      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> class_type -> class_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type\n    end\n\n  (** Class type fields *)\n  module Ctf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        class_type_field_desc -> class_type_field\n      val attr: class_type_field -> attribute -> class_type_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field\n      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag -> virtual_flag -> core_type -> class_type_field\n      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag -> virtual_flag -> core_type -> class_type_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_type_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field\n      val attribute: ?loc:loc -> attribute -> class_type_field\n      val text: text -> class_type_field list\n    end\n\n  (** Class expressions *)\n  module Cl:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr\n      val attr: class_expr -> attribute -> class_expr\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr\n      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern -> class_expr -> class_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> class_expr -> (label * expression) list -> class_expr\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list -> class_expr -> class_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type -> class_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr\n    end\n\n  (** Class fields *)\n  module Cf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc -> class_field\n      val attr: class_field -> attribute -> class_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr -> string option -> class_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag -> class_field_kind -> class_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag -> class_field_kind -> class_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_field\n      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field\n      val attribute: ?loc:loc -> attribute -> class_field\n      val text: text -> class_field list\n\n      val virtual_: core_type -> class_field_kind\n      val concrete: override_flag -> expression -> class_field_kind\n\n    end\n\n  (** Classes *)\n  module Ci:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?virt:virtual_flag -> ?params:(core_type * variance) list ->\n        str -> 'a -> 'a class_infos\n    end\n\n  (** Class signatures *)\n  module Csig:\n    sig\n      val mk: core_type -> class_type_field list -> class_signature\n    end\n\n  (** Class structures *)\n  module Cstr:\n    sig\n      val mk: pattern -> class_field list -> class_structure\n    end\n\nend = struct\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Parsetree\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  let default_loc = ref Location.none\n\n  let with_default_loc l f =\n    let old = !default_loc in\n    default_loc := l;\n    try let r = f () in default_loc := old; r\n    with exn -> default_loc := old; raise exn\n\n  module Typ = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}\n    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))\n    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))\n    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))\n    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))\n    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)\n\n    let force_poly t =\n      match t.ptyp_desc with\n      | Ptyp_poly _ -> t\n      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)\n  end\n\n  module Pat = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}\n    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)\n    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)\n    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))\n    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)\n    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)\n    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)\n  end\n\n  module Exp = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}\n    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))\n    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))\n    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))\n    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))\n    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))\n    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)\n    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))\n    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))\n    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))\n    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))\n    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))\n    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))\n    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)\n    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))\n    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)\n    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))\n    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))\n    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)\n    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))\n    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)\n\n    let case lhs ?guard rhs =\n      {\n       pc_lhs = lhs;\n       pc_guard = guard;\n       pc_rhs = rhs;\n      }\n  end\n\n  module Mty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}\n    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)\n    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)\n    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))\n    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))\n    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)\n  end\n\n  module Mod = struct\n  let mk ?(loc = !default_loc) ?(attrs = []) d =\n    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}\n    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}\n\n    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)\n    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)\n    let functor_ ?loc ?attrs arg arg_ty body =\n      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))\n    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))\n    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))\n    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)\n  end\n\n  module Sig = struct\n    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}\n\n    let value ?loc a = mk ?loc (Psig_value a)\n    let type_ ?loc a = mk ?loc (Psig_type a)\n    let type_extension ?loc a = mk ?loc (Psig_typext a)\n    let exception_ ?loc a = mk ?loc (Psig_exception a)\n    let module_ ?loc a = mk ?loc (Psig_module a)\n    let rec_module ?loc a = mk ?loc (Psig_recmodule a)\n    let modtype ?loc a = mk ?loc (Psig_modtype a)\n    let open_ ?loc a = mk ?loc (Psig_open a)\n    let include_ ?loc a = mk ?loc (Psig_include a)\n    let class_ ?loc a = mk ?loc (Psig_class a)\n    let class_type ?loc a = mk ?loc (Psig_class_type a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Psig_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n  end\n\n  module Str = struct\n    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}\n\n    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))\n    let value ?loc a b = mk ?loc (Pstr_value (a, b))\n    let primitive ?loc a = mk ?loc (Pstr_primitive a)\n    let type_ ?loc a = mk ?loc (Pstr_type a)\n    let type_extension ?loc a = mk ?loc (Pstr_typext a)\n    let exception_ ?loc a = mk ?loc (Pstr_exception a)\n    let module_ ?loc a = mk ?loc (Pstr_module a)\n    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)\n    let modtype ?loc a = mk ?loc (Pstr_modtype a)\n    let open_ ?loc a = mk ?loc (Pstr_open a)\n    let class_ ?loc a = mk ?loc (Pstr_class a)\n    let class_type ?loc a = mk ?loc (Pstr_class_type a)\n    let include_ ?loc a = mk ?loc (Pstr_include a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Pstr_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n  end\n\n  module Cl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcl_desc = d;\n       pcl_loc = loc;\n       pcl_attributes = attrs;\n      }\n    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))\n    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)\n  end\n\n  module Cty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcty_desc = d;\n       pcty_loc = loc;\n       pcty_attributes = attrs;\n      }\n    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)\n  end\n\n  module Ctf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n             ?(docs = empty_docs) d =\n      {\n       pctf_desc = d;\n       pctf_loc = loc;\n       pctf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)\n    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))\n    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)\n    let attribute ?loc a = mk ?loc (Pctf_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n\n    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}\n\n  end\n\n  module Cf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) d =\n      {\n       pcf_desc = d;\n       pcf_loc = loc;\n       pcf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))\n    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))\n    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))\n    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)\n    let attribute ?loc a = mk ?loc (Pcf_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n\n    let virtual_ ct = Cfk_virtual ct\n    let concrete o e = Cfk_concrete (o, e)\n\n    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}\n\n  end\n\n  module Val = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(prim = []) name typ =\n      {\n       pval_name = name;\n       pval_type = typ;\n       pval_attributes = add_docs_attrs docs attrs;\n       pval_loc = loc;\n       pval_prim = prim;\n      }\n  end\n\n  module Md = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name typ =\n      {\n       pmd_name = name;\n       pmd_type = typ;\n       pmd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmd_loc = loc;\n      }\n  end\n\n  module Mtd = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) ?typ name =\n      {\n       pmtd_name = name;\n       pmtd_type = typ;\n       pmtd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmtd_loc = loc;\n      }\n  end\n\n  module Mb = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name expr =\n      {\n       pmb_name = name;\n       pmb_expr = expr;\n       pmb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmb_loc = loc;\n      }\n  end\n\n  module Opn = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(override = Fresh) lid =\n      {\n       popen_lid = lid;\n       popen_override = override;\n       popen_loc = loc;\n       popen_attributes = add_docs_attrs docs attrs;\n      }\n  end\n\n  module Incl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =\n      {\n       pincl_mod = mexpr;\n       pincl_loc = loc;\n       pincl_attributes = add_docs_attrs docs attrs;\n      }\n\n  end\n\n  module Vb = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(text = []) pat expr =\n      {\n       pvb_pat = pat;\n       pvb_expr = expr;\n       pvb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pvb_loc = loc;\n      }\n  end\n\n  module Ci = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n          ?(virt = Concrete) ?(params = []) name expr =\n      {\n       pci_virt = virt;\n       pci_params = params;\n       pci_name = name;\n       pci_expr = expr;\n       pci_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pci_loc = loc;\n      }\n  end\n\n  module Type = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n        ?(params = [])\n        ?(cstrs = [])\n        ?(kind = Ptype_abstract)\n        ?(priv = Public)\n        ?manifest\n        name =\n      {\n       ptype_name = name;\n       ptype_params = params;\n       ptype_cstrs = cstrs;\n       ptype_kind = kind;\n       ptype_private = priv;\n       ptype_manifest = manifest;\n       ptype_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       ptype_loc = loc;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(args = []) ?res name =\n      {\n       pcd_name = name;\n       pcd_args = args;\n       pcd_res = res;\n       pcd_loc = loc;\n       pcd_attributes = add_info_attrs info attrs;\n      }\n\n    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(mut = Immutable) name typ =\n      {\n       pld_name = name;\n       pld_mutable = mut;\n       pld_type = typ;\n       pld_loc = loc;\n       pld_attributes = add_info_attrs info attrs;\n      }\n\n  end\n\n  (** Type extensions *)\n  module Te = struct\n    let mk ?(attrs = []) ?(docs = empty_docs)\n          ?(params = []) ?(priv = Public) path constructors =\n      {\n       ptyext_path = path;\n       ptyext_params = params;\n       ptyext_constructors = constructors;\n       ptyext_private = priv;\n       ptyext_attributes = add_docs_attrs docs attrs;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name kind =\n      {\n       pext_name = name;\n       pext_kind = kind;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let decl ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) ?(args = []) ?res name =\n      {\n       pext_name = name;\n       pext_kind = Pext_decl(args, res);\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let rebind ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name lid =\n      {\n       pext_name = name;\n       pext_kind = Pext_rebind lid;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n  end\n\n  module Csig = struct\n    let mk self fields =\n      {\n       pcsig_self = self;\n       pcsig_fields = fields;\n      }\n  end\n\n  module Cstr = struct\n    let mk self fields =\n      {\n       pcstr_self = self;\n       pcstr_fields = fields;\n      }\n  end\n\nend\n\nmodule Ast_mapper : sig\n  (** The interface of a -ppx rewriter\n\n    A -ppx rewriter is a program that accepts a serialized abstract syntax\n    tree and outputs another, possibly modified, abstract syntax tree.\n    This module encapsulates the interface between the compiler and\n    the -ppx rewriters, handling such details as the serialization format,\n    forwarding of command-line flags, and storing state.\n\n    {!mapper} allows to implement AST rewriting using open recursion.\n    A typical mapper would be based on {!default_mapper}, a deep\n    identity mapper, and will fall back on it for handling the syntax it\n    does not modify. For example:\n\n    {[\n  open Asttypes\n  open Parsetree\n  open Ast_mapper\n\n  let test_mapper argv =\n    { default_mapper with\n      expr = fun mapper expr ->\n        match expr with\n        | { pexp_desc = Pexp_extension ({ txt = \"test\" }, PStr [])} ->\n          Ast_helper.Exp.constant (Const_int 42)\n        | other -> default_mapper.expr mapper other; }\n\n  let () =\n    register \"ppx_test\" test_mapper]}\n\n    This -ppx rewriter, which replaces [[%test]] in expressions with\n    the constant [42], can be compiled using\n    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].\n\n    *)\n\n  open Parsetree\n\n  (** {2 A generic Parsetree mapper} *)\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n  (** A mapper record implements one \"method\" per syntactic category,\n      using an open recursion style: each method takes as its first\n      argument the mapper to be applied to children in the syntax\n      tree. *)\n\n  val default_mapper: mapper\n  (** A default mapper, which implements a \"deep identity\" mapping. *)\n\n  (** {2 Convenience functions to write mappers} *)\n\n  val map_opt: ('a -> 'b) -> 'a option -> 'b option\n\n  val extension_of_error: Location.error -> extension\n  (** Encode an error into an 'ocaml.error' extension node which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the error. *)\n\n  val attribute_of_warning: Location.t -> string -> attribute\n  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the warning. *)\n\nend = struct\n  (* A generic Parsetree mapping class *)\n\n  (*\n  [@@@ocaml.warning \"+9\"]\n    (* Ensure that record patterns don't miss any field. *)\n  *)\n\n\n  open Parsetree\n  open Ast_helper\n  open Location\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n\n  let map_fst f (x, y) = (f x, y)\n  let map_snd f (x, y) = (x, f y)\n  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)\n  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)\n  let map_opt f = function None -> None | Some x -> Some (f x)\n\n  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}\n\n  module T = struct\n    (* Type expressions for the core language *)\n\n    let row_field sub = function\n      | Rtag (l, attrs, b, tl) ->\n          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)\n      | Rinherit t -> Rinherit (sub.typ sub t)\n\n    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =\n      let open Typ in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ptyp_any -> any ~loc ~attrs ()\n      | Ptyp_var s -> var ~loc ~attrs s\n      | Ptyp_arrow (lab, t1, t2) ->\n          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)\n      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)\n      | Ptyp_constr (lid, tl) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_object (l, o) ->\n          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in\n          object_ ~loc ~attrs (List.map f l) o\n      | Ptyp_class (lid, tl) ->\n          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s\n      | Ptyp_variant (rl, b, ll) ->\n          variant ~loc ~attrs (List.map (row_field sub) rl) b ll\n      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)\n      | Ptyp_package (lid, l) ->\n          package ~loc ~attrs (map_loc sub lid)\n            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)\n      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_type_declaration sub\n        {ptype_name; ptype_params; ptype_cstrs;\n         ptype_kind;\n         ptype_private;\n         ptype_manifest;\n         ptype_attributes;\n         ptype_loc} =\n      Type.mk (map_loc sub ptype_name)\n        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)\n        ~priv:ptype_private\n        ~cstrs:(List.map\n                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))\n                  ptype_cstrs)\n        ~kind:(sub.type_kind sub ptype_kind)\n        ?manifest:(map_opt (sub.typ sub) ptype_manifest)\n        ~loc:(sub.location sub ptype_loc)\n        ~attrs:(sub.attributes sub ptype_attributes)\n\n    let map_type_kind sub = function\n      | Ptype_abstract -> Ptype_abstract\n      | Ptype_variant l ->\n          Ptype_variant (List.map (sub.constructor_declaration sub) l)\n      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)\n      | Ptype_open -> Ptype_open\n\n    let map_type_extension sub\n        {ptyext_path; ptyext_params;\n         ptyext_constructors;\n         ptyext_private;\n         ptyext_attributes} =\n      Te.mk\n        (map_loc sub ptyext_path)\n        (List.map (sub.extension_constructor sub) ptyext_constructors)\n        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)\n        ~priv:ptyext_private\n        ~attrs:(sub.attributes sub ptyext_attributes)\n\n    let map_extension_constructor_kind sub = function\n        Pext_decl(ctl, cto) ->\n          Pext_decl(List.map (sub.typ sub) ctl, map_opt (sub.typ sub) cto)\n      | Pext_rebind li ->\n          Pext_rebind (map_loc sub li)\n\n    let map_extension_constructor sub\n        {pext_name;\n         pext_kind;\n         pext_loc;\n         pext_attributes} =\n      Te.constructor\n        (map_loc sub pext_name)\n        (map_extension_constructor_kind sub pext_kind)\n        ~loc:(sub.location sub pext_loc)\n        ~attrs:(sub.attributes sub pext_attributes)\n\n  end\n\n  module CT = struct\n    (* Type expressions for the class language *)\n\n    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =\n      let open Cty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcty_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)\n      | Pcty_arrow (lab, t, ct) ->\n          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)\n      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}\n      =\n      let open Ctf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)\n      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)\n      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)\n      | Pctf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_signature sub {pcsig_self; pcsig_fields} =\n      Csig.mk\n        (sub.typ sub pcsig_self)\n        (List.map (sub.class_type_field sub) pcsig_fields)\n  end\n\n  module MT = struct\n    (* Type expressions for the module language *)\n\n    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =\n      let open Mty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)\n      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)\n      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)\n      | Pmty_functor (s, mt1, mt2) ->\n          functor_ ~loc ~attrs (map_loc sub s)\n            (Misc.may_map (sub.module_type sub) mt1)\n            (sub.module_type sub mt2)\n      | Pmty_with (mt, l) ->\n          with_ ~loc ~attrs (sub.module_type sub mt)\n            (List.map (sub.with_constraint sub) l)\n      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)\n      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_with_constraint sub = function\n      | Pwith_type (lid, d) ->\n          Pwith_type (map_loc sub lid, sub.type_declaration sub d)\n      | Pwith_module (lid, lid2) ->\n          Pwith_module (map_loc sub lid, map_loc sub lid2)\n      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)\n      | Pwith_modsubst (s, lid) ->\n          Pwith_modsubst (map_loc sub s, map_loc sub lid)\n\n    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =\n      let open Sig in\n      let loc = sub.location sub loc in\n      match desc with\n      | Psig_value vd -> value ~loc (sub.value_description sub vd)\n      | Psig_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)\n      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)\n      | Psig_recmodule l ->\n          rec_module ~loc (List.map (sub.module_declaration sub) l)\n      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Psig_open x -> open_ ~loc (sub.open_description sub x)\n      | Psig_include x -> include_ ~loc (sub.include_description sub x)\n      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)\n      | Psig_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Psig_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n\n  module M = struct\n    (* Value expressions for the module language *)\n\n    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =\n      let open Mod in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)\n      | Pmod_functor (arg, arg_ty, body) ->\n          functor_ ~loc ~attrs (map_loc sub arg)\n            (Misc.may_map (sub.module_type sub) arg_ty)\n            (sub.module_expr sub body)\n      | Pmod_apply (m1, m2) ->\n          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)\n      | Pmod_constraint (m, mty) ->\n          constraint_ ~loc ~attrs (sub.module_expr sub m)\n                      (sub.module_type sub mty)\n      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)\n      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =\n      let open Str in\n      let loc = sub.location sub loc in\n      match desc with\n      | Pstr_eval (x, attrs) ->\n          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)\n      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)\n      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)\n      | Pstr_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)\n      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)\n      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)\n      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Pstr_open x -> open_ ~loc (sub.open_description sub x)\n      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)\n      | Pstr_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)\n      | Pstr_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n  module E = struct\n    (* Value expressions for the core language *)\n\n    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =\n      let open Exp in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pexp_constant x -> constant ~loc ~attrs x\n      | Pexp_let (r, vbs, e) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.expr sub e)\n      | Pexp_fun (lab, def, p, e) ->\n          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)\n            (sub.expr sub e)\n      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)\n      | Pexp_apply (e, l) ->\n          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)\n      | Pexp_match (e, pel) ->\n          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_construct (lid, arg) ->\n          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)\n      | Pexp_variant (lab, eo) ->\n          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)\n      | Pexp_record (l, eo) ->\n          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)\n            (map_opt (sub.expr sub) eo)\n      | Pexp_field (e, lid) ->\n          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)\n      | Pexp_setfield (e1, lid, e2) ->\n          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)\n            (sub.expr sub e2)\n      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_ifthenelse (e1, e2, e3) ->\n          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n            (map_opt (sub.expr sub) e3)\n      | Pexp_sequence (e1, e2) ->\n          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_while (e1, e2) ->\n          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_for (p, e1, e2, d, e3) ->\n          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d\n            (sub.expr sub e3)\n      | Pexp_coerce (e, t1, t2) ->\n          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)\n            (sub.typ sub t2)\n      | Pexp_constraint (e, t) ->\n          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)\n      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s\n      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)\n      | Pexp_setinstvar (s, e) ->\n          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_override sel ->\n          override ~loc ~attrs\n            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)\n      | Pexp_letmodule (s, me, e) ->\n          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)\n            (sub.expr sub e)\n      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_poly (e, t) ->\n          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)\n      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)\n      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)\n      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)\n      | Pexp_open (ovf, lid, e) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)\n      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module P = struct\n    (* Patterns *)\n\n    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =\n      let open Pat in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ppat_any -> any ~loc ~attrs ()\n      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)\n      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)\n      | Ppat_constant c -> constant ~loc ~attrs c\n      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2\n      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_construct (l, p) ->\n          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)\n      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)\n      | Ppat_record (lpl, cf) ->\n          record ~loc ~attrs\n                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf\n      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)\n      | Ppat_constraint (p, t) ->\n          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)\n      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)\n      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)\n      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module CE = struct\n    (* Value expressions for the class language *)\n\n    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =\n      let open Cl in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcl_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcl_structure s ->\n          structure ~loc ~attrs (sub.class_structure sub s)\n      | Pcl_fun (lab, e, p, ce) ->\n          fun_ ~loc ~attrs lab\n            (map_opt (sub.expr sub) e)\n            (sub.pat sub p)\n            (sub.class_expr sub ce)\n      | Pcl_apply (ce, l) ->\n          apply ~loc ~attrs (sub.class_expr sub ce)\n            (List.map (map_snd (sub.expr sub)) l)\n      | Pcl_let (r, vbs, ce) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.class_expr sub ce)\n      | Pcl_constraint (ce, ct) ->\n          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)\n      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_kind sub = function\n      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)\n      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)\n\n    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =\n      let open Cf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s\n      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)\n      | Pcf_method (s, p, k) ->\n          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)\n      | Pcf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)\n      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure sub {pcstr_self; pcstr_fields} =\n      {\n        pcstr_self = sub.pat sub pcstr_self;\n        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;\n      }\n\n    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;\n                           pci_loc; pci_attributes} =\n      Ci.mk\n       ~virt:pci_virt\n       ~params:(List.map (map_fst (sub.typ sub)) pl)\n        (map_loc sub pci_name)\n        (f pci_expr)\n        ~loc:(sub.location sub pci_loc)\n        ~attrs:(sub.attributes sub pci_attributes)\n  end\n\n  (* Now, a generic AST mapper, to be extended to cover all kinds and\n     cases of the OCaml grammar.  The default behavior of the mapper is\n     the identity. *)\n\n  let default_mapper =\n    {\n      structure = (fun this l -> List.map (this.structure_item this) l);\n      structure_item = M.map_structure_item;\n      module_expr = M.map;\n      signature = (fun this l -> List.map (this.signature_item this) l);\n      signature_item = MT.map_signature_item;\n      module_type = MT.map;\n      with_constraint = MT.map_with_constraint;\n      class_declaration =\n        (fun this -> CE.class_infos this (this.class_expr this));\n      class_expr = CE.map;\n      class_field = CE.map_field;\n      class_structure = CE.map_structure;\n      class_type = CT.map;\n      class_type_field = CT.map_field;\n      class_signature = CT.map_signature;\n      class_type_declaration =\n        (fun this -> CE.class_infos this (this.class_type this));\n      class_description =\n        (fun this -> CE.class_infos this (this.class_type this));\n      type_declaration = T.map_type_declaration;\n      type_kind = T.map_type_kind;\n      typ = T.map;\n      type_extension = T.map_type_extension;\n      extension_constructor = T.map_extension_constructor;\n      value_description =\n        (fun this {pval_name; pval_type; pval_prim; pval_loc;\n                   pval_attributes} ->\n          Val.mk\n            (map_loc this pval_name)\n            (this.typ this pval_type)\n            ~attrs:(this.attributes this pval_attributes)\n            ~loc:(this.location this pval_loc)\n            ~prim:pval_prim\n        );\n\n      pat = P.map;\n      expr = E.map;\n\n      module_declaration =\n        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->\n           Md.mk\n             (map_loc this pmd_name)\n             (this.module_type this pmd_type)\n             ~attrs:(this.attributes this pmd_attributes)\n             ~loc:(this.location this pmd_loc)\n        );\n\n      module_type_declaration =\n        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->\n           Mtd.mk\n             (map_loc this pmtd_name)\n             ?typ:(map_opt (this.module_type this) pmtd_type)\n             ~attrs:(this.attributes this pmtd_attributes)\n             ~loc:(this.location this pmtd_loc)\n        );\n\n      module_binding =\n        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->\n           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)\n             ~attrs:(this.attributes this pmb_attributes)\n             ~loc:(this.location this pmb_loc)\n        );\n\n\n      open_description =\n        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->\n           Opn.mk (map_loc this popen_lid)\n             ~override:popen_override\n             ~loc:(this.location this popen_loc)\n             ~attrs:(this.attributes this popen_attributes)\n        );\n\n\n      include_description =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_type this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n      include_declaration =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_expr this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n\n      value_binding =\n        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->\n           Vb.mk\n             (this.pat this pvb_pat)\n             (this.expr this pvb_expr)\n             ~loc:(this.location this pvb_loc)\n             ~attrs:(this.attributes this pvb_attributes)\n        );\n\n\n      constructor_declaration =\n        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->\n          Type.constructor\n            (map_loc this pcd_name)\n            ~args:(List.map (this.typ this) pcd_args)\n            ?res:(map_opt (this.typ this) pcd_res)\n            ~loc:(this.location this pcd_loc)\n            ~attrs:(this.attributes this pcd_attributes)\n        );\n\n      label_declaration =\n        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->\n           Type.field\n             (map_loc this pld_name)\n             (this.typ this pld_type)\n             ~mut:pld_mutable\n             ~loc:(this.location this pld_loc)\n             ~attrs:(this.attributes this pld_attributes)\n        );\n\n      cases = (fun this l -> List.map (this.case this) l);\n      case =\n        (fun this {pc_lhs; pc_guard; pc_rhs} ->\n           {\n             pc_lhs = this.pat this pc_lhs;\n             pc_guard = map_opt (this.expr this) pc_guard;\n             pc_rhs = this.expr this pc_rhs;\n           }\n        );\n\n\n\n      location = (fun _this l -> l);\n\n      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attributes = (fun this l -> List.map (this.attribute this) l);\n      payload =\n        (fun this -> function\n           | PStr x -> PStr (this.structure this x)\n           | PTyp x -> PTyp (this.typ this x)\n           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)\n        );\n    }\n\n  let rec extension_of_error {loc; msg; if_highlight; sub} =\n    { loc; txt = \"ocaml.error\" },\n    PStr ([Str.eval (Exp.constant (Asttypes.Const_string (msg, None)));\n           Str.eval (Exp.constant (Asttypes.Const_string (if_highlight, None)))] @\n          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))\n\n  let attribute_of_warning loc s =\n    { loc; txt = \"ocaml.ppwarning\" },\n    PStr ([Str.eval ~loc (Exp.constant (Asttypes.Const_string (s, None)))])\nend\n\nmodule Outcometree = struct\n  (* Module [Outcometree]: results displayed by the toplevel *)\n\n  (* These types represent messages that the toplevel displays as normal\n     results or errors. The real displaying is customisable using the hooks:\n        [Toploop.print_out_value]\n        [Toploop.print_out_type]\n        [Toploop.print_out_sig_item]\n        [Toploop.print_out_phrase] *)\n\n  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =\n    | Oide_apply of out_ident * out_ident\n    | Oide_dot of out_ident * string\n    | Oide_ident of string\n\n  type out_value (*IF_CURRENT = Outcometree.out_value *) =\n    | Oval_array of out_value list\n    | Oval_char of char\n    | Oval_constr of out_ident * out_value list\n    | Oval_ellipsis\n    | Oval_float of float\n    | Oval_int of int\n    | Oval_int32 of int32\n    | Oval_int64 of int64\n    | Oval_nativeint of nativeint\n    | Oval_list of out_value list\n    | Oval_printer of (Format.formatter -> unit)\n    | Oval_record of (out_ident * out_value) list\n    | Oval_string of string\n    | Oval_stuff of string\n    | Oval_tuple of out_value list\n    | Oval_variant of string * out_value option\n\n  type out_type (*IF_CURRENT = Outcometree.out_type *) =\n    | Otyp_abstract\n    | Otyp_open\n    | Otyp_alias of out_type * string\n    | Otyp_arrow of string * out_type * out_type\n    | Otyp_class of bool * out_ident * out_type list\n    | Otyp_constr of out_ident * out_type list\n    | Otyp_manifest of out_type * out_type\n    | Otyp_object of (string * out_type) list * bool option\n    | Otyp_record of (string * bool * out_type) list\n    | Otyp_stuff of string\n    | Otyp_sum of (string * out_type list * out_type option) list\n    | Otyp_tuple of out_type list\n    | Otyp_var of bool * string\n    | Otyp_variant of\n        bool * out_variant * bool * (string list) option\n    | Otyp_poly of string list * out_type\n    | Otyp_module of string * string list * out_type list\n\n  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =\n    | Ovar_fields of (string * bool * out_type list) list\n    | Ovar_name of out_ident * out_type list\n\n  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =\n    | Octy_constr of out_ident * out_type list\n    | Octy_arrow of string * out_type * out_class_type\n    | Octy_signature of out_type option * out_class_sig_item list\n  and out_class_sig_item  (*IF_CURRENT = Outcometree.out_class_sig_item *) =\n    | Ocsg_constraint of out_type * out_type\n    | Ocsg_method of string * bool * bool * out_type\n    | Ocsg_value of string * bool * bool * out_type\n\n  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =\n    | Omty_abstract\n    | Omty_functor of string * out_module_type option * out_module_type\n    | Omty_ident of out_ident\n    | Omty_signature of out_sig_item list\n    | Omty_alias of out_ident\n  and out_sig_item  (*IF_CURRENT = Outcometree.out_sig_item *) =\n    | Osig_class of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_class_type of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_typext of out_extension_constructor * out_ext_status\n    | Osig_modtype of string * out_module_type\n    | Osig_module of string * out_module_type * out_rec_status\n    | Osig_type of out_type_decl * out_rec_status\n    | Osig_value of string * out_type * string list\n  and out_type_decl  (*IF_CURRENT = Outcometree.out_type_decl *) =\n    { otype_name: string;\n      otype_params: (string * (bool * bool)) list;\n      otype_type: out_type;\n      otype_private: Asttypes.private_flag;\n      otype_cstrs: (out_type * out_type) list }\n  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =\n    { oext_name: string;\n      oext_type_name: string;\n      oext_type_params: string list;\n      oext_args: out_type list;\n      oext_ret_type: out_type option;\n      oext_private: Asttypes.private_flag }\n  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =\n    { otyext_name: string;\n      otyext_params: string list;\n      otyext_constructors: (string * out_type list * out_type option) list;\n      otyext_private: Asttypes.private_flag }\n  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =\n    | Orec_not\n    | Orec_first\n    | Orec_next\n  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status*) =\n    | Oext_first\n    | Oext_next\n    | Oext_exception\n\n  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =\n    | Ophr_eval of out_value * out_type\n    | Ophr_signature of (out_sig_item * out_value option) list\n    | Ophr_exception of (exn * out_value)\n\nend\n\nmodule Config = struct\n  let ast_impl_magic_number = \"Caml1999M016\"\n  let ast_intf_magic_number = \"Caml1999N015\"\nend\n\nlet map_signature mapper = mapper.Ast_mapper.signature mapper\nlet map_structure mapper = mapper.Ast_mapper.structure mapper\n\nlet shallow_identity =\n  let id _ x = x in\n  {\n    Ast_mapper.\n    structure               = id;\n    structure_item          = id;\n    module_expr             = id;\n    signature               = id;\n    signature_item          = id;\n    module_type             = id;\n    with_constraint         = id;\n    class_declaration       = id;\n    class_expr              = id;\n    class_field             = id;\n    class_structure         = id;\n    class_type              = id;\n    class_type_field        = id;\n    class_signature         = id;\n    class_type_declaration  = id;\n    class_description       = id;\n    type_declaration        = id;\n    type_kind               = id;\n    typ                     = id;\n    type_extension          = id;\n    extension_constructor   = id;\n    value_description       = id;\n    pat                     = id;\n    expr                    = id;\n    module_declaration      = id;\n    module_type_declaration = id;\n    module_binding          = id;\n    open_description        = id;\n    include_description     = id;\n    include_declaration     = id;\n    value_binding           = id;\n    constructor_declaration = id;\n    label_declaration       = id;\n    cases                   = id;\n    case                    = id;\n    location                = id;\n    extension               = id;\n    attribute               = id;\n    attributes              = id;\n    payload                 = id;\n  }\n\nlet failing_mapper =\n  let fail _ _ =\n    invalid_arg \"failing_mapper: this mapper function should never get called\"\n  in\n  {\n    Ast_mapper.\n    structure               = fail;\n    structure_item          = fail;\n    module_expr             = fail;\n    signature               = fail;\n    signature_item          = fail;\n    module_type             = fail;\n    with_constraint         = fail;\n    class_declaration       = fail;\n    class_expr              = fail;\n    class_field             = fail;\n    class_structure         = fail;\n    class_type              = fail;\n    class_type_field        = fail;\n    class_signature         = fail;\n    class_type_declaration  = fail;\n    class_description       = fail;\n    type_declaration        = fail;\n    type_kind               = fail;\n    typ                     = fail;\n    type_extension          = fail;\n    extension_constructor   = fail;\n    value_description       = fail;\n    pat                     = fail;\n    expr                    = fail;\n    module_declaration      = fail;\n    module_type_declaration = fail;\n    module_binding          = fail;\n    open_description        = fail;\n    include_description     = fail;\n    include_declaration     = fail;\n    value_binding           = fail;\n    constructor_declaration = fail;\n    label_declaration       = fail;\n    cases                   = fail;\n    case                    = fail;\n    location                = fail;\n    extension               = fail;\n    attribute               = fail;\n    attributes              = fail;\n    payload                 = fail;\n  }\n\nlet make_top_mapper ~signature ~structure =\n  {failing_mapper with Ast_mapper.\n                    signature = (fun _ x -> signature x);\n                    structure = (fun _ x -> structure x) }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*            Jérémie Dimino and Leo White, Jane Street Europe            *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)\n(*                         Alain Frisch, LexiFi                           *)\n(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Location = Location\nmodule Longident = Longident\n\nmodule Asttypes = struct\n  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)\n\n  type constant (*IF_CURRENT = Asttypes.constant *) =\n      Const_int of int\n    | Const_char of char\n    | Const_string of string * string option\n    | Const_float of string\n    | Const_int32 of int32\n    | Const_int64 of int64\n    | Const_nativeint of nativeint\n\n  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive\n\n  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto\n\n  (* Order matters, used in polymorphic comparison *)\n  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public\n\n  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable\n\n  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete\n\n  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh\n\n  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open\n\n  type label = string\n\n  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =\n      Nolabel\n    | Labelled of string (*  label:T -> ... *)\n    | Optional of string (* ?label:T -> ... *)\n\n  type 'a loc = 'a Location.loc = {\n    txt : 'a;\n    loc : Location.t;\n  }\n\n\n  type variance (*IF_CURRENT = Asttypes.variance *) =\n    | Covariant\n    | Contravariant\n    | Invariant\nend\n\nmodule Parsetree = struct\n  (** Abstract syntax tree produced by parsing *)\n\n  open Asttypes\n\n  type constant (*IF_CURRENT = Parsetree.constant *) =\n      Pconst_integer of string * char option\n    (* 3 3l 3L 3n\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker\n    *)\n    | Pconst_char of char\n    (* 'c' *)\n    | Pconst_string of string * string option\n    (* \"constant\"\n       {delim|other constant|delim}\n    *)\n    | Pconst_float of string * char option\n    (* 3.4 2e5 1.4e-4\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes are rejected by the typechecker.\n    *)\n\n  (** {2 Extension points} *)\n\n  type attribute = string loc * payload\n         (* [@id ARG]\n            [@@id ARG]\n\n            Metadata containers passed around within the AST.\n            The compiler ignores unknown attributes.\n         *)\n\n  and extension = string loc * payload\n        (* [%id ARG]\n           [%%id ARG]\n\n           Sub-language placeholder -- rejected by the typechecker.\n        *)\n\n  and attributes = attribute list\n\n  and payload (*IF_CURRENT = Parsetree.payload *) =\n    | PStr of structure\n    | PSig of signature (* : SIG *)\n    | PTyp of core_type  (* : T *)\n    | PPat of pattern * expression option  (* ? P  or  ? P when E *)\n\n  (** {2 Core language} *)\n\n  (* Type expressions *)\n\n  and core_type (*IF_CURRENT = Parsetree.core_type *) =\n      {\n       ptyp_desc: core_type_desc;\n       ptyp_loc: Location.t;\n       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =\n    | Ptyp_any\n          (*  _ *)\n    | Ptyp_var of string\n          (* 'a *)\n    | Ptyp_arrow of arg_label * core_type * core_type\n          (* T1 -> T2       Simple\n             ~l:T1 -> T2    Labelled\n             ?l:T1 -> T2    Otional\n           *)\n    | Ptyp_tuple of core_type list\n          (* T1 * ... * Tn\n\n             Invariant: n >= 2\n          *)\n    | Ptyp_constr of Longident.t loc * core_type list\n          (* tconstr\n             T tconstr\n             (T1, ..., Tn) tconstr\n           *)\n    | Ptyp_object of (string * attributes * core_type) list * closed_flag\n          (* < l1:T1; ...; ln:Tn >     (flag = Closed)\n             < l1:T1; ...; ln:Tn; .. > (flag = Open)\n           *)\n    | Ptyp_class of Longident.t loc * core_type list\n          (* #tconstr\n             T #tconstr\n             (T1, ..., Tn) #tconstr\n           *)\n    | Ptyp_alias of core_type * string\n          (* T as 'a *)\n    | Ptyp_variant of row_field list * closed_flag * label list option\n          (* [ `A|`B ]         (flag = Closed; labels = None)\n             [> `A|`B ]        (flag = Open;   labels = None)\n             [< `A|`B ]        (flag = Closed; labels = Some [])\n             [< `A|`B > `X `Y ](flag = Closed; labels = Some [\"X\";\"Y\"])\n           *)\n    | Ptyp_poly of string list * core_type\n          (* 'a1 ... 'an. T\n\n             Can only appear in the following context:\n\n             - As the core_type of a Ppat_constraint node corresponding\n               to a constraint on a let-binding: let x : 'a1 ... 'an. T\n               = e ...\n\n             - Under Cfk_virtual for methods (not values).\n\n             - As the core_type of a Pctf_method node.\n\n             - As the core_type of a Pexp_poly node.\n\n             - As the pld_type field of a label_declaration.\n\n             - As a core_type of a Ptyp_object node.\n           *)\n\n    | Ptyp_package of package_type\n          (* (module S) *)\n    | Ptyp_extension of extension\n          (* [%id] *)\n\n  and package_type = Longident.t loc * (Longident.t loc * core_type) list\n        (*\n          (module S)\n          (module S with type t1 = T1 and ... and tn = Tn)\n         *)\n\n  and row_field (*IF_CURRENT = Parsetree.row_field *) =\n    | Rtag of label * attributes * bool * core_type list\n          (* [`A]                   ( true,  [] )\n             [`A of T]              ( false, [T] )\n             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )\n             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )\n\n            - The 2nd field is true if the tag contains a\n              constant (empty) constructor.\n            - '&' occurs when several types are used for the same constructor\n              (see 4.2 in the manual)\n\n            - TODO: switch to a record representation, and keep location\n          *)\n    | Rinherit of core_type\n          (* [ T ] *)\n\n  (* Patterns *)\n\n  and pattern (*IF_CURRENT = Parsetree.pattern *) =\n      {\n       ppat_desc: pattern_desc;\n       ppat_loc: Location.t;\n       ppat_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =\n    | Ppat_any\n          (* _ *)\n    | Ppat_var of string loc\n          (* x *)\n    | Ppat_alias of pattern * string loc\n          (* P as 'a *)\n    | Ppat_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Ppat_interval of constant * constant\n          (* 'a'..'z'\n\n             Other forms of interval are recognized by the parser\n             but rejected by the type-checker. *)\n    | Ppat_tuple of pattern list\n          (* (P1, ..., Pn)\n\n             Invariant: n >= 2\n          *)\n    | Ppat_construct of Longident.t loc * pattern option\n          (* C                None\n             C P              Some P\n             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])\n           *)\n    | Ppat_variant of label * pattern option\n          (* `A             (None)\n             `A P           (Some P)\n           *)\n    | Ppat_record of (Longident.t loc * pattern) list * closed_flag\n          (* { l1=P1; ...; ln=Pn }     (flag = Closed)\n             { l1=P1; ...; ln=Pn; _}   (flag = Open)\n\n             Invariant: n > 0\n           *)\n    | Ppat_array of pattern list\n          (* [| P1; ...; Pn |] *)\n    | Ppat_or of pattern * pattern\n          (* P1 | P2 *)\n    | Ppat_constraint of pattern * core_type\n          (* (P : T) *)\n    | Ppat_type of Longident.t loc\n          (* #tconst *)\n    | Ppat_lazy of pattern\n          (* lazy P *)\n    | Ppat_unpack of string loc\n          (* (module P)\n             Note: (module P : S) is represented as\n             Ppat_constraint(Ppat_unpack, Ptyp_package)\n           *)\n    | Ppat_exception of pattern\n          (* exception P *)\n    | Ppat_extension of extension\n          (* [%id] *)\n\n  (* Value expressions *)\n\n  and expression (*IF_CURRENT = Parsetree.expression *) =\n      {\n       pexp_desc: expression_desc;\n       pexp_loc: Location.t;\n       pexp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =\n    | Pexp_ident of Longident.t loc\n          (* x\n             M.x\n           *)\n    | Pexp_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Pexp_let of rec_flag * value_binding list * expression\n          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)\n           *)\n    | Pexp_function of case list\n          (* function P1 -> E1 | ... | Pn -> En *)\n    | Pexp_fun of arg_label * expression option * pattern * expression\n          (* fun P -> E1                          (Simple, None)\n             fun ~l:P -> E1                       (Labelled l, None)\n             fun ?l:P -> E1                       (Optional l, None)\n             fun ?l:(P = E0) -> E1                (Optional l, Some E0)\n\n             Notes:\n             - If E0 is provided, only Optional is allowed.\n             - \"fun P1 P2 .. Pn -> E1\" is represented as nested Pexp_fun.\n             - \"let f P = E\" is represented using Pexp_fun.\n           *)\n    | Pexp_apply of expression * (arg_label * expression) list\n          (* E0 ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pexp_match of expression * case list\n          (* match E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_try of expression * case list\n          (* try E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_tuple of expression list\n          (* (E1, ..., En)\n\n             Invariant: n >= 2\n          *)\n    | Pexp_construct of Longident.t loc * expression option\n          (* C                None\n             C E              Some E\n             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])\n          *)\n    | Pexp_variant of label * expression option\n          (* `A             (None)\n             `A E           (Some E)\n           *)\n    | Pexp_record of (Longident.t loc * expression) list * expression option\n          (* { l1=P1; ...; ln=Pn }     (None)\n             { E0 with l1=P1; ...; ln=Pn }   (Some E0)\n\n             Invariant: n > 0\n           *)\n    | Pexp_field of expression * Longident.t loc\n          (* E.l *)\n    | Pexp_setfield of expression * Longident.t loc * expression\n          (* E1.l <- E2 *)\n    | Pexp_array of expression list\n          (* [| E1; ...; En |] *)\n    | Pexp_ifthenelse of expression * expression * expression option\n          (* if E1 then E2 else E3 *)\n    | Pexp_sequence of expression * expression\n          (* E1; E2 *)\n    | Pexp_while of expression * expression\n          (* while E1 do E2 done *)\n    | Pexp_for of\n        pattern *  expression * expression * direction_flag * expression\n          (* for i = E1 to E2 do E3 done      (flag = Upto)\n             for i = E1 downto E2 do E3 done  (flag = Downto)\n           *)\n    | Pexp_constraint of expression * core_type\n          (* (E : T) *)\n    | Pexp_coerce of expression * core_type option * core_type\n          (* (E :> T)        (None, T)\n             (E : T0 :> T)   (Some T0, T)\n           *)\n    | Pexp_send of expression * string\n          (*  E # m *)\n    | Pexp_new of Longident.t loc\n          (* new M.c *)\n    | Pexp_setinstvar of string loc * expression\n          (* x <- 2 *)\n    | Pexp_override of (string loc * expression) list\n          (* {< x1 = E1; ...; Xn = En >} *)\n    | Pexp_letmodule of string loc * module_expr * expression\n          (* let module M = ME in E *)\n    | Pexp_assert of expression\n          (* assert E\n             Note: \"assert false\" is treated in a special way by the\n             type-checker. *)\n    | Pexp_lazy of expression\n          (* lazy E *)\n    | Pexp_poly of expression * core_type option\n          (* Used for method bodies.\n\n             Can only be used as the expression under Cfk_concrete\n             for methods (not values). *)\n    | Pexp_object of class_structure\n          (* object ... end *)\n    | Pexp_newtype of string * expression\n          (* fun (type t) -> E *)\n    | Pexp_pack of module_expr\n          (* (module ME)\n\n             (module ME : S) is represented as\n             Pexp_constraint(Pexp_pack, Ptyp_package S) *)\n    | Pexp_open of override_flag * Longident.t loc * expression\n          (* let open M in E\n             let! open M in E\n          *)\n    | Pexp_extension of extension\n          (* [%id] *)\n    | Pexp_unreachable\n          (* . *)\n\n  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)\n      {\n       pc_lhs: pattern;\n       pc_guard: expression option;\n       pc_rhs: expression;\n      }\n\n  (* Value descriptions *)\n\n  and value_description (*IF_CURRENT = Parsetree.value_description *) =\n      {\n       pval_name: string loc;\n       pval_type: core_type;\n       pval_prim: string list;\n       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n       pval_loc: Location.t;\n      }\n\n  (*\n    val x: T                            (prim = [])\n    external x: T = \"s1\" ... \"sn\"       (prim = [\"s1\";...\"sn\"])\n  *)\n\n  (* Type declarations *)\n\n  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =\n      {\n       ptype_name: string loc;\n       ptype_params: (core_type * variance) list;\n             (* ('a1,...'an) t; None represents  _*)\n       ptype_cstrs: (core_type * core_type * Location.t) list;\n             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)\n       ptype_kind: type_kind;\n       ptype_private: private_flag;   (* = private ... *)\n       ptype_manifest: core_type option;  (* = T *)\n       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n       ptype_loc: Location.t;\n      }\n\n  (*\n    type t                     (abstract, no manifest)\n    type t = T0                (abstract, manifest=T0)\n    type t = C of T | ...      (variant,  no manifest)\n    type t = T0 = C of T | ... (variant,  manifest=T0)\n    type t = {l: T; ...}       (record,   no manifest)\n    type t = T0 = {l : T; ...} (record,   manifest=T0)\n    type t = ..                (open,     no manifest)\n  *)\n\n  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =\n    | Ptype_abstract\n    | Ptype_variant of constructor_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_record of label_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_open\n\n  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =\n      {\n       pld_name: string loc;\n       pld_mutable: mutable_flag;\n       pld_type: core_type;\n       pld_loc: Location.t;\n       pld_attributes: attributes; (* l [@id1] [@id2] : T *)\n      }\n\n  (*  { ...; l: T; ... }            (mutable=Immutable)\n      { ...; mutable l: T; ... }    (mutable=Mutable)\n\n      Note: T can be a Ptyp_poly.\n  *)\n\n  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =\n      {\n       pcd_name: string loc;\n       pcd_args: constructor_arguments;\n       pcd_res: core_type option;\n       pcd_loc: Location.t;\n       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =\n    | Pcstr_tuple of core_type list\n    | Pcstr_record of label_declaration list\n\n  (*\n    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])\n    | C: T0                  (res = Some T0, args = [])\n    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)\n    | C of {...}             (res = None,    args = Pcstr_record)\n    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)\n    | C of {...} as t        (res = None,    args = Pcstr_record)\n  *)\n\n  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =\n      {\n       ptyext_path: Longident.t loc;\n       ptyext_params: (core_type * variance) list;\n       ptyext_constructors: extension_constructor list;\n       ptyext_private: private_flag;\n       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n      }\n  (*\n    type t += ...\n  *)\n\n  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =\n      {\n       pext_name: string loc;\n       pext_kind : extension_constructor_kind;\n       pext_loc : Location.t;\n       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =\n      Pext_decl of constructor_arguments * core_type option\n        (*\n           | C of T1 * ... * Tn     ([T1; ...; Tn], None)\n           | C: T0                  ([], Some T0)\n           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)\n         *)\n    | Pext_rebind of Longident.t loc\n        (*\n           | C = D\n         *)\n\n  (** {2 Class language} *)\n\n  (* Type expressions for the class language *)\n\n  and class_type (*IF_CURRENT = Parsetree.class_type *) =\n      {\n       pcty_desc: class_type_desc;\n       pcty_loc: Location.t;\n       pcty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =\n    | Pcty_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcty_signature of class_signature\n          (* object ... end *)\n    | Pcty_arrow of arg_label * core_type * class_type\n          (* T -> CT       Simple\n             ~l:T -> CT    Labelled l\n             ?l:T -> CT    Optional l\n           *)\n    | Pcty_extension of extension\n          (* [%id] *)\n\n  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =\n      {\n       pcsig_self: core_type;\n       pcsig_fields: class_type_field list;\n      }\n  (* object('selfpat) ... end\n     object ... end             (self = Ptyp_any)\n   *)\n\n  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =\n      {\n       pctf_desc: class_type_field_desc;\n       pctf_loc: Location.t;\n       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =\n    | Pctf_inherit of class_type\n          (* inherit CT *)\n    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)\n          (* val x: T *)\n    | Pctf_method  of (string * private_flag * virtual_flag * core_type)\n          (* method x: T\n\n             Note: T can be a Ptyp_poly.\n           *)\n    | Pctf_constraint  of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pctf_attribute of attribute\n          (* [@@@id] *)\n    | Pctf_extension of extension\n          (* [%%id] *)\n\n  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =\n      {\n       pci_virt: virtual_flag;\n       pci_params: (core_type * variance) list;\n       pci_name: string loc;\n       pci_expr: 'a;\n       pci_loc: Location.t;\n       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n      }\n  (* class c = ...\n     class ['a1,...,'an] c = ...\n     class virtual c = ...\n\n     Also used for \"class type\" declaration.\n  *)\n\n  and class_description = class_type class_infos\n\n  and class_type_declaration = class_type class_infos\n\n  (* Value expressions for the class language *)\n\n  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =\n      {\n       pcl_desc: class_expr_desc;\n       pcl_loc: Location.t;\n       pcl_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =\n    | Pcl_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcl_structure of class_structure\n          (* object ... end *)\n    | Pcl_fun of arg_label * expression option * pattern * class_expr\n          (* fun P -> CE                          (Simple, None)\n             fun ~l:P -> CE                       (Labelled l, None)\n             fun ?l:P -> CE                       (Optional l, None)\n             fun ?l:(P = E0) -> CE                (Optional l, Some E0)\n           *)\n    | Pcl_apply of class_expr * (arg_label * expression) list\n          (* CE ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pcl_let of rec_flag * value_binding list * class_expr\n          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)\n           *)\n    | Pcl_constraint of class_expr * class_type\n          (* (CE : CT) *)\n    | Pcl_extension of extension\n          (* [%id] *)\n\n  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =\n      {\n       pcstr_self: pattern;\n       pcstr_fields: class_field list;\n      }\n  (* object(selfpat) ... end\n     object ... end           (self = Ppat_any)\n   *)\n\n  and class_field (*IF_CURRENT = Parsetree.class_field *) =\n      {\n       pcf_desc: class_field_desc;\n       pcf_loc: Location.t;\n       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =\n    | Pcf_inherit of override_flag * class_expr * string option\n          (* inherit CE\n             inherit CE as x\n             inherit! CE\n             inherit! CE as x\n           *)\n    | Pcf_val of (string loc * mutable_flag * class_field_kind)\n          (* val x = E\n             val virtual x: T\n           *)\n    | Pcf_method of (string loc * private_flag * class_field_kind)\n          (* method x = E            (E can be a Pexp_poly)\n             method virtual x: T     (T can be a Ptyp_poly)\n           *)\n    | Pcf_constraint of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pcf_initializer of expression\n          (* initializer E *)\n    | Pcf_attribute of attribute\n          (* [@@@id] *)\n    | Pcf_extension of extension\n          (* [%%id] *)\n\n  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =\n    | Cfk_virtual of core_type\n    | Cfk_concrete of override_flag * expression\n\n  and class_declaration = class_expr class_infos\n\n  (** {2 Module language} *)\n\n  (* Type expressions for the module language *)\n\n  and module_type (*IF_CURRENT = Parsetree.module_type *) =\n      {\n       pmty_desc: module_type_desc;\n       pmty_loc: Location.t;\n       pmty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =\n    | Pmty_ident of Longident.t loc\n          (* S *)\n    | Pmty_signature of signature\n          (* sig ... end *)\n    | Pmty_functor of string loc * module_type option * module_type\n          (* functor(X : MT1) -> MT2 *)\n    | Pmty_with of module_type * with_constraint list\n          (* MT with ... *)\n    | Pmty_typeof of module_expr\n          (* module type of ME *)\n    | Pmty_extension of extension\n          (* [%id] *)\n    | Pmty_alias of Longident.t loc\n          (* (module M) *)\n\n  and signature = signature_item list\n\n  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =\n      {\n       psig_desc: signature_item_desc;\n       psig_loc: Location.t;\n      }\n\n  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =\n    | Psig_value of value_description\n          (*\n            val x: T\n            external x: T = \"s1\" ... \"sn\"\n           *)\n    | Psig_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Psig_typext of type_extension\n          (* type t1 += ... *)\n    | Psig_exception of extension_constructor\n          (* exception C of T *)\n    | Psig_module of module_declaration\n          (* module X : MT *)\n    | Psig_recmodule of module_declaration list\n          (* module rec X1 : MT1 and ... and Xn : MTn *)\n    | Psig_modtype of module_type_declaration\n          (* module type S = MT\n             module type S *)\n    | Psig_open of open_description\n          (* open X *)\n    | Psig_include of include_description\n          (* include MT *)\n    | Psig_class of class_description list\n          (* class c1 : ... and ... and cn : ... *)\n    | Psig_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Psig_attribute of attribute\n          (* [@@@id] *)\n    | Psig_extension of extension * attributes\n          (* [%%id] *)\n\n  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =\n      {\n       pmd_name: string loc;\n       pmd_type: module_type;\n       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmd_loc: Location.t;\n      }\n  (* S : MT *)\n\n  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =\n      {\n       pmtd_name: string loc;\n       pmtd_type: module_type option;\n       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmtd_loc: Location.t;\n      }\n  (* S = MT\n     S       (abstract module type declaration, pmtd_type = None)\n  *)\n\n  and open_description (*IF_CURRENT = Parsetree.open_description *) =\n      {\n       popen_lid: Longident.t loc;\n       popen_override: override_flag;\n       popen_loc: Location.t;\n       popen_attributes: attributes;\n      }\n  (* open! X - popen_override = Override (silences the 'used identifier\n                                shadowing' warning)\n     open  X - popen_override = Fresh\n   *)\n\n  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =\n      {\n       pincl_mod: 'a;\n       pincl_loc: Location.t;\n       pincl_attributes: attributes;\n      }\n\n  and include_description = module_type include_infos\n  (* include MT *)\n\n  and include_declaration = module_expr include_infos\n  (* include ME *)\n\n  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =\n    | Pwith_type of Longident.t loc * type_declaration\n          (* with type X.t = ...\n\n             Note: the last component of the longident must match\n             the name of the type_declaration. *)\n    | Pwith_module of Longident.t loc * Longident.t loc\n          (* with module X.Y = Z *)\n    | Pwith_typesubst of type_declaration\n          (* with type t := ... *)\n    | Pwith_modsubst of string loc * Longident.t loc\n          (* with module X := Z *)\n\n  (* Value expressions for the module language *)\n\n  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =\n      {\n       pmod_desc: module_expr_desc;\n       pmod_loc: Location.t;\n       pmod_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =\n    | Pmod_ident of Longident.t loc\n          (* X *)\n    | Pmod_structure of structure\n          (* struct ... end *)\n    | Pmod_functor of string loc * module_type option * module_expr\n          (* functor(X : MT1) -> ME *)\n    | Pmod_apply of module_expr * module_expr\n          (* ME1(ME2) *)\n    | Pmod_constraint of module_expr * module_type\n          (* (ME : MT) *)\n    | Pmod_unpack of expression\n          (* (val E) *)\n    | Pmod_extension of extension\n          (* [%id] *)\n\n  and structure = structure_item list\n\n  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =\n      {\n       pstr_desc: structure_item_desc;\n       pstr_loc: Location.t;\n      }\n\n  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =\n    | Pstr_eval of expression * attributes\n          (* E *)\n    | Pstr_value of rec_flag * value_binding list\n          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)\n           *)\n    | Pstr_primitive of value_description\n          (*  val x: T\n              external x: T = \"s1\" ... \"sn\" *)\n    | Pstr_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Pstr_typext of type_extension\n          (* type t1 += ... *)\n    | Pstr_exception of extension_constructor\n          (* exception C of T\n             exception C = M.X *)\n    | Pstr_module of module_binding\n          (* module X = ME *)\n    | Pstr_recmodule of module_binding list\n          (* module rec X1 = ME1 and ... and Xn = MEn *)\n    | Pstr_modtype of module_type_declaration\n          (* module type S = MT *)\n    | Pstr_open of open_description\n          (* open X *)\n    | Pstr_class of class_declaration list\n          (* class c1 = ... and ... and cn = ... *)\n    | Pstr_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Pstr_include of include_declaration\n          (* include ME *)\n    | Pstr_attribute of attribute\n          (* [@@@id] *)\n    | Pstr_extension of extension * attributes\n          (* [%%id] *)\n\n  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =\n    {\n      pvb_pat: pattern;\n      pvb_expr: expression;\n      pvb_attributes: attributes;\n      pvb_loc: Location.t;\n    }\n\n  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =\n      {\n       pmb_name: string loc;\n       pmb_expr: module_expr;\n       pmb_attributes: attributes;\n       pmb_loc: Location.t;\n      }\n  (* X = ME *)\n\n  (** {2 Toplevel} *)\n\n  (* Toplevel phrases *)\n\n  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =\n    | Ptop_def of structure\n    | Ptop_dir of string * directive_argument\n       (* #use, #load ... *)\n\n  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =\n    | Pdir_none\n    | Pdir_string of string\n    | Pdir_int of string * char option\n    | Pdir_ident of Longident.t\n    | Pdir_bool of bool\nend\n\nmodule Docstrings : sig\n  (** {3 Docstrings} *)\n\n  (** Documentation comments *)\n  type docstring\n\n  (** Create a docstring *)\n  val docstring : string -> Location.t -> docstring\n\n  (** Get the text of a docstring *)\n  val docstring_body : docstring -> string\n\n  (** Get the location of a docstring *)\n  val docstring_loc : docstring -> Location.t\n\n  (** {3 Items}\n\n      The {!docs} type represents documentation attached to an item. *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  val empty_docs : docs\n\n  val docs_attr : docstring -> Parsetree.attribute\n\n  (** Convert item documentation to attributes and add them to an\n      attribute list *)\n  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Fields and constructors}\n\n      The {!info} type represents documentation attached to a field or\n      constructor. *)\n\n  type info = docstring option\n\n  val empty_info : info\n\n  val info_attr : docstring -> Parsetree.attribute\n\n  (** Convert field info to attributes and add them to an\n      attribute list *)\n  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Unattached comments}\n\n      The {!text} type represents documentation which is not attached to\n      anything. *)\n\n  type text = docstring list\n\n  val empty_text : text\n\n  val text_attr : docstring -> Parsetree.attribute\n\n  (** Convert text to attributes and add them to an attribute list *)\n  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes\n\nend = struct\n  open Location\n\n  (* Docstrings *)\n\n  type docstring =\n    { ds_body: string;\n      ds_loc: Location.t; }\n\n  (* Docstring constructors and destructors *)\n\n  let docstring body loc =\n    let ds =\n      { ds_body = body;\n        ds_loc = loc; }\n    in\n    ds\n\n  let docstring_body ds = ds.ds_body\n\n  let docstring_loc ds = ds.ds_loc\n\n  (* Docstrings attached to items *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  let empty_docs = { docs_pre = None; docs_post = None }\n\n  let doc_loc = {txt = \"ocaml.doc\"; loc = Location.none}\n\n  let docs_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (doc_loc, PStr [item])\n\n  let add_docs_attrs docs attrs =\n    let attrs =\n      match docs.docs_pre with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> docs_attr ds :: attrs\n    in\n    let attrs =\n      match docs.docs_post with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> attrs @ [docs_attr ds]\n    in\n    attrs\n\n  (* Docstrings attached to constructors or fields *)\n\n  type info = docstring option\n\n  let empty_info = None\n\n  let info_attr = docs_attr\n\n  let add_info_attrs info attrs =\n    match info with\n    | None | Some {ds_body=\"\"; _} -> attrs\n    | Some ds -> attrs @ [info_attr ds]\n\n  (* Docstrings not attached to a specific item *)\n\n  type text = docstring list\n\n  let empty_text = []\n\n  let text_loc = {txt = \"ocaml.text\"; loc = Location.none}\n\n  let text_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (text_loc, PStr [item])\n\n  let add_text_attrs dsl attrs =\n    let fdsl = List.filter (function {ds_body=\"\"; _} -> false| _ ->true) dsl in\n    (List.map text_attr fdsl) @ attrs\n\nend\n\nmodule Ast_helper : sig\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Docstrings\n  open Parsetree\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  (** {2 Default locations} *)\n\n  val default_loc: loc ref\n      (** Default value for all optional location arguments. *)\n\n  val with_default_loc: loc -> (unit -> 'a) -> 'a\n      (** Set the [default_loc] within the scope of the execution\n          of the provided function. *)\n\n  (** {2 Constants} *)\n\n  module Const : sig\n    val char : char -> constant\n    val string : ?quotation_delimiter:string -> string -> constant\n    val integer : ?suffix:char -> string -> constant\n    val int : ?suffix:char -> int -> constant\n    val int32 : ?suffix:char -> int32 -> constant\n    val int64 : ?suffix:char -> int64 -> constant\n    val nativeint : ?suffix:char -> nativeint -> constant\n    val float : ?suffix:char -> string -> constant\n  end\n\n  (** {2 Core language} *)\n\n  (** Type expressions *)\n  module Typ :\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type\n      val attr: core_type -> attribute -> core_type\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type\n      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type\n                 -> core_type\n      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val object_: ?loc:loc -> ?attrs:attrs ->\n                    (string * attributes * core_type) list -> closed_flag ->\n                    core_type\n      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type\n      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag\n                   -> label list option -> core_type\n      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type\n      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list\n                   -> core_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type\n\n      val force_poly: core_type -> core_type\n    end\n\n  (** Patterns *)\n  module Pat:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern\n      val attr:pattern -> attribute -> pattern\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern\n      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern\n      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern\n      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag\n                  -> pattern\n      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern\n      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern\n      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern\n      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern\n    end\n\n  (** Expressions *)\n  module Exp:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression\n      val attr: expression -> attribute -> expression\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list\n                -> expression -> expression\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option\n                -> pattern -> expression -> expression\n      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression\n      val apply: ?loc:loc -> ?attrs:attrs -> expression\n                 -> (arg_label * expression) list -> expression\n      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list\n                  -> expression\n      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression\n      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option\n                     -> expression\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option\n                   -> expression\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list\n                  -> expression option -> expression\n      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n                    -> expression\n      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                      -> expression option -> expression\n      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                    -> expression\n      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                  -> expression\n      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression\n                -> direction_flag -> expression -> expression\n      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                  -> core_type -> expression\n      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type\n                       -> expression\n      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression\n      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list\n                    -> expression\n      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression\n                     -> expression\n      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                -> expression\n      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression\n      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression\n      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression\n                 -> expression\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression\n      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression\n\n      val case: pattern -> ?guard:expression -> expression -> case\n    end\n\n  (** Value declarations *)\n  module Val:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        ?prim:string list -> str -> core_type -> value_description\n    end\n\n  (** Type declarations *)\n  module Type:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?params:(core_type * variance) list ->\n        ?cstrs:(core_type * core_type * loc) list ->\n        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->\n        type_declaration\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        constructor_declaration\n      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?mut:mutable_flag -> str -> core_type -> label_declaration\n    end\n\n  (** Type extensions *)\n  module Te:\n    sig\n      val mk: ?attrs:attrs -> ?docs:docs ->\n        ?params:(core_type * variance) list -> ?priv:private_flag ->\n        lid -> extension_constructor list -> type_extension\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> extension_constructor_kind -> extension_constructor\n\n      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        extension_constructor\n      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> lid -> extension_constructor\n    end\n\n  (** {2 Module language} *)\n\n  (** Module type expressions *)\n  module Mty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type\n      val attr: module_type -> attribute -> module_type\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_type -> module_type\n      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->\n        with_constraint list -> module_type\n      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type\n    end\n\n  (** Module expressions *)\n  module Mod:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr\n      val attr: module_expr -> attribute -> module_expr\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_expr -> module_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->\n        module_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->\n        module_expr\n      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr\n    end\n\n  (** Signature items *)\n  module Sig:\n    sig\n      val mk: ?loc:loc -> signature_item_desc -> signature_item\n\n      val value: ?loc:loc -> value_description -> signature_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item\n      val type_extension: ?loc:loc -> type_extension -> signature_item\n      val exception_: ?loc:loc -> extension_constructor -> signature_item\n      val module_: ?loc:loc -> module_declaration -> signature_item\n      val rec_module: ?loc:loc -> module_declaration list -> signature_item\n      val modtype: ?loc:loc -> module_type_declaration -> signature_item\n      val open_: ?loc:loc -> open_description -> signature_item\n      val include_: ?loc:loc -> include_description -> signature_item\n      val class_: ?loc:loc -> class_description list -> signature_item\n      val class_type: ?loc:loc -> class_type_declaration list -> signature_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item\n      val attribute: ?loc:loc -> attribute -> signature_item\n      val text: text -> signature_item list\n    end\n\n  (** Structure items *)\n  module Str:\n    sig\n      val mk: ?loc:loc -> structure_item_desc -> structure_item\n\n      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item\n      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item\n      val primitive: ?loc:loc -> value_description -> structure_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item\n      val type_extension: ?loc:loc -> type_extension -> structure_item\n      val exception_: ?loc:loc -> extension_constructor -> structure_item\n      val module_: ?loc:loc -> module_binding -> structure_item\n      val rec_module: ?loc:loc -> module_binding list -> structure_item\n      val modtype: ?loc:loc -> module_type_declaration -> structure_item\n      val open_: ?loc:loc -> open_description -> structure_item\n      val class_: ?loc:loc -> class_declaration list -> structure_item\n      val class_type: ?loc:loc -> class_type_declaration list -> structure_item\n      val include_: ?loc:loc -> include_declaration -> structure_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item\n      val attribute: ?loc:loc -> attribute -> structure_item\n      val text: text -> structure_item list\n    end\n\n  (** Module declarations *)\n  module Md:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_type -> module_declaration\n    end\n\n  (** Module type declarations *)\n  module Mtd:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?typ:module_type -> str -> module_type_declaration\n    end\n\n  (** Module bindings *)\n  module Mb:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_expr -> module_binding\n    end\n\n  (* Opens *)\n  module Opn:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->\n        ?override:override_flag -> lid -> open_description\n    end\n\n  (* Includes *)\n  module Incl:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos\n    end\n\n  (** Value bindings *)\n\n  module Vb:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        pattern -> expression -> value_binding\n    end\n\n\n  (** {2 Class language} *)\n\n  (** Class type expressions *)\n  module Cty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type\n      val attr: class_type -> attribute -> class_type\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type\n      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->\n        class_type -> class_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type\n    end\n\n  (** Class type fields *)\n  module Ctf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        class_type_field_desc -> class_type_field\n      val attr: class_type_field -> attribute -> class_type_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field\n      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_type_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field\n      val attribute: ?loc:loc -> attribute -> class_type_field\n      val text: text -> class_type_field list\n    end\n\n  (** Class expressions *)\n  module Cl:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr\n      val attr: class_expr -> attribute -> class_expr\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->\n        pattern -> class_expr -> class_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->\n        (arg_label * expression) list -> class_expr\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->\n        class_expr -> class_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->\n        class_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr\n    end\n\n  (** Class fields *)\n  module Cf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->\n        class_field\n      val attr: class_field -> attribute -> class_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->\n        string option -> class_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        class_field_kind -> class_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        class_field_kind -> class_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_field\n      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field\n      val attribute: ?loc:loc -> attribute -> class_field\n      val text: text -> class_field list\n\n      val virtual_: core_type -> class_field_kind\n      val concrete: override_flag -> expression -> class_field_kind\n\n    end\n\n  (** Classes *)\n  module Ci:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?virt:virtual_flag -> ?params:(core_type * variance) list ->\n        str -> 'a -> 'a class_infos\n    end\n\n  (** Class signatures *)\n  module Csig:\n    sig\n      val mk: core_type -> class_type_field list -> class_signature\n    end\n\n  (** Class structures *)\n  module Cstr:\n    sig\n      val mk: pattern -> class_field list -> class_structure\n    end\n\nend = struct\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Parsetree\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  let default_loc = ref Location.none\n\n  let with_default_loc l f =\n    let old = !default_loc in\n    default_loc := l;\n    try let r = f () in default_loc := old; r\n    with exn -> default_loc := old; raise exn\n\n  module Const = struct\n    let integer ?suffix i = Pconst_integer (i, suffix)\n    let int ?suffix i = integer ?suffix (string_of_int i)\n    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)\n    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)\n    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)\n    let float ?suffix f = Pconst_float (f, suffix)\n    let char c = Pconst_char c\n    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)\n  end\n\n  module Typ = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}\n    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))\n    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))\n    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))\n    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))\n    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)\n\n    let force_poly t =\n      match t.ptyp_desc with\n      | Ptyp_poly _ -> t\n      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)\n  end\n\n  module Pat = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}\n    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)\n    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)\n    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))\n    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)\n    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)\n    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)\n  end\n\n  module Exp = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}\n    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))\n    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))\n    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))\n    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))\n    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))\n    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)\n    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))\n    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))\n    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))\n    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))\n    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))\n    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))\n    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)\n    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))\n    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)\n    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))\n    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))\n    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)\n    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))\n    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)\n    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable\n\n    let case lhs ?guard rhs =\n      {\n       pc_lhs = lhs;\n       pc_guard = guard;\n       pc_rhs = rhs;\n      }\n  end\n\n  module Mty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}\n    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)\n    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)\n    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))\n    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))\n    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)\n  end\n\n  module Mod = struct\n  let mk ?(loc = !default_loc) ?(attrs = []) d =\n    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}\n    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}\n\n    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)\n    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)\n    let functor_ ?loc ?attrs arg arg_ty body =\n      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))\n    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))\n    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))\n    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)\n  end\n\n  module Sig = struct\n    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}\n\n    let value ?loc a = mk ?loc (Psig_value a)\n    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Psig_typext a)\n    let exception_ ?loc a = mk ?loc (Psig_exception a)\n    let module_ ?loc a = mk ?loc (Psig_module a)\n    let rec_module ?loc a = mk ?loc (Psig_recmodule a)\n    let modtype ?loc a = mk ?loc (Psig_modtype a)\n    let open_ ?loc a = mk ?loc (Psig_open a)\n    let include_ ?loc a = mk ?loc (Psig_include a)\n    let class_ ?loc a = mk ?loc (Psig_class a)\n    let class_type ?loc a = mk ?loc (Psig_class_type a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Psig_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n  end\n\n  module Str = struct\n    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}\n\n    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))\n    let value ?loc a b = mk ?loc (Pstr_value (a, b))\n    let primitive ?loc a = mk ?loc (Pstr_primitive a)\n    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Pstr_typext a)\n    let exception_ ?loc a = mk ?loc (Pstr_exception a)\n    let module_ ?loc a = mk ?loc (Pstr_module a)\n    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)\n    let modtype ?loc a = mk ?loc (Pstr_modtype a)\n    let open_ ?loc a = mk ?loc (Pstr_open a)\n    let class_ ?loc a = mk ?loc (Pstr_class a)\n    let class_type ?loc a = mk ?loc (Pstr_class_type a)\n    let include_ ?loc a = mk ?loc (Pstr_include a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Pstr_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n  end\n\n  module Cl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcl_desc = d;\n       pcl_loc = loc;\n       pcl_attributes = attrs;\n      }\n    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))\n    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)\n  end\n\n  module Cty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcty_desc = d;\n       pcty_loc = loc;\n       pcty_attributes = attrs;\n      }\n    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)\n  end\n\n  module Ctf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n             ?(docs = empty_docs) d =\n      {\n       pctf_desc = d;\n       pctf_loc = loc;\n       pctf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)\n    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))\n    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)\n    let attribute ?loc a = mk ?loc (Pctf_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n\n    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}\n\n  end\n\n  module Cf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) d =\n      {\n       pcf_desc = d;\n       pcf_loc = loc;\n       pcf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))\n    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))\n    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))\n    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)\n    let attribute ?loc a = mk ?loc (Pcf_attribute a)\n    let text txt =\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        txt\n\n    let virtual_ ct = Cfk_virtual ct\n    let concrete o e = Cfk_concrete (o, e)\n\n    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}\n\n  end\n\n  module Val = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(prim = []) name typ =\n      {\n       pval_name = name;\n       pval_type = typ;\n       pval_attributes = add_docs_attrs docs attrs;\n       pval_loc = loc;\n       pval_prim = prim;\n      }\n  end\n\n  module Md = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name typ =\n      {\n       pmd_name = name;\n       pmd_type = typ;\n       pmd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmd_loc = loc;\n      }\n  end\n\n  module Mtd = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) ?typ name =\n      {\n       pmtd_name = name;\n       pmtd_type = typ;\n       pmtd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmtd_loc = loc;\n      }\n  end\n\n  module Mb = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name expr =\n      {\n       pmb_name = name;\n       pmb_expr = expr;\n       pmb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmb_loc = loc;\n      }\n  end\n\n  module Opn = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(override = Fresh) lid =\n      {\n       popen_lid = lid;\n       popen_override = override;\n       popen_loc = loc;\n       popen_attributes = add_docs_attrs docs attrs;\n      }\n  end\n\n  module Incl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =\n      {\n       pincl_mod = mexpr;\n       pincl_loc = loc;\n       pincl_attributes = add_docs_attrs docs attrs;\n      }\n\n  end\n\n  module Vb = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(text = []) pat expr =\n      {\n       pvb_pat = pat;\n       pvb_expr = expr;\n       pvb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pvb_loc = loc;\n      }\n  end\n\n  module Ci = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n          ?(virt = Concrete) ?(params = []) name expr =\n      {\n       pci_virt = virt;\n       pci_params = params;\n       pci_name = name;\n       pci_expr = expr;\n       pci_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pci_loc = loc;\n      }\n  end\n\n  module Type = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n        ?(params = [])\n        ?(cstrs = [])\n        ?(kind = Ptype_abstract)\n        ?(priv = Public)\n        ?manifest\n        name =\n      {\n       ptype_name = name;\n       ptype_params = params;\n       ptype_cstrs = cstrs;\n       ptype_kind = kind;\n       ptype_private = priv;\n       ptype_manifest = manifest;\n       ptype_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       ptype_loc = loc;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(args = Pcstr_tuple []) ?res name =\n      {\n       pcd_name = name;\n       pcd_args = args;\n       pcd_res = res;\n       pcd_loc = loc;\n       pcd_attributes = add_info_attrs info attrs;\n      }\n\n    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(mut = Immutable) name typ =\n      {\n       pld_name = name;\n       pld_mutable = mut;\n       pld_type = typ;\n       pld_loc = loc;\n       pld_attributes = add_info_attrs info attrs;\n      }\n\n  end\n\n  (** Type extensions *)\n  module Te = struct\n    let mk ?(attrs = []) ?(docs = empty_docs)\n          ?(params = []) ?(priv = Public) path constructors =\n      {\n       ptyext_path = path;\n       ptyext_params = params;\n       ptyext_constructors = constructors;\n       ptyext_private = priv;\n       ptyext_attributes = add_docs_attrs docs attrs;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name kind =\n      {\n       pext_name = name;\n       pext_kind = kind;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =\n      {\n       pext_name = name;\n       pext_kind = Pext_decl(args, res);\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let rebind ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name lid =\n      {\n       pext_name = name;\n       pext_kind = Pext_rebind lid;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n  end\n\n  module Csig = struct\n    let mk self fields =\n      {\n       pcsig_self = self;\n       pcsig_fields = fields;\n      }\n  end\n\n  module Cstr = struct\n    let mk self fields =\n      {\n       pcstr_self = self;\n       pcstr_fields = fields;\n      }\n  end\n\nend\n\nmodule Ast_mapper : sig\n  (** The interface of a -ppx rewriter\n\n    A -ppx rewriter is a program that accepts a serialized abstract syntax\n    tree and outputs another, possibly modified, abstract syntax tree.\n    This module encapsulates the interface between the compiler and\n    the -ppx rewriters, handling such details as the serialization format,\n    forwarding of command-line flags, and storing state.\n\n    {!mapper} allows to implement AST rewriting using open recursion.\n    A typical mapper would be based on {!default_mapper}, a deep\n    identity mapper, and will fall back on it for handling the syntax it\n    does not modify. For example:\n\n    {[\n  open Asttypes\n  open Parsetree\n  open Ast_mapper\n\n  let test_mapper argv =\n    { default_mapper with\n      expr = fun mapper expr ->\n        match expr with\n        | { pexp_desc = Pexp_extension ({ txt = \"test\" }, PStr [])} ->\n          Ast_helper.Exp.constant (Const_int 42)\n        | other -> default_mapper.expr mapper other; }\n\n  let () =\n    register \"ppx_test\" test_mapper]}\n\n    This -ppx rewriter, which replaces [[%test]] in expressions with\n    the constant [42], can be compiled using\n    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].\n\n    *)\n\n  open Parsetree\n\n  (** {2 A generic Parsetree mapper} *)\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n  (** A mapper record implements one \"method\" per syntactic category,\n      using an open recursion style: each method takes as its first\n      argument the mapper to be applied to children in the syntax\n      tree. *)\n\n  val default_mapper: mapper\n  (** A default mapper, which implements a \"deep identity\" mapping. *)\n\n  (** {2 Convenience functions to write mappers} *)\n\n  val map_opt: ('a -> 'b) -> 'a option -> 'b option\n\n  val extension_of_error: Location.error -> extension\n  (** Encode an error into an 'ocaml.error' extension node which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the error. *)\n\n  val attribute_of_warning: Location.t -> string -> attribute\n  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the warning. *)\n\nend = struct\n  (* A generic Parsetree mapping class *)\n\n  (*\n  [@@@ocaml.warning \"+9\"]\n    (* Ensure that record patterns don't miss any field. *)\n  *)\n\n\n  open Parsetree\n  open Ast_helper\n  open Location\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n\n  let map_fst f (x, y) = (f x, y)\n  let map_snd f (x, y) = (x, f y)\n  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)\n  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)\n  let map_opt f = function None -> None | Some x -> Some (f x)\n\n  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}\n\n  module T = struct\n    (* Type expressions for the core language *)\n\n    let row_field sub = function\n      | Rtag (l, attrs, b, tl) ->\n          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)\n      | Rinherit t -> Rinherit (sub.typ sub t)\n\n    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =\n      let open Typ in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ptyp_any -> any ~loc ~attrs ()\n      | Ptyp_var s -> var ~loc ~attrs s\n      | Ptyp_arrow (lab, t1, t2) ->\n          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)\n      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)\n      | Ptyp_constr (lid, tl) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_object (l, o) ->\n          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in\n          object_ ~loc ~attrs (List.map f l) o\n      | Ptyp_class (lid, tl) ->\n          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s\n      | Ptyp_variant (rl, b, ll) ->\n          variant ~loc ~attrs (List.map (row_field sub) rl) b ll\n      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)\n      | Ptyp_package (lid, l) ->\n          package ~loc ~attrs (map_loc sub lid)\n            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)\n      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_type_declaration sub\n        {ptype_name; ptype_params; ptype_cstrs;\n         ptype_kind;\n         ptype_private;\n         ptype_manifest;\n         ptype_attributes;\n         ptype_loc} =\n      Type.mk (map_loc sub ptype_name)\n        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)\n        ~priv:ptype_private\n        ~cstrs:(List.map\n                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))\n                  ptype_cstrs)\n        ~kind:(sub.type_kind sub ptype_kind)\n        ?manifest:(map_opt (sub.typ sub) ptype_manifest)\n        ~loc:(sub.location sub ptype_loc)\n        ~attrs:(sub.attributes sub ptype_attributes)\n\n    let map_type_kind sub = function\n      | Ptype_abstract -> Ptype_abstract\n      | Ptype_variant l ->\n          Ptype_variant (List.map (sub.constructor_declaration sub) l)\n      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)\n      | Ptype_open -> Ptype_open\n\n    let map_constructor_arguments sub = function\n      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)\n      | Pcstr_record l ->\n          Pcstr_record (List.map (sub.label_declaration sub) l)\n\n    let map_type_extension sub\n        {ptyext_path; ptyext_params;\n         ptyext_constructors;\n         ptyext_private;\n         ptyext_attributes} =\n      Te.mk\n        (map_loc sub ptyext_path)\n        (List.map (sub.extension_constructor sub) ptyext_constructors)\n        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)\n        ~priv:ptyext_private\n        ~attrs:(sub.attributes sub ptyext_attributes)\n\n    let map_extension_constructor_kind sub = function\n        Pext_decl(ctl, cto) ->\n          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)\n      | Pext_rebind li ->\n          Pext_rebind (map_loc sub li)\n\n    let map_extension_constructor sub\n        {pext_name;\n         pext_kind;\n         pext_loc;\n         pext_attributes} =\n      Te.constructor\n        (map_loc sub pext_name)\n        (map_extension_constructor_kind sub pext_kind)\n        ~loc:(sub.location sub pext_loc)\n        ~attrs:(sub.attributes sub pext_attributes)\n\n  end\n\n  module CT = struct\n    (* Type expressions for the class language *)\n\n    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =\n      let open Cty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcty_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)\n      | Pcty_arrow (lab, t, ct) ->\n          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)\n      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}\n      =\n      let open Ctf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)\n      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)\n      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)\n      | Pctf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_signature sub {pcsig_self; pcsig_fields} =\n      Csig.mk\n        (sub.typ sub pcsig_self)\n        (List.map (sub.class_type_field sub) pcsig_fields)\n  end\n\n  module MT = struct\n    (* Type expressions for the module language *)\n\n    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =\n      let open Mty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)\n      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)\n      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)\n      | Pmty_functor (s, mt1, mt2) ->\n          functor_ ~loc ~attrs (map_loc sub s)\n            (Misc.may_map (sub.module_type sub) mt1)\n            (sub.module_type sub mt2)\n      | Pmty_with (mt, l) ->\n          with_ ~loc ~attrs (sub.module_type sub mt)\n            (List.map (sub.with_constraint sub) l)\n      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)\n      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_with_constraint sub = function\n      | Pwith_type (lid, d) ->\n          Pwith_type (map_loc sub lid, sub.type_declaration sub d)\n      | Pwith_module (lid, lid2) ->\n          Pwith_module (map_loc sub lid, map_loc sub lid2)\n      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)\n      | Pwith_modsubst (s, lid) ->\n          Pwith_modsubst (map_loc sub s, map_loc sub lid)\n\n    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =\n      let open Sig in\n      let loc = sub.location sub loc in\n      match desc with\n      | Psig_value vd -> value ~loc (sub.value_description sub vd)\n      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)\n      | Psig_recmodule l ->\n          rec_module ~loc (List.map (sub.module_declaration sub) l)\n      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Psig_open x -> open_ ~loc (sub.open_description sub x)\n      | Psig_include x -> include_ ~loc (sub.include_description sub x)\n      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)\n      | Psig_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Psig_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n\n  module M = struct\n    (* Value expressions for the module language *)\n\n    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =\n      let open Mod in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)\n      | Pmod_functor (arg, arg_ty, body) ->\n          functor_ ~loc ~attrs (map_loc sub arg)\n            (Misc.may_map (sub.module_type sub) arg_ty)\n            (sub.module_expr sub body)\n      | Pmod_apply (m1, m2) ->\n          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)\n      | Pmod_constraint (m, mty) ->\n          constraint_ ~loc ~attrs (sub.module_expr sub m)\n                      (sub.module_type sub mty)\n      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)\n      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =\n      let open Str in\n      let loc = sub.location sub loc in\n      match desc with\n      | Pstr_eval (x, attrs) ->\n          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)\n      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)\n      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)\n      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)\n      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)\n      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Pstr_open x -> open_ ~loc (sub.open_description sub x)\n      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)\n      | Pstr_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)\n      | Pstr_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n  module E = struct\n    (* Value expressions for the core language *)\n\n    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =\n      let open Exp in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pexp_constant x -> constant ~loc ~attrs x\n      | Pexp_let (r, vbs, e) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.expr sub e)\n      | Pexp_fun (lab, def, p, e) ->\n          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)\n            (sub.expr sub e)\n      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)\n      | Pexp_apply (e, l) ->\n          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)\n      | Pexp_match (e, pel) ->\n          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_construct (lid, arg) ->\n          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)\n      | Pexp_variant (lab, eo) ->\n          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)\n      | Pexp_record (l, eo) ->\n          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)\n            (map_opt (sub.expr sub) eo)\n      | Pexp_field (e, lid) ->\n          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)\n      | Pexp_setfield (e1, lid, e2) ->\n          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)\n            (sub.expr sub e2)\n      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_ifthenelse (e1, e2, e3) ->\n          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n            (map_opt (sub.expr sub) e3)\n      | Pexp_sequence (e1, e2) ->\n          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_while (e1, e2) ->\n          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_for (p, e1, e2, d, e3) ->\n          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d\n            (sub.expr sub e3)\n      | Pexp_coerce (e, t1, t2) ->\n          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)\n            (sub.typ sub t2)\n      | Pexp_constraint (e, t) ->\n          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)\n      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s\n      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)\n      | Pexp_setinstvar (s, e) ->\n          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_override sel ->\n          override ~loc ~attrs\n            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)\n      | Pexp_letmodule (s, me, e) ->\n          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)\n            (sub.expr sub e)\n      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_poly (e, t) ->\n          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)\n      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)\n      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)\n      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)\n      | Pexp_open (ovf, lid, e) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)\n      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pexp_unreachable -> unreachable ~loc ~attrs ()\n  end\n\n  module P = struct\n    (* Patterns *)\n\n    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =\n      let open Pat in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ppat_any -> any ~loc ~attrs ()\n      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)\n      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)\n      | Ppat_constant c -> constant ~loc ~attrs c\n      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2\n      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_construct (l, p) ->\n          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)\n      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)\n      | Ppat_record (lpl, cf) ->\n          record ~loc ~attrs\n                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf\n      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)\n      | Ppat_constraint (p, t) ->\n          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)\n      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)\n      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)\n      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module CE = struct\n    (* Value expressions for the class language *)\n\n    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =\n      let open Cl in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcl_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcl_structure s ->\n          structure ~loc ~attrs (sub.class_structure sub s)\n      | Pcl_fun (lab, e, p, ce) ->\n          fun_ ~loc ~attrs lab\n            (map_opt (sub.expr sub) e)\n            (sub.pat sub p)\n            (sub.class_expr sub ce)\n      | Pcl_apply (ce, l) ->\n          apply ~loc ~attrs (sub.class_expr sub ce)\n            (List.map (map_snd (sub.expr sub)) l)\n      | Pcl_let (r, vbs, ce) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.class_expr sub ce)\n      | Pcl_constraint (ce, ct) ->\n          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)\n      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_kind sub = function\n      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)\n      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)\n\n    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =\n      let open Cf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s\n      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)\n      | Pcf_method (s, p, k) ->\n          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)\n      | Pcf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)\n      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure sub {pcstr_self; pcstr_fields} =\n      {\n        pcstr_self = sub.pat sub pcstr_self;\n        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;\n      }\n\n    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;\n                           pci_loc; pci_attributes} =\n      Ci.mk\n       ~virt:pci_virt\n       ~params:(List.map (map_fst (sub.typ sub)) pl)\n        (map_loc sub pci_name)\n        (f pci_expr)\n        ~loc:(sub.location sub pci_loc)\n        ~attrs:(sub.attributes sub pci_attributes)\n  end\n\n  (* Now, a generic AST mapper, to be extended to cover all kinds and\n     cases of the OCaml grammar.  The default behavior of the mapper is\n     the identity. *)\n\n  let default_mapper =\n    {\n      structure = (fun this l -> List.map (this.structure_item this) l);\n      structure_item = M.map_structure_item;\n      module_expr = M.map;\n      signature = (fun this l -> List.map (this.signature_item this) l);\n      signature_item = MT.map_signature_item;\n      module_type = MT.map;\n      with_constraint = MT.map_with_constraint;\n      class_declaration =\n        (fun this -> CE.class_infos this (this.class_expr this));\n      class_expr = CE.map;\n      class_field = CE.map_field;\n      class_structure = CE.map_structure;\n      class_type = CT.map;\n      class_type_field = CT.map_field;\n      class_signature = CT.map_signature;\n      class_type_declaration =\n        (fun this -> CE.class_infos this (this.class_type this));\n      class_description =\n        (fun this -> CE.class_infos this (this.class_type this));\n      type_declaration = T.map_type_declaration;\n      type_kind = T.map_type_kind;\n      typ = T.map;\n      type_extension = T.map_type_extension;\n      extension_constructor = T.map_extension_constructor;\n      value_description =\n        (fun this {pval_name; pval_type; pval_prim; pval_loc;\n                   pval_attributes} ->\n          Val.mk\n            (map_loc this pval_name)\n            (this.typ this pval_type)\n            ~attrs:(this.attributes this pval_attributes)\n            ~loc:(this.location this pval_loc)\n            ~prim:pval_prim\n        );\n\n      pat = P.map;\n      expr = E.map;\n\n      module_declaration =\n        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->\n           Md.mk\n             (map_loc this pmd_name)\n             (this.module_type this pmd_type)\n             ~attrs:(this.attributes this pmd_attributes)\n             ~loc:(this.location this pmd_loc)\n        );\n\n      module_type_declaration =\n        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->\n           Mtd.mk\n             (map_loc this pmtd_name)\n             ?typ:(map_opt (this.module_type this) pmtd_type)\n             ~attrs:(this.attributes this pmtd_attributes)\n             ~loc:(this.location this pmtd_loc)\n        );\n\n      module_binding =\n        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->\n           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)\n             ~attrs:(this.attributes this pmb_attributes)\n             ~loc:(this.location this pmb_loc)\n        );\n\n\n      open_description =\n        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->\n           Opn.mk (map_loc this popen_lid)\n             ~override:popen_override\n             ~loc:(this.location this popen_loc)\n             ~attrs:(this.attributes this popen_attributes)\n        );\n\n\n      include_description =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_type this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n      include_declaration =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_expr this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n\n      value_binding =\n        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->\n           Vb.mk\n             (this.pat this pvb_pat)\n             (this.expr this pvb_expr)\n             ~loc:(this.location this pvb_loc)\n             ~attrs:(this.attributes this pvb_attributes)\n        );\n\n\n      constructor_declaration =\n        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->\n          Type.constructor\n            (map_loc this pcd_name)\n            ~args:(T.map_constructor_arguments this pcd_args)\n            ?res:(map_opt (this.typ this) pcd_res)\n            ~loc:(this.location this pcd_loc)\n            ~attrs:(this.attributes this pcd_attributes)\n        );\n\n      label_declaration =\n        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->\n           Type.field\n             (map_loc this pld_name)\n             (this.typ this pld_type)\n             ~mut:pld_mutable\n             ~loc:(this.location this pld_loc)\n             ~attrs:(this.attributes this pld_attributes)\n        );\n\n      cases = (fun this l -> List.map (this.case this) l);\n      case =\n        (fun this {pc_lhs; pc_guard; pc_rhs} ->\n           {\n             pc_lhs = this.pat this pc_lhs;\n             pc_guard = map_opt (this.expr this) pc_guard;\n             pc_rhs = this.expr this pc_rhs;\n           }\n        );\n\n\n\n      location = (fun _this l -> l);\n\n      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attributes = (fun this l -> List.map (this.attribute this) l);\n      payload =\n        (fun this -> function\n           | PStr x -> PStr (this.structure this x)\n           | PSig x -> PSig (this.signature this x)\n           | PTyp x -> PTyp (this.typ this x)\n           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)\n        );\n    }\n\n  let rec extension_of_error {loc; msg; if_highlight; sub} =\n    { loc; txt = \"ocaml.error\" },\n    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));\n           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @\n          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))\n\n  let attribute_of_warning loc s =\n    { loc; txt = \"ocaml.ppwarning\" },\n    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])\n\nend\n\nmodule Outcometree = struct\n  (* Module [Outcometree]: results displayed by the toplevel *)\n\n  (* These types represent messages that the toplevel displays as normal\n     results or errors. The real displaying is customisable using the hooks:\n        [Toploop.print_out_value]\n        [Toploop.print_out_type]\n        [Toploop.print_out_sig_item]\n        [Toploop.print_out_phrase] *)\n\n  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =\n    | Oide_apply of out_ident * out_ident\n    | Oide_dot of out_ident * string\n    | Oide_ident of string\n\n  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =\n    { oattr_name: string }\n\n  type out_value (*IF_CURRENT = Outcometree.out_value *) =\n    | Oval_array of out_value list\n    | Oval_char of char\n    | Oval_constr of out_ident * out_value list\n    | Oval_ellipsis\n    | Oval_float of float\n    | Oval_int of int\n    | Oval_int32 of int32\n    | Oval_int64 of int64\n    | Oval_nativeint of nativeint\n    | Oval_list of out_value list\n    | Oval_printer of (Format.formatter -> unit)\n    | Oval_record of (out_ident * out_value) list\n    | Oval_string of string\n    | Oval_stuff of string\n    | Oval_tuple of out_value list\n    | Oval_variant of string * out_value option\n\n  type out_type (*IF_CURRENT = Outcometree.out_type *) =\n    | Otyp_abstract\n    | Otyp_open\n    | Otyp_alias of out_type * string\n    | Otyp_arrow of string * out_type * out_type\n    | Otyp_class of bool * out_ident * out_type list\n    | Otyp_constr of out_ident * out_type list\n    | Otyp_manifest of out_type * out_type\n    | Otyp_object of (string * out_type) list * bool option\n    | Otyp_record of (string * bool * out_type) list\n    | Otyp_stuff of string\n    | Otyp_sum of (string * out_type list * out_type option) list\n    | Otyp_tuple of out_type list\n    | Otyp_var of bool * string\n    | Otyp_variant of\n        bool * out_variant * bool * (string list) option\n    | Otyp_poly of string list * out_type\n    | Otyp_module of string * string list * out_type list\n    | Otyp_attribute of out_type * out_attribute\n\n  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =\n    | Ovar_fields of (string * bool * out_type list) list\n    | Ovar_name of out_ident * out_type list\n\n  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =\n    | Octy_constr of out_ident * out_type list\n    | Octy_arrow of string * out_type * out_class_type\n    | Octy_signature of out_type option * out_class_sig_item list\n  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =\n    | Ocsg_constraint of out_type * out_type\n    | Ocsg_method of string * bool * bool * out_type\n    | Ocsg_value of string * bool * bool * out_type\n\n  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =\n    | Omty_abstract\n    | Omty_functor of string * out_module_type option * out_module_type\n    | Omty_ident of out_ident\n    | Omty_signature of out_sig_item list\n    | Omty_alias of out_ident\n  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =\n    | Osig_class of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_class_type of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_typext of out_extension_constructor * out_ext_status\n    | Osig_modtype of string * out_module_type\n    | Osig_module of string * out_module_type * out_rec_status\n    | Osig_type of out_type_decl * out_rec_status\n    | Osig_value of out_val_decl\n    | Osig_ellipsis\n  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =\n    { otype_name: string;\n      otype_params: (string * (bool * bool)) list;\n      otype_type: out_type;\n      otype_private: Asttypes.private_flag;\n      otype_immediate: bool;\n      otype_cstrs: (out_type * out_type) list }\n  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =\n    { oext_name: string;\n      oext_type_name: string;\n      oext_type_params: string list;\n      oext_args: out_type list;\n      oext_ret_type: out_type option;\n      oext_private: Asttypes.private_flag }\n  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =\n    { otyext_name: string;\n      otyext_params: string list;\n      otyext_constructors: (string * out_type list * out_type option) list;\n      otyext_private: Asttypes.private_flag }\n  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =\n    { oval_name: string;\n      oval_type: out_type;\n      oval_prims: string list;\n      oval_attributes: out_attribute list }\n  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =\n    | Orec_not\n    | Orec_first\n    | Orec_next\n  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =\n    | Oext_first\n    | Oext_next\n    | Oext_exception\n\n  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =\n    | Ophr_eval of out_value * out_type\n    | Ophr_signature of (out_sig_item * out_value option) list\n    | Ophr_exception of (exn * out_value)\n\nend\n\nmodule Config = struct\n  let ast_impl_magic_number = \"Caml1999M019\"\n  let ast_intf_magic_number = \"Caml1999N018\"\nend\n\nlet map_signature mapper = mapper.Ast_mapper.signature mapper\nlet map_structure mapper = mapper.Ast_mapper.structure mapper\n\nlet shallow_identity =\n  let id _ x = x in\n  {\n    Ast_mapper.\n    structure               = id;\n    structure_item          = id;\n    module_expr             = id;\n    signature               = id;\n    signature_item          = id;\n    module_type             = id;\n    with_constraint         = id;\n    class_declaration       = id;\n    class_expr              = id;\n    class_field             = id;\n    class_structure         = id;\n    class_type              = id;\n    class_type_field        = id;\n    class_signature         = id;\n    class_type_declaration  = id;\n    class_description       = id;\n    type_declaration        = id;\n    type_kind               = id;\n    typ                     = id;\n    type_extension          = id;\n    extension_constructor   = id;\n    value_description       = id;\n    pat                     = id;\n    expr                    = id;\n    module_declaration      = id;\n    module_type_declaration = id;\n    module_binding          = id;\n    open_description        = id;\n    include_description     = id;\n    include_declaration     = id;\n    value_binding           = id;\n    constructor_declaration = id;\n    label_declaration       = id;\n    cases                   = id;\n    case                    = id;\n    location                = id;\n    extension               = id;\n    attribute               = id;\n    attributes              = id;\n    payload                 = id;\n  }\n\nlet failing_mapper =\n  let fail _ _ =\n    invalid_arg \"failing_mapper: this mapper function should never get called\"\n  in\n  {\n    Ast_mapper.\n    structure               = fail;\n    structure_item          = fail;\n    module_expr             = fail;\n    signature               = fail;\n    signature_item          = fail;\n    module_type             = fail;\n    with_constraint         = fail;\n    class_declaration       = fail;\n    class_expr              = fail;\n    class_field             = fail;\n    class_structure         = fail;\n    class_type              = fail;\n    class_type_field        = fail;\n    class_signature         = fail;\n    class_type_declaration  = fail;\n    class_description       = fail;\n    type_declaration        = fail;\n    type_kind               = fail;\n    typ                     = fail;\n    type_extension          = fail;\n    extension_constructor   = fail;\n    value_description       = fail;\n    pat                     = fail;\n    expr                    = fail;\n    module_declaration      = fail;\n    module_type_declaration = fail;\n    module_binding          = fail;\n    open_description        = fail;\n    include_description     = fail;\n    include_declaration     = fail;\n    value_binding           = fail;\n    constructor_declaration = fail;\n    label_declaration       = fail;\n    cases                   = fail;\n    case                    = fail;\n    location                = fail;\n    extension               = fail;\n    attribute               = fail;\n    attributes              = fail;\n    payload                 = fail;\n  }\n\nlet make_top_mapper ~signature ~structure =\n  {failing_mapper with Ast_mapper.\n                    signature = (fun _ x -> signature x);\n                    structure = (fun _ x -> structure x) }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*            Jérémie Dimino and Leo White, Jane Street Europe            *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)\n(*                         Alain Frisch, LexiFi                           *)\n(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Location = Location\nmodule Longident = Longident\n\nmodule Asttypes = struct\n  (** Auxiliary AST types used by parsetree and typedtree. *)\n\n  type constant (*IF_CURRENT = Asttypes.constant *) =\n      Const_int of int\n    | Const_char of char\n    | Const_string of string * string option\n    | Const_float of string\n    | Const_int32 of int32\n    | Const_int64 of int64\n    | Const_nativeint of nativeint\n\n  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive\n\n  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto\n\n  (* Order matters, used in polymorphic comparison *)\n  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public\n\n  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable\n\n  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete\n\n  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh\n\n  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open\n\n  type label = string\n\n  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =\n      Nolabel\n    | Labelled of string (*  label:T -> ... *)\n    | Optional of string (* ?label:T -> ... *)\n\n  type 'a loc = 'a Location.loc = {\n    txt : 'a;\n    loc : Location.t;\n  }\n\n\n  type variance (*IF_CURRENT = Asttypes.variance *) =\n    | Covariant\n    | Contravariant\n    | Invariant\nend\n\nmodule Parsetree = struct\n  (** Abstract syntax tree produced by parsing *)\n\n  open Asttypes\n\n  type constant (*IF_CURRENT = Parsetree.constant *) =\n      Pconst_integer of string * char option\n    (* 3 3l 3L 3n\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker\n    *)\n    | Pconst_char of char\n    (* 'c' *)\n    | Pconst_string of string * string option\n    (* \"constant\"\n       {delim|other constant|delim}\n    *)\n    | Pconst_float of string * char option\n    (* 3.4 2e5 1.4e-4\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes are rejected by the typechecker.\n    *)\n\n  (** {2 Extension points} *)\n\n  type attribute = string loc * payload\n         (* [@id ARG]\n            [@@id ARG]\n\n            Metadata containers passed around within the AST.\n            The compiler ignores unknown attributes.\n         *)\n\n  and extension = string loc * payload\n        (* [%id ARG]\n           [%%id ARG]\n\n           Sub-language placeholder -- rejected by the typechecker.\n        *)\n\n  and attributes = attribute list\n\n  and payload (*IF_CURRENT = Parsetree.payload *) =\n    | PStr of structure\n    | PSig of signature (* : SIG *)\n    | PTyp of core_type  (* : T *)\n    | PPat of pattern * expression option  (* ? P  or  ? P when E *)\n\n  (** {2 Core language} *)\n\n  (* Type expressions *)\n\n  and core_type (*IF_CURRENT = Parsetree.core_type *) =\n      {\n       ptyp_desc: core_type_desc;\n       ptyp_loc: Location.t;\n       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =\n    | Ptyp_any\n          (*  _ *)\n    | Ptyp_var of string\n          (* 'a *)\n    | Ptyp_arrow of arg_label * core_type * core_type\n          (* T1 -> T2       Simple\n             ~l:T1 -> T2    Labelled\n             ?l:T1 -> T2    Otional\n           *)\n    | Ptyp_tuple of core_type list\n          (* T1 * ... * Tn\n\n             Invariant: n >= 2\n          *)\n    | Ptyp_constr of Longident.t loc * core_type list\n          (* tconstr\n             T tconstr\n             (T1, ..., Tn) tconstr\n           *)\n    | Ptyp_object of (string * attributes * core_type) list * closed_flag\n          (* < l1:T1; ...; ln:Tn >     (flag = Closed)\n             < l1:T1; ...; ln:Tn; .. > (flag = Open)\n           *)\n    | Ptyp_class of Longident.t loc * core_type list\n          (* #tconstr\n             T #tconstr\n             (T1, ..., Tn) #tconstr\n           *)\n    | Ptyp_alias of core_type * string\n          (* T as 'a *)\n    | Ptyp_variant of row_field list * closed_flag * label list option\n          (* [ `A|`B ]         (flag = Closed; labels = None)\n             [> `A|`B ]        (flag = Open;   labels = None)\n             [< `A|`B ]        (flag = Closed; labels = Some [])\n             [< `A|`B > `X `Y ](flag = Closed; labels = Some [\"X\";\"Y\"])\n           *)\n    | Ptyp_poly of string list * core_type\n          (* 'a1 ... 'an. T\n\n             Can only appear in the following context:\n\n             - As the core_type of a Ppat_constraint node corresponding\n               to a constraint on a let-binding: let x : 'a1 ... 'an. T\n               = e ...\n\n             - Under Cfk_virtual for methods (not values).\n\n             - As the core_type of a Pctf_method node.\n\n             - As the core_type of a Pexp_poly node.\n\n             - As the pld_type field of a label_declaration.\n\n             - As a core_type of a Ptyp_object node.\n           *)\n\n    | Ptyp_package of package_type\n          (* (module S) *)\n    | Ptyp_extension of extension\n          (* [%id] *)\n\n  and package_type = Longident.t loc * (Longident.t loc * core_type) list\n        (*\n          (module S)\n          (module S with type t1 = T1 and ... and tn = Tn)\n         *)\n\n  and row_field (*IF_CURRENT = Parsetree.row_field *) =\n    | Rtag of label * attributes * bool * core_type list\n          (* [`A]                   ( true,  [] )\n             [`A of T]              ( false, [T] )\n             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )\n             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )\n\n            - The 2nd field is true if the tag contains a\n              constant (empty) constructor.\n            - '&' occurs when several types are used for the same constructor\n              (see 4.2 in the manual)\n\n            - TODO: switch to a record representation, and keep location\n          *)\n    | Rinherit of core_type\n          (* [ T ] *)\n\n  (* Patterns *)\n\n  and pattern (*IF_CURRENT = Parsetree.pattern *) =\n      {\n       ppat_desc: pattern_desc;\n       ppat_loc: Location.t;\n       ppat_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =\n    | Ppat_any\n          (* _ *)\n    | Ppat_var of string loc\n          (* x *)\n    | Ppat_alias of pattern * string loc\n          (* P as 'a *)\n    | Ppat_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Ppat_interval of constant * constant\n          (* 'a'..'z'\n\n             Other forms of interval are recognized by the parser\n             but rejected by the type-checker. *)\n    | Ppat_tuple of pattern list\n          (* (P1, ..., Pn)\n\n             Invariant: n >= 2\n          *)\n    | Ppat_construct of Longident.t loc * pattern option\n          (* C                None\n             C P              Some P\n             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])\n           *)\n    | Ppat_variant of label * pattern option\n          (* `A             (None)\n             `A P           (Some P)\n           *)\n    | Ppat_record of (Longident.t loc * pattern) list * closed_flag\n          (* { l1=P1; ...; ln=Pn }     (flag = Closed)\n             { l1=P1; ...; ln=Pn; _}   (flag = Open)\n\n             Invariant: n > 0\n           *)\n    | Ppat_array of pattern list\n          (* [| P1; ...; Pn |] *)\n    | Ppat_or of pattern * pattern\n          (* P1 | P2 *)\n    | Ppat_constraint of pattern * core_type\n          (* (P : T) *)\n    | Ppat_type of Longident.t loc\n          (* #tconst *)\n    | Ppat_lazy of pattern\n          (* lazy P *)\n    | Ppat_unpack of string loc\n          (* (module P)\n             Note: (module P : S) is represented as\n             Ppat_constraint(Ppat_unpack, Ptyp_package)\n           *)\n    | Ppat_exception of pattern\n          (* exception P *)\n    | Ppat_extension of extension\n          (* [%id] *)\n    | Ppat_open of Longident.t loc * pattern\n\n  (* Value expressions *)\n\n  and expression (*IF_CURRENT = Parsetree.expression *) =\n      {\n       pexp_desc: expression_desc;\n       pexp_loc: Location.t;\n       pexp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =\n    | Pexp_ident of Longident.t loc\n          (* x\n             M.x\n           *)\n    | Pexp_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Pexp_let of rec_flag * value_binding list * expression\n          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)\n           *)\n    | Pexp_function of case list\n          (* function P1 -> E1 | ... | Pn -> En *)\n    | Pexp_fun of arg_label * expression option * pattern * expression\n          (* fun P -> E1                          (Simple, None)\n             fun ~l:P -> E1                       (Labelled l, None)\n             fun ?l:P -> E1                       (Optional l, None)\n             fun ?l:(P = E0) -> E1                (Optional l, Some E0)\n\n             Notes:\n             - If E0 is provided, only Optional is allowed.\n             - \"fun P1 P2 .. Pn -> E1\" is represented as nested Pexp_fun.\n             - \"let f P = E\" is represented using Pexp_fun.\n           *)\n    | Pexp_apply of expression * (arg_label * expression) list\n          (* E0 ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pexp_match of expression * case list\n          (* match E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_try of expression * case list\n          (* try E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_tuple of expression list\n          (* (E1, ..., En)\n\n             Invariant: n >= 2\n          *)\n    | Pexp_construct of Longident.t loc * expression option\n          (* C                None\n             C E              Some E\n             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])\n          *)\n    | Pexp_variant of label * expression option\n          (* `A             (None)\n             `A E           (Some E)\n           *)\n    | Pexp_record of (Longident.t loc * expression) list * expression option\n          (* { l1=P1; ...; ln=Pn }     (None)\n             { E0 with l1=P1; ...; ln=Pn }   (Some E0)\n\n             Invariant: n > 0\n           *)\n    | Pexp_field of expression * Longident.t loc\n          (* E.l *)\n    | Pexp_setfield of expression * Longident.t loc * expression\n          (* E1.l <- E2 *)\n    | Pexp_array of expression list\n          (* [| E1; ...; En |] *)\n    | Pexp_ifthenelse of expression * expression * expression option\n          (* if E1 then E2 else E3 *)\n    | Pexp_sequence of expression * expression\n          (* E1; E2 *)\n    | Pexp_while of expression * expression\n          (* while E1 do E2 done *)\n    | Pexp_for of\n        pattern *  expression * expression * direction_flag * expression\n          (* for i = E1 to E2 do E3 done      (flag = Upto)\n             for i = E1 downto E2 do E3 done  (flag = Downto)\n           *)\n    | Pexp_constraint of expression * core_type\n          (* (E : T) *)\n    | Pexp_coerce of expression * core_type option * core_type\n          (* (E :> T)        (None, T)\n             (E : T0 :> T)   (Some T0, T)\n           *)\n    | Pexp_send of expression * string\n          (*  E # m *)\n    | Pexp_new of Longident.t loc\n          (* new M.c *)\n    | Pexp_setinstvar of string loc * expression\n          (* x <- 2 *)\n    | Pexp_override of (string loc * expression) list\n          (* {< x1 = E1; ...; Xn = En >} *)\n    | Pexp_letmodule of string loc * module_expr * expression\n          (* let module M = ME in E *)\n    | Pexp_letexception of extension_constructor * expression\n          (* let exception C in E *)\n    | Pexp_assert of expression\n          (* assert E\n             Note: \"assert false\" is treated in a special way by the\n             type-checker. *)\n    | Pexp_lazy of expression\n          (* lazy E *)\n    | Pexp_poly of expression * core_type option\n          (* Used for method bodies.\n\n             Can only be used as the expression under Cfk_concrete\n             for methods (not values). *)\n    | Pexp_object of class_structure\n          (* object ... end *)\n    | Pexp_newtype of string * expression\n          (* fun (type t) -> E *)\n    | Pexp_pack of module_expr\n          (* (module ME)\n\n             (module ME : S) is represented as\n             Pexp_constraint(Pexp_pack, Ptyp_package S) *)\n    | Pexp_open of override_flag * Longident.t loc * expression\n          (* let open M in E\n             let! open M in E\n          *)\n    | Pexp_extension of extension\n          (* [%id] *)\n    | Pexp_unreachable\n          (* . *)\n\n  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)\n      {\n       pc_lhs: pattern;\n       pc_guard: expression option;\n       pc_rhs: expression;\n      }\n\n  (* Value descriptions *)\n\n  and value_description (*IF_CURRENT = Parsetree.value_description *) =\n      {\n       pval_name: string loc;\n       pval_type: core_type;\n       pval_prim: string list;\n       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n       pval_loc: Location.t;\n      }\n\n  (*\n    val x: T                            (prim = [])\n    external x: T = \"s1\" ... \"sn\"       (prim = [\"s1\";...\"sn\"])\n  *)\n\n  (* Type declarations *)\n\n  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =\n      {\n       ptype_name: string loc;\n       ptype_params: (core_type * variance) list;\n             (* ('a1,...'an) t; None represents  _*)\n       ptype_cstrs: (core_type * core_type * Location.t) list;\n             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)\n       ptype_kind: type_kind;\n       ptype_private: private_flag;   (* = private ... *)\n       ptype_manifest: core_type option;  (* = T *)\n       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n       ptype_loc: Location.t;\n      }\n\n  (*\n    type t                     (abstract, no manifest)\n    type t = T0                (abstract, manifest=T0)\n    type t = C of T | ...      (variant,  no manifest)\n    type t = T0 = C of T | ... (variant,  manifest=T0)\n    type t = {l: T; ...}       (record,   no manifest)\n    type t = T0 = {l : T; ...} (record,   manifest=T0)\n    type t = ..                (open,     no manifest)\n  *)\n\n  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =\n    | Ptype_abstract\n    | Ptype_variant of constructor_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_record of label_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_open\n\n  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =\n      {\n       pld_name: string loc;\n       pld_mutable: mutable_flag;\n       pld_type: core_type;\n       pld_loc: Location.t;\n       pld_attributes: attributes; (* l [@id1] [@id2] : T *)\n      }\n\n  (*  { ...; l: T; ... }            (mutable=Immutable)\n      { ...; mutable l: T; ... }    (mutable=Mutable)\n\n      Note: T can be a Ptyp_poly.\n  *)\n\n  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =\n      {\n       pcd_name: string loc;\n       pcd_args: constructor_arguments;\n       pcd_res: core_type option;\n       pcd_loc: Location.t;\n       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =\n    | Pcstr_tuple of core_type list\n    | Pcstr_record of label_declaration list\n\n  (*\n    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])\n    | C: T0                  (res = Some T0, args = [])\n    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)\n    | C of {...}             (res = None,    args = Pcstr_record)\n    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)\n    | C of {...} as t        (res = None,    args = Pcstr_record)\n  *)\n\n  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =\n      {\n       ptyext_path: Longident.t loc;\n       ptyext_params: (core_type * variance) list;\n       ptyext_constructors: extension_constructor list;\n       ptyext_private: private_flag;\n       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n      }\n  (*\n    type t += ...\n  *)\n\n  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =\n      {\n       pext_name: string loc;\n       pext_kind : extension_constructor_kind;\n       pext_loc : Location.t;\n       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =\n      Pext_decl of constructor_arguments * core_type option\n        (*\n           | C of T1 * ... * Tn     ([T1; ...; Tn], None)\n           | C: T0                  ([], Some T0)\n           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)\n         *)\n    | Pext_rebind of Longident.t loc\n        (*\n           | C = D\n         *)\n\n  (** {2 Class language} *)\n\n  (* Type expressions for the class language *)\n\n  and class_type (*IF_CURRENT = Parsetree.class_type *) =\n      {\n       pcty_desc: class_type_desc;\n       pcty_loc: Location.t;\n       pcty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =\n    | Pcty_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcty_signature of class_signature\n          (* object ... end *)\n    | Pcty_arrow of arg_label * core_type * class_type\n          (* T -> CT       Simple\n             ~l:T -> CT    Labelled l\n             ?l:T -> CT    Optional l\n           *)\n    | Pcty_extension of extension\n          (* [%id] *)\n\n  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =\n      {\n       pcsig_self: core_type;\n       pcsig_fields: class_type_field list;\n      }\n  (* object('selfpat) ... end\n     object ... end             (self = Ptyp_any)\n   *)\n\n  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =\n      {\n       pctf_desc: class_type_field_desc;\n       pctf_loc: Location.t;\n       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =\n    | Pctf_inherit of class_type\n          (* inherit CT *)\n    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)\n          (* val x: T *)\n    | Pctf_method  of (string * private_flag * virtual_flag * core_type)\n          (* method x: T\n\n             Note: T can be a Ptyp_poly.\n           *)\n    | Pctf_constraint  of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pctf_attribute of attribute\n          (* [@@@id] *)\n    | Pctf_extension of extension\n          (* [%%id] *)\n\n  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =\n      {\n       pci_virt: virtual_flag;\n       pci_params: (core_type * variance) list;\n       pci_name: string loc;\n       pci_expr: 'a;\n       pci_loc: Location.t;\n       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n      }\n  (* class c = ...\n     class ['a1,...,'an] c = ...\n     class virtual c = ...\n\n     Also used for \"class type\" declaration.\n  *)\n\n  and class_description = class_type class_infos\n\n  and class_type_declaration = class_type class_infos\n\n  (* Value expressions for the class language *)\n\n  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =\n      {\n       pcl_desc: class_expr_desc;\n       pcl_loc: Location.t;\n       pcl_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =\n    | Pcl_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcl_structure of class_structure\n          (* object ... end *)\n    | Pcl_fun of arg_label * expression option * pattern * class_expr\n          (* fun P -> CE                          (Simple, None)\n             fun ~l:P -> CE                       (Labelled l, None)\n             fun ?l:P -> CE                       (Optional l, None)\n             fun ?l:(P = E0) -> CE                (Optional l, Some E0)\n           *)\n    | Pcl_apply of class_expr * (arg_label * expression) list\n          (* CE ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pcl_let of rec_flag * value_binding list * class_expr\n          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)\n           *)\n    | Pcl_constraint of class_expr * class_type\n          (* (CE : CT) *)\n    | Pcl_extension of extension\n          (* [%id] *)\n\n  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =\n      {\n       pcstr_self: pattern;\n       pcstr_fields: class_field list;\n      }\n  (* object(selfpat) ... end\n     object ... end           (self = Ppat_any)\n   *)\n\n  and class_field (*IF_CURRENT = Parsetree.class_field *) =\n      {\n       pcf_desc: class_field_desc;\n       pcf_loc: Location.t;\n       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =\n    | Pcf_inherit of override_flag * class_expr * string option\n          (* inherit CE\n             inherit CE as x\n             inherit! CE\n             inherit! CE as x\n           *)\n    | Pcf_val of (string loc * mutable_flag * class_field_kind)\n          (* val x = E\n             val virtual x: T\n           *)\n    | Pcf_method of (string loc * private_flag * class_field_kind)\n          (* method x = E            (E can be a Pexp_poly)\n             method virtual x: T     (T can be a Ptyp_poly)\n           *)\n    | Pcf_constraint of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pcf_initializer of expression\n          (* initializer E *)\n    | Pcf_attribute of attribute\n          (* [@@@id] *)\n    | Pcf_extension of extension\n          (* [%%id] *)\n\n  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =\n    | Cfk_virtual of core_type\n    | Cfk_concrete of override_flag * expression\n\n  and class_declaration = class_expr class_infos\n\n  (** {2 Module language} *)\n\n  (* Type expressions for the module language *)\n\n  and module_type (*IF_CURRENT = Parsetree.module_type *) =\n      {\n       pmty_desc: module_type_desc;\n       pmty_loc: Location.t;\n       pmty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =\n    | Pmty_ident of Longident.t loc\n          (* S *)\n    | Pmty_signature of signature\n          (* sig ... end *)\n    | Pmty_functor of string loc * module_type option * module_type\n          (* functor(X : MT1) -> MT2 *)\n    | Pmty_with of module_type * with_constraint list\n          (* MT with ... *)\n    | Pmty_typeof of module_expr\n          (* module type of ME *)\n    | Pmty_extension of extension\n          (* [%id] *)\n    | Pmty_alias of Longident.t loc\n          (* (module M) *)\n\n  and signature = signature_item list\n\n  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =\n      {\n       psig_desc: signature_item_desc;\n       psig_loc: Location.t;\n      }\n\n  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =\n    | Psig_value of value_description\n          (*\n            val x: T\n            external x: T = \"s1\" ... \"sn\"\n           *)\n    | Psig_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Psig_typext of type_extension\n          (* type t1 += ... *)\n    | Psig_exception of extension_constructor\n          (* exception C of T *)\n    | Psig_module of module_declaration\n          (* module X : MT *)\n    | Psig_recmodule of module_declaration list\n          (* module rec X1 : MT1 and ... and Xn : MTn *)\n    | Psig_modtype of module_type_declaration\n          (* module type S = MT\n             module type S *)\n    | Psig_open of open_description\n          (* open X *)\n    | Psig_include of include_description\n          (* include MT *)\n    | Psig_class of class_description list\n          (* class c1 : ... and ... and cn : ... *)\n    | Psig_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Psig_attribute of attribute\n          (* [@@@id] *)\n    | Psig_extension of extension * attributes\n          (* [%%id] *)\n\n  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =\n      {\n       pmd_name: string loc;\n       pmd_type: module_type;\n       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmd_loc: Location.t;\n      }\n  (* S : MT *)\n\n  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =\n      {\n       pmtd_name: string loc;\n       pmtd_type: module_type option;\n       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmtd_loc: Location.t;\n      }\n  (* S = MT\n     S       (abstract module type declaration, pmtd_type = None)\n  *)\n\n  and open_description (*IF_CURRENT = Parsetree.open_description *) =\n      {\n       popen_lid: Longident.t loc;\n       popen_override: override_flag;\n       popen_loc: Location.t;\n       popen_attributes: attributes;\n      }\n  (* open! X - popen_override = Override (silences the 'used identifier\n                                shadowing' warning)\n     open  X - popen_override = Fresh\n   *)\n\n  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =\n      {\n       pincl_mod: 'a;\n       pincl_loc: Location.t;\n       pincl_attributes: attributes;\n      }\n\n  and include_description = module_type include_infos\n  (* include MT *)\n\n  and include_declaration = module_expr include_infos\n  (* include ME *)\n\n  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =\n    | Pwith_type of Longident.t loc * type_declaration\n          (* with type X.t = ...\n\n             Note: the last component of the longident must match\n             the name of the type_declaration. *)\n    | Pwith_module of Longident.t loc * Longident.t loc\n          (* with module X.Y = Z *)\n    | Pwith_typesubst of type_declaration\n          (* with type t := ... *)\n    | Pwith_modsubst of string loc * Longident.t loc\n          (* with module X := Z *)\n\n  (* Value expressions for the module language *)\n\n  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =\n      {\n       pmod_desc: module_expr_desc;\n       pmod_loc: Location.t;\n       pmod_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =\n    | Pmod_ident of Longident.t loc\n          (* X *)\n    | Pmod_structure of structure\n          (* struct ... end *)\n    | Pmod_functor of string loc * module_type option * module_expr\n          (* functor(X : MT1) -> ME *)\n    | Pmod_apply of module_expr * module_expr\n          (* ME1(ME2) *)\n    | Pmod_constraint of module_expr * module_type\n          (* (ME : MT) *)\n    | Pmod_unpack of expression\n          (* (val E) *)\n    | Pmod_extension of extension\n          (* [%id] *)\n\n  and structure = structure_item list\n\n  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =\n      {\n       pstr_desc: structure_item_desc;\n       pstr_loc: Location.t;\n      }\n\n  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =\n    | Pstr_eval of expression * attributes\n          (* E *)\n    | Pstr_value of rec_flag * value_binding list\n          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)\n           *)\n    | Pstr_primitive of value_description\n          (*  val x: T\n              external x: T = \"s1\" ... \"sn\" *)\n    | Pstr_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Pstr_typext of type_extension\n          (* type t1 += ... *)\n    | Pstr_exception of extension_constructor\n          (* exception C of T\n             exception C = M.X *)\n    | Pstr_module of module_binding\n          (* module X = ME *)\n    | Pstr_recmodule of module_binding list\n          (* module rec X1 = ME1 and ... and Xn = MEn *)\n    | Pstr_modtype of module_type_declaration\n          (* module type S = MT *)\n    | Pstr_open of open_description\n          (* open X *)\n    | Pstr_class of class_declaration list\n          (* class c1 = ... and ... and cn = ... *)\n    | Pstr_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Pstr_include of include_declaration\n          (* include ME *)\n    | Pstr_attribute of attribute\n          (* [@@@id] *)\n    | Pstr_extension of extension * attributes\n          (* [%%id] *)\n\n  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =\n    {\n      pvb_pat: pattern;\n      pvb_expr: expression;\n      pvb_attributes: attributes;\n      pvb_loc: Location.t;\n    }\n\n  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =\n      {\n       pmb_name: string loc;\n       pmb_expr: module_expr;\n       pmb_attributes: attributes;\n       pmb_loc: Location.t;\n      }\n  (* X = ME *)\n\n  (** {2 Toplevel} *)\n\n  (* Toplevel phrases *)\n\n  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =\n    | Ptop_def of structure\n    | Ptop_dir of string * directive_argument\n       (* #use, #load ... *)\n\n  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =\n    | Pdir_none\n    | Pdir_string of string\n    | Pdir_int of string * char option\n    | Pdir_ident of Longident.t\n    | Pdir_bool of bool\nend\n\nmodule Docstrings : sig\n  (** {3 Docstrings} *)\n\n  (** Documentation comments *)\n  type docstring\n\n  (** Create a docstring *)\n  val docstring : string -> Location.t -> docstring\n\n  (** Get the text of a docstring *)\n  val docstring_body : docstring -> string\n\n  (** Get the location of a docstring *)\n  val docstring_loc : docstring -> Location.t\n\n  (** {3 Items}\n\n      The {!docs} type represents documentation attached to an item. *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  val empty_docs : docs\n\n  val docs_attr : docstring -> Parsetree.attribute\n\n  (** Convert item documentation to attributes and add them to an\n      attribute list *)\n  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Fields and constructors}\n\n      The {!info} type represents documentation attached to a field or\n      constructor. *)\n\n  type info = docstring option\n\n  val empty_info : info\n\n  val info_attr : docstring -> Parsetree.attribute\n\n  (** Convert field info to attributes and add them to an\n      attribute list *)\n  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Unattached comments}\n\n      The {!text} type represents documentation which is not attached to\n      anything. *)\n\n  type text = docstring list\n\n  val empty_text : text\n\n  val text_attr : docstring -> Parsetree.attribute\n\n  (** Convert text to attributes and add them to an attribute list *)\n  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes\n\nend = struct\n  open Location\n\n  (* Docstrings *)\n\n  type docstring =\n    { ds_body: string;\n      ds_loc: Location.t; }\n\n  (* Docstring constructors and destructors *)\n\n  let docstring body loc =\n    let ds =\n      { ds_body = body;\n        ds_loc = loc; }\n    in\n    ds\n\n  let docstring_body ds = ds.ds_body\n\n  let docstring_loc ds = ds.ds_loc\n\n  (* Docstrings attached to items *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  let empty_docs = { docs_pre = None; docs_post = None }\n\n  let doc_loc = {txt = \"ocaml.doc\"; loc = Location.none}\n\n  let docs_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (doc_loc, PStr [item])\n\n  let add_docs_attrs docs attrs =\n    let attrs =\n      match docs.docs_pre with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> docs_attr ds :: attrs\n    in\n    let attrs =\n      match docs.docs_post with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> attrs @ [docs_attr ds]\n    in\n    attrs\n\n  (* Docstrings attached to constructors or fields *)\n\n  type info = docstring option\n\n  let empty_info = None\n\n  let info_attr = docs_attr\n\n  let add_info_attrs info attrs =\n    match info with\n    | None | Some {ds_body=\"\"; _} -> attrs\n    | Some ds -> attrs @ [info_attr ds]\n\n  (* Docstrings not attached to a specific item *)\n\n  type text = docstring list\n\n  let empty_text = []\n\n  let text_loc = {txt = \"ocaml.text\"; loc = Location.none}\n\n  let text_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (text_loc, PStr [item])\n\n  let add_text_attrs dsl attrs =\n    let fdsl = List.filter (function {ds_body=\"\"; _} -> false| _ ->true) dsl in\n    (List.map text_attr fdsl) @ attrs\n\nend\n\nmodule Ast_helper : sig\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Docstrings\n  open Parsetree\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  (** {2 Default locations} *)\n\n  val default_loc: loc ref\n      (** Default value for all optional location arguments. *)\n\n  val with_default_loc: loc -> (unit -> 'a) -> 'a\n      (** Set the [default_loc] within the scope of the execution\n          of the provided function. *)\n\n  (** {2 Constants} *)\n\n  module Const : sig\n    val char : char -> constant\n    val string : ?quotation_delimiter:string -> string -> constant\n    val integer : ?suffix:char -> string -> constant\n    val int : ?suffix:char -> int -> constant\n    val int32 : ?suffix:char -> int32 -> constant\n    val int64 : ?suffix:char -> int64 -> constant\n    val nativeint : ?suffix:char -> nativeint -> constant\n    val float : ?suffix:char -> string -> constant\n  end\n\n  (** {2 Core language} *)\n\n  (** Type expressions *)\n  module Typ :\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type\n      val attr: core_type -> attribute -> core_type\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type\n      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type\n                 -> core_type\n      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val object_: ?loc:loc -> ?attrs:attrs ->\n                    (string * attributes * core_type) list -> closed_flag ->\n                    core_type\n      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type\n      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag\n                   -> label list option -> core_type\n      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type\n      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list\n                   -> core_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type\n\n      val force_poly: core_type -> core_type\n    end\n\n  (** Patterns *)\n  module Pat:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern\n      val attr:pattern -> attribute -> pattern\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern\n      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern\n      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern\n      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag\n                  -> pattern\n      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern\n      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern\n      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern\n      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern\n      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern\n    end\n\n  (** Expressions *)\n  module Exp:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression\n      val attr: expression -> attribute -> expression\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list\n                -> expression -> expression\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option\n                -> pattern -> expression -> expression\n      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression\n      val apply: ?loc:loc -> ?attrs:attrs -> expression\n                 -> (arg_label * expression) list -> expression\n      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list\n                  -> expression\n      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression\n      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option\n                     -> expression\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option\n                   -> expression\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list\n                  -> expression option -> expression\n      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n                    -> expression\n      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                      -> expression option -> expression\n      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                    -> expression\n      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                  -> expression\n      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression\n                -> direction_flag -> expression -> expression\n      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                  -> core_type -> expression\n      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type\n                       -> expression\n      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression\n      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list\n                    -> expression\n      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression\n                     -> expression\n      val letexception:\n        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression\n        -> expression\n      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                -> expression\n      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression\n      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression\n      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression\n                 -> expression\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression\n      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression\n\n      val case: pattern -> ?guard:expression -> expression -> case\n    end\n\n  (** Value declarations *)\n  module Val:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        ?prim:string list -> str -> core_type -> value_description\n    end\n\n  (** Type declarations *)\n  module Type:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?params:(core_type * variance) list ->\n        ?cstrs:(core_type * core_type * loc) list ->\n        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->\n        type_declaration\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        constructor_declaration\n      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?mut:mutable_flag -> str -> core_type -> label_declaration\n    end\n\n  (** Type extensions *)\n  module Te:\n    sig\n      val mk: ?attrs:attrs -> ?docs:docs ->\n        ?params:(core_type * variance) list -> ?priv:private_flag ->\n        lid -> extension_constructor list -> type_extension\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> extension_constructor_kind -> extension_constructor\n\n      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        extension_constructor\n      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> lid -> extension_constructor\n    end\n\n  (** {2 Module language} *)\n\n  (** Module type expressions *)\n  module Mty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type\n      val attr: module_type -> attribute -> module_type\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_type -> module_type\n      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->\n        with_constraint list -> module_type\n      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type\n    end\n\n  (** Module expressions *)\n  module Mod:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr\n      val attr: module_expr -> attribute -> module_expr\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_expr -> module_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->\n        module_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->\n        module_expr\n      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr\n    end\n\n  (** Signature items *)\n  module Sig:\n    sig\n      val mk: ?loc:loc -> signature_item_desc -> signature_item\n\n      val value: ?loc:loc -> value_description -> signature_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item\n      val type_extension: ?loc:loc -> type_extension -> signature_item\n      val exception_: ?loc:loc -> extension_constructor -> signature_item\n      val module_: ?loc:loc -> module_declaration -> signature_item\n      val rec_module: ?loc:loc -> module_declaration list -> signature_item\n      val modtype: ?loc:loc -> module_type_declaration -> signature_item\n      val open_: ?loc:loc -> open_description -> signature_item\n      val include_: ?loc:loc -> include_description -> signature_item\n      val class_: ?loc:loc -> class_description list -> signature_item\n      val class_type: ?loc:loc -> class_type_declaration list -> signature_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item\n      val attribute: ?loc:loc -> attribute -> signature_item\n      val text: text -> signature_item list\n    end\n\n  (** Structure items *)\n  module Str:\n    sig\n      val mk: ?loc:loc -> structure_item_desc -> structure_item\n\n      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item\n      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item\n      val primitive: ?loc:loc -> value_description -> structure_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item\n      val type_extension: ?loc:loc -> type_extension -> structure_item\n      val exception_: ?loc:loc -> extension_constructor -> structure_item\n      val module_: ?loc:loc -> module_binding -> structure_item\n      val rec_module: ?loc:loc -> module_binding list -> structure_item\n      val modtype: ?loc:loc -> module_type_declaration -> structure_item\n      val open_: ?loc:loc -> open_description -> structure_item\n      val class_: ?loc:loc -> class_declaration list -> structure_item\n      val class_type: ?loc:loc -> class_type_declaration list -> structure_item\n      val include_: ?loc:loc -> include_declaration -> structure_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item\n      val attribute: ?loc:loc -> attribute -> structure_item\n      val text: text -> structure_item list\n    end\n\n  (** Module declarations *)\n  module Md:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_type -> module_declaration\n    end\n\n  (** Module type declarations *)\n  module Mtd:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?typ:module_type -> str -> module_type_declaration\n    end\n\n  (** Module bindings *)\n  module Mb:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_expr -> module_binding\n    end\n\n  (** Opens *)\n  module Opn:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->\n        ?override:override_flag -> lid -> open_description\n    end\n\n  (** Includes *)\n  module Incl:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos\n    end\n\n  (** Value bindings *)\n  module Vb:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        pattern -> expression -> value_binding\n    end\n\n\n  (** {2 Class language} *)\n\n  (** Class type expressions *)\n  module Cty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type\n      val attr: class_type -> attribute -> class_type\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type\n      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->\n        class_type -> class_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type\n    end\n\n  (** Class type fields *)\n  module Ctf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        class_type_field_desc -> class_type_field\n      val attr: class_type_field -> attribute -> class_type_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field\n      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_type_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field\n      val attribute: ?loc:loc -> attribute -> class_type_field\n      val text: text -> class_type_field list\n    end\n\n  (** Class expressions *)\n  module Cl:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr\n      val attr: class_expr -> attribute -> class_expr\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->\n        pattern -> class_expr -> class_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->\n        (arg_label * expression) list -> class_expr\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->\n        class_expr -> class_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->\n        class_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr\n    end\n\n  (** Class fields *)\n  module Cf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->\n        class_field\n      val attr: class_field -> attribute -> class_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->\n        string option -> class_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        class_field_kind -> class_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        class_field_kind -> class_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_field\n      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field\n      val attribute: ?loc:loc -> attribute -> class_field\n      val text: text -> class_field list\n\n      val virtual_: core_type -> class_field_kind\n      val concrete: override_flag -> expression -> class_field_kind\n\n    end\n\n  (** Classes *)\n  module Ci:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?virt:virtual_flag -> ?params:(core_type * variance) list ->\n        str -> 'a -> 'a class_infos\n    end\n\n  (** Class signatures *)\n  module Csig:\n    sig\n      val mk: core_type -> class_type_field list -> class_signature\n    end\n\n  (** Class structures *)\n  module Cstr:\n    sig\n      val mk: pattern -> class_field list -> class_structure\n    end\n\nend = struct\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Parsetree\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  let default_loc = ref Location.none\n\n  let with_default_loc l f =\n    let old = !default_loc in\n    default_loc := l;\n    try let r = f () in default_loc := old; r\n    with exn -> default_loc := old; raise exn\n\n  module Const = struct\n    let integer ?suffix i = Pconst_integer (i, suffix)\n    let int ?suffix i = integer ?suffix (string_of_int i)\n    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)\n    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)\n    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)\n    let float ?suffix f = Pconst_float (f, suffix)\n    let char c = Pconst_char c\n    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)\n  end\n\n  module Typ = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}\n    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))\n    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))\n    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))\n    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))\n    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)\n\n    let force_poly t =\n      match t.ptyp_desc with\n      | Ptyp_poly _ -> t\n      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)\n  end\n\n  module Pat = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}\n    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)\n    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)\n    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))\n    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)\n    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)\n    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))\n    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)\n  end\n\n  module Exp = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}\n    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))\n    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))\n    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))\n    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))\n    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))\n    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)\n    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))\n    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))\n    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))\n    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))\n    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))\n    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))\n    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)\n    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))\n    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)\n    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))\n    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))\n    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))\n    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)\n    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))\n    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)\n    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable\n\n    let case lhs ?guard rhs =\n      {\n       pc_lhs = lhs;\n       pc_guard = guard;\n       pc_rhs = rhs;\n      }\n  end\n\n  module Mty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}\n    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)\n    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)\n    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))\n    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))\n    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)\n  end\n\n  module Mod = struct\n  let mk ?(loc = !default_loc) ?(attrs = []) d =\n    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}\n    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}\n\n    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)\n    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)\n    let functor_ ?loc ?attrs arg arg_ty body =\n      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))\n    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))\n    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))\n    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)\n  end\n\n  module Sig = struct\n    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}\n\n    let value ?loc a = mk ?loc (Psig_value a)\n    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Psig_typext a)\n    let exception_ ?loc a = mk ?loc (Psig_exception a)\n    let module_ ?loc a = mk ?loc (Psig_module a)\n    let rec_module ?loc a = mk ?loc (Psig_recmodule a)\n    let modtype ?loc a = mk ?loc (Psig_modtype a)\n    let open_ ?loc a = mk ?loc (Psig_open a)\n    let include_ ?loc a = mk ?loc (Psig_include a)\n    let class_ ?loc a = mk ?loc (Psig_class a)\n    let class_type ?loc a = mk ?loc (Psig_class_type a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Psig_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Str = struct\n    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}\n\n    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))\n    let value ?loc a b = mk ?loc (Pstr_value (a, b))\n    let primitive ?loc a = mk ?loc (Pstr_primitive a)\n    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Pstr_typext a)\n    let exception_ ?loc a = mk ?loc (Pstr_exception a)\n    let module_ ?loc a = mk ?loc (Pstr_module a)\n    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)\n    let modtype ?loc a = mk ?loc (Pstr_modtype a)\n    let open_ ?loc a = mk ?loc (Pstr_open a)\n    let class_ ?loc a = mk ?loc (Pstr_class a)\n    let class_type ?loc a = mk ?loc (Pstr_class_type a)\n    let include_ ?loc a = mk ?loc (Pstr_include a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Pstr_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Cl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcl_desc = d;\n       pcl_loc = loc;\n       pcl_attributes = attrs;\n      }\n    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))\n    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)\n  end\n\n  module Cty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcty_desc = d;\n       pcty_loc = loc;\n       pcty_attributes = attrs;\n      }\n    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)\n  end\n\n  module Ctf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n             ?(docs = empty_docs) d =\n      {\n       pctf_desc = d;\n       pctf_loc = loc;\n       pctf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)\n    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))\n    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)\n    let attribute ?loc a = mk ?loc (Pctf_attribute a)\n    let text txt =\n     let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n       List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}\n\n  end\n\n  module Cf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) d =\n      {\n       pcf_desc = d;\n       pcf_loc = loc;\n       pcf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))\n    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))\n    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))\n    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)\n    let attribute ?loc a = mk ?loc (Pcf_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let virtual_ ct = Cfk_virtual ct\n    let concrete o e = Cfk_concrete (o, e)\n\n    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}\n\n  end\n\n  module Val = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(prim = []) name typ =\n      {\n       pval_name = name;\n       pval_type = typ;\n       pval_attributes = add_docs_attrs docs attrs;\n       pval_loc = loc;\n       pval_prim = prim;\n      }\n  end\n\n  module Md = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name typ =\n      {\n       pmd_name = name;\n       pmd_type = typ;\n       pmd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmd_loc = loc;\n      }\n  end\n\n  module Mtd = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) ?typ name =\n      {\n       pmtd_name = name;\n       pmtd_type = typ;\n       pmtd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmtd_loc = loc;\n      }\n  end\n\n  module Mb = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name expr =\n      {\n       pmb_name = name;\n       pmb_expr = expr;\n       pmb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmb_loc = loc;\n      }\n  end\n\n  module Opn = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(override = Fresh) lid =\n      {\n       popen_lid = lid;\n       popen_override = override;\n       popen_loc = loc;\n       popen_attributes = add_docs_attrs docs attrs;\n      }\n  end\n\n  module Incl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =\n      {\n       pincl_mod = mexpr;\n       pincl_loc = loc;\n       pincl_attributes = add_docs_attrs docs attrs;\n      }\n\n  end\n\n  module Vb = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(text = []) pat expr =\n      {\n       pvb_pat = pat;\n       pvb_expr = expr;\n       pvb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pvb_loc = loc;\n      }\n  end\n\n  module Ci = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n          ?(virt = Concrete) ?(params = []) name expr =\n      {\n       pci_virt = virt;\n       pci_params = params;\n       pci_name = name;\n       pci_expr = expr;\n       pci_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pci_loc = loc;\n      }\n  end\n\n  module Type = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n        ?(params = [])\n        ?(cstrs = [])\n        ?(kind = Ptype_abstract)\n        ?(priv = Public)\n        ?manifest\n        name =\n      {\n       ptype_name = name;\n       ptype_params = params;\n       ptype_cstrs = cstrs;\n       ptype_kind = kind;\n       ptype_private = priv;\n       ptype_manifest = manifest;\n       ptype_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       ptype_loc = loc;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(args = Pcstr_tuple []) ?res name =\n      {\n       pcd_name = name;\n       pcd_args = args;\n       pcd_res = res;\n       pcd_loc = loc;\n       pcd_attributes = add_info_attrs info attrs;\n      }\n\n    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(mut = Immutable) name typ =\n      {\n       pld_name = name;\n       pld_mutable = mut;\n       pld_type = typ;\n       pld_loc = loc;\n       pld_attributes = add_info_attrs info attrs;\n      }\n\n  end\n\n  (** Type extensions *)\n  module Te = struct\n    let mk ?(attrs = []) ?(docs = empty_docs)\n          ?(params = []) ?(priv = Public) path constructors =\n      {\n       ptyext_path = path;\n       ptyext_params = params;\n       ptyext_constructors = constructors;\n       ptyext_private = priv;\n       ptyext_attributes = add_docs_attrs docs attrs;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name kind =\n      {\n       pext_name = name;\n       pext_kind = kind;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =\n      {\n       pext_name = name;\n       pext_kind = Pext_decl(args, res);\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let rebind ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name lid =\n      {\n       pext_name = name;\n       pext_kind = Pext_rebind lid;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n  end\n\n  module Csig = struct\n    let mk self fields =\n      {\n       pcsig_self = self;\n       pcsig_fields = fields;\n      }\n  end\n\n  module Cstr = struct\n    let mk self fields =\n      {\n       pcstr_self = self;\n       pcstr_fields = fields;\n      }\n  end\n\nend\n\nmodule Ast_mapper : sig\n  (** The interface of a -ppx rewriter\n\n    A -ppx rewriter is a program that accepts a serialized abstract syntax\n    tree and outputs another, possibly modified, abstract syntax tree.\n    This module encapsulates the interface between the compiler and\n    the -ppx rewriters, handling such details as the serialization format,\n    forwarding of command-line flags, and storing state.\n\n    {!mapper} allows to implement AST rewriting using open recursion.\n    A typical mapper would be based on {!default_mapper}, a deep\n    identity mapper, and will fall back on it for handling the syntax it\n    does not modify. For example:\n\n    {[\n  open Asttypes\n  open Parsetree\n  open Ast_mapper\n\n  let test_mapper argv =\n    { default_mapper with\n      expr = fun mapper expr ->\n        match expr with\n        | { pexp_desc = Pexp_extension ({ txt = \"test\" }, PStr [])} ->\n          Ast_helper.Exp.constant (Const_int 42)\n        | other -> default_mapper.expr mapper other; }\n\n  let () =\n    register \"ppx_test\" test_mapper]}\n\n    This -ppx rewriter, which replaces [[%test]] in expressions with\n    the constant [42], can be compiled using\n    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].\n\n    *)\n\n  open Parsetree\n\n  (** {2 A generic Parsetree mapper} *)\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n  (** A mapper record implements one \"method\" per syntactic category,\n      using an open recursion style: each method takes as its first\n      argument the mapper to be applied to children in the syntax\n      tree. *)\n\n  val default_mapper: mapper\n  (** A default mapper, which implements a \"deep identity\" mapping. *)\n\n  (** {2 Convenience functions to write mappers} *)\n\n  val map_opt: ('a -> 'b) -> 'a option -> 'b option\n\n  val extension_of_error: Location.error -> extension\n  (** Encode an error into an 'ocaml.error' extension node which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the error. *)\n\n  val attribute_of_warning: Location.t -> string -> attribute\n  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the warning. *)\n\nend = struct\n  (* A generic Parsetree mapping class *)\n\n  (*\n  [@@@ocaml.warning \"+9\"]\n    (* Ensure that record patterns don't miss any field. *)\n  *)\n\n\n  open Parsetree\n  open Ast_helper\n  open Location\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n\n  let map_fst f (x, y) = (f x, y)\n  let map_snd f (x, y) = (x, f y)\n  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)\n  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)\n  let map_opt f = function None -> None | Some x -> Some (f x)\n\n  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}\n\n  module T = struct\n    (* Type expressions for the core language *)\n\n    let row_field sub = function\n      | Rtag (l, attrs, b, tl) ->\n          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)\n      | Rinherit t -> Rinherit (sub.typ sub t)\n\n    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =\n      let open Typ in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ptyp_any -> any ~loc ~attrs ()\n      | Ptyp_var s -> var ~loc ~attrs s\n      | Ptyp_arrow (lab, t1, t2) ->\n          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)\n      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)\n      | Ptyp_constr (lid, tl) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_object (l, o) ->\n          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in\n          object_ ~loc ~attrs (List.map f l) o\n      | Ptyp_class (lid, tl) ->\n          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s\n      | Ptyp_variant (rl, b, ll) ->\n          variant ~loc ~attrs (List.map (row_field sub) rl) b ll\n      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)\n      | Ptyp_package (lid, l) ->\n          package ~loc ~attrs (map_loc sub lid)\n            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)\n      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_type_declaration sub\n        {ptype_name; ptype_params; ptype_cstrs;\n         ptype_kind;\n         ptype_private;\n         ptype_manifest;\n         ptype_attributes;\n         ptype_loc} =\n      Type.mk (map_loc sub ptype_name)\n        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)\n        ~priv:ptype_private\n        ~cstrs:(List.map\n                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))\n                  ptype_cstrs)\n        ~kind:(sub.type_kind sub ptype_kind)\n        ?manifest:(map_opt (sub.typ sub) ptype_manifest)\n        ~loc:(sub.location sub ptype_loc)\n        ~attrs:(sub.attributes sub ptype_attributes)\n\n    let map_type_kind sub = function\n      | Ptype_abstract -> Ptype_abstract\n      | Ptype_variant l ->\n          Ptype_variant (List.map (sub.constructor_declaration sub) l)\n      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)\n      | Ptype_open -> Ptype_open\n\n    let map_constructor_arguments sub = function\n      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)\n      | Pcstr_record l ->\n          Pcstr_record (List.map (sub.label_declaration sub) l)\n\n    let map_type_extension sub\n        {ptyext_path; ptyext_params;\n         ptyext_constructors;\n         ptyext_private;\n         ptyext_attributes} =\n      Te.mk\n        (map_loc sub ptyext_path)\n        (List.map (sub.extension_constructor sub) ptyext_constructors)\n        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)\n        ~priv:ptyext_private\n        ~attrs:(sub.attributes sub ptyext_attributes)\n\n    let map_extension_constructor_kind sub = function\n        Pext_decl(ctl, cto) ->\n          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)\n      | Pext_rebind li ->\n          Pext_rebind (map_loc sub li)\n\n    let map_extension_constructor sub\n        {pext_name;\n         pext_kind;\n         pext_loc;\n         pext_attributes} =\n      Te.constructor\n        (map_loc sub pext_name)\n        (map_extension_constructor_kind sub pext_kind)\n        ~loc:(sub.location sub pext_loc)\n        ~attrs:(sub.attributes sub pext_attributes)\n\n  end\n\n  module CT = struct\n    (* Type expressions for the class language *)\n\n    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =\n      let open Cty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcty_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)\n      | Pcty_arrow (lab, t, ct) ->\n          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)\n      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}\n      =\n      let open Ctf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)\n      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)\n      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)\n      | Pctf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_signature sub {pcsig_self; pcsig_fields} =\n      Csig.mk\n        (sub.typ sub pcsig_self)\n        (List.map (sub.class_type_field sub) pcsig_fields)\n  end\n\n  module MT = struct\n    (* Type expressions for the module language *)\n\n    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =\n      let open Mty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)\n      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)\n      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)\n      | Pmty_functor (s, mt1, mt2) ->\n          functor_ ~loc ~attrs (map_loc sub s)\n            (Misc.may_map (sub.module_type sub) mt1)\n            (sub.module_type sub mt2)\n      | Pmty_with (mt, l) ->\n          with_ ~loc ~attrs (sub.module_type sub mt)\n            (List.map (sub.with_constraint sub) l)\n      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)\n      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_with_constraint sub = function\n      | Pwith_type (lid, d) ->\n          Pwith_type (map_loc sub lid, sub.type_declaration sub d)\n      | Pwith_module (lid, lid2) ->\n          Pwith_module (map_loc sub lid, map_loc sub lid2)\n      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)\n      | Pwith_modsubst (s, lid) ->\n          Pwith_modsubst (map_loc sub s, map_loc sub lid)\n\n    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =\n      let open Sig in\n      let loc = sub.location sub loc in\n      match desc with\n      | Psig_value vd -> value ~loc (sub.value_description sub vd)\n      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)\n      | Psig_recmodule l ->\n          rec_module ~loc (List.map (sub.module_declaration sub) l)\n      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Psig_open x -> open_ ~loc (sub.open_description sub x)\n      | Psig_include x -> include_ ~loc (sub.include_description sub x)\n      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)\n      | Psig_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Psig_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n\n  module M = struct\n    (* Value expressions for the module language *)\n\n    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =\n      let open Mod in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)\n      | Pmod_functor (arg, arg_ty, body) ->\n          functor_ ~loc ~attrs (map_loc sub arg)\n            (Misc.may_map (sub.module_type sub) arg_ty)\n            (sub.module_expr sub body)\n      | Pmod_apply (m1, m2) ->\n          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)\n      | Pmod_constraint (m, mty) ->\n          constraint_ ~loc ~attrs (sub.module_expr sub m)\n                      (sub.module_type sub mty)\n      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)\n      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =\n      let open Str in\n      let loc = sub.location sub loc in\n      match desc with\n      | Pstr_eval (x, attrs) ->\n          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)\n      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)\n      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)\n      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)\n      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)\n      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Pstr_open x -> open_ ~loc (sub.open_description sub x)\n      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)\n      | Pstr_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)\n      | Pstr_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n  module E = struct\n    (* Value expressions for the core language *)\n\n    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =\n      let open Exp in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pexp_constant x -> constant ~loc ~attrs x\n      | Pexp_let (r, vbs, e) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.expr sub e)\n      | Pexp_fun (lab, def, p, e) ->\n          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)\n            (sub.expr sub e)\n      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)\n      | Pexp_apply (e, l) ->\n          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)\n      | Pexp_match (e, pel) ->\n          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_construct (lid, arg) ->\n          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)\n      | Pexp_variant (lab, eo) ->\n          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)\n      | Pexp_record (l, eo) ->\n          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)\n            (map_opt (sub.expr sub) eo)\n      | Pexp_field (e, lid) ->\n          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)\n      | Pexp_setfield (e1, lid, e2) ->\n          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)\n            (sub.expr sub e2)\n      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_ifthenelse (e1, e2, e3) ->\n          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n            (map_opt (sub.expr sub) e3)\n      | Pexp_sequence (e1, e2) ->\n          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_while (e1, e2) ->\n          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_for (p, e1, e2, d, e3) ->\n          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d\n            (sub.expr sub e3)\n      | Pexp_coerce (e, t1, t2) ->\n          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)\n            (sub.typ sub t2)\n      | Pexp_constraint (e, t) ->\n          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)\n      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s\n      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)\n      | Pexp_setinstvar (s, e) ->\n          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_override sel ->\n          override ~loc ~attrs\n            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)\n      | Pexp_letmodule (s, me, e) ->\n          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)\n            (sub.expr sub e)\n      | Pexp_letexception (cd, e) ->\n          letexception ~loc ~attrs\n            (sub.extension_constructor sub cd)\n            (sub.expr sub e)\n      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_poly (e, t) ->\n          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)\n      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)\n      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)\n      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)\n      | Pexp_open (ovf, lid, e) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)\n      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pexp_unreachable -> unreachable ~loc ~attrs ()\n  end\n\n  module P = struct\n    (* Patterns *)\n\n    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =\n      let open Pat in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ppat_any -> any ~loc ~attrs ()\n      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)\n      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)\n      | Ppat_constant c -> constant ~loc ~attrs c\n      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2\n      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_construct (l, p) ->\n          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)\n      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)\n      | Ppat_record (lpl, cf) ->\n          record ~loc ~attrs\n                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf\n      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)\n      | Ppat_constraint (p, t) ->\n          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)\n      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)\n      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)\n      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)\n      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module CE = struct\n    (* Value expressions for the class language *)\n\n    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =\n      let open Cl in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcl_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcl_structure s ->\n          structure ~loc ~attrs (sub.class_structure sub s)\n      | Pcl_fun (lab, e, p, ce) ->\n          fun_ ~loc ~attrs lab\n            (map_opt (sub.expr sub) e)\n            (sub.pat sub p)\n            (sub.class_expr sub ce)\n      | Pcl_apply (ce, l) ->\n          apply ~loc ~attrs (sub.class_expr sub ce)\n            (List.map (map_snd (sub.expr sub)) l)\n      | Pcl_let (r, vbs, ce) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.class_expr sub ce)\n      | Pcl_constraint (ce, ct) ->\n          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)\n      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_kind sub = function\n      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)\n      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)\n\n    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =\n      let open Cf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s\n      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)\n      | Pcf_method (s, p, k) ->\n          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)\n      | Pcf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)\n      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure sub {pcstr_self; pcstr_fields} =\n      {\n        pcstr_self = sub.pat sub pcstr_self;\n        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;\n      }\n\n    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;\n                           pci_loc; pci_attributes} =\n      Ci.mk\n       ~virt:pci_virt\n       ~params:(List.map (map_fst (sub.typ sub)) pl)\n        (map_loc sub pci_name)\n        (f pci_expr)\n        ~loc:(sub.location sub pci_loc)\n        ~attrs:(sub.attributes sub pci_attributes)\n  end\n\n  (* Now, a generic AST mapper, to be extended to cover all kinds and\n     cases of the OCaml grammar.  The default behavior of the mapper is\n     the identity. *)\n\n  let default_mapper =\n    {\n      structure = (fun this l -> List.map (this.structure_item this) l);\n      structure_item = M.map_structure_item;\n      module_expr = M.map;\n      signature = (fun this l -> List.map (this.signature_item this) l);\n      signature_item = MT.map_signature_item;\n      module_type = MT.map;\n      with_constraint = MT.map_with_constraint;\n      class_declaration =\n        (fun this -> CE.class_infos this (this.class_expr this));\n      class_expr = CE.map;\n      class_field = CE.map_field;\n      class_structure = CE.map_structure;\n      class_type = CT.map;\n      class_type_field = CT.map_field;\n      class_signature = CT.map_signature;\n      class_type_declaration =\n        (fun this -> CE.class_infos this (this.class_type this));\n      class_description =\n        (fun this -> CE.class_infos this (this.class_type this));\n      type_declaration = T.map_type_declaration;\n      type_kind = T.map_type_kind;\n      typ = T.map;\n      type_extension = T.map_type_extension;\n      extension_constructor = T.map_extension_constructor;\n      value_description =\n        (fun this {pval_name; pval_type; pval_prim; pval_loc;\n                   pval_attributes} ->\n          Val.mk\n            (map_loc this pval_name)\n            (this.typ this pval_type)\n            ~attrs:(this.attributes this pval_attributes)\n            ~loc:(this.location this pval_loc)\n            ~prim:pval_prim\n        );\n\n      pat = P.map;\n      expr = E.map;\n\n      module_declaration =\n        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->\n           Md.mk\n             (map_loc this pmd_name)\n             (this.module_type this pmd_type)\n             ~attrs:(this.attributes this pmd_attributes)\n             ~loc:(this.location this pmd_loc)\n        );\n\n      module_type_declaration =\n        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->\n           Mtd.mk\n             (map_loc this pmtd_name)\n             ?typ:(map_opt (this.module_type this) pmtd_type)\n             ~attrs:(this.attributes this pmtd_attributes)\n             ~loc:(this.location this pmtd_loc)\n        );\n\n      module_binding =\n        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->\n           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)\n             ~attrs:(this.attributes this pmb_attributes)\n             ~loc:(this.location this pmb_loc)\n        );\n\n\n      open_description =\n        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->\n           Opn.mk (map_loc this popen_lid)\n             ~override:popen_override\n             ~loc:(this.location this popen_loc)\n             ~attrs:(this.attributes this popen_attributes)\n        );\n\n\n      include_description =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_type this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n      include_declaration =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_expr this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n\n      value_binding =\n        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->\n           Vb.mk\n             (this.pat this pvb_pat)\n             (this.expr this pvb_expr)\n             ~loc:(this.location this pvb_loc)\n             ~attrs:(this.attributes this pvb_attributes)\n        );\n\n\n      constructor_declaration =\n        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->\n          Type.constructor\n            (map_loc this pcd_name)\n            ~args:(T.map_constructor_arguments this pcd_args)\n            ?res:(map_opt (this.typ this) pcd_res)\n            ~loc:(this.location this pcd_loc)\n            ~attrs:(this.attributes this pcd_attributes)\n        );\n\n      label_declaration =\n        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->\n           Type.field\n             (map_loc this pld_name)\n             (this.typ this pld_type)\n             ~mut:pld_mutable\n             ~loc:(this.location this pld_loc)\n             ~attrs:(this.attributes this pld_attributes)\n        );\n\n      cases = (fun this l -> List.map (this.case this) l);\n      case =\n        (fun this {pc_lhs; pc_guard; pc_rhs} ->\n           {\n             pc_lhs = this.pat this pc_lhs;\n             pc_guard = map_opt (this.expr this) pc_guard;\n             pc_rhs = this.expr this pc_rhs;\n           }\n        );\n\n\n\n      location = (fun _this l -> l);\n\n      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attributes = (fun this l -> List.map (this.attribute this) l);\n      payload =\n        (fun this -> function\n           | PStr x -> PStr (this.structure this x)\n           | PSig x -> PSig (this.signature this x)\n           | PTyp x -> PTyp (this.typ this x)\n           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)\n        );\n    }\n\n  let rec extension_of_error {loc; msg; if_highlight; sub} =\n    { loc; txt = \"ocaml.error\" },\n    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));\n           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @\n          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))\n\n  let attribute_of_warning loc s =\n    { loc; txt = \"ocaml.ppwarning\" },\n    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])\n\nend\n\nmodule Outcometree = struct\n  (* Module [Outcometree]: results displayed by the toplevel *)\n\n  (* These types represent messages that the toplevel displays as normal\n     results or errors. The real displaying is customisable using the hooks:\n        [Toploop.print_out_value]\n        [Toploop.print_out_type]\n        [Toploop.print_out_sig_item]\n        [Toploop.print_out_phrase] *)\n\n  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =\n    | Oide_apply of out_ident * out_ident\n    | Oide_dot of out_ident * string\n    | Oide_ident of string\n\n  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =\n    { oattr_name: string }\n\n  type out_value (*IF_CURRENT = Outcometree.out_value *) =\n    | Oval_array of out_value list\n    | Oval_char of char\n    | Oval_constr of out_ident * out_value list\n    | Oval_ellipsis\n    | Oval_float of float\n    | Oval_int of int\n    | Oval_int32 of int32\n    | Oval_int64 of int64\n    | Oval_nativeint of nativeint\n    | Oval_list of out_value list\n    | Oval_printer of (Format.formatter -> unit)\n    | Oval_record of (out_ident * out_value) list\n    | Oval_string of string\n    | Oval_stuff of string\n    | Oval_tuple of out_value list\n    | Oval_variant of string * out_value option\n\n  type out_type (*IF_CURRENT = Outcometree.out_type *) =\n    | Otyp_abstract\n    | Otyp_open\n    | Otyp_alias of out_type * string\n    | Otyp_arrow of string * out_type * out_type\n    | Otyp_class of bool * out_ident * out_type list\n    | Otyp_constr of out_ident * out_type list\n    | Otyp_manifest of out_type * out_type\n    | Otyp_object of (string * out_type) list * bool option\n    | Otyp_record of (string * bool * out_type) list\n    | Otyp_stuff of string\n    | Otyp_sum of (string * out_type list * out_type option) list\n    | Otyp_tuple of out_type list\n    | Otyp_var of bool * string\n    | Otyp_variant of\n        bool * out_variant * bool * (string list) option\n    | Otyp_poly of string list * out_type\n    | Otyp_module of string * string list * out_type list\n    | Otyp_attribute of out_type * out_attribute\n\n  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =\n    | Ovar_fields of (string * bool * out_type list) list\n    | Ovar_name of out_ident * out_type list\n\n  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =\n    | Octy_constr of out_ident * out_type list\n    | Octy_arrow of string * out_type * out_class_type\n    | Octy_signature of out_type option * out_class_sig_item list\n  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =\n    | Ocsg_constraint of out_type * out_type\n    | Ocsg_method of string * bool * bool * out_type\n    | Ocsg_value of string * bool * bool * out_type\n\n  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =\n    | Omty_abstract\n    | Omty_functor of string * out_module_type option * out_module_type\n    | Omty_ident of out_ident\n    | Omty_signature of out_sig_item list\n    | Omty_alias of out_ident\n  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =\n    | Osig_class of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_class_type of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_typext of out_extension_constructor * out_ext_status\n    | Osig_modtype of string * out_module_type\n    | Osig_module of string * out_module_type * out_rec_status\n    | Osig_type of out_type_decl * out_rec_status\n    | Osig_value of out_val_decl\n    | Osig_ellipsis\n  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =\n    { otype_name: string;\n      otype_params: (string * (bool * bool)) list;\n      otype_type: out_type;\n      otype_private: Asttypes.private_flag;\n      otype_immediate: bool;\n      otype_unboxed: bool;\n      otype_cstrs: (out_type * out_type) list }\n  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =\n    { oext_name: string;\n      oext_type_name: string;\n      oext_type_params: string list;\n      oext_args: out_type list;\n      oext_ret_type: out_type option;\n      oext_private: Asttypes.private_flag }\n  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =\n    { otyext_name: string;\n      otyext_params: string list;\n      otyext_constructors: (string * out_type list * out_type option) list;\n      otyext_private: Asttypes.private_flag }\n  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =\n    { oval_name: string;\n      oval_type: out_type;\n      oval_prims: string list;\n      oval_attributes: out_attribute list }\n  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =\n    | Orec_not\n    | Orec_first\n    | Orec_next\n  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =\n    | Oext_first\n    | Oext_next\n    | Oext_exception\n\n  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =\n    | Ophr_eval of out_value * out_type\n    | Ophr_signature of (out_sig_item * out_value option) list\n    | Ophr_exception of (exn * out_value)\n\nend\n\nmodule Config = struct\n  let ast_impl_magic_number = \"Caml1999M020\"\n  let ast_intf_magic_number = \"Caml1999N018\"\nend\n\nlet map_signature mapper = mapper.Ast_mapper.signature mapper\nlet map_structure mapper = mapper.Ast_mapper.structure mapper\n\nlet shallow_identity =\n  let id _ x = x in\n  {\n    Ast_mapper.\n    structure               = id;\n    structure_item          = id;\n    module_expr             = id;\n    signature               = id;\n    signature_item          = id;\n    module_type             = id;\n    with_constraint         = id;\n    class_declaration       = id;\n    class_expr              = id;\n    class_field             = id;\n    class_structure         = id;\n    class_type              = id;\n    class_type_field        = id;\n    class_signature         = id;\n    class_type_declaration  = id;\n    class_description       = id;\n    type_declaration        = id;\n    type_kind               = id;\n    typ                     = id;\n    type_extension          = id;\n    extension_constructor   = id;\n    value_description       = id;\n    pat                     = id;\n    expr                    = id;\n    module_declaration      = id;\n    module_type_declaration = id;\n    module_binding          = id;\n    open_description        = id;\n    include_description     = id;\n    include_declaration     = id;\n    value_binding           = id;\n    constructor_declaration = id;\n    label_declaration       = id;\n    cases                   = id;\n    case                    = id;\n    location                = id;\n    extension               = id;\n    attribute               = id;\n    attributes              = id;\n    payload                 = id;\n  }\n\nlet failing_mapper =\n  let fail _ _ =\n    invalid_arg \"failing_mapper: this mapper function should never get called\"\n  in\n  {\n    Ast_mapper.\n    structure               = fail;\n    structure_item          = fail;\n    module_expr             = fail;\n    signature               = fail;\n    signature_item          = fail;\n    module_type             = fail;\n    with_constraint         = fail;\n    class_declaration       = fail;\n    class_expr              = fail;\n    class_field             = fail;\n    class_structure         = fail;\n    class_type              = fail;\n    class_type_field        = fail;\n    class_signature         = fail;\n    class_type_declaration  = fail;\n    class_description       = fail;\n    type_declaration        = fail;\n    type_kind               = fail;\n    typ                     = fail;\n    type_extension          = fail;\n    extension_constructor   = fail;\n    value_description       = fail;\n    pat                     = fail;\n    expr                    = fail;\n    module_declaration      = fail;\n    module_type_declaration = fail;\n    module_binding          = fail;\n    open_description        = fail;\n    include_description     = fail;\n    include_declaration     = fail;\n    value_binding           = fail;\n    constructor_declaration = fail;\n    label_declaration       = fail;\n    cases                   = fail;\n    case                    = fail;\n    location                = fail;\n    extension               = fail;\n    attribute               = fail;\n    attributes              = fail;\n    payload                 = fail;\n  }\n\nlet make_top_mapper ~signature ~structure =\n  {failing_mapper with Ast_mapper.\n                    signature = (fun _ x -> signature x);\n                    structure = (fun _ x -> structure x) }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*            Jérémie Dimino and Leo White, Jane Street Europe            *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)\n(*                         Alain Frisch, LexiFi                           *)\n(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Location = Location\nmodule Longident = Longident\n\nmodule Asttypes = struct\n  (** Auxiliary AST types used by parsetree and typedtree. *)\n\n  type constant (*IF_CURRENT = Asttypes.constant *) =\n      Const_int of int\n    | Const_char of char\n    | Const_string of string * string option\n    | Const_float of string\n    | Const_int32 of int32\n    | Const_int64 of int64\n    | Const_nativeint of nativeint\n\n  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive\n\n  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto\n\n  (* Order matters, used in polymorphic comparison *)\n  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public\n\n  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable\n\n  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete\n\n  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh\n\n  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open\n\n  type label = string\n\n  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =\n      Nolabel\n    | Labelled of string (*  label:T -> ... *)\n    | Optional of string (* ?label:T -> ... *)\n\n  type 'a loc = 'a Location.loc = {\n    txt : 'a;\n    loc : Location.t;\n  }\n\n\n  type variance (*IF_CURRENT = Asttypes.variance *) =\n    | Covariant\n    | Contravariant\n    | Invariant\nend\n\nmodule Parsetree = struct\n  (** Abstract syntax tree produced by parsing *)\n\n  open Asttypes\n\n  type constant (*IF_CURRENT = Parsetree.constant *) =\n      Pconst_integer of string * char option\n    (* 3 3l 3L 3n\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker\n    *)\n    | Pconst_char of char\n    (* 'c' *)\n    | Pconst_string of string * string option\n    (* \"constant\"\n       {delim|other constant|delim}\n    *)\n    | Pconst_float of string * char option\n    (* 3.4 2e5 1.4e-4\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes are rejected by the typechecker.\n    *)\n\n  (** {2 Extension points} *)\n\n  type attribute = string loc * payload\n         (* [@id ARG]\n            [@@id ARG]\n\n            Metadata containers passed around within the AST.\n            The compiler ignores unknown attributes.\n         *)\n\n  and extension = string loc * payload\n        (* [%id ARG]\n           [%%id ARG]\n\n           Sub-language placeholder -- rejected by the typechecker.\n        *)\n\n  and attributes = attribute list\n\n  and payload (*IF_CURRENT = Parsetree.payload *) =\n    | PStr of structure\n    | PSig of signature (* : SIG *)\n    | PTyp of core_type  (* : T *)\n    | PPat of pattern * expression option  (* ? P  or  ? P when E *)\n\n  (** {2 Core language} *)\n\n  (* Type expressions *)\n\n  and core_type (*IF_CURRENT = Parsetree.core_type *) =\n      {\n       ptyp_desc: core_type_desc;\n       ptyp_loc: Location.t;\n       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =\n    | Ptyp_any\n          (*  _ *)\n    | Ptyp_var of string\n          (* 'a *)\n    | Ptyp_arrow of arg_label * core_type * core_type\n          (* T1 -> T2       Simple\n             ~l:T1 -> T2    Labelled\n             ?l:T1 -> T2    Otional\n           *)\n    | Ptyp_tuple of core_type list\n          (* T1 * ... * Tn\n\n             Invariant: n >= 2\n          *)\n    | Ptyp_constr of Longident.t loc * core_type list\n          (* tconstr\n             T tconstr\n             (T1, ..., Tn) tconstr\n           *)\n    | Ptyp_object of (string loc * attributes * core_type) list * closed_flag\n          (* < l1:T1; ...; ln:Tn >     (flag = Closed)\n             < l1:T1; ...; ln:Tn; .. > (flag = Open)\n           *)\n    | Ptyp_class of Longident.t loc * core_type list\n          (* #tconstr\n             T #tconstr\n             (T1, ..., Tn) #tconstr\n           *)\n    | Ptyp_alias of core_type * string\n          (* T as 'a *)\n    | Ptyp_variant of row_field list * closed_flag * label list option\n          (* [ `A|`B ]         (flag = Closed; labels = None)\n             [> `A|`B ]        (flag = Open;   labels = None)\n             [< `A|`B ]        (flag = Closed; labels = Some [])\n             [< `A|`B > `X `Y ](flag = Closed; labels = Some [\"X\";\"Y\"])\n           *)\n    | Ptyp_poly of string loc list * core_type\n          (* 'a1 ... 'an. T\n\n             Can only appear in the following context:\n\n             - As the core_type of a Ppat_constraint node corresponding\n               to a constraint on a let-binding: let x : 'a1 ... 'an. T\n               = e ...\n\n             - Under Cfk_virtual for methods (not values).\n\n             - As the core_type of a Pctf_method node.\n\n             - As the core_type of a Pexp_poly node.\n\n             - As the pld_type field of a label_declaration.\n\n             - As a core_type of a Ptyp_object node.\n           *)\n\n    | Ptyp_package of package_type\n          (* (module S) *)\n    | Ptyp_extension of extension\n          (* [%id] *)\n\n  and package_type = Longident.t loc * (Longident.t loc * core_type) list\n        (*\n          (module S)\n          (module S with type t1 = T1 and ... and tn = Tn)\n         *)\n\n  and row_field (*IF_CURRENT = Parsetree.row_field *) =\n    | Rtag of label * attributes * bool * core_type list\n          (* [`A]                   ( true,  [] )\n             [`A of T]              ( false, [T] )\n             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )\n             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )\n\n            - The 2nd field is true if the tag contains a\n              constant (empty) constructor.\n            - '&' occurs when several types are used for the same constructor\n              (see 4.2 in the manual)\n\n            - TODO: switch to a record representation, and keep location\n          *)\n    | Rinherit of core_type\n          (* [ T ] *)\n\n  (* Patterns *)\n\n  and pattern (*IF_CURRENT = Parsetree.pattern *) =\n      {\n       ppat_desc: pattern_desc;\n       ppat_loc: Location.t;\n       ppat_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =\n    | Ppat_any\n          (* _ *)\n    | Ppat_var of string loc\n          (* x *)\n    | Ppat_alias of pattern * string loc\n          (* P as 'a *)\n    | Ppat_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Ppat_interval of constant * constant\n          (* 'a'..'z'\n\n             Other forms of interval are recognized by the parser\n             but rejected by the type-checker. *)\n    | Ppat_tuple of pattern list\n          (* (P1, ..., Pn)\n\n             Invariant: n >= 2\n          *)\n    | Ppat_construct of Longident.t loc * pattern option\n          (* C                None\n             C P              Some P\n             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])\n           *)\n    | Ppat_variant of label * pattern option\n          (* `A             (None)\n             `A P           (Some P)\n           *)\n    | Ppat_record of (Longident.t loc * pattern) list * closed_flag\n          (* { l1=P1; ...; ln=Pn }     (flag = Closed)\n             { l1=P1; ...; ln=Pn; _}   (flag = Open)\n\n             Invariant: n > 0\n           *)\n    | Ppat_array of pattern list\n          (* [| P1; ...; Pn |] *)\n    | Ppat_or of pattern * pattern\n          (* P1 | P2 *)\n    | Ppat_constraint of pattern * core_type\n          (* (P : T) *)\n    | Ppat_type of Longident.t loc\n          (* #tconst *)\n    | Ppat_lazy of pattern\n          (* lazy P *)\n    | Ppat_unpack of string loc\n          (* (module P)\n             Note: (module P : S) is represented as\n             Ppat_constraint(Ppat_unpack, Ptyp_package)\n           *)\n    | Ppat_exception of pattern\n          (* exception P *)\n    | Ppat_extension of extension\n          (* [%id] *)\n    | Ppat_open of Longident.t loc * pattern\n          (* M.(P) *)\n\n  (* Value expressions *)\n\n  and expression (*IF_CURRENT = Parsetree.expression *) =\n      {\n       pexp_desc: expression_desc;\n       pexp_loc: Location.t;\n       pexp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =\n    | Pexp_ident of Longident.t loc\n          (* x\n             M.x\n           *)\n    | Pexp_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Pexp_let of rec_flag * value_binding list * expression\n          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)\n           *)\n    | Pexp_function of case list\n          (* function P1 -> E1 | ... | Pn -> En *)\n    | Pexp_fun of arg_label * expression option * pattern * expression\n          (* fun P -> E1                          (Simple, None)\n             fun ~l:P -> E1                       (Labelled l, None)\n             fun ?l:P -> E1                       (Optional l, None)\n             fun ?l:(P = E0) -> E1                (Optional l, Some E0)\n\n             Notes:\n             - If E0 is provided, only Optional is allowed.\n             - \"fun P1 P2 .. Pn -> E1\" is represented as nested Pexp_fun.\n             - \"let f P = E\" is represented using Pexp_fun.\n           *)\n    | Pexp_apply of expression * (arg_label * expression) list\n          (* E0 ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pexp_match of expression * case list\n          (* match E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_try of expression * case list\n          (* try E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_tuple of expression list\n          (* (E1, ..., En)\n\n             Invariant: n >= 2\n          *)\n    | Pexp_construct of Longident.t loc * expression option\n          (* C                None\n             C E              Some E\n             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])\n          *)\n    | Pexp_variant of label * expression option\n          (* `A             (None)\n             `A E           (Some E)\n           *)\n    | Pexp_record of (Longident.t loc * expression) list * expression option\n          (* { l1=P1; ...; ln=Pn }     (None)\n             { E0 with l1=P1; ...; ln=Pn }   (Some E0)\n\n             Invariant: n > 0\n           *)\n    | Pexp_field of expression * Longident.t loc\n          (* E.l *)\n    | Pexp_setfield of expression * Longident.t loc * expression\n          (* E1.l <- E2 *)\n    | Pexp_array of expression list\n          (* [| E1; ...; En |] *)\n    | Pexp_ifthenelse of expression * expression * expression option\n          (* if E1 then E2 else E3 *)\n    | Pexp_sequence of expression * expression\n          (* E1; E2 *)\n    | Pexp_while of expression * expression\n          (* while E1 do E2 done *)\n    | Pexp_for of\n        pattern *  expression * expression * direction_flag * expression\n          (* for i = E1 to E2 do E3 done      (flag = Upto)\n             for i = E1 downto E2 do E3 done  (flag = Downto)\n           *)\n    | Pexp_constraint of expression * core_type\n          (* (E : T) *)\n    | Pexp_coerce of expression * core_type option * core_type\n          (* (E :> T)        (None, T)\n             (E : T0 :> T)   (Some T0, T)\n           *)\n    | Pexp_send of expression * string loc\n          (*  E # m *)\n    | Pexp_new of Longident.t loc\n          (* new M.c *)\n    | Pexp_setinstvar of string loc * expression\n          (* x <- 2 *)\n    | Pexp_override of (string loc * expression) list\n          (* {< x1 = E1; ...; Xn = En >} *)\n    | Pexp_letmodule of string loc * module_expr * expression\n          (* let module M = ME in E *)\n    | Pexp_letexception of extension_constructor * expression\n          (* let exception C in E *)\n    | Pexp_assert of expression\n          (* assert E\n             Note: \"assert false\" is treated in a special way by the\n             type-checker. *)\n    | Pexp_lazy of expression\n          (* lazy E *)\n    | Pexp_poly of expression * core_type option\n          (* Used for method bodies.\n\n             Can only be used as the expression under Cfk_concrete\n             for methods (not values). *)\n    | Pexp_object of class_structure\n          (* object ... end *)\n    | Pexp_newtype of string loc * expression\n          (* fun (type t) -> E *)\n    | Pexp_pack of module_expr\n          (* (module ME)\n\n             (module ME : S) is represented as\n             Pexp_constraint(Pexp_pack, Ptyp_package S) *)\n    | Pexp_open of override_flag * Longident.t loc * expression\n          (* M.(E)\n             let open M in E\n             let! open M in E *)\n    | Pexp_extension of extension\n          (* [%id] *)\n    | Pexp_unreachable\n          (* . *)\n\n  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)\n      {\n       pc_lhs: pattern;\n       pc_guard: expression option;\n       pc_rhs: expression;\n      }\n\n  (* Value descriptions *)\n\n  and value_description (*IF_CURRENT = Parsetree.value_description *) =\n      {\n       pval_name: string loc;\n       pval_type: core_type;\n       pval_prim: string list;\n       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n       pval_loc: Location.t;\n      }\n\n  (*\n    val x: T                            (prim = [])\n    external x: T = \"s1\" ... \"sn\"       (prim = [\"s1\";...\"sn\"])\n  *)\n\n  (* Type declarations *)\n\n  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =\n      {\n       ptype_name: string loc;\n       ptype_params: (core_type * variance) list;\n             (* ('a1,...'an) t; None represents  _*)\n       ptype_cstrs: (core_type * core_type * Location.t) list;\n             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)\n       ptype_kind: type_kind;\n       ptype_private: private_flag;   (* = private ... *)\n       ptype_manifest: core_type option;  (* = T *)\n       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n       ptype_loc: Location.t;\n      }\n\n  (*\n    type t                     (abstract, no manifest)\n    type t = T0                (abstract, manifest=T0)\n    type t = C of T | ...      (variant,  no manifest)\n    type t = T0 = C of T | ... (variant,  manifest=T0)\n    type t = {l: T; ...}       (record,   no manifest)\n    type t = T0 = {l : T; ...} (record,   manifest=T0)\n    type t = ..                (open,     no manifest)\n  *)\n\n  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =\n    | Ptype_abstract\n    | Ptype_variant of constructor_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_record of label_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_open\n\n  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =\n      {\n       pld_name: string loc;\n       pld_mutable: mutable_flag;\n       pld_type: core_type;\n       pld_loc: Location.t;\n       pld_attributes: attributes; (* l [@id1] [@id2] : T *)\n      }\n\n  (*  { ...; l: T; ... }            (mutable=Immutable)\n      { ...; mutable l: T; ... }    (mutable=Mutable)\n\n      Note: T can be a Ptyp_poly.\n  *)\n\n  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =\n      {\n       pcd_name: string loc;\n       pcd_args: constructor_arguments;\n       pcd_res: core_type option;\n       pcd_loc: Location.t;\n       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =\n    | Pcstr_tuple of core_type list\n    | Pcstr_record of label_declaration list\n\n  (*\n    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])\n    | C: T0                  (res = Some T0, args = [])\n    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)\n    | C of {...}             (res = None,    args = Pcstr_record)\n    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)\n    | C of {...} as t        (res = None,    args = Pcstr_record)\n  *)\n\n  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =\n      {\n       ptyext_path: Longident.t loc;\n       ptyext_params: (core_type * variance) list;\n       ptyext_constructors: extension_constructor list;\n       ptyext_private: private_flag;\n       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n      }\n  (*\n    type t += ...\n  *)\n\n  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =\n      {\n       pext_name: string loc;\n       pext_kind : extension_constructor_kind;\n       pext_loc : Location.t;\n       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =\n      Pext_decl of constructor_arguments * core_type option\n        (*\n           | C of T1 * ... * Tn     ([T1; ...; Tn], None)\n           | C: T0                  ([], Some T0)\n           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)\n         *)\n    | Pext_rebind of Longident.t loc\n        (*\n           | C = D\n         *)\n\n  (** {2 Class language} *)\n\n  (* Type expressions for the class language *)\n\n  and class_type (*IF_CURRENT = Parsetree.class_type *) =\n      {\n       pcty_desc: class_type_desc;\n       pcty_loc: Location.t;\n       pcty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =\n    | Pcty_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcty_signature of class_signature\n          (* object ... end *)\n    | Pcty_arrow of arg_label * core_type * class_type\n          (* T -> CT       Simple\n             ~l:T -> CT    Labelled l\n             ?l:T -> CT    Optional l\n           *)\n    | Pcty_extension of extension\n          (* [%id] *)\n\n  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =\n      {\n       pcsig_self: core_type;\n       pcsig_fields: class_type_field list;\n      }\n  (* object('selfpat) ... end\n     object ... end             (self = Ptyp_any)\n   *)\n\n  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =\n      {\n       pctf_desc: class_type_field_desc;\n       pctf_loc: Location.t;\n       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =\n    | Pctf_inherit of class_type\n          (* inherit CT *)\n    | Pctf_val of (string loc * mutable_flag * virtual_flag * core_type)\n          (* val x: T *)\n    | Pctf_method  of (string loc * private_flag * virtual_flag * core_type)\n          (* method x: T\n\n             Note: T can be a Ptyp_poly.\n           *)\n    | Pctf_constraint  of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pctf_attribute of attribute\n          (* [@@@id] *)\n    | Pctf_extension of extension\n          (* [%%id] *)\n\n  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =\n      {\n       pci_virt: virtual_flag;\n       pci_params: (core_type * variance) list;\n       pci_name: string loc;\n       pci_expr: 'a;\n       pci_loc: Location.t;\n       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n      }\n  (* class c = ...\n     class ['a1,...,'an] c = ...\n     class virtual c = ...\n\n     Also used for \"class type\" declaration.\n  *)\n\n  and class_description = class_type class_infos\n\n  and class_type_declaration = class_type class_infos\n\n  (* Value expressions for the class language *)\n\n  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =\n      {\n       pcl_desc: class_expr_desc;\n       pcl_loc: Location.t;\n       pcl_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =\n    | Pcl_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcl_structure of class_structure\n          (* object ... end *)\n    | Pcl_fun of arg_label * expression option * pattern * class_expr\n          (* fun P -> CE                          (Simple, None)\n             fun ~l:P -> CE                       (Labelled l, None)\n             fun ?l:P -> CE                       (Optional l, None)\n             fun ?l:(P = E0) -> CE                (Optional l, Some E0)\n           *)\n    | Pcl_apply of class_expr * (arg_label * expression) list\n          (* CE ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pcl_let of rec_flag * value_binding list * class_expr\n          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)\n           *)\n    | Pcl_constraint of class_expr * class_type\n          (* (CE : CT) *)\n    | Pcl_extension of extension\n          (* [%id] *)\n\n  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =\n      {\n       pcstr_self: pattern;\n       pcstr_fields: class_field list;\n      }\n  (* object(selfpat) ... end\n     object ... end           (self = Ppat_any)\n   *)\n\n  and class_field (*IF_CURRENT = Parsetree.class_field *) =\n      {\n       pcf_desc: class_field_desc;\n       pcf_loc: Location.t;\n       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =\n    | Pcf_inherit of override_flag * class_expr * string loc option\n          (* inherit CE\n             inherit CE as x\n             inherit! CE\n             inherit! CE as x\n           *)\n    | Pcf_val of (string loc * mutable_flag * class_field_kind)\n          (* val x = E\n             val virtual x: T\n           *)\n    | Pcf_method of (string loc * private_flag * class_field_kind)\n          (* method x = E            (E can be a Pexp_poly)\n             method virtual x: T     (T can be a Ptyp_poly)\n           *)\n    | Pcf_constraint of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pcf_initializer of expression\n          (* initializer E *)\n    | Pcf_attribute of attribute\n          (* [@@@id] *)\n    | Pcf_extension of extension\n          (* [%%id] *)\n\n  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =\n    | Cfk_virtual of core_type\n    | Cfk_concrete of override_flag * expression\n\n  and class_declaration = class_expr class_infos\n\n  (** {2 Module language} *)\n\n  (* Type expressions for the module language *)\n\n  and module_type (*IF_CURRENT = Parsetree.module_type *) =\n      {\n       pmty_desc: module_type_desc;\n       pmty_loc: Location.t;\n       pmty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =\n    | Pmty_ident of Longident.t loc\n          (* S *)\n    | Pmty_signature of signature\n          (* sig ... end *)\n    | Pmty_functor of string loc * module_type option * module_type\n          (* functor(X : MT1) -> MT2 *)\n    | Pmty_with of module_type * with_constraint list\n          (* MT with ... *)\n    | Pmty_typeof of module_expr\n          (* module type of ME *)\n    | Pmty_extension of extension\n          (* [%id] *)\n    | Pmty_alias of Longident.t loc\n          (* (module M) *)\n\n  and signature = signature_item list\n\n  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =\n      {\n       psig_desc: signature_item_desc;\n       psig_loc: Location.t;\n      }\n\n  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =\n    | Psig_value of value_description\n          (*\n            val x: T\n            external x: T = \"s1\" ... \"sn\"\n           *)\n    | Psig_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Psig_typext of type_extension\n          (* type t1 += ... *)\n    | Psig_exception of extension_constructor\n          (* exception C of T *)\n    | Psig_module of module_declaration\n          (* module X : MT *)\n    | Psig_recmodule of module_declaration list\n          (* module rec X1 : MT1 and ... and Xn : MTn *)\n    | Psig_modtype of module_type_declaration\n          (* module type S = MT\n             module type S *)\n    | Psig_open of open_description\n          (* open X *)\n    | Psig_include of include_description\n          (* include MT *)\n    | Psig_class of class_description list\n          (* class c1 : ... and ... and cn : ... *)\n    | Psig_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Psig_attribute of attribute\n          (* [@@@id] *)\n    | Psig_extension of extension * attributes\n          (* [%%id] *)\n\n  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =\n      {\n       pmd_name: string loc;\n       pmd_type: module_type;\n       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmd_loc: Location.t;\n      }\n  (* S : MT *)\n\n  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =\n      {\n       pmtd_name: string loc;\n       pmtd_type: module_type option;\n       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmtd_loc: Location.t;\n      }\n  (* S = MT\n     S       (abstract module type declaration, pmtd_type = None)\n  *)\n\n  and open_description (*IF_CURRENT = Parsetree.open_description *) =\n      {\n       popen_lid: Longident.t loc;\n       popen_override: override_flag;\n       popen_loc: Location.t;\n       popen_attributes: attributes;\n      }\n  (* open! X - popen_override = Override (silences the 'used identifier\n                                shadowing' warning)\n     open  X - popen_override = Fresh\n   *)\n\n  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =\n      {\n       pincl_mod: 'a;\n       pincl_loc: Location.t;\n       pincl_attributes: attributes;\n      }\n\n  and include_description = module_type include_infos\n  (* include MT *)\n\n  and include_declaration = module_expr include_infos\n  (* include ME *)\n\n  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =\n    | Pwith_type of Longident.t loc * type_declaration\n          (* with type X.t = ...\n\n             Note: the last component of the longident must match\n             the name of the type_declaration. *)\n    | Pwith_module of Longident.t loc * Longident.t loc\n          (* with module X.Y = Z *)\n    | Pwith_typesubst of type_declaration\n          (* with type t := ... *)\n    | Pwith_modsubst of string loc * Longident.t loc\n          (* with module X := Z *)\n\n  (* Value expressions for the module language *)\n\n  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =\n      {\n       pmod_desc: module_expr_desc;\n       pmod_loc: Location.t;\n       pmod_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =\n    | Pmod_ident of Longident.t loc\n          (* X *)\n    | Pmod_structure of structure\n          (* struct ... end *)\n    | Pmod_functor of string loc * module_type option * module_expr\n          (* functor(X : MT1) -> ME *)\n    | Pmod_apply of module_expr * module_expr\n          (* ME1(ME2) *)\n    | Pmod_constraint of module_expr * module_type\n          (* (ME : MT) *)\n    | Pmod_unpack of expression\n          (* (val E) *)\n    | Pmod_extension of extension\n          (* [%id] *)\n\n  and structure = structure_item list\n\n  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =\n      {\n       pstr_desc: structure_item_desc;\n       pstr_loc: Location.t;\n      }\n\n  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =\n    | Pstr_eval of expression * attributes\n          (* E *)\n    | Pstr_value of rec_flag * value_binding list\n          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)\n           *)\n    | Pstr_primitive of value_description\n          (*  val x: T\n              external x: T = \"s1\" ... \"sn\" *)\n    | Pstr_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Pstr_typext of type_extension\n          (* type t1 += ... *)\n    | Pstr_exception of extension_constructor\n          (* exception C of T\n             exception C = M.X *)\n    | Pstr_module of module_binding\n          (* module X = ME *)\n    | Pstr_recmodule of module_binding list\n          (* module rec X1 = ME1 and ... and Xn = MEn *)\n    | Pstr_modtype of module_type_declaration\n          (* module type S = MT *)\n    | Pstr_open of open_description\n          (* open X *)\n    | Pstr_class of class_declaration list\n          (* class c1 = ... and ... and cn = ... *)\n    | Pstr_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Pstr_include of include_declaration\n          (* include ME *)\n    | Pstr_attribute of attribute\n          (* [@@@id] *)\n    | Pstr_extension of extension * attributes\n          (* [%%id] *)\n\n  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =\n    {\n      pvb_pat: pattern;\n      pvb_expr: expression;\n      pvb_attributes: attributes;\n      pvb_loc: Location.t;\n    }\n\n  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =\n      {\n       pmb_name: string loc;\n       pmb_expr: module_expr;\n       pmb_attributes: attributes;\n       pmb_loc: Location.t;\n      }\n  (* X = ME *)\n\n  (** {2 Toplevel} *)\n\n  (* Toplevel phrases *)\n\n  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =\n    | Ptop_def of structure\n    | Ptop_dir of string * directive_argument\n       (* #use, #load ... *)\n\n  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =\n    | Pdir_none\n    | Pdir_string of string\n    | Pdir_int of string * char option\n    | Pdir_ident of Longident.t\n    | Pdir_bool of bool\n\nend\n\nmodule Docstrings : sig\n  (** {3 Docstrings} *)\n\n  (** Documentation comments *)\n  type docstring\n\n  (** Create a docstring *)\n  val docstring : string -> Location.t -> docstring\n\n  (** Get the text of a docstring *)\n  val docstring_body : docstring -> string\n\n  (** Get the location of a docstring *)\n  val docstring_loc : docstring -> Location.t\n\n  (** {3 Items}\n\n      The {!docs} type represents documentation attached to an item. *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  val empty_docs : docs\n\n  val docs_attr : docstring -> Parsetree.attribute\n\n  (** Convert item documentation to attributes and add them to an\n      attribute list *)\n  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Fields and constructors}\n\n      The {!info} type represents documentation attached to a field or\n      constructor. *)\n\n  type info = docstring option\n\n  val empty_info : info\n\n  val info_attr : docstring -> Parsetree.attribute\n\n  (** Convert field info to attributes and add them to an\n      attribute list *)\n  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Unattached comments}\n\n      The {!text} type represents documentation which is not attached to\n      anything. *)\n\n  type text = docstring list\n\n  val empty_text : text\n\n  val text_attr : docstring -> Parsetree.attribute\n\n  (** Convert text to attributes and add them to an attribute list *)\n  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes\n\nend = struct\n  open Location\n\n  (* Docstrings *)\n\n  type docstring =\n    { ds_body: string;\n      ds_loc: Location.t;\n    }\n\n  (* Docstring constructors and destructors *)\n\n  let docstring body loc =\n    let ds =\n      { ds_body = body;\n        ds_loc = loc;\n      }\n    in\n    ds\n\n  let docstring_body ds = ds.ds_body\n\n  let docstring_loc ds = ds.ds_loc\n\n  (* Docstrings attached to items *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  let empty_docs = { docs_pre = None; docs_post = None }\n\n  let doc_loc = {txt = \"ocaml.doc\"; loc = Location.none}\n\n  let docs_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (doc_loc, PStr [item])\n\n  let add_docs_attrs docs attrs =\n    let attrs =\n      match docs.docs_pre with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> docs_attr ds :: attrs\n    in\n    let attrs =\n      match docs.docs_post with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> attrs @ [docs_attr ds]\n    in\n    attrs\n\n  (* Docstrings attached to constructors or fields *)\n\n  type info = docstring option\n\n  let empty_info = None\n\n  let info_attr = docs_attr\n\n  let add_info_attrs info attrs =\n    match info with\n    | None | Some {ds_body=\"\"; _} -> attrs\n    | Some ds -> attrs @ [info_attr ds]\n\n  (* Docstrings not attached to a specific item *)\n\n  type text = docstring list\n\n  let empty_text = []\n\n  let text_loc = {txt = \"ocaml.text\"; loc = Location.none}\n\n  let text_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (text_loc, PStr [item])\n\n  let add_text_attrs dsl attrs =\n    let fdsl = List.filter (function {ds_body=\"\"; _} -> false| _ ->true) dsl in\n    (List.map text_attr fdsl) @ attrs\n\nend\n\nmodule Ast_helper : sig\n\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Docstrings\n  open Parsetree\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  (** {2 Default locations} *)\n\n  val default_loc: loc ref\n      (** Default value for all optional location arguments. *)\n\n  val with_default_loc: loc -> (unit -> 'a) -> 'a\n      (** Set the [default_loc] within the scope of the execution\n          of the provided function. *)\n\n  (** {2 Constants} *)\n\n  module Const : sig\n    val char : char -> constant\n    val string : ?quotation_delimiter:string -> string -> constant\n    val integer : ?suffix:char -> string -> constant\n    val int : ?suffix:char -> int -> constant\n    val int32 : ?suffix:char -> int32 -> constant\n    val int64 : ?suffix:char -> int64 -> constant\n    val nativeint : ?suffix:char -> nativeint -> constant\n    val float : ?suffix:char -> string -> constant\n  end\n\n  (** {2 Core language} *)\n\n  (** Type expressions *)\n  module Typ :\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type\n      val attr: core_type -> attribute -> core_type\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type\n      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type\n                 -> core_type\n      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val object_: ?loc:loc -> ?attrs:attrs ->\n                    (str * attributes * core_type) list -> closed_flag ->\n                    core_type\n      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type\n      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag\n                   -> label list option -> core_type\n      val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type\n      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list\n                   -> core_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type\n\n      val force_poly: core_type -> core_type\n\n      val varify_constructors: str list -> core_type -> core_type\n      (** [varify_constructors newtypes te] is type expression [te], of which\n          any of nullary type constructor [tc] is replaced by type variable of\n          the same name, if [tc]'s name appears in [newtypes].\n          Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]\n          appears in [newtypes].\n          @since 4.05\n       *)\n    end\n\n  (** Patterns *)\n  module Pat:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern\n      val attr:pattern -> attribute -> pattern\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern\n      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern\n      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern\n      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag\n                  -> pattern\n      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern\n      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern\n      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern\n      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern\n      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern\n    end\n\n  (** Expressions *)\n  module Exp:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression\n      val attr: expression -> attribute -> expression\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list\n                -> expression -> expression\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option\n                -> pattern -> expression -> expression\n      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression\n      val apply: ?loc:loc -> ?attrs:attrs -> expression\n                 -> (arg_label * expression) list -> expression\n      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list\n                  -> expression\n      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression\n      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option\n                     -> expression\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option\n                   -> expression\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list\n                  -> expression option -> expression\n      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n                    -> expression\n      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                      -> expression option -> expression\n      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                    -> expression\n      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                  -> expression\n      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression\n                -> direction_flag -> expression -> expression\n      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                  -> core_type -> expression\n      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type\n                       -> expression\n      val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression\n      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list\n                    -> expression\n      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression\n                     -> expression\n      val letexception:\n        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression\n        -> expression\n      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                -> expression\n      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression\n      val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression\n                 -> expression\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression\n      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression\n\n      val case: pattern -> ?guard:expression -> expression -> case\n    end\n\n  (** Value declarations *)\n  module Val:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        ?prim:string list -> str -> core_type -> value_description\n    end\n\n  (** Type declarations *)\n  module Type:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?params:(core_type * variance) list ->\n        ?cstrs:(core_type * core_type * loc) list ->\n        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->\n        type_declaration\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        constructor_declaration\n      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?mut:mutable_flag -> str -> core_type -> label_declaration\n    end\n\n  (** Type extensions *)\n  module Te:\n    sig\n      val mk: ?attrs:attrs -> ?docs:docs ->\n        ?params:(core_type * variance) list -> ?priv:private_flag ->\n        lid -> extension_constructor list -> type_extension\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> extension_constructor_kind -> extension_constructor\n\n      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        extension_constructor\n      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> lid -> extension_constructor\n    end\n\n  (** {2 Module language} *)\n\n  (** Module type expressions *)\n  module Mty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type\n      val attr: module_type -> attribute -> module_type\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_type -> module_type\n      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->\n        with_constraint list -> module_type\n      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type\n    end\n\n  (** Module expressions *)\n  module Mod:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr\n      val attr: module_expr -> attribute -> module_expr\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_expr -> module_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->\n        module_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->\n        module_expr\n      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr\n    end\n\n  (** Signature items *)\n  module Sig:\n    sig\n      val mk: ?loc:loc -> signature_item_desc -> signature_item\n\n      val value: ?loc:loc -> value_description -> signature_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item\n      val type_extension: ?loc:loc -> type_extension -> signature_item\n      val exception_: ?loc:loc -> extension_constructor -> signature_item\n      val module_: ?loc:loc -> module_declaration -> signature_item\n      val rec_module: ?loc:loc -> module_declaration list -> signature_item\n      val modtype: ?loc:loc -> module_type_declaration -> signature_item\n      val open_: ?loc:loc -> open_description -> signature_item\n      val include_: ?loc:loc -> include_description -> signature_item\n      val class_: ?loc:loc -> class_description list -> signature_item\n      val class_type: ?loc:loc -> class_type_declaration list -> signature_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item\n      val attribute: ?loc:loc -> attribute -> signature_item\n      val text: text -> signature_item list\n    end\n\n  (** Structure items *)\n  module Str:\n    sig\n      val mk: ?loc:loc -> structure_item_desc -> structure_item\n\n      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item\n      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item\n      val primitive: ?loc:loc -> value_description -> structure_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item\n      val type_extension: ?loc:loc -> type_extension -> structure_item\n      val exception_: ?loc:loc -> extension_constructor -> structure_item\n      val module_: ?loc:loc -> module_binding -> structure_item\n      val rec_module: ?loc:loc -> module_binding list -> structure_item\n      val modtype: ?loc:loc -> module_type_declaration -> structure_item\n      val open_: ?loc:loc -> open_description -> structure_item\n      val class_: ?loc:loc -> class_declaration list -> structure_item\n      val class_type: ?loc:loc -> class_type_declaration list -> structure_item\n      val include_: ?loc:loc -> include_declaration -> structure_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item\n      val attribute: ?loc:loc -> attribute -> structure_item\n      val text: text -> structure_item list\n    end\n\n  (** Module declarations *)\n  module Md:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_type -> module_declaration\n    end\n\n  (** Module type declarations *)\n  module Mtd:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?typ:module_type -> str -> module_type_declaration\n    end\n\n  (** Module bindings *)\n  module Mb:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_expr -> module_binding\n    end\n\n  (** Opens *)\n  module Opn:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->\n        ?override:override_flag -> lid -> open_description\n    end\n\n  (** Includes *)\n  module Incl:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos\n    end\n\n  (** Value bindings *)\n  module Vb:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        pattern -> expression -> value_binding\n    end\n\n\n  (** {2 Class language} *)\n\n  (** Class type expressions *)\n  module Cty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type\n      val attr: class_type -> attribute -> class_type\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type\n      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->\n        class_type -> class_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type\n    end\n\n  (** Class type fields *)\n  module Ctf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        class_type_field_desc -> class_type_field\n      val attr: class_type_field -> attribute -> class_type_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_type_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field\n      val attribute: ?loc:loc -> attribute -> class_type_field\n      val text: text -> class_type_field list\n    end\n\n  (** Class expressions *)\n  module Cl:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr\n      val attr: class_expr -> attribute -> class_expr\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->\n        pattern -> class_expr -> class_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->\n        (arg_label * expression) list -> class_expr\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->\n        class_expr -> class_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->\n        class_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr\n    end\n\n  (** Class fields *)\n  module Cf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->\n        class_field\n      val attr: class_field -> attribute -> class_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->\n        str option -> class_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        class_field_kind -> class_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        class_field_kind -> class_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_field\n      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field\n      val attribute: ?loc:loc -> attribute -> class_field\n      val text: text -> class_field list\n\n      val virtual_: core_type -> class_field_kind\n      val concrete: override_flag -> expression -> class_field_kind\n\n    end\n\n  (** Classes *)\n  module Ci:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?virt:virtual_flag -> ?params:(core_type * variance) list ->\n        str -> 'a -> 'a class_infos\n    end\n\n  (** Class signatures *)\n  module Csig:\n    sig\n      val mk: core_type -> class_type_field list -> class_signature\n    end\n\n  (** Class structures *)\n  module Cstr:\n    sig\n      val mk: pattern -> class_field list -> class_structure\n    end\n\nend = struct\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Parsetree\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  let default_loc = ref Location.none\n\n  let with_default_loc l f =\n    let old = !default_loc in\n    default_loc := l;\n    try let r = f () in default_loc := old; r\n    with exn -> default_loc := old; raise exn\n\n  module Const = struct\n    let integer ?suffix i = Pconst_integer (i, suffix)\n    let int ?suffix i = integer ?suffix (string_of_int i)\n    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)\n    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)\n    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)\n    let float ?suffix f = Pconst_float (f, suffix)\n    let char c = Pconst_char c\n    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)\n  end\n\n  module Typ = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}\n    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))\n    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))\n    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))\n    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))\n    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)\n\n    let force_poly t =\n      match t.ptyp_desc with\n      | Ptyp_poly _ -> t\n      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)\n\n    let varify_constructors var_names t =\n      let check_variable vl loc v =\n        if List.mem v vl then\n          raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in\n      let var_names = List.map (fun v -> v.txt) var_names in\n      let rec loop t =\n        let desc =\n          match t.ptyp_desc with\n          | Ptyp_any -> Ptyp_any\n          | Ptyp_var x ->\n              check_variable var_names t.ptyp_loc x;\n              Ptyp_var x\n          | Ptyp_arrow (label,core_type,core_type') ->\n              Ptyp_arrow(label, loop core_type, loop core_type')\n          | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)\n          | Ptyp_constr( { txt = Longident.Lident s; _ }, [])\n            when List.mem s var_names ->\n              Ptyp_var s\n          | Ptyp_constr(longident, lst) ->\n              Ptyp_constr(longident, List.map loop lst)\n          | Ptyp_object (lst, o) ->\n              Ptyp_object\n                (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)\n          | Ptyp_class (longident, lst) ->\n              Ptyp_class (longident, List.map loop lst)\n          | Ptyp_alias(core_type, string) ->\n              check_variable var_names t.ptyp_loc string;\n              Ptyp_alias(loop core_type, string)\n          | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->\n              Ptyp_variant(List.map loop_row_field row_field_list,\n                           flag, lbl_lst_option)\n          | Ptyp_poly(string_lst, core_type) ->\n            List.iter (fun v ->\n              check_variable var_names t.ptyp_loc v.txt) string_lst;\n              Ptyp_poly(string_lst, loop core_type)\n          | Ptyp_package(longident,lst) ->\n              Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)\n          | Ptyp_extension (s, arg) ->\n              Ptyp_extension (s, arg)\n        in\n        {t with ptyp_desc = desc}\n      and loop_row_field  =\n        function\n          | Rtag(label,attrs,flag,lst) ->\n              Rtag(label,attrs,flag,List.map loop lst)\n          | Rinherit t ->\n              Rinherit (loop t)\n      in\n      loop t\n\n  end\n\n  module Pat = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}\n    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)\n    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)\n    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))\n    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)\n    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)\n    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))\n    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)\n  end\n\n  module Exp = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}\n    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))\n    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))\n    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))\n    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))\n    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))\n    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)\n    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))\n    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))\n    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))\n    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))\n    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))\n    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))\n    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)\n    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))\n    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)\n    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))\n    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))\n    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))\n    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)\n    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))\n    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)\n    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable\n\n    let case lhs ?guard rhs =\n      {\n       pc_lhs = lhs;\n       pc_guard = guard;\n       pc_rhs = rhs;\n      }\n  end\n\n  module Mty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}\n    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)\n    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)\n    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))\n    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))\n    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)\n  end\n\n  module Mod = struct\n  let mk ?(loc = !default_loc) ?(attrs = []) d =\n    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}\n    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}\n\n    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)\n    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)\n    let functor_ ?loc ?attrs arg arg_ty body =\n      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))\n    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))\n    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))\n    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)\n  end\n\n  module Sig = struct\n    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}\n\n    let value ?loc a = mk ?loc (Psig_value a)\n    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Psig_typext a)\n    let exception_ ?loc a = mk ?loc (Psig_exception a)\n    let module_ ?loc a = mk ?loc (Psig_module a)\n    let rec_module ?loc a = mk ?loc (Psig_recmodule a)\n    let modtype ?loc a = mk ?loc (Psig_modtype a)\n    let open_ ?loc a = mk ?loc (Psig_open a)\n    let include_ ?loc a = mk ?loc (Psig_include a)\n    let class_ ?loc a = mk ?loc (Psig_class a)\n    let class_type ?loc a = mk ?loc (Psig_class_type a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Psig_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Str = struct\n    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}\n\n    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))\n    let value ?loc a b = mk ?loc (Pstr_value (a, b))\n    let primitive ?loc a = mk ?loc (Pstr_primitive a)\n    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Pstr_typext a)\n    let exception_ ?loc a = mk ?loc (Pstr_exception a)\n    let module_ ?loc a = mk ?loc (Pstr_module a)\n    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)\n    let modtype ?loc a = mk ?loc (Pstr_modtype a)\n    let open_ ?loc a = mk ?loc (Pstr_open a)\n    let class_ ?loc a = mk ?loc (Pstr_class a)\n    let class_type ?loc a = mk ?loc (Pstr_class_type a)\n    let include_ ?loc a = mk ?loc (Pstr_include a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Pstr_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Cl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcl_desc = d;\n       pcl_loc = loc;\n       pcl_attributes = attrs;\n      }\n    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))\n    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)\n  end\n\n  module Cty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcty_desc = d;\n       pcty_loc = loc;\n       pcty_attributes = attrs;\n      }\n    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)\n  end\n\n  module Ctf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n             ?(docs = empty_docs) d =\n      {\n       pctf_desc = d;\n       pctf_loc = loc;\n       pctf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)\n    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))\n    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)\n    let attribute ?loc a = mk ?loc (Pctf_attribute a)\n    let text txt =\n     let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n       List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}\n\n  end\n\n  module Cf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) d =\n      {\n       pcf_desc = d;\n       pcf_loc = loc;\n       pcf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))\n    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))\n    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))\n    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)\n    let attribute ?loc a = mk ?loc (Pcf_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let virtual_ ct = Cfk_virtual ct\n    let concrete o e = Cfk_concrete (o, e)\n\n    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}\n\n  end\n\n  module Val = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(prim = []) name typ =\n      {\n       pval_name = name;\n       pval_type = typ;\n       pval_attributes = add_docs_attrs docs attrs;\n       pval_loc = loc;\n       pval_prim = prim;\n      }\n  end\n\n  module Md = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name typ =\n      {\n       pmd_name = name;\n       pmd_type = typ;\n       pmd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmd_loc = loc;\n      }\n  end\n\n  module Mtd = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) ?typ name =\n      {\n       pmtd_name = name;\n       pmtd_type = typ;\n       pmtd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmtd_loc = loc;\n      }\n  end\n\n  module Mb = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name expr =\n      {\n       pmb_name = name;\n       pmb_expr = expr;\n       pmb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmb_loc = loc;\n      }\n  end\n\n  module Opn = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(override = Fresh) lid =\n      {\n       popen_lid = lid;\n       popen_override = override;\n       popen_loc = loc;\n       popen_attributes = add_docs_attrs docs attrs;\n      }\n  end\n\n  module Incl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =\n      {\n       pincl_mod = mexpr;\n       pincl_loc = loc;\n       pincl_attributes = add_docs_attrs docs attrs;\n      }\n\n  end\n\n  module Vb = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(text = []) pat expr =\n      {\n       pvb_pat = pat;\n       pvb_expr = expr;\n       pvb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pvb_loc = loc;\n      }\n  end\n\n  module Ci = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n          ?(virt = Concrete) ?(params = []) name expr =\n      {\n       pci_virt = virt;\n       pci_params = params;\n       pci_name = name;\n       pci_expr = expr;\n       pci_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pci_loc = loc;\n      }\n  end\n\n  module Type = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n        ?(params = [])\n        ?(cstrs = [])\n        ?(kind = Ptype_abstract)\n        ?(priv = Public)\n        ?manifest\n        name =\n      {\n       ptype_name = name;\n       ptype_params = params;\n       ptype_cstrs = cstrs;\n       ptype_kind = kind;\n       ptype_private = priv;\n       ptype_manifest = manifest;\n       ptype_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       ptype_loc = loc;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(args = Pcstr_tuple []) ?res name =\n      {\n       pcd_name = name;\n       pcd_args = args;\n       pcd_res = res;\n       pcd_loc = loc;\n       pcd_attributes = add_info_attrs info attrs;\n       }\n\n    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(mut = Immutable) name typ =\n      {\n       pld_name = name;\n       pld_mutable = mut;\n       pld_type = typ;\n       pld_loc = loc;\n       pld_attributes = add_info_attrs info attrs;\n      }\n\n  end\n\n  (** Type extensions *)\n  module Te = struct\n    let mk ?(attrs = []) ?(docs = empty_docs)\n          ?(params = []) ?(priv = Public) path constructors =\n      {\n       ptyext_path = path;\n       ptyext_params = params;\n       ptyext_constructors = constructors;\n       ptyext_private = priv;\n       ptyext_attributes = add_docs_attrs docs attrs;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name kind =\n      {\n       pext_name = name;\n       pext_kind = kind;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =\n      {\n       pext_name = name;\n       pext_kind = Pext_decl(args, res);\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let rebind ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name lid =\n      {\n       pext_name = name;\n       pext_kind = Pext_rebind lid;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n  end\n\n  module Csig = struct\n    let mk self fields =\n      {\n       pcsig_self = self;\n       pcsig_fields = fields;\n      }\n  end\n\n  module Cstr = struct\n    let mk self fields =\n      {\n       pcstr_self = self;\n       pcstr_fields = fields;\n      }\n  end\n\nend\n\nmodule Ast_mapper : sig\n  (** The interface of a -ppx rewriter\n\n    A -ppx rewriter is a program that accepts a serialized abstract syntax\n    tree and outputs another, possibly modified, abstract syntax tree.\n    This module encapsulates the interface between the compiler and\n    the -ppx rewriters, handling such details as the serialization format,\n    forwarding of command-line flags, and storing state.\n\n    {!mapper} allows to implement AST rewriting using open recursion.\n    A typical mapper would be based on {!default_mapper}, a deep\n    identity mapper, and will fall back on it for handling the syntax it\n    does not modify. For example:\n\n    {[\n  open Asttypes\n  open Parsetree\n  open Ast_mapper\n\n  let test_mapper argv =\n    { default_mapper with\n      expr = fun mapper expr ->\n        match expr with\n        | { pexp_desc = Pexp_extension ({ txt = \"test\" }, PStr [])} ->\n          Ast_helper.Exp.constant (Const_int 42)\n        | other -> default_mapper.expr mapper other; }\n\n  let () =\n    register \"ppx_test\" test_mapper]}\n\n    This -ppx rewriter, which replaces [[%test]] in expressions with\n    the constant [42], can be compiled using\n    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].\n\n    *)\n\n  open Parsetree\n\n  (** {2 A generic Parsetree mapper} *)\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n  (** A mapper record implements one \"method\" per syntactic category,\n      using an open recursion style: each method takes as its first\n      argument the mapper to be applied to children in the syntax\n      tree. *)\n\n  val default_mapper: mapper\n  (** A default mapper, which implements a \"deep identity\" mapping. *)\n\n  (** {2 Convenience functions to write mappers} *)\n\n  val map_opt: ('a -> 'b) -> 'a option -> 'b option\n\n  val extension_of_error: Location.error -> extension\n  (** Encode an error into an 'ocaml.error' extension node which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the error. *)\n\n  val attribute_of_warning: Location.t -> string -> attribute\n  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the warning. *)\n\nend = struct\n  (* A generic Parsetree mapping class *)\n\n  (*\n  [@@@ocaml.warning \"+9\"]\n    (* Ensure that record patterns don't miss any field. *)\n  *)\n\n\n  open Parsetree\n  open Ast_helper\n  open Location\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n\n  let map_fst f (x, y) = (f x, y)\n  let map_snd f (x, y) = (x, f y)\n  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)\n  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)\n  let map_opt f = function None -> None | Some x -> Some (f x)\n\n  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}\n\n  module T = struct\n    (* Type expressions for the core language *)\n\n    let row_field sub = function\n      | Rtag (l, attrs, b, tl) ->\n          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)\n      | Rinherit t -> Rinherit (sub.typ sub t)\n\n    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =\n      let open Typ in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ptyp_any -> any ~loc ~attrs ()\n      | Ptyp_var s -> var ~loc ~attrs s\n      | Ptyp_arrow (lab, t1, t2) ->\n          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)\n      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)\n      | Ptyp_constr (lid, tl) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_object (l, o) ->\n          let f (s, a, t) =\n            (map_loc sub s, sub.attributes sub a, sub.typ sub t) in\n          object_ ~loc ~attrs (List.map f l) o\n      | Ptyp_class (lid, tl) ->\n          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s\n      | Ptyp_variant (rl, b, ll) ->\n          variant ~loc ~attrs (List.map (row_field sub) rl) b ll\n      | Ptyp_poly (sl, t) -> poly ~loc ~attrs\n                               (List.map (map_loc sub) sl) (sub.typ sub t)\n      | Ptyp_package (lid, l) ->\n          package ~loc ~attrs (map_loc sub lid)\n            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)\n      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_type_declaration sub\n        {ptype_name; ptype_params; ptype_cstrs;\n         ptype_kind;\n         ptype_private;\n         ptype_manifest;\n         ptype_attributes;\n         ptype_loc} =\n      Type.mk (map_loc sub ptype_name)\n        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)\n        ~priv:ptype_private\n        ~cstrs:(List.map\n                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))\n                  ptype_cstrs)\n        ~kind:(sub.type_kind sub ptype_kind)\n        ?manifest:(map_opt (sub.typ sub) ptype_manifest)\n        ~loc:(sub.location sub ptype_loc)\n        ~attrs:(sub.attributes sub ptype_attributes)\n\n    let map_type_kind sub = function\n      | Ptype_abstract -> Ptype_abstract\n      | Ptype_variant l ->\n          Ptype_variant (List.map (sub.constructor_declaration sub) l)\n      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)\n      | Ptype_open -> Ptype_open\n\n    let map_constructor_arguments sub = function\n      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)\n      | Pcstr_record l ->\n          Pcstr_record (List.map (sub.label_declaration sub) l)\n\n    let map_type_extension sub\n        {ptyext_path; ptyext_params;\n         ptyext_constructors;\n         ptyext_private;\n         ptyext_attributes} =\n      Te.mk\n        (map_loc sub ptyext_path)\n        (List.map (sub.extension_constructor sub) ptyext_constructors)\n        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)\n        ~priv:ptyext_private\n        ~attrs:(sub.attributes sub ptyext_attributes)\n\n    let map_extension_constructor_kind sub = function\n        Pext_decl(ctl, cto) ->\n          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)\n      | Pext_rebind li ->\n          Pext_rebind (map_loc sub li)\n\n    let map_extension_constructor sub\n        {pext_name;\n         pext_kind;\n         pext_loc;\n         pext_attributes} =\n      Te.constructor\n        (map_loc sub pext_name)\n        (map_extension_constructor_kind sub pext_kind)\n        ~loc:(sub.location sub pext_loc)\n        ~attrs:(sub.attributes sub pext_attributes)\n\n  end\n\n  module CT = struct\n    (* Type expressions for the class language *)\n\n    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =\n      let open Cty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcty_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)\n      | Pcty_arrow (lab, t, ct) ->\n          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)\n      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}\n      =\n      let open Ctf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)\n      | Pctf_val (s, m, v, t) ->\n          val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)\n      | Pctf_method (s, p, v, t) ->\n          method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)\n      | Pctf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_signature sub {pcsig_self; pcsig_fields} =\n      Csig.mk\n        (sub.typ sub pcsig_self)\n        (List.map (sub.class_type_field sub) pcsig_fields)\n  end\n\n  module MT = struct\n    (* Type expressions for the module language *)\n\n    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =\n      let open Mty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)\n      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)\n      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)\n      | Pmty_functor (s, mt1, mt2) ->\n          functor_ ~loc ~attrs (map_loc sub s)\n            (Misc.may_map (sub.module_type sub) mt1)\n            (sub.module_type sub mt2)\n      | Pmty_with (mt, l) ->\n          with_ ~loc ~attrs (sub.module_type sub mt)\n            (List.map (sub.with_constraint sub) l)\n      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)\n      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_with_constraint sub = function\n      | Pwith_type (lid, d) ->\n          Pwith_type (map_loc sub lid, sub.type_declaration sub d)\n      | Pwith_module (lid, lid2) ->\n          Pwith_module (map_loc sub lid, map_loc sub lid2)\n      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)\n      | Pwith_modsubst (s, lid) ->\n          Pwith_modsubst (map_loc sub s, map_loc sub lid)\n\n    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =\n      let open Sig in\n      let loc = sub.location sub loc in\n      match desc with\n      | Psig_value vd -> value ~loc (sub.value_description sub vd)\n      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)\n      | Psig_recmodule l ->\n          rec_module ~loc (List.map (sub.module_declaration sub) l)\n      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Psig_open x -> open_ ~loc (sub.open_description sub x)\n      | Psig_include x -> include_ ~loc (sub.include_description sub x)\n      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)\n      | Psig_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Psig_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n\n  module M = struct\n    (* Value expressions for the module language *)\n\n    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =\n      let open Mod in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)\n      | Pmod_functor (arg, arg_ty, body) ->\n          functor_ ~loc ~attrs (map_loc sub arg)\n            (Misc.may_map (sub.module_type sub) arg_ty)\n            (sub.module_expr sub body)\n      | Pmod_apply (m1, m2) ->\n          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)\n      | Pmod_constraint (m, mty) ->\n          constraint_ ~loc ~attrs (sub.module_expr sub m)\n                      (sub.module_type sub mty)\n      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)\n      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =\n      let open Str in\n      let loc = sub.location sub loc in\n      match desc with\n      | Pstr_eval (x, attrs) ->\n          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)\n      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)\n      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)\n      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)\n      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)\n      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Pstr_open x -> open_ ~loc (sub.open_description sub x)\n      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)\n      | Pstr_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)\n      | Pstr_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n  module E = struct\n    (* Value expressions for the core language *)\n\n    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =\n      let open Exp in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pexp_constant x -> constant ~loc ~attrs x\n      | Pexp_let (r, vbs, e) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.expr sub e)\n      | Pexp_fun (lab, def, p, e) ->\n          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)\n            (sub.expr sub e)\n      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)\n      | Pexp_apply (e, l) ->\n          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)\n      | Pexp_match (e, pel) ->\n          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_construct (lid, arg) ->\n          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)\n      | Pexp_variant (lab, eo) ->\n          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)\n      | Pexp_record (l, eo) ->\n          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)\n            (map_opt (sub.expr sub) eo)\n      | Pexp_field (e, lid) ->\n          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)\n      | Pexp_setfield (e1, lid, e2) ->\n          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)\n            (sub.expr sub e2)\n      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_ifthenelse (e1, e2, e3) ->\n          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n            (map_opt (sub.expr sub) e3)\n      | Pexp_sequence (e1, e2) ->\n          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_while (e1, e2) ->\n          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_for (p, e1, e2, d, e3) ->\n          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d\n            (sub.expr sub e3)\n      | Pexp_coerce (e, t1, t2) ->\n          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)\n            (sub.typ sub t2)\n      | Pexp_constraint (e, t) ->\n          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)\n      | Pexp_send (e, s) ->\n          send ~loc ~attrs (sub.expr sub e) (map_loc sub s)\n      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)\n      | Pexp_setinstvar (s, e) ->\n          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_override sel ->\n          override ~loc ~attrs\n            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)\n      | Pexp_letmodule (s, me, e) ->\n          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)\n            (sub.expr sub e)\n      | Pexp_letexception (cd, e) ->\n          letexception ~loc ~attrs\n            (sub.extension_constructor sub cd)\n            (sub.expr sub e)\n      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_poly (e, t) ->\n          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)\n      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)\n      | Pexp_newtype (s, e) ->\n          newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)\n      | Pexp_open (ovf, lid, e) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)\n      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pexp_unreachable -> unreachable ~loc ~attrs ()\n  end\n\n  module P = struct\n    (* Patterns *)\n\n    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =\n      let open Pat in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ppat_any -> any ~loc ~attrs ()\n      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)\n      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)\n      | Ppat_constant c -> constant ~loc ~attrs c\n      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2\n      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_construct (l, p) ->\n          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)\n      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)\n      | Ppat_record (lpl, cf) ->\n          record ~loc ~attrs\n                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf\n      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)\n      | Ppat_constraint (p, t) ->\n          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)\n      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)\n      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)\n      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)\n      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module CE = struct\n    (* Value expressions for the class language *)\n\n    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =\n      let open Cl in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcl_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcl_structure s ->\n          structure ~loc ~attrs (sub.class_structure sub s)\n      | Pcl_fun (lab, e, p, ce) ->\n          fun_ ~loc ~attrs lab\n            (map_opt (sub.expr sub) e)\n            (sub.pat sub p)\n            (sub.class_expr sub ce)\n      | Pcl_apply (ce, l) ->\n          apply ~loc ~attrs (sub.class_expr sub ce)\n            (List.map (map_snd (sub.expr sub)) l)\n      | Pcl_let (r, vbs, ce) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.class_expr sub ce)\n      | Pcl_constraint (ce, ct) ->\n          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)\n      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_kind sub = function\n      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)\n      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)\n\n    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =\n      let open Cf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcf_inherit (o, ce, s) ->\n          inherit_ ~loc ~attrs o (sub.class_expr sub ce)\n            (map_opt (map_loc sub) s)\n      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)\n      | Pcf_method (s, p, k) ->\n          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)\n      | Pcf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)\n      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure sub {pcstr_self; pcstr_fields} =\n      {\n        pcstr_self = sub.pat sub pcstr_self;\n        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;\n      }\n\n    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;\n                           pci_loc; pci_attributes} =\n      Ci.mk\n       ~virt:pci_virt\n       ~params:(List.map (map_fst (sub.typ sub)) pl)\n        (map_loc sub pci_name)\n        (f pci_expr)\n        ~loc:(sub.location sub pci_loc)\n        ~attrs:(sub.attributes sub pci_attributes)\n  end\n\n  (* Now, a generic AST mapper, to be extended to cover all kinds and\n     cases of the OCaml grammar.  The default behavior of the mapper is\n     the identity. *)\n\n  let default_mapper =\n    {\n      structure = (fun this l -> List.map (this.structure_item this) l);\n      structure_item = M.map_structure_item;\n      module_expr = M.map;\n      signature = (fun this l -> List.map (this.signature_item this) l);\n      signature_item = MT.map_signature_item;\n      module_type = MT.map;\n      with_constraint = MT.map_with_constraint;\n      class_declaration =\n        (fun this -> CE.class_infos this (this.class_expr this));\n      class_expr = CE.map;\n      class_field = CE.map_field;\n      class_structure = CE.map_structure;\n      class_type = CT.map;\n      class_type_field = CT.map_field;\n      class_signature = CT.map_signature;\n      class_type_declaration =\n        (fun this -> CE.class_infos this (this.class_type this));\n      class_description =\n        (fun this -> CE.class_infos this (this.class_type this));\n      type_declaration = T.map_type_declaration;\n      type_kind = T.map_type_kind;\n      typ = T.map;\n      type_extension = T.map_type_extension;\n      extension_constructor = T.map_extension_constructor;\n      value_description =\n        (fun this {pval_name; pval_type; pval_prim; pval_loc;\n                   pval_attributes} ->\n          Val.mk\n            (map_loc this pval_name)\n            (this.typ this pval_type)\n            ~attrs:(this.attributes this pval_attributes)\n            ~loc:(this.location this pval_loc)\n            ~prim:pval_prim\n        );\n\n      pat = P.map;\n      expr = E.map;\n\n      module_declaration =\n        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->\n           Md.mk\n             (map_loc this pmd_name)\n             (this.module_type this pmd_type)\n             ~attrs:(this.attributes this pmd_attributes)\n             ~loc:(this.location this pmd_loc)\n        );\n\n      module_type_declaration =\n        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->\n           Mtd.mk\n             (map_loc this pmtd_name)\n             ?typ:(map_opt (this.module_type this) pmtd_type)\n             ~attrs:(this.attributes this pmtd_attributes)\n             ~loc:(this.location this pmtd_loc)\n        );\n\n      module_binding =\n        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->\n           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)\n             ~attrs:(this.attributes this pmb_attributes)\n             ~loc:(this.location this pmb_loc)\n        );\n\n\n      open_description =\n        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->\n           Opn.mk (map_loc this popen_lid)\n             ~override:popen_override\n             ~loc:(this.location this popen_loc)\n             ~attrs:(this.attributes this popen_attributes)\n        );\n\n\n      include_description =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_type this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n      include_declaration =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_expr this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n\n      value_binding =\n        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->\n           Vb.mk\n             (this.pat this pvb_pat)\n             (this.expr this pvb_expr)\n             ~loc:(this.location this pvb_loc)\n             ~attrs:(this.attributes this pvb_attributes)\n        );\n\n\n      constructor_declaration =\n        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->\n          Type.constructor\n            (map_loc this pcd_name)\n            ~args:(T.map_constructor_arguments this pcd_args)\n            ?res:(map_opt (this.typ this) pcd_res)\n            ~loc:(this.location this pcd_loc)\n            ~attrs:(this.attributes this pcd_attributes)\n        );\n\n      label_declaration =\n        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->\n           Type.field\n             (map_loc this pld_name)\n             (this.typ this pld_type)\n             ~mut:pld_mutable\n             ~loc:(this.location this pld_loc)\n             ~attrs:(this.attributes this pld_attributes)\n        );\n\n      cases = (fun this l -> List.map (this.case this) l);\n      case =\n        (fun this {pc_lhs; pc_guard; pc_rhs} ->\n           {\n             pc_lhs = this.pat this pc_lhs;\n             pc_guard = map_opt (this.expr this) pc_guard;\n             pc_rhs = this.expr this pc_rhs;\n           }\n        );\n\n\n\n      location = (fun _this l -> l);\n\n      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attributes = (fun this l -> List.map (this.attribute this) l);\n      payload =\n        (fun this -> function\n           | PStr x -> PStr (this.structure this x)\n           | PSig x -> PSig (this.signature this x)\n           | PTyp x -> PTyp (this.typ this x)\n           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)\n        );\n    }\n\n  let rec extension_of_error {loc; msg; if_highlight; sub} =\n    { loc; txt = \"ocaml.error\" },\n    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));\n           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @\n          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))\n\n  let attribute_of_warning loc s =\n    { loc; txt = \"ocaml.ppwarning\" },\n    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])\n\nend\n\nmodule Outcometree = struct\n  (* Module [Outcometree]: results displayed by the toplevel *)\n\n  (* These types represent messages that the toplevel displays as normal\n     results or errors. The real displaying is customisable using the hooks:\n        [Toploop.print_out_value]\n        [Toploop.print_out_type]\n        [Toploop.print_out_sig_item]\n        [Toploop.print_out_phrase] *)\n\n  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =\n    | Oide_apply of out_ident * out_ident\n    | Oide_dot of out_ident * string\n    | Oide_ident of string\n\n  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =\n    { oattr_name: string }\n\n  type out_value (*IF_CURRENT = Outcometree.out_value *) =\n    | Oval_array of out_value list\n    | Oval_char of char\n    | Oval_constr of out_ident * out_value list\n    | Oval_ellipsis\n    | Oval_float of float\n    | Oval_int of int\n    | Oval_int32 of int32\n    | Oval_int64 of int64\n    | Oval_nativeint of nativeint\n    | Oval_list of out_value list\n    | Oval_printer of (Format.formatter -> unit)\n    | Oval_record of (out_ident * out_value) list\n    | Oval_string of string\n    | Oval_stuff of string\n    | Oval_tuple of out_value list\n    | Oval_variant of string * out_value option\n\n  type out_type (*IF_CURRENT = Outcometree.out_type *) =\n    | Otyp_abstract\n    | Otyp_open\n    | Otyp_alias of out_type * string\n    | Otyp_arrow of string * out_type * out_type\n    | Otyp_class of bool * out_ident * out_type list\n    | Otyp_constr of out_ident * out_type list\n    | Otyp_manifest of out_type * out_type\n    | Otyp_object of (string * out_type) list * bool option\n    | Otyp_record of (string * bool * out_type) list\n    | Otyp_stuff of string\n    | Otyp_sum of (string * out_type list * out_type option) list\n    | Otyp_tuple of out_type list\n    | Otyp_var of bool * string\n    | Otyp_variant of\n        bool * out_variant * bool * (string list) option\n    | Otyp_poly of string list * out_type\n    | Otyp_module of string * string list * out_type list\n    | Otyp_attribute of out_type * out_attribute\n\n  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =\n    | Ovar_fields of (string * bool * out_type list) list\n    | Ovar_typ of out_type\n\n  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =\n    | Octy_constr of out_ident * out_type list\n    | Octy_arrow of string * out_type * out_class_type\n    | Octy_signature of out_type option * out_class_sig_item list\n  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =\n    | Ocsg_constraint of out_type * out_type\n    | Ocsg_method of string * bool * bool * out_type\n    | Ocsg_value of string * bool * bool * out_type\n\n  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =\n    | Omty_abstract\n    | Omty_functor of string * out_module_type option * out_module_type\n    | Omty_ident of out_ident\n    | Omty_signature of out_sig_item list\n    | Omty_alias of out_ident\n  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =\n    | Osig_class of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_class_type of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_typext of out_extension_constructor * out_ext_status\n    | Osig_modtype of string * out_module_type\n    | Osig_module of string * out_module_type * out_rec_status\n    | Osig_type of out_type_decl * out_rec_status\n    | Osig_value of out_val_decl\n    | Osig_ellipsis\n  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =\n    { otype_name: string;\n      otype_params: (string * (bool * bool)) list;\n      otype_type: out_type;\n      otype_private: Asttypes.private_flag;\n      otype_immediate: bool;\n      otype_unboxed: bool;\n      otype_cstrs: (out_type * out_type) list }\n  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =\n    { oext_name: string;\n      oext_type_name: string;\n      oext_type_params: string list;\n      oext_args: out_type list;\n      oext_ret_type: out_type option;\n      oext_private: Asttypes.private_flag }\n  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =\n    { otyext_name: string;\n      otyext_params: string list;\n      otyext_constructors: (string * out_type list * out_type option) list;\n      otyext_private: Asttypes.private_flag }\n  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =\n    { oval_name: string;\n      oval_type: out_type;\n      oval_prims: string list;\n      oval_attributes: out_attribute list }\n  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =\n    | Orec_not\n    | Orec_first\n    | Orec_next\n  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =\n    | Oext_first\n    | Oext_next\n    | Oext_exception\n\n  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =\n    | Ophr_eval of out_value * out_type\n    | Ophr_signature of (out_sig_item * out_value option) list\n    | Ophr_exception of (exn * out_value)\n\nend\n\nmodule Config = struct\n  let ast_impl_magic_number = \"Caml1999M020\"\n  let ast_intf_magic_number = \"Caml1999N018\"\nend\n\nlet map_signature mapper = mapper.Ast_mapper.signature mapper\nlet map_structure mapper = mapper.Ast_mapper.structure mapper\n\nlet shallow_identity =\n  let id _ x = x in\n  {\n    Ast_mapper.\n    structure               = id;\n    structure_item          = id;\n    module_expr             = id;\n    signature               = id;\n    signature_item          = id;\n    module_type             = id;\n    with_constraint         = id;\n    class_declaration       = id;\n    class_expr              = id;\n    class_field             = id;\n    class_structure         = id;\n    class_type              = id;\n    class_type_field        = id;\n    class_signature         = id;\n    class_type_declaration  = id;\n    class_description       = id;\n    type_declaration        = id;\n    type_kind               = id;\n    typ                     = id;\n    type_extension          = id;\n    extension_constructor   = id;\n    value_description       = id;\n    pat                     = id;\n    expr                    = id;\n    module_declaration      = id;\n    module_type_declaration = id;\n    module_binding          = id;\n    open_description        = id;\n    include_description     = id;\n    include_declaration     = id;\n    value_binding           = id;\n    constructor_declaration = id;\n    label_declaration       = id;\n    cases                   = id;\n    case                    = id;\n    location                = id;\n    extension               = id;\n    attribute               = id;\n    attributes              = id;\n    payload                 = id;\n  }\n\nlet failing_mapper =\n  let fail _ _ =\n    invalid_arg \"failing_mapper: this mapper function should never get called\"\n  in\n  {\n    Ast_mapper.\n    structure               = fail;\n    structure_item          = fail;\n    module_expr             = fail;\n    signature               = fail;\n    signature_item          = fail;\n    module_type             = fail;\n    with_constraint         = fail;\n    class_declaration       = fail;\n    class_expr              = fail;\n    class_field             = fail;\n    class_structure         = fail;\n    class_type              = fail;\n    class_type_field        = fail;\n    class_signature         = fail;\n    class_type_declaration  = fail;\n    class_description       = fail;\n    type_declaration        = fail;\n    type_kind               = fail;\n    typ                     = fail;\n    type_extension          = fail;\n    extension_constructor   = fail;\n    value_description       = fail;\n    pat                     = fail;\n    expr                    = fail;\n    module_declaration      = fail;\n    module_type_declaration = fail;\n    module_binding          = fail;\n    open_description        = fail;\n    include_description     = fail;\n    include_declaration     = fail;\n    value_binding           = fail;\n    constructor_declaration = fail;\n    label_declaration       = fail;\n    cases                   = fail;\n    case                    = fail;\n    location                = fail;\n    extension               = fail;\n    attribute               = fail;\n    attributes              = fail;\n    payload                 = fail;\n  }\n\nlet make_top_mapper ~signature ~structure =\n  {failing_mapper with Ast_mapper.\n                    signature = (fun _ x -> signature x);\n                    structure = (fun _ x -> structure x) }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*            Jérémie Dimino and Leo White, Jane Street Europe            *)\n(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)\n(*                         Alain Frisch, LexiFi                           *)\n(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Ast ported on Mon Aug 21 18:16:29 CEST 2017\n   OCaml trunk was:\n     commit 3ea80c98ceb8bcf845e618ccf9b5512ecfee3853\n     Merge: 14f142b18 e61e8740a\n     Author: Florian Angeletti <octa@polychoron.fr>\n     Date:   Mon Aug 21 12:42:37 2017 +0200\n\n         Merge pull request #1299 from gasche/cleanup-changes\n\n         minor Changes cleanup\n*)\n\nmodule Location = Location\nmodule Longident = Longident\n\nmodule Asttypes = struct\n  (** Auxiliary AST types used by parsetree and typedtree. *)\n\n  type constant (*IF_CURRENT = Asttypes.constant *) =\n      Const_int of int\n    | Const_char of char\n    | Const_string of string * string option\n    | Const_float of string\n    | Const_int32 of int32\n    | Const_int64 of int64\n    | Const_nativeint of nativeint\n\n  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive\n\n  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto\n\n  (* Order matters, used in polymorphic comparison *)\n  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public\n\n  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable\n\n  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete\n\n  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh\n\n  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open\n\n  type label = string\n\n  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =\n      Nolabel\n    | Labelled of string (*  label:T -> ... *)\n    | Optional of string (* ?label:T -> ... *)\n\n  type 'a loc = 'a Location.loc = {\n    txt : 'a;\n    loc : Location.t;\n  }\n\n\n  type variance (*IF_CURRENT = Asttypes.variance *) =\n    | Covariant\n    | Contravariant\n    | Invariant\nend\n\nmodule Parsetree = struct\n  (** Abstract syntax tree produced by parsing *)\n\n  open Asttypes\n\n  type constant (*IF_CURRENT = Parsetree.constant *) =\n      Pconst_integer of string * char option\n    (* 3 3l 3L 3n\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker\n    *)\n    | Pconst_char of char\n    (* 'c' *)\n    | Pconst_string of string * string option\n    (* \"constant\"\n       {delim|other constant|delim}\n    *)\n    | Pconst_float of string * char option\n    (* 3.4 2e5 1.4e-4\n\n       Suffixes [g-z][G-Z] are accepted by the parser.\n       Suffixes are rejected by the typechecker.\n    *)\n\n  (** {2 Extension points} *)\n\n  type attribute = string loc * payload\n         (* [@id ARG]\n            [@@id ARG]\n\n            Metadata containers passed around within the AST.\n            The compiler ignores unknown attributes.\n         *)\n\n  and extension = string loc * payload\n        (* [%id ARG]\n           [%%id ARG]\n\n           Sub-language placeholder -- rejected by the typechecker.\n        *)\n\n  and attributes = attribute list\n\n  and payload (*IF_CURRENT = Parsetree.payload *) =\n    | PStr of structure\n    | PSig of signature (* : SIG *)\n    | PTyp of core_type  (* : T *)\n    | PPat of pattern * expression option  (* ? P  or  ? P when E *)\n\n  (** {2 Core language} *)\n\n  (* Type expressions *)\n\n  and core_type (*IF_CURRENT = Parsetree.core_type *) =\n      {\n       ptyp_desc: core_type_desc;\n       ptyp_loc: Location.t;\n       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =\n    | Ptyp_any\n          (*  _ *)\n    | Ptyp_var of string\n          (* 'a *)\n    | Ptyp_arrow of arg_label * core_type * core_type\n          (* T1 -> T2       Simple\n             ~l:T1 -> T2    Labelled\n             ?l:T1 -> T2    Optional\n           *)\n    | Ptyp_tuple of core_type list\n          (* T1 * ... * Tn\n\n             Invariant: n >= 2\n          *)\n    | Ptyp_constr of Longident.t loc * core_type list\n          (* tconstr\n             T tconstr\n             (T1, ..., Tn) tconstr\n           *)\n    | Ptyp_object of object_field list * closed_flag\n          (* < l1:T1; ...; ln:Tn >     (flag = Closed)\n             < l1:T1; ...; ln:Tn; .. > (flag = Open)\n           *)\n    | Ptyp_class of Longident.t loc * core_type list\n          (* #tconstr\n             T #tconstr\n             (T1, ..., Tn) #tconstr\n           *)\n    | Ptyp_alias of core_type * string\n          (* T as 'a *)\n    | Ptyp_variant of row_field list * closed_flag * label list option\n          (* [ `A|`B ]         (flag = Closed; labels = None)\n             [> `A|`B ]        (flag = Open;   labels = None)\n             [< `A|`B ]        (flag = Closed; labels = Some [])\n             [< `A|`B > `X `Y ](flag = Closed; labels = Some [\"X\";\"Y\"])\n           *)\n    | Ptyp_poly of string loc list * core_type\n          (* 'a1 ... 'an. T\n\n             Can only appear in the following context:\n\n             - As the core_type of a Ppat_constraint node corresponding\n               to a constraint on a let-binding: let x : 'a1 ... 'an. T\n               = e ...\n\n             - Under Cfk_virtual for methods (not values).\n\n             - As the core_type of a Pctf_method node.\n\n             - As the core_type of a Pexp_poly node.\n\n             - As the pld_type field of a label_declaration.\n\n             - As a core_type of a Ptyp_object node.\n           *)\n\n    | Ptyp_package of package_type\n          (* (module S) *)\n    | Ptyp_extension of extension\n          (* [%id] *)\n\n  and package_type = Longident.t loc * (Longident.t loc * core_type) list\n        (*\n          (module S)\n          (module S with type t1 = T1 and ... and tn = Tn)\n         *)\n\n  and row_field (*IF_CURRENT = Parsetree.row_field *) =\n    | Rtag of label loc * attributes * bool * core_type list\n          (* [`A]                   ( true,  [] )\n             [`A of T]              ( false, [T] )\n             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )\n             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )\n\n            - The 2nd field is true if the tag contains a\n              constant (empty) constructor.\n            - '&' occurs when several types are used for the same constructor\n              (see 4.2 in the manual)\n\n            - TODO: switch to a record representation, and keep location\n          *)\n    | Rinherit of core_type\n          (* [ T ] *)\n\n  and object_field (*IF_CURRENT = Parsetree.object_field *) =\n    | Otag of label loc * attributes * core_type\n    | Oinherit of core_type\n\n  (* Patterns *)\n\n  and pattern (*IF_CURRENT = Parsetree.pattern *) =\n      {\n       ppat_desc: pattern_desc;\n       ppat_loc: Location.t;\n       ppat_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =\n    | Ppat_any\n          (* _ *)\n    | Ppat_var of string loc\n          (* x *)\n    | Ppat_alias of pattern * string loc\n          (* P as 'a *)\n    | Ppat_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Ppat_interval of constant * constant\n          (* 'a'..'z'\n\n             Other forms of interval are recognized by the parser\n             but rejected by the type-checker. *)\n    | Ppat_tuple of pattern list\n          (* (P1, ..., Pn)\n\n             Invariant: n >= 2\n          *)\n    | Ppat_construct of Longident.t loc * pattern option\n          (* C                None\n             C P              Some P\n             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])\n           *)\n    | Ppat_variant of label * pattern option\n          (* `A             (None)\n             `A P           (Some P)\n           *)\n    | Ppat_record of (Longident.t loc * pattern) list * closed_flag\n          (* { l1=P1; ...; ln=Pn }     (flag = Closed)\n             { l1=P1; ...; ln=Pn; _}   (flag = Open)\n\n             Invariant: n > 0\n           *)\n    | Ppat_array of pattern list\n          (* [| P1; ...; Pn |] *)\n    | Ppat_or of pattern * pattern\n          (* P1 | P2 *)\n    | Ppat_constraint of pattern * core_type\n          (* (P : T) *)\n    | Ppat_type of Longident.t loc\n          (* #tconst *)\n    | Ppat_lazy of pattern\n          (* lazy P *)\n    | Ppat_unpack of string loc\n          (* (module P)\n             Note: (module P : S) is represented as\n             Ppat_constraint(Ppat_unpack, Ptyp_package)\n           *)\n    | Ppat_exception of pattern\n          (* exception P *)\n    | Ppat_extension of extension\n          (* [%id] *)\n    | Ppat_open of Longident.t loc * pattern\n          (* M.(P) *)\n\n  (* Value expressions *)\n\n  and expression (*IF_CURRENT = Parsetree.expression *) =\n      {\n       pexp_desc: expression_desc;\n       pexp_loc: Location.t;\n       pexp_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =\n    | Pexp_ident of Longident.t loc\n          (* x\n             M.x\n           *)\n    | Pexp_constant of constant\n          (* 1, 'a', \"true\", 1.0, 1l, 1L, 1n *)\n    | Pexp_let of rec_flag * value_binding list * expression\n          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)\n           *)\n    | Pexp_function of case list\n          (* function P1 -> E1 | ... | Pn -> En *)\n    | Pexp_fun of arg_label * expression option * pattern * expression\n          (* fun P -> E1                          (Simple, None)\n             fun ~l:P -> E1                       (Labelled l, None)\n             fun ?l:P -> E1                       (Optional l, None)\n             fun ?l:(P = E0) -> E1                (Optional l, Some E0)\n\n             Notes:\n             - If E0 is provided, only Optional is allowed.\n             - \"fun P1 P2 .. Pn -> E1\" is represented as nested Pexp_fun.\n             - \"let f P = E\" is represented using Pexp_fun.\n           *)\n    | Pexp_apply of expression * (arg_label * expression) list\n          (* E0 ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pexp_match of expression * case list\n          (* match E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_try of expression * case list\n          (* try E0 with P1 -> E1 | ... | Pn -> En *)\n    | Pexp_tuple of expression list\n          (* (E1, ..., En)\n\n             Invariant: n >= 2\n          *)\n    | Pexp_construct of Longident.t loc * expression option\n          (* C                None\n             C E              Some E\n             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])\n          *)\n    | Pexp_variant of label * expression option\n          (* `A             (None)\n             `A E           (Some E)\n           *)\n    | Pexp_record of (Longident.t loc * expression) list * expression option\n          (* { l1=P1; ...; ln=Pn }     (None)\n             { E0 with l1=P1; ...; ln=Pn }   (Some E0)\n\n             Invariant: n > 0\n           *)\n    | Pexp_field of expression * Longident.t loc\n          (* E.l *)\n    | Pexp_setfield of expression * Longident.t loc * expression\n          (* E1.l <- E2 *)\n    | Pexp_array of expression list\n          (* [| E1; ...; En |] *)\n    | Pexp_ifthenelse of expression * expression * expression option\n          (* if E1 then E2 else E3 *)\n    | Pexp_sequence of expression * expression\n          (* E1; E2 *)\n    | Pexp_while of expression * expression\n          (* while E1 do E2 done *)\n    | Pexp_for of\n        pattern *  expression * expression * direction_flag * expression\n          (* for i = E1 to E2 do E3 done      (flag = Upto)\n             for i = E1 downto E2 do E3 done  (flag = Downto)\n           *)\n    | Pexp_constraint of expression * core_type\n          (* (E : T) *)\n    | Pexp_coerce of expression * core_type option * core_type\n          (* (E :> T)        (None, T)\n             (E : T0 :> T)   (Some T0, T)\n           *)\n    | Pexp_send of expression * label loc\n          (*  E # m *)\n    | Pexp_new of Longident.t loc\n          (* new M.c *)\n    | Pexp_setinstvar of label loc * expression\n          (* x <- 2 *)\n    | Pexp_override of (label loc * expression) list\n          (* {< x1 = E1; ...; Xn = En >} *)\n    | Pexp_letmodule of string loc * module_expr * expression\n          (* let module M = ME in E *)\n    | Pexp_letexception of extension_constructor * expression\n          (* let exception C in E *)\n    | Pexp_assert of expression\n          (* assert E\n             Note: \"assert false\" is treated in a special way by the\n             type-checker. *)\n    | Pexp_lazy of expression\n          (* lazy E *)\n    | Pexp_poly of expression * core_type option\n          (* Used for method bodies.\n\n             Can only be used as the expression under Cfk_concrete\n             for methods (not values). *)\n    | Pexp_object of class_structure\n          (* object ... end *)\n    | Pexp_newtype of string loc * expression\n          (* fun (type t) -> E *)\n    | Pexp_pack of module_expr\n          (* (module ME)\n\n             (module ME : S) is represented as\n             Pexp_constraint(Pexp_pack, Ptyp_package S) *)\n    | Pexp_open of override_flag * Longident.t loc * expression\n          (* M.(E)\n             let open M in E\n             let! open M in E *)\n    | Pexp_extension of extension\n          (* [%id] *)\n    | Pexp_unreachable\n          (* . *)\n\n  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)\n      {\n       pc_lhs: pattern;\n       pc_guard: expression option;\n       pc_rhs: expression;\n      }\n\n  (* Value descriptions *)\n\n  and value_description (*IF_CURRENT = Parsetree.value_description *) =\n      {\n       pval_name: string loc;\n       pval_type: core_type;\n       pval_prim: string list;\n       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n       pval_loc: Location.t;\n      }\n\n  (*\n    val x: T                            (prim = [])\n    external x: T = \"s1\" ... \"sn\"       (prim = [\"s1\";...\"sn\"])\n  *)\n\n  (* Type declarations *)\n\n  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =\n      {\n       ptype_name: string loc;\n       ptype_params: (core_type * variance) list;\n             (* ('a1,...'an) t; None represents  _*)\n       ptype_cstrs: (core_type * core_type * Location.t) list;\n             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)\n       ptype_kind: type_kind;\n       ptype_private: private_flag;   (* = private ... *)\n       ptype_manifest: core_type option;  (* = T *)\n       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n       ptype_loc: Location.t;\n      }\n\n  (*\n    type t                     (abstract, no manifest)\n    type t = T0                (abstract, manifest=T0)\n    type t = C of T | ...      (variant,  no manifest)\n    type t = T0 = C of T | ... (variant,  manifest=T0)\n    type t = {l: T; ...}       (record,   no manifest)\n    type t = T0 = {l : T; ...} (record,   manifest=T0)\n    type t = ..                (open,     no manifest)\n  *)\n\n  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =\n    | Ptype_abstract\n    | Ptype_variant of constructor_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_record of label_declaration list\n          (* Invariant: non-empty list *)\n    | Ptype_open\n\n  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =\n      {\n       pld_name: string loc;\n       pld_mutable: mutable_flag;\n       pld_type: core_type;\n       pld_loc: Location.t;\n       pld_attributes: attributes; (* l [@id1] [@id2] : T *)\n      }\n\n  (*  { ...; l: T; ... }            (mutable=Immutable)\n      { ...; mutable l: T; ... }    (mutable=Mutable)\n\n      Note: T can be a Ptyp_poly.\n  *)\n\n  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =\n      {\n       pcd_name: string loc;\n       pcd_args: constructor_arguments;\n       pcd_res: core_type option;\n       pcd_loc: Location.t;\n       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =\n    | Pcstr_tuple of core_type list\n    | Pcstr_record of label_declaration list\n\n  (*\n    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])\n    | C: T0                  (res = Some T0, args = [])\n    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)\n    | C of {...}             (res = None,    args = Pcstr_record)\n    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)\n    | C of {...} as t        (res = None,    args = Pcstr_record)\n  *)\n\n  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =\n      {\n       ptyext_path: Longident.t loc;\n       ptyext_params: (core_type * variance) list;\n       ptyext_constructors: extension_constructor list;\n       ptyext_private: private_flag;\n       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)\n      }\n  (*\n    type t += ...\n  *)\n\n  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =\n      {\n       pext_name: string loc;\n       pext_kind : extension_constructor_kind;\n       pext_loc : Location.t;\n       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)\n      }\n\n  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =\n      Pext_decl of constructor_arguments * core_type option\n        (*\n           | C of T1 * ... * Tn     ([T1; ...; Tn], None)\n           | C: T0                  ([], Some T0)\n           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)\n         *)\n    | Pext_rebind of Longident.t loc\n        (*\n           | C = D\n         *)\n\n  (** {2 Class language} *)\n\n  (* Type expressions for the class language *)\n\n  and class_type (*IF_CURRENT = Parsetree.class_type *) =\n      {\n       pcty_desc: class_type_desc;\n       pcty_loc: Location.t;\n       pcty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =\n    | Pcty_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcty_signature of class_signature\n          (* object ... end *)\n    | Pcty_arrow of arg_label * core_type * class_type\n          (* T -> CT       Simple\n             ~l:T -> CT    Labelled l\n             ?l:T -> CT    Optional l\n           *)\n    | Pcty_extension of extension\n          (* [%id] *)\n    | Pcty_open of override_flag * Longident.t loc * class_type\n          (* let open M in CT *)\n\n\n  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =\n      {\n       pcsig_self: core_type;\n       pcsig_fields: class_type_field list;\n      }\n  (* object('selfpat) ... end\n     object ... end             (self = Ptyp_any)\n   *)\n\n  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =\n      {\n       pctf_desc: class_type_field_desc;\n       pctf_loc: Location.t;\n       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =\n    | Pctf_inherit of class_type\n          (* inherit CT *)\n    | Pctf_val of (label loc * mutable_flag * virtual_flag * core_type)\n          (* val x: T *)\n    | Pctf_method  of (label loc * private_flag * virtual_flag * core_type)\n          (* method x: T\n\n             Note: T can be a Ptyp_poly.\n           *)\n    | Pctf_constraint  of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pctf_attribute of attribute\n          (* [@@@id] *)\n    | Pctf_extension of extension\n          (* [%%id] *)\n\n  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =\n      {\n       pci_virt: virtual_flag;\n       pci_params: (core_type * variance) list;\n       pci_name: string loc;\n       pci_expr: 'a;\n       pci_loc: Location.t;\n       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)\n      }\n  (* class c = ...\n     class ['a1,...,'an] c = ...\n     class virtual c = ...\n\n     Also used for \"class type\" declaration.\n  *)\n\n  and class_description = class_type class_infos\n\n  and class_type_declaration = class_type class_infos\n\n  (* Value expressions for the class language *)\n\n  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =\n      {\n       pcl_desc: class_expr_desc;\n       pcl_loc: Location.t;\n       pcl_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =\n    | Pcl_constr of Longident.t loc * core_type list\n          (* c\n             ['a1, ..., 'an] c *)\n    | Pcl_structure of class_structure\n          (* object ... end *)\n    | Pcl_fun of arg_label * expression option * pattern * class_expr\n          (* fun P -> CE                          (Simple, None)\n             fun ~l:P -> CE                       (Labelled l, None)\n             fun ?l:P -> CE                       (Optional l, None)\n             fun ?l:(P = E0) -> CE                (Optional l, Some E0)\n           *)\n    | Pcl_apply of class_expr * (arg_label * expression) list\n          (* CE ~l1:E1 ... ~ln:En\n             li can be empty (non labeled argument) or start with '?'\n             (optional argument).\n\n             Invariant: n > 0\n           *)\n    | Pcl_let of rec_flag * value_binding list * class_expr\n          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)\n           *)\n    | Pcl_constraint of class_expr * class_type\n          (* (CE : CT) *)\n    | Pcl_extension of extension\n    (* [%id] *)\n    | Pcl_open of override_flag * Longident.t loc * class_expr\n    (* let open M in CE *)\n\n\n  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =\n      {\n       pcstr_self: pattern;\n       pcstr_fields: class_field list;\n      }\n  (* object(selfpat) ... end\n     object ... end           (self = Ppat_any)\n   *)\n\n  and class_field (*IF_CURRENT = Parsetree.class_field *) =\n      {\n       pcf_desc: class_field_desc;\n       pcf_loc: Location.t;\n       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)\n      }\n\n  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =\n    | Pcf_inherit of override_flag * class_expr * string loc option\n          (* inherit CE\n             inherit CE as x\n             inherit! CE\n             inherit! CE as x\n           *)\n    | Pcf_val of (label loc * mutable_flag * class_field_kind)\n          (* val x = E\n             val virtual x: T\n           *)\n    | Pcf_method of (label loc * private_flag * class_field_kind)\n          (* method x = E            (E can be a Pexp_poly)\n             method virtual x: T     (T can be a Ptyp_poly)\n           *)\n    | Pcf_constraint of (core_type * core_type)\n          (* constraint T1 = T2 *)\n    | Pcf_initializer of expression\n          (* initializer E *)\n    | Pcf_attribute of attribute\n          (* [@@@id] *)\n    | Pcf_extension of extension\n          (* [%%id] *)\n\n  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =\n    | Cfk_virtual of core_type\n    | Cfk_concrete of override_flag * expression\n\n  and class_declaration = class_expr class_infos\n\n  (** {2 Module language} *)\n\n  (* Type expressions for the module language *)\n\n  and module_type (*IF_CURRENT = Parsetree.module_type *) =\n      {\n       pmty_desc: module_type_desc;\n       pmty_loc: Location.t;\n       pmty_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =\n    | Pmty_ident of Longident.t loc\n          (* S *)\n    | Pmty_signature of signature\n          (* sig ... end *)\n    | Pmty_functor of string loc * module_type option * module_type\n          (* functor(X : MT1) -> MT2 *)\n    | Pmty_with of module_type * with_constraint list\n          (* MT with ... *)\n    | Pmty_typeof of module_expr\n          (* module type of ME *)\n    | Pmty_extension of extension\n          (* [%id] *)\n    | Pmty_alias of Longident.t loc\n          (* (module M) *)\n\n  and signature = signature_item list\n\n  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =\n      {\n       psig_desc: signature_item_desc;\n       psig_loc: Location.t;\n      }\n\n  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =\n    | Psig_value of value_description\n          (*\n            val x: T\n            external x: T = \"s1\" ... \"sn\"\n           *)\n    | Psig_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Psig_typext of type_extension\n          (* type t1 += ... *)\n    | Psig_exception of extension_constructor\n          (* exception C of T *)\n    | Psig_module of module_declaration\n          (* module X : MT *)\n    | Psig_recmodule of module_declaration list\n          (* module rec X1 : MT1 and ... and Xn : MTn *)\n    | Psig_modtype of module_type_declaration\n          (* module type S = MT\n             module type S *)\n    | Psig_open of open_description\n          (* open X *)\n    | Psig_include of include_description\n          (* include MT *)\n    | Psig_class of class_description list\n          (* class c1 : ... and ... and cn : ... *)\n    | Psig_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Psig_attribute of attribute\n          (* [@@@id] *)\n    | Psig_extension of extension * attributes\n          (* [%%id] *)\n\n  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =\n      {\n       pmd_name: string loc;\n       pmd_type: module_type;\n       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmd_loc: Location.t;\n      }\n  (* S : MT *)\n\n  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =\n      {\n       pmtd_name: string loc;\n       pmtd_type: module_type option;\n       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)\n       pmtd_loc: Location.t;\n      }\n  (* S = MT\n     S       (abstract module type declaration, pmtd_type = None)\n  *)\n\n  and open_description (*IF_CURRENT = Parsetree.open_description *) =\n      {\n       popen_lid: Longident.t loc;\n       popen_override: override_flag;\n       popen_loc: Location.t;\n       popen_attributes: attributes;\n      }\n  (* open! X - popen_override = Override (silences the 'used identifier\n                                shadowing' warning)\n     open  X - popen_override = Fresh\n   *)\n\n  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =\n      {\n       pincl_mod: 'a;\n       pincl_loc: Location.t;\n       pincl_attributes: attributes;\n      }\n\n  and include_description = module_type include_infos\n  (* include MT *)\n\n  and include_declaration = module_expr include_infos\n  (* include ME *)\n\n  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =\n    | Pwith_type of Longident.t loc * type_declaration\n          (* with type X.t = ...\n\n             Note: the last component of the longident must match\n             the name of the type_declaration. *)\n    | Pwith_module of Longident.t loc * Longident.t loc\n          (* with module X.Y = Z *)\n    | Pwith_typesubst of type_declaration\n          (* with type t := ... *)\n    | Pwith_modsubst of string loc * Longident.t loc\n          (* with module X := Z *)\n\n  (* Value expressions for the module language *)\n\n  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =\n      {\n       pmod_desc: module_expr_desc;\n       pmod_loc: Location.t;\n       pmod_attributes: attributes; (* ... [@id1] [@id2] *)\n      }\n\n  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =\n    | Pmod_ident of Longident.t loc\n          (* X *)\n    | Pmod_structure of structure\n          (* struct ... end *)\n    | Pmod_functor of string loc * module_type option * module_expr\n          (* functor(X : MT1) -> ME *)\n    | Pmod_apply of module_expr * module_expr\n          (* ME1(ME2) *)\n    | Pmod_constraint of module_expr * module_type\n          (* (ME : MT) *)\n    | Pmod_unpack of expression\n          (* (val E) *)\n    | Pmod_extension of extension\n          (* [%id] *)\n\n  and structure = structure_item list\n\n  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =\n      {\n       pstr_desc: structure_item_desc;\n       pstr_loc: Location.t;\n      }\n\n  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =\n    | Pstr_eval of expression * attributes\n          (* E *)\n    | Pstr_value of rec_flag * value_binding list\n          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)\n             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)\n           *)\n    | Pstr_primitive of value_description\n          (*  val x: T\n              external x: T = \"s1\" ... \"sn\" *)\n    | Pstr_type of rec_flag * type_declaration list\n          (* type t1 = ... and ... and tn = ... *)\n    | Pstr_typext of type_extension\n          (* type t1 += ... *)\n    | Pstr_exception of extension_constructor\n          (* exception C of T\n             exception C = M.X *)\n    | Pstr_module of module_binding\n          (* module X = ME *)\n    | Pstr_recmodule of module_binding list\n          (* module rec X1 = ME1 and ... and Xn = MEn *)\n    | Pstr_modtype of module_type_declaration\n          (* module type S = MT *)\n    | Pstr_open of open_description\n          (* open X *)\n    | Pstr_class of class_declaration list\n          (* class c1 = ... and ... and cn = ... *)\n    | Pstr_class_type of class_type_declaration list\n          (* class type ct1 = ... and ... and ctn = ... *)\n    | Pstr_include of include_declaration\n          (* include ME *)\n    | Pstr_attribute of attribute\n          (* [@@@id] *)\n    | Pstr_extension of extension * attributes\n          (* [%%id] *)\n\n  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =\n    {\n      pvb_pat: pattern;\n      pvb_expr: expression;\n      pvb_attributes: attributes;\n      pvb_loc: Location.t;\n    }\n\n  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =\n      {\n       pmb_name: string loc;\n       pmb_expr: module_expr;\n       pmb_attributes: attributes;\n       pmb_loc: Location.t;\n      }\n  (* X = ME *)\n\n  (** {2 Toplevel} *)\n\n  (* Toplevel phrases *)\n\n  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =\n    | Ptop_def of structure\n    | Ptop_dir of string * directive_argument\n       (* #use, #load ... *)\n\n  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =\n    | Pdir_none\n    | Pdir_string of string\n    | Pdir_int of string * char option\n    | Pdir_ident of Longident.t\n    | Pdir_bool of bool\n\nend\n\nmodule Docstrings : sig\n  (** {3 Docstrings} *)\n\n  (** Documentation comments *)\n  type docstring\n\n  (** Create a docstring *)\n  val docstring : string -> Location.t -> docstring\n\n  (** Get the text of a docstring *)\n  val docstring_body : docstring -> string\n\n  (** Get the location of a docstring *)\n  val docstring_loc : docstring -> Location.t\n\n  (** {3 Items}\n\n      The {!docs} type represents documentation attached to an item. *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  val empty_docs : docs\n\n  val docs_attr : docstring -> Parsetree.attribute\n\n  (** Convert item documentation to attributes and add them to an\n      attribute list *)\n  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Fields and constructors}\n\n      The {!info} type represents documentation attached to a field or\n      constructor. *)\n\n  type info = docstring option\n\n  val empty_info : info\n\n  val info_attr : docstring -> Parsetree.attribute\n\n  (** Convert field info to attributes and add them to an\n      attribute list *)\n  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes\n\n  (** {3 Unattached comments}\n\n      The {!text} type represents documentation which is not attached to\n      anything. *)\n\n  type text = docstring list\n\n  val empty_text : text\n\n  val text_attr : docstring -> Parsetree.attribute\n\n  (** Convert text to attributes and add them to an attribute list *)\n  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes\n\nend = struct\n  open Location\n\n  (* Docstrings *)\n\n  type docstring =\n    { ds_body: string;\n      ds_loc: Location.t;\n    }\n\n  (* Docstring constructors and destructors *)\n\n  let docstring body loc =\n    let ds =\n      { ds_body = body;\n        ds_loc = loc;\n      }\n    in\n    ds\n\n  let docstring_body ds = ds.ds_body\n\n  let docstring_loc ds = ds.ds_loc\n\n  (* Docstrings attached to items *)\n\n  type docs =\n    { docs_pre: docstring option;\n      docs_post: docstring option; }\n\n  let empty_docs = { docs_pre = None; docs_post = None }\n\n  let doc_loc = {txt = \"ocaml.doc\"; loc = Location.none}\n\n  let docs_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (doc_loc, PStr [item])\n\n  let add_docs_attrs docs attrs =\n    let attrs =\n      match docs.docs_pre with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> docs_attr ds :: attrs\n    in\n    let attrs =\n      match docs.docs_post with\n      | None | Some { ds_body=\"\"; _ } -> attrs\n      | Some ds -> attrs @ [docs_attr ds]\n    in\n    attrs\n\n  (* Docstrings attached to constructors or fields *)\n\n  type info = docstring option\n\n  let empty_info = None\n\n  let info_attr = docs_attr\n\n  let add_info_attrs info attrs =\n    match info with\n    | None | Some {ds_body=\"\"; _} -> attrs\n    | Some ds -> attrs @ [info_attr ds]\n\n  (* Docstrings not attached to a specific item *)\n\n  type text = docstring list\n\n  let empty_text = []\n\n  let text_loc = {txt = \"ocaml.text\"; loc = Location.none}\n\n  let text_attr ds =\n    let open Parsetree in\n    let exp =\n      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));\n        pexp_loc = ds.ds_loc;\n        pexp_attributes = []; }\n    in\n    let item =\n      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }\n    in\n      (text_loc, PStr [item])\n\n  let add_text_attrs dsl attrs =\n    let fdsl = List.filter (function {ds_body=\"\"; _} -> false| _ ->true) dsl in\n    (List.map text_attr fdsl) @ attrs\n\nend\n\nmodule Ast_helper : sig\n\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Docstrings\n  open Parsetree\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  (** {2 Default locations} *)\n\n  val default_loc: loc ref\n      (** Default value for all optional location arguments. *)\n\n  val with_default_loc: loc -> (unit -> 'a) -> 'a\n      (** Set the [default_loc] within the scope of the execution\n          of the provided function. *)\n\n  (** {2 Constants} *)\n\n  module Const : sig\n    val char : char -> constant\n    val string : ?quotation_delimiter:string -> string -> constant\n    val integer : ?suffix:char -> string -> constant\n    val int : ?suffix:char -> int -> constant\n    val int32 : ?suffix:char -> int32 -> constant\n    val int64 : ?suffix:char -> int64 -> constant\n    val nativeint : ?suffix:char -> nativeint -> constant\n    val float : ?suffix:char -> string -> constant\n  end\n\n  (** {2 Core language} *)\n\n  (** Type expressions *)\n  module Typ :\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type\n      val attr: core_type -> attribute -> core_type\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type\n      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type\n                 -> core_type\n      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val object_: ?loc:loc -> ?attrs:attrs -> object_field list\n                     -> closed_flag -> core_type\n      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type\n      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type\n      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag\n                   -> label list option -> core_type\n      val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type\n      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list\n                   -> core_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type\n\n      val force_poly: core_type -> core_type\n\n      val varify_constructors: str list -> core_type -> core_type\n      (** [varify_constructors newtypes te] is type expression [te], of which\n          any of nullary type constructor [tc] is replaced by type variable of\n          the same name, if [tc]'s name appears in [newtypes].\n          Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]\n          appears in [newtypes].\n          @since 4.05\n       *)\n    end\n\n  (** Patterns *)\n  module Pat:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern\n      val attr:pattern -> attribute -> pattern\n\n      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern\n      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern\n      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern\n      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag\n                  -> pattern\n      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern\n      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern\n      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern\n      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern\n      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern\n      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern\n      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern\n    end\n\n  (** Expressions *)\n  module Exp:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression\n      val attr: expression -> attribute -> expression\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list\n                -> expression -> expression\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option\n                -> pattern -> expression -> expression\n      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression\n      val apply: ?loc:loc -> ?attrs:attrs -> expression\n                 -> (arg_label * expression) list -> expression\n      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list\n                  -> expression\n      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression\n      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option\n                     -> expression\n      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option\n                   -> expression\n      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list\n                  -> expression option -> expression\n      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression\n                    -> expression\n      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression\n      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                      -> expression option -> expression\n      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                    -> expression\n      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n                  -> expression\n      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression\n                -> direction_flag -> expression -> expression\n      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                  -> core_type -> expression\n      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type\n                       -> expression\n      val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression\n      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression\n      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list\n                    -> expression\n      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression\n                     -> expression\n      val letexception:\n        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression\n        -> expression\n      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression\n      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option\n                -> expression\n      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression\n      val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression\n      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression\n                 -> expression\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression\n      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression\n\n      val case: pattern -> ?guard:expression -> expression -> case\n    end\n\n  (** Value declarations *)\n  module Val:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        ?prim:string list -> str -> core_type -> value_description\n    end\n\n  (** Type declarations *)\n  module Type:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?params:(core_type * variance) list ->\n        ?cstrs:(core_type * core_type * loc) list ->\n        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->\n        type_declaration\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        constructor_declaration\n      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->\n        ?mut:mutable_flag -> str -> core_type -> label_declaration\n    end\n\n  (** Type extensions *)\n  module Te:\n    sig\n      val mk: ?attrs:attrs -> ?docs:docs ->\n        ?params:(core_type * variance) list -> ?priv:private_flag ->\n        lid -> extension_constructor list -> type_extension\n\n      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> extension_constructor_kind -> extension_constructor\n\n      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        ?args:constructor_arguments -> ?res:core_type -> str ->\n        extension_constructor\n      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->\n        str -> lid -> extension_constructor\n    end\n\n  (** {2 Module language} *)\n\n  (** Module type expressions *)\n  module Mty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type\n      val attr: module_type -> attribute -> module_type\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type\n      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_type -> module_type\n      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->\n        with_constraint list -> module_type\n      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type\n    end\n\n  (** Module expressions *)\n  module Mod:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr\n      val attr: module_expr -> attribute -> module_expr\n\n      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr\n      val functor_: ?loc:loc -> ?attrs:attrs ->\n        str -> module_type option -> module_expr -> module_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->\n        module_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->\n        module_expr\n      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr\n    end\n\n  (** Signature items *)\n  module Sig:\n    sig\n      val mk: ?loc:loc -> signature_item_desc -> signature_item\n\n      val value: ?loc:loc -> value_description -> signature_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item\n      val type_extension: ?loc:loc -> type_extension -> signature_item\n      val exception_: ?loc:loc -> extension_constructor -> signature_item\n      val module_: ?loc:loc -> module_declaration -> signature_item\n      val rec_module: ?loc:loc -> module_declaration list -> signature_item\n      val modtype: ?loc:loc -> module_type_declaration -> signature_item\n      val open_: ?loc:loc -> open_description -> signature_item\n      val include_: ?loc:loc -> include_description -> signature_item\n      val class_: ?loc:loc -> class_description list -> signature_item\n      val class_type: ?loc:loc -> class_type_declaration list -> signature_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item\n      val attribute: ?loc:loc -> attribute -> signature_item\n      val text: text -> signature_item list\n    end\n\n  (** Structure items *)\n  module Str:\n    sig\n      val mk: ?loc:loc -> structure_item_desc -> structure_item\n\n      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item\n      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item\n      val primitive: ?loc:loc -> value_description -> structure_item\n      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item\n      val type_extension: ?loc:loc -> type_extension -> structure_item\n      val exception_: ?loc:loc -> extension_constructor -> structure_item\n      val module_: ?loc:loc -> module_binding -> structure_item\n      val rec_module: ?loc:loc -> module_binding list -> structure_item\n      val modtype: ?loc:loc -> module_type_declaration -> structure_item\n      val open_: ?loc:loc -> open_description -> structure_item\n      val class_: ?loc:loc -> class_declaration list -> structure_item\n      val class_type: ?loc:loc -> class_type_declaration list -> structure_item\n      val include_: ?loc:loc -> include_declaration -> structure_item\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item\n      val attribute: ?loc:loc -> attribute -> structure_item\n      val text: text -> structure_item list\n    end\n\n  (** Module declarations *)\n  module Md:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_type -> module_declaration\n    end\n\n  (** Module type declarations *)\n  module Mtd:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?typ:module_type -> str -> module_type_declaration\n    end\n\n  (** Module bindings *)\n  module Mb:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        str -> module_expr -> module_binding\n    end\n\n  (** Opens *)\n  module Opn:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->\n        ?override:override_flag -> lid -> open_description\n    end\n\n  (** Includes *)\n  module Incl:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos\n    end\n\n  (** Value bindings *)\n  module Vb:\n    sig\n      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        pattern -> expression -> value_binding\n    end\n\n\n  (** {2 Class language} *)\n\n  (** Class type expressions *)\n  module Cty:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type\n      val attr: class_type -> attribute -> class_type\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type\n      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type\n      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->\n        class_type -> class_type\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_type\n                 -> class_type\n    end\n\n  (** Class type fields *)\n  module Ctf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->\n        class_type_field_desc -> class_type_field\n      val attr: class_type_field -> attribute -> class_type_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        virtual_flag -> core_type -> class_type_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_type_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field\n      val attribute: ?loc:loc -> attribute -> class_type_field\n      val text: text -> class_type_field list\n    end\n\n  (** Class expressions *)\n  module Cl:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr\n      val attr: class_expr -> attribute -> class_expr\n\n      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr\n      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr\n      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->\n        pattern -> class_expr -> class_expr\n      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->\n        (arg_label * expression) list -> class_expr\n      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->\n        class_expr -> class_expr\n      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->\n        class_expr\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr\n      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_expr\n                 -> class_expr\n    end\n\n  (** Class fields *)\n  module Cf:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->\n        class_field\n      val attr: class_field -> attribute -> class_field\n\n      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->\n        str option -> class_field\n      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->\n        class_field_kind -> class_field\n      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->\n        class_field_kind -> class_field\n      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->\n        class_field\n      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field\n      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field\n      val attribute: ?loc:loc -> attribute -> class_field\n      val text: text -> class_field list\n\n      val virtual_: core_type -> class_field_kind\n      val concrete: override_flag -> expression -> class_field_kind\n\n    end\n\n  (** Classes *)\n  module Ci:\n    sig\n      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->\n        ?virt:virtual_flag -> ?params:(core_type * variance) list ->\n        str -> 'a -> 'a class_infos\n    end\n\n  (** Class signatures *)\n  module Csig:\n    sig\n      val mk: core_type -> class_type_field list -> class_signature\n    end\n\n  (** Class structures *)\n  module Cstr:\n    sig\n      val mk: pattern -> class_field list -> class_structure\n    end\n\nend = struct\n  (** Helpers to produce Parsetree fragments *)\n\n  open Asttypes\n  open Parsetree\n  open Docstrings\n\n  type lid = Longident.t loc\n  type str = string loc\n  type loc = Location.t\n  type attrs = attribute list\n\n  let default_loc = ref Location.none\n\n  let with_default_loc l f =\n    let old = !default_loc in\n    default_loc := l;\n    try let r = f () in default_loc := old; r\n    with exn -> default_loc := old; raise exn\n\n  module Const = struct\n    let integer ?suffix i = Pconst_integer (i, suffix)\n    let int ?suffix i = integer ?suffix (string_of_int i)\n    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)\n    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)\n    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)\n    let float ?suffix f = Pconst_float (f, suffix)\n    let char c = Pconst_char c\n    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)\n  end\n\n  module Typ = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}\n    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))\n    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))\n    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))\n    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))\n    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)\n\n    let force_poly t =\n      match t.ptyp_desc with\n      | Ptyp_poly _ -> t\n      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)\n\n    let varify_constructors var_names t =\n      let check_variable vl loc v =\n        if List.mem v vl then\n          raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in\n      let var_names = List.map (fun v -> v.txt) var_names in\n      let rec loop t =\n        let desc =\n          match t.ptyp_desc with\n          | Ptyp_any -> Ptyp_any\n          | Ptyp_var x ->\n              check_variable var_names t.ptyp_loc x;\n              Ptyp_var x\n          | Ptyp_arrow (label,core_type,core_type') ->\n              Ptyp_arrow(label, loop core_type, loop core_type')\n          | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)\n          | Ptyp_constr( { txt = Longident.Lident s; _ }, [])\n            when List.mem s var_names ->\n              Ptyp_var s\n          | Ptyp_constr(longident, lst) ->\n              Ptyp_constr(longident, List.map loop lst)\n          | Ptyp_object (lst, o) ->\n              Ptyp_object (List.map loop_object_field lst, o)\n          | Ptyp_class (longident, lst) ->\n              Ptyp_class (longident, List.map loop lst)\n          | Ptyp_alias(core_type, string) ->\n              check_variable var_names t.ptyp_loc string;\n              Ptyp_alias(loop core_type, string)\n          | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->\n              Ptyp_variant(List.map loop_row_field row_field_list,\n                           flag, lbl_lst_option)\n          | Ptyp_poly(string_lst, core_type) ->\n            List.iter (fun v ->\n              check_variable var_names t.ptyp_loc v.txt) string_lst;\n              Ptyp_poly(string_lst, loop core_type)\n          | Ptyp_package(longident,lst) ->\n              Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)\n          | Ptyp_extension (s, arg) ->\n              Ptyp_extension (s, arg)\n        in\n        {t with ptyp_desc = desc}\n      and loop_row_field  =\n        function\n          | Rtag(label,attrs,flag,lst) ->\n              Rtag(label,attrs,flag,List.map loop lst)\n          | Rinherit t ->\n              Rinherit (loop t)\n      and loop_object_field =\n        function\n          | Otag(label, attrs, t) ->\n              Otag(label, attrs, loop t)\n          | Oinherit t ->\n              Oinherit (loop t)\n      in\n      loop t\n\n  end\n\n  module Pat = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}\n    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}\n\n    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any\n    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)\n    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)\n    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)\n    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))\n    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)\n    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)\n    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))\n    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)\n  end\n\n  module Exp = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}\n    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)\n    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))\n    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))\n    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))\n    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))\n    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)\n    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))\n    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))\n    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))\n    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))\n    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))\n    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)\n    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))\n    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))\n    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))\n    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))\n    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))\n    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))\n    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)\n    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))\n    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)\n    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))\n    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))\n    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)\n    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)\n    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))\n    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)\n    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))\n    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)\n    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable\n\n    let case lhs ?guard rhs =\n      {\n       pc_lhs = lhs;\n       pc_guard = guard;\n       pc_rhs = rhs;\n      }\n  end\n\n  module Mty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}\n    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}\n\n    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)\n    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)\n    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))\n    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))\n    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)\n  end\n\n  module Mod = struct\n  let mk ?(loc = !default_loc) ?(attrs = []) d =\n    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}\n    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}\n\n    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)\n    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)\n    let functor_ ?loc ?attrs arg arg_ty body =\n      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))\n    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))\n    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))\n    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)\n  end\n\n  module Sig = struct\n    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}\n\n    let value ?loc a = mk ?loc (Psig_value a)\n    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Psig_typext a)\n    let exception_ ?loc a = mk ?loc (Psig_exception a)\n    let module_ ?loc a = mk ?loc (Psig_module a)\n    let rec_module ?loc a = mk ?loc (Psig_recmodule a)\n    let modtype ?loc a = mk ?loc (Psig_modtype a)\n    let open_ ?loc a = mk ?loc (Psig_open a)\n    let include_ ?loc a = mk ?loc (Psig_include a)\n    let class_ ?loc a = mk ?loc (Psig_class a)\n    let class_type ?loc a = mk ?loc (Psig_class_type a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Psig_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Str = struct\n    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}\n\n    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))\n    let value ?loc a b = mk ?loc (Pstr_value (a, b))\n    let primitive ?loc a = mk ?loc (Pstr_primitive a)\n    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))\n    let type_extension ?loc a = mk ?loc (Pstr_typext a)\n    let exception_ ?loc a = mk ?loc (Pstr_exception a)\n    let module_ ?loc a = mk ?loc (Pstr_module a)\n    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)\n    let modtype ?loc a = mk ?loc (Pstr_modtype a)\n    let open_ ?loc a = mk ?loc (Pstr_open a)\n    let class_ ?loc a = mk ?loc (Pstr_class a)\n    let class_type ?loc a = mk ?loc (Pstr_class_type a)\n    let include_ ?loc a = mk ?loc (Pstr_include a)\n    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))\n    let attribute ?loc a = mk ?loc (Pstr_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n  end\n\n  module Cl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcl_desc = d;\n       pcl_loc = loc;\n       pcl_attributes = attrs;\n      }\n    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))\n    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)\n    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))\n    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))\n    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_open (a, b, c))\n  end\n\n  module Cty = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) d =\n      {\n       pcty_desc = d;\n       pcty_loc = loc;\n       pcty_attributes = attrs;\n      }\n    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}\n\n    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))\n    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)\n    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)\n    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_open (a, b, c))\n  end\n\n  module Ctf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n             ?(docs = empty_docs) d =\n      {\n       pctf_desc = d;\n       pctf_loc = loc;\n       pctf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)\n    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))\n    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)\n    let attribute ?loc a = mk ?loc (Pctf_attribute a)\n    let text txt =\n     let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n       List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}\n\n  end\n\n  module Cf = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) d =\n      {\n       pcf_desc = d;\n       pcf_loc = loc;\n       pcf_attributes = add_docs_attrs docs attrs;\n      }\n\n    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))\n    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))\n    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))\n    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))\n    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)\n    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)\n    let attribute ?loc a = mk ?loc (Pcf_attribute a)\n    let text txt =\n      let f_txt = List.filter (fun ds -> docstring_body ds <> \"\") txt in\n      List.map\n        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))\n        f_txt\n\n    let virtual_ ct = Cfk_virtual ct\n    let concrete o e = Cfk_concrete (o, e)\n\n    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}\n\n  end\n\n  module Val = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(prim = []) name typ =\n      {\n       pval_name = name;\n       pval_type = typ;\n       pval_attributes = add_docs_attrs docs attrs;\n       pval_loc = loc;\n       pval_prim = prim;\n      }\n  end\n\n  module Md = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name typ =\n      {\n       pmd_name = name;\n       pmd_type = typ;\n       pmd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmd_loc = loc;\n      }\n  end\n\n  module Mtd = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) ?typ name =\n      {\n       pmtd_name = name;\n       pmtd_type = typ;\n       pmtd_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmtd_loc = loc;\n      }\n  end\n\n  module Mb = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = []) name expr =\n      {\n       pmb_name = name;\n       pmb_expr = expr;\n       pmb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pmb_loc = loc;\n      }\n  end\n\n  module Opn = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(override = Fresh) lid =\n      {\n       popen_lid = lid;\n       popen_override = override;\n       popen_loc = loc;\n       popen_attributes = add_docs_attrs docs attrs;\n      }\n  end\n\n  module Incl = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =\n      {\n       pincl_mod = mexpr;\n       pincl_loc = loc;\n       pincl_attributes = add_docs_attrs docs attrs;\n      }\n\n  end\n\n  module Vb = struct\n    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n          ?(text = []) pat expr =\n      {\n       pvb_pat = pat;\n       pvb_expr = expr;\n       pvb_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pvb_loc = loc;\n      }\n  end\n\n  module Ci = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n          ?(virt = Concrete) ?(params = []) name expr =\n      {\n       pci_virt = virt;\n       pci_params = params;\n       pci_name = name;\n       pci_expr = expr;\n       pci_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       pci_loc = loc;\n      }\n  end\n\n  module Type = struct\n    let mk ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(text = [])\n        ?(params = [])\n        ?(cstrs = [])\n        ?(kind = Ptype_abstract)\n        ?(priv = Public)\n        ?manifest\n        name =\n      {\n       ptype_name = name;\n       ptype_params = params;\n       ptype_cstrs = cstrs;\n       ptype_kind = kind;\n       ptype_private = priv;\n       ptype_manifest = manifest;\n       ptype_attributes =\n         add_text_attrs text (add_docs_attrs docs attrs);\n       ptype_loc = loc;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(args = Pcstr_tuple []) ?res name =\n      {\n       pcd_name = name;\n       pcd_args = args;\n       pcd_res = res;\n       pcd_loc = loc;\n       pcd_attributes = add_info_attrs info attrs;\n      }\n\n    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)\n          ?(mut = Immutable) name typ =\n      {\n       pld_name = name;\n       pld_mutable = mut;\n       pld_type = typ;\n       pld_loc = loc;\n       pld_attributes = add_info_attrs info attrs;\n      }\n\n  end\n\n  (** Type extensions *)\n  module Te = struct\n    let mk ?(attrs = []) ?(docs = empty_docs)\n          ?(params = []) ?(priv = Public) path constructors =\n      {\n       ptyext_path = path;\n       ptyext_params = params;\n       ptyext_constructors = constructors;\n       ptyext_private = priv;\n       ptyext_attributes = add_docs_attrs docs attrs;\n      }\n\n    let constructor ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name kind =\n      {\n       pext_name = name;\n       pext_kind = kind;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)\n               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =\n      {\n       pext_name = name;\n       pext_kind = Pext_decl(args, res);\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n    let rebind ?(loc = !default_loc) ?(attrs = [])\n          ?(docs = empty_docs) ?(info = empty_info) name lid =\n      {\n       pext_name = name;\n       pext_kind = Pext_rebind lid;\n       pext_loc = loc;\n       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);\n      }\n\n  end\n\n  module Csig = struct\n    let mk self fields =\n      {\n       pcsig_self = self;\n       pcsig_fields = fields;\n      }\n  end\n\n  module Cstr = struct\n    let mk self fields =\n      {\n       pcstr_self = self;\n       pcstr_fields = fields;\n      }\n  end\n\nend\n\nmodule Ast_mapper : sig\n  (** The interface of a -ppx rewriter\n\n    A -ppx rewriter is a program that accepts a serialized abstract syntax\n    tree and outputs another, possibly modified, abstract syntax tree.\n    This module encapsulates the interface between the compiler and\n    the -ppx rewriters, handling such details as the serialization format,\n    forwarding of command-line flags, and storing state.\n\n    {!mapper} allows to implement AST rewriting using open recursion.\n    A typical mapper would be based on {!default_mapper}, a deep\n    identity mapper, and will fall back on it for handling the syntax it\n    does not modify. For example:\n\n    {[\n  open Asttypes\n  open Parsetree\n  open Ast_mapper\n\n  let test_mapper argv =\n    { default_mapper with\n      expr = fun mapper expr ->\n        match expr with\n        | { pexp_desc = Pexp_extension ({ txt = \"test\" }, PStr [])} ->\n          Ast_helper.Exp.constant (Const_int 42)\n        | other -> default_mapper.expr mapper other; }\n\n  let () =\n    register \"ppx_test\" test_mapper]}\n\n    This -ppx rewriter, which replaces [[%test]] in expressions with\n    the constant [42], can be compiled using\n    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].\n\n    *)\n\n  open Parsetree\n\n  (** {2 A generic Parsetree mapper} *)\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n  (** A mapper record implements one \"method\" per syntactic category,\n      using an open recursion style: each method takes as its first\n      argument the mapper to be applied to children in the syntax\n      tree. *)\n\n  val default_mapper: mapper\n  (** A default mapper, which implements a \"deep identity\" mapping. *)\n\n  (** {2 Convenience functions to write mappers} *)\n\n  val map_opt: ('a -> 'b) -> 'a option -> 'b option\n\n  val extension_of_error: Location.error -> extension\n  (** Encode an error into an 'ocaml.error' extension node which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the error. *)\n\n  val attribute_of_warning: Location.t -> string -> attribute\n  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be\n      inserted in a generated Parsetree.  The compiler will be\n      responsible for reporting the warning. *)\n\nend = struct\n  (* A generic Parsetree mapping class *)\n\n  (*\n  [@@@ocaml.warning \"+9\"]\n    (* Ensure that record patterns don't miss any field. *)\n  *)\n\n\n  open Parsetree\n  open Ast_helper\n  open Location\n\n  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {\n    attribute: mapper -> attribute -> attribute;\n    attributes: mapper -> attribute list -> attribute list;\n    case: mapper -> case -> case;\n    cases: mapper -> case list -> case list;\n    class_declaration: mapper -> class_declaration -> class_declaration;\n    class_description: mapper -> class_description -> class_description;\n    class_expr: mapper -> class_expr -> class_expr;\n    class_field: mapper -> class_field -> class_field;\n    class_signature: mapper -> class_signature -> class_signature;\n    class_structure: mapper -> class_structure -> class_structure;\n    class_type: mapper -> class_type -> class_type;\n    class_type_declaration: mapper -> class_type_declaration\n                            -> class_type_declaration;\n    class_type_field: mapper -> class_type_field -> class_type_field;\n    constructor_declaration: mapper -> constructor_declaration\n                             -> constructor_declaration;\n    expr: mapper -> expression -> expression;\n    extension: mapper -> extension -> extension;\n    extension_constructor: mapper -> extension_constructor\n                           -> extension_constructor;\n    include_declaration: mapper -> include_declaration -> include_declaration;\n    include_description: mapper -> include_description -> include_description;\n    label_declaration: mapper -> label_declaration -> label_declaration;\n    location: mapper -> Location.t -> Location.t;\n    module_binding: mapper -> module_binding -> module_binding;\n    module_declaration: mapper -> module_declaration -> module_declaration;\n    module_expr: mapper -> module_expr -> module_expr;\n    module_type: mapper -> module_type -> module_type;\n    module_type_declaration: mapper -> module_type_declaration\n                             -> module_type_declaration;\n    open_description: mapper -> open_description -> open_description;\n    pat: mapper -> pattern -> pattern;\n    payload: mapper -> payload -> payload;\n    signature: mapper -> signature -> signature;\n    signature_item: mapper -> signature_item -> signature_item;\n    structure: mapper -> structure -> structure;\n    structure_item: mapper -> structure_item -> structure_item;\n    typ: mapper -> core_type -> core_type;\n    type_declaration: mapper -> type_declaration -> type_declaration;\n    type_extension: mapper -> type_extension -> type_extension;\n    type_kind: mapper -> type_kind -> type_kind;\n    value_binding: mapper -> value_binding -> value_binding;\n    value_description: mapper -> value_description -> value_description;\n    with_constraint: mapper -> with_constraint -> with_constraint;\n  }\n\n  let map_fst f (x, y) = (f x, y)\n  let map_snd f (x, y) = (x, f y)\n  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)\n  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)\n  let map_opt f = function None -> None | Some x -> Some (f x)\n\n  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}\n\n  module T = struct\n    (* Type expressions for the core language *)\n\n    let row_field sub = function\n      | Rtag (l, attrs, b, tl) ->\n          Rtag (map_loc sub l, sub.attributes sub attrs,\n                b, List.map (sub.typ sub) tl)\n      | Rinherit t -> Rinherit (sub.typ sub t)\n\n    let object_field sub = function\n      | Otag (l, attrs, t) ->\n          Otag (map_loc sub l, sub.attributes sub attrs, sub.typ sub t)\n      | Oinherit t -> Oinherit (sub.typ sub t)\n\n    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =\n      let open Typ in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ptyp_any -> any ~loc ~attrs ()\n      | Ptyp_var s -> var ~loc ~attrs s\n      | Ptyp_arrow (lab, t1, t2) ->\n          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)\n      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)\n      | Ptyp_constr (lid, tl) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_object (l, o) ->\n          object_ ~loc ~attrs (List.map (object_field sub) l) o\n      | Ptyp_class (lid, tl) ->\n          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)\n      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s\n      | Ptyp_variant (rl, b, ll) ->\n          variant ~loc ~attrs (List.map (row_field sub) rl) b ll\n      | Ptyp_poly (sl, t) -> poly ~loc ~attrs\n                               (List.map (map_loc sub) sl) (sub.typ sub t)\n      | Ptyp_package (lid, l) ->\n          package ~loc ~attrs (map_loc sub lid)\n            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)\n      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_type_declaration sub\n        {ptype_name; ptype_params; ptype_cstrs;\n         ptype_kind;\n         ptype_private;\n         ptype_manifest;\n         ptype_attributes;\n         ptype_loc} =\n      Type.mk (map_loc sub ptype_name)\n        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)\n        ~priv:ptype_private\n        ~cstrs:(List.map\n                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))\n                  ptype_cstrs)\n        ~kind:(sub.type_kind sub ptype_kind)\n        ?manifest:(map_opt (sub.typ sub) ptype_manifest)\n        ~loc:(sub.location sub ptype_loc)\n        ~attrs:(sub.attributes sub ptype_attributes)\n\n    let map_type_kind sub = function\n      | Ptype_abstract -> Ptype_abstract\n      | Ptype_variant l ->\n          Ptype_variant (List.map (sub.constructor_declaration sub) l)\n      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)\n      | Ptype_open -> Ptype_open\n\n    let map_constructor_arguments sub = function\n      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)\n      | Pcstr_record l ->\n          Pcstr_record (List.map (sub.label_declaration sub) l)\n\n    let map_type_extension sub\n        {ptyext_path; ptyext_params;\n         ptyext_constructors;\n         ptyext_private;\n         ptyext_attributes} =\n      Te.mk\n        (map_loc sub ptyext_path)\n        (List.map (sub.extension_constructor sub) ptyext_constructors)\n        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)\n        ~priv:ptyext_private\n        ~attrs:(sub.attributes sub ptyext_attributes)\n\n    let map_extension_constructor_kind sub = function\n        Pext_decl(ctl, cto) ->\n          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)\n      | Pext_rebind li ->\n          Pext_rebind (map_loc sub li)\n\n    let map_extension_constructor sub\n        {pext_name;\n         pext_kind;\n         pext_loc;\n         pext_attributes} =\n      Te.constructor\n        (map_loc sub pext_name)\n        (map_extension_constructor_kind sub pext_kind)\n        ~loc:(sub.location sub pext_loc)\n        ~attrs:(sub.attributes sub pext_attributes)\n\n  end\n\n  module CT = struct\n    (* Type expressions for the class language *)\n\n    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =\n      let open Cty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcty_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)\n      | Pcty_arrow (lab, t, ct) ->\n          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)\n      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pcty_open (ovf, lid, ct) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.class_type sub ct)\n\n    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}\n      =\n      let open Ctf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)\n      | Pctf_val (s, m, v, t) ->\n          val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)\n      | Pctf_method (s, p, v, t) ->\n          method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)\n      | Pctf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_signature sub {pcsig_self; pcsig_fields} =\n      Csig.mk\n        (sub.typ sub pcsig_self)\n        (List.map (sub.class_type_field sub) pcsig_fields)\n  end\n\n  module MT = struct\n    (* Type expressions for the module language *)\n\n    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =\n      let open Mty in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)\n      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)\n      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)\n      | Pmty_functor (s, mt1, mt2) ->\n          functor_ ~loc ~attrs (map_loc sub s)\n            (Misc.may_map (sub.module_type sub) mt1)\n            (sub.module_type sub mt2)\n      | Pmty_with (mt, l) ->\n          with_ ~loc ~attrs (sub.module_type sub mt)\n            (List.map (sub.with_constraint sub) l)\n      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)\n      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_with_constraint sub = function\n      | Pwith_type (lid, d) ->\n          Pwith_type (map_loc sub lid, sub.type_declaration sub d)\n      | Pwith_module (lid, lid2) ->\n          Pwith_module (map_loc sub lid, map_loc sub lid2)\n      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)\n      | Pwith_modsubst (s, lid) ->\n          Pwith_modsubst (map_loc sub s, map_loc sub lid)\n\n    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =\n      let open Sig in\n      let loc = sub.location sub loc in\n      match desc with\n      | Psig_value vd -> value ~loc (sub.value_description sub vd)\n      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)\n      | Psig_recmodule l ->\n          rec_module ~loc (List.map (sub.module_declaration sub) l)\n      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Psig_open x -> open_ ~loc (sub.open_description sub x)\n      | Psig_include x -> include_ ~loc (sub.include_description sub x)\n      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)\n      | Psig_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Psig_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n\n  module M = struct\n    (* Value expressions for the module language *)\n\n    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =\n      let open Mod in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)\n      | Pmod_functor (arg, arg_ty, body) ->\n          functor_ ~loc ~attrs (map_loc sub arg)\n            (Misc.may_map (sub.module_type sub) arg_ty)\n            (sub.module_expr sub body)\n      | Pmod_apply (m1, m2) ->\n          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)\n      | Pmod_constraint (m, mty) ->\n          constraint_ ~loc ~attrs (sub.module_expr sub m)\n                      (sub.module_type sub mty)\n      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)\n      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =\n      let open Str in\n      let loc = sub.location sub loc in\n      match desc with\n      | Pstr_eval (x, attrs) ->\n          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)\n      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)\n      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)\n      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)\n      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)\n      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)\n      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)\n      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)\n      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)\n      | Pstr_open x -> open_ ~loc (sub.open_description sub x)\n      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)\n      | Pstr_class_type l ->\n          class_type ~loc (List.map (sub.class_type_declaration sub) l)\n      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)\n      | Pstr_extension (x, attrs) ->\n          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)\n      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)\n  end\n\n  module E = struct\n    (* Value expressions for the core language *)\n\n    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =\n      let open Exp in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)\n      | Pexp_constant x -> constant ~loc ~attrs x\n      | Pexp_let (r, vbs, e) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.expr sub e)\n      | Pexp_fun (lab, def, p, e) ->\n          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)\n            (sub.expr sub e)\n      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)\n      | Pexp_apply (e, l) ->\n          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)\n      | Pexp_match (e, pel) ->\n          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)\n      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_construct (lid, arg) ->\n          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)\n      | Pexp_variant (lab, eo) ->\n          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)\n      | Pexp_record (l, eo) ->\n          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)\n            (map_opt (sub.expr sub) eo)\n      | Pexp_field (e, lid) ->\n          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)\n      | Pexp_setfield (e1, lid, e2) ->\n          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)\n            (sub.expr sub e2)\n      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)\n      | Pexp_ifthenelse (e1, e2, e3) ->\n          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n            (map_opt (sub.expr sub) e3)\n      | Pexp_sequence (e1, e2) ->\n          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_while (e1, e2) ->\n          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)\n      | Pexp_for (p, e1, e2, d, e3) ->\n          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d\n            (sub.expr sub e3)\n      | Pexp_coerce (e, t1, t2) ->\n          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)\n            (sub.typ sub t2)\n      | Pexp_constraint (e, t) ->\n          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)\n      | Pexp_send (e, s) ->\n          send ~loc ~attrs (sub.expr sub e) (map_loc sub s)\n      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)\n      | Pexp_setinstvar (s, e) ->\n          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_override sel ->\n          override ~loc ~attrs\n            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)\n      | Pexp_letmodule (s, me, e) ->\n          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)\n            (sub.expr sub e)\n      | Pexp_letexception (cd, e) ->\n          letexception ~loc ~attrs\n            (sub.extension_constructor sub cd)\n            (sub.expr sub e)\n      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)\n      | Pexp_poly (e, t) ->\n          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)\n      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)\n      | Pexp_newtype (s, e) ->\n          newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)\n      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)\n      | Pexp_open (ovf, lid, e) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)\n      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pexp_unreachable -> unreachable ~loc ~attrs ()\n  end\n\n  module P = struct\n    (* Patterns *)\n\n    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =\n      let open Pat in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Ppat_any -> any ~loc ~attrs ()\n      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)\n      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)\n      | Ppat_constant c -> constant ~loc ~attrs c\n      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2\n      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_construct (l, p) ->\n          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)\n      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)\n      | Ppat_record (lpl, cf) ->\n          record ~loc ~attrs\n                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf\n      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)\n      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)\n      | Ppat_constraint (p, t) ->\n          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)\n      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)\n      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)\n      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)\n      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)\n      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)\n  end\n\n  module CE = struct\n    (* Value expressions for the class language *)\n\n    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =\n      let open Cl in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcl_constr (lid, tys) ->\n          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)\n      | Pcl_structure s ->\n          structure ~loc ~attrs (sub.class_structure sub s)\n      | Pcl_fun (lab, e, p, ce) ->\n          fun_ ~loc ~attrs lab\n            (map_opt (sub.expr sub) e)\n            (sub.pat sub p)\n            (sub.class_expr sub ce)\n      | Pcl_apply (ce, l) ->\n          apply ~loc ~attrs (sub.class_expr sub ce)\n            (List.map (map_snd (sub.expr sub)) l)\n      | Pcl_let (r, vbs, ce) ->\n          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)\n            (sub.class_expr sub ce)\n      | Pcl_constraint (ce, ct) ->\n          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)\n      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)\n      | Pcl_open (ovf, lid, ce) ->\n          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.class_expr sub ce)\n\n    let map_kind sub = function\n      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)\n      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)\n\n    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =\n      let open Cf in\n      let loc = sub.location sub loc in\n      let attrs = sub.attributes sub attrs in\n      match desc with\n      | Pcf_inherit (o, ce, s) ->\n          inherit_ ~loc ~attrs o (sub.class_expr sub ce)\n            (map_opt (map_loc sub) s)\n      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)\n      | Pcf_method (s, p, k) ->\n          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)\n      | Pcf_constraint (t1, t2) ->\n          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)\n      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)\n      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)\n      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)\n\n    let map_structure sub {pcstr_self; pcstr_fields} =\n      {\n        pcstr_self = sub.pat sub pcstr_self;\n        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;\n      }\n\n    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;\n                           pci_loc; pci_attributes} =\n      Ci.mk\n       ~virt:pci_virt\n       ~params:(List.map (map_fst (sub.typ sub)) pl)\n        (map_loc sub pci_name)\n        (f pci_expr)\n        ~loc:(sub.location sub pci_loc)\n        ~attrs:(sub.attributes sub pci_attributes)\n  end\n\n  (* Now, a generic AST mapper, to be extended to cover all kinds and\n     cases of the OCaml grammar.  The default behavior of the mapper is\n     the identity. *)\n\n  let default_mapper =\n    {\n      structure = (fun this l -> List.map (this.structure_item this) l);\n      structure_item = M.map_structure_item;\n      module_expr = M.map;\n      signature = (fun this l -> List.map (this.signature_item this) l);\n      signature_item = MT.map_signature_item;\n      module_type = MT.map;\n      with_constraint = MT.map_with_constraint;\n      class_declaration =\n        (fun this -> CE.class_infos this (this.class_expr this));\n      class_expr = CE.map;\n      class_field = CE.map_field;\n      class_structure = CE.map_structure;\n      class_type = CT.map;\n      class_type_field = CT.map_field;\n      class_signature = CT.map_signature;\n      class_type_declaration =\n        (fun this -> CE.class_infos this (this.class_type this));\n      class_description =\n        (fun this -> CE.class_infos this (this.class_type this));\n      type_declaration = T.map_type_declaration;\n      type_kind = T.map_type_kind;\n      typ = T.map;\n      type_extension = T.map_type_extension;\n      extension_constructor = T.map_extension_constructor;\n      value_description =\n        (fun this {pval_name; pval_type; pval_prim; pval_loc;\n                   pval_attributes} ->\n          Val.mk\n            (map_loc this pval_name)\n            (this.typ this pval_type)\n            ~attrs:(this.attributes this pval_attributes)\n            ~loc:(this.location this pval_loc)\n            ~prim:pval_prim\n        );\n\n      pat = P.map;\n      expr = E.map;\n\n      module_declaration =\n        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->\n           Md.mk\n             (map_loc this pmd_name)\n             (this.module_type this pmd_type)\n             ~attrs:(this.attributes this pmd_attributes)\n             ~loc:(this.location this pmd_loc)\n        );\n\n      module_type_declaration =\n        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->\n           Mtd.mk\n             (map_loc this pmtd_name)\n             ?typ:(map_opt (this.module_type this) pmtd_type)\n             ~attrs:(this.attributes this pmtd_attributes)\n             ~loc:(this.location this pmtd_loc)\n        );\n\n      module_binding =\n        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->\n           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)\n             ~attrs:(this.attributes this pmb_attributes)\n             ~loc:(this.location this pmb_loc)\n        );\n\n\n      open_description =\n        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->\n           Opn.mk (map_loc this popen_lid)\n             ~override:popen_override\n             ~loc:(this.location this popen_loc)\n             ~attrs:(this.attributes this popen_attributes)\n        );\n\n\n      include_description =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_type this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n      include_declaration =\n        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->\n           Incl.mk (this.module_expr this pincl_mod)\n             ~loc:(this.location this pincl_loc)\n             ~attrs:(this.attributes this pincl_attributes)\n        );\n\n\n      value_binding =\n        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->\n           Vb.mk\n             (this.pat this pvb_pat)\n             (this.expr this pvb_expr)\n             ~loc:(this.location this pvb_loc)\n             ~attrs:(this.attributes this pvb_attributes)\n        );\n\n\n      constructor_declaration =\n        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->\n          Type.constructor\n            (map_loc this pcd_name)\n            ~args:(T.map_constructor_arguments this pcd_args)\n            ?res:(map_opt (this.typ this) pcd_res)\n            ~loc:(this.location this pcd_loc)\n            ~attrs:(this.attributes this pcd_attributes)\n        );\n\n      label_declaration =\n        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->\n           Type.field\n             (map_loc this pld_name)\n             (this.typ this pld_type)\n             ~mut:pld_mutable\n             ~loc:(this.location this pld_loc)\n             ~attrs:(this.attributes this pld_attributes)\n        );\n\n      cases = (fun this l -> List.map (this.case this) l);\n      case =\n        (fun this {pc_lhs; pc_guard; pc_rhs} ->\n           {\n             pc_lhs = this.pat this pc_lhs;\n             pc_guard = map_opt (this.expr this) pc_guard;\n             pc_rhs = this.expr this pc_rhs;\n           }\n        );\n\n\n\n      location = (fun _this l -> l);\n\n      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));\n      attributes = (fun this l -> List.map (this.attribute this) l);\n      payload =\n        (fun this -> function\n           | PStr x -> PStr (this.structure this x)\n           | PSig x -> PSig (this.signature this x)\n           | PTyp x -> PTyp (this.typ this x)\n           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)\n        );\n    }\n\n  let rec extension_of_error {loc; msg; if_highlight; sub} =\n    { loc; txt = \"ocaml.error\" },\n    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));\n           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @\n          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))\n\n  let attribute_of_warning loc s =\n    { loc; txt = \"ocaml.ppwarning\" },\n    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])\n\nend\n\nmodule Outcometree = struct\n  (* Module [Outcometree]: results displayed by the toplevel *)\n\n  (* These types represent messages that the toplevel displays as normal\n     results or errors. The real displaying is customisable using the hooks:\n        [Toploop.print_out_value]\n        [Toploop.print_out_type]\n        [Toploop.print_out_sig_item]\n        [Toploop.print_out_phrase] *)\n\n  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =\n    | Oide_apply of out_ident * out_ident\n    | Oide_dot of out_ident * string\n    | Oide_ident of string\n\n  type out_string (*IF_CURRENT = Outcometree.out_string *) =\n    | Ostr_string\n    | Ostr_bytes\n\n  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =\n    { oattr_name: string }\n\n  type out_value (*IF_CURRENT = Outcometree.out_value *) =\n    | Oval_array of out_value list\n    | Oval_char of char\n    | Oval_constr of out_ident * out_value list\n    | Oval_ellipsis\n    | Oval_float of float\n    | Oval_int of int\n    | Oval_int32 of int32\n    | Oval_int64 of int64\n    | Oval_nativeint of nativeint\n    | Oval_list of out_value list\n    | Oval_printer of (Format.formatter -> unit)\n    | Oval_record of (out_ident * out_value) list\n    | Oval_string of string * int * out_string (* string, size-to-print, kind *)\n    | Oval_stuff of string\n    | Oval_tuple of out_value list\n    | Oval_variant of string * out_value option\n\n  type out_type (*IF_CURRENT = Outcometree.out_type *) =\n    | Otyp_abstract\n    | Otyp_open\n    | Otyp_alias of out_type * string\n    | Otyp_arrow of string * out_type * out_type\n    | Otyp_class of bool * out_ident * out_type list\n    | Otyp_constr of out_ident * out_type list\n    | Otyp_manifest of out_type * out_type\n    | Otyp_object of (string * out_type) list * bool option\n    | Otyp_record of (string * bool * out_type) list\n    | Otyp_stuff of string\n    | Otyp_sum of (string * out_type list * out_type option) list\n    | Otyp_tuple of out_type list\n    | Otyp_var of bool * string\n    | Otyp_variant of\n        bool * out_variant * bool * (string list) option\n    | Otyp_poly of string list * out_type\n    | Otyp_module of string * string list * out_type list\n    | Otyp_attribute of out_type * out_attribute\n\n  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =\n    | Ovar_fields of (string * bool * out_type list) list\n    | Ovar_typ of out_type\n\n  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =\n    | Octy_constr of out_ident * out_type list\n    | Octy_arrow of string * out_type * out_class_type\n    | Octy_signature of out_type option * out_class_sig_item list\n  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =\n    | Ocsg_constraint of out_type * out_type\n    | Ocsg_method of string * bool * bool * out_type\n    | Ocsg_value of string * bool * bool * out_type\n\n  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =\n    | Omty_abstract\n    | Omty_functor of string * out_module_type option * out_module_type\n    | Omty_ident of out_ident\n    | Omty_signature of out_sig_item list\n    | Omty_alias of out_ident\n  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =\n    | Osig_class of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_class_type of\n        bool * string * (string * (bool * bool)) list * out_class_type *\n          out_rec_status\n    | Osig_typext of out_extension_constructor * out_ext_status\n    | Osig_modtype of string * out_module_type\n    | Osig_module of string * out_module_type * out_rec_status\n    | Osig_type of out_type_decl * out_rec_status\n    | Osig_value of out_val_decl\n    | Osig_ellipsis\n  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =\n    { otype_name: string;\n      otype_params: (string * (bool * bool)) list;\n      otype_type: out_type;\n      otype_private: Asttypes.private_flag;\n      otype_immediate: bool;\n      otype_unboxed: bool;\n      otype_cstrs: (out_type * out_type) list }\n  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =\n    { oext_name: string;\n      oext_type_name: string;\n      oext_type_params: string list;\n      oext_args: out_type list;\n      oext_ret_type: out_type option;\n      oext_private: Asttypes.private_flag }\n  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =\n    { otyext_name: string;\n      otyext_params: string list;\n      otyext_constructors: (string * out_type list * out_type option) list;\n      otyext_private: Asttypes.private_flag }\n  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =\n    { oval_name: string;\n      oval_type: out_type;\n      oval_prims: string list;\n      oval_attributes: out_attribute list }\n  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =\n    | Orec_not\n    | Orec_first\n    | Orec_next\n  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =\n    | Oext_first\n    | Oext_next\n    | Oext_exception\n\n  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =\n    | Ophr_eval of out_value * out_type\n    | Ophr_signature of (out_sig_item * out_value option) list\n    | Ophr_exception of (exn * out_value)\n\nend\n\nmodule Config = struct\n  let ast_impl_magic_number = \"Caml1999M020\"\n  let ast_intf_magic_number = \"Caml1999N018\"\nend\n\nlet map_signature mapper = mapper.Ast_mapper.signature mapper\nlet map_structure mapper = mapper.Ast_mapper.structure mapper\n\nlet shallow_identity =\n  let id _ x = x in\n  {\n    Ast_mapper.\n    structure               = id;\n    structure_item          = id;\n    module_expr             = id;\n    signature               = id;\n    signature_item          = id;\n    module_type             = id;\n    with_constraint         = id;\n    class_declaration       = id;\n    class_expr              = id;\n    class_field             = id;\n    class_structure         = id;\n    class_type              = id;\n    class_type_field        = id;\n    class_signature         = id;\n    class_type_declaration  = id;\n    class_description       = id;\n    type_declaration        = id;\n    type_kind               = id;\n    typ                     = id;\n    type_extension          = id;\n    extension_constructor   = id;\n    value_description       = id;\n    pat                     = id;\n    expr                    = id;\n    module_declaration      = id;\n    module_type_declaration = id;\n    module_binding          = id;\n    open_description        = id;\n    include_description     = id;\n    include_declaration     = id;\n    value_binding           = id;\n    constructor_declaration = id;\n    label_declaration       = id;\n    cases                   = id;\n    case                    = id;\n    location                = id;\n    extension               = id;\n    attribute               = id;\n    attributes              = id;\n    payload                 = id;\n  }\n\nlet failing_mapper =\n  let fail _ _ =\n    invalid_arg \"failing_mapper: this mapper function should never get called\"\n  in\n  {\n    Ast_mapper.\n    structure               = fail;\n    structure_item          = fail;\n    module_expr             = fail;\n    signature               = fail;\n    signature_item          = fail;\n    module_type             = fail;\n    with_constraint         = fail;\n    class_declaration       = fail;\n    class_expr              = fail;\n    class_field             = fail;\n    class_structure         = fail;\n    class_type              = fail;\n    class_type_field        = fail;\n    class_signature         = fail;\n    class_type_declaration  = fail;\n    class_description       = fail;\n    type_declaration        = fail;\n    type_kind               = fail;\n    typ                     = fail;\n    type_extension          = fail;\n    extension_constructor   = fail;\n    value_description       = fail;\n    pat                     = fail;\n    expr                    = fail;\n    module_declaration      = fail;\n    module_type_declaration = fail;\n    module_binding          = fail;\n    open_description        = fail;\n    include_description     = fail;\n    include_declaration     = fail;\n    value_binding           = fail;\n    constructor_declaration = fail;\n    label_declaration       = fail;\n    cases                   = fail;\n    case                    = fail;\n    location                = fail;\n    extension               = fail;\n    attribute               = fail;\n    attributes              = fail;\n    payload                 = fail;\n  }\n\nlet make_top_mapper ~signature ~structure =\n  {failing_mapper with Ast_mapper.\n                    signature = (fun _ x -> signature x);\n                    structure = (fun _ x -> structure x) }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Def = Migrate_parsetree_def\nmodule From = Ast_403\nmodule To = Ast_402\n\nlet inject_predef_option label d =\n  let open To in\n  let open Parsetree in\n  match label with\n  | From.Asttypes.Optional _ ->\n    let loc = {d.ptyp_loc with Location.loc_ghost = true} in\n    let txt = Longident.Ldot (Longident.Lident \"*predef*\", \"option\") in\n    let ident = {Location. txt; loc} in\n    { ptyp_desc = Ptyp_constr(ident,[d]); ptyp_loc = loc; ptyp_attributes = []}\n  | _ -> d\n\nlet from_loc {From.Location. txt = _; loc} = loc\n\nlet migration_error location feature =\n  raise (Def.Migration_error (feature, location))\n\nlet rec copy_expression :\n  From.Parsetree.expression ->\n    To.Parsetree.expression\n  =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc =\n        (copy_expression_desc pexp_loc pexp_desc);\n      To.Parsetree.pexp_loc =\n        (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes =\n        (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc loc :\n  From.Parsetree.expression_desc ->\n    To.Parsetree.expression_desc\n  =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant\n        (copy_constant loc x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), x1)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert\n        (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy\n        (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (x0, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack\n        (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension\n        (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  ->\n      migration_error loc Def.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag ->\n    To.Asttypes.direction_flag\n  =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs =\n        (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs =\n        (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding ->\n    To.Parsetree.value_binding\n  =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat =\n        (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc =\n        (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_loc ppat_desc);\n      To.Parsetree.ppat_loc =\n        (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc loc :\n  From.Parsetree.pattern_desc ->\n    To.Parsetree.pattern_desc\n  =\n  function\n  | From.Parsetree.Ppat_any  ->\n      To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant\n        (copy_constant loc x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant loc x0),\n          (copy_constant loc x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension\n        (copy_extension x0)\n\nand copy_core_type :\n  From.Parsetree.core_type ->\n    To.Parsetree.core_type\n  =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc =\n        (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc ->\n    To.Parsetree.core_type_desc\n  =\n  function\n  | From.Parsetree.Ptyp_any  ->\n      To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 ->\n      To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          inject_predef_option x0 (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (x0, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option\n             (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> x) x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package\n        (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension\n        (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type ->\n    To.Parsetree.package_type\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc\n                copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field ->\n    To.Parsetree.row_field\n  =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit\n        (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes ->\n    To.Parsetree.attributes\n  = fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute ->\n    To.Parsetree.attribute\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload (from_loc x0) x1))\n\nand copy_payload loc :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr\n        (copy_structure x0)\n  | From.Parsetree.PSig _x0 ->\n      migration_error loc Def.PSig\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp\n        (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure ->\n    To.Parsetree.structure\n  = fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item ->\n    To.Parsetree.structure_item\n  =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc =\n        (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type (type_declarations x0 x1)\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration ->\n    To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr ->\n    To.Parsetree.class_expr\n  =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc =\n        (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc ->\n    To.Parsetree.class_expr_desc\n  =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension\n        (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure ->\n    To.Parsetree.class_structure\n  =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field ->\n    To.Parsetree.class_field\n  =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc =\n        (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc ->\n    To.Parsetree.class_field_desc\n  =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> x) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension\n        (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind ->\n    To.Parsetree.class_field_kind\n  =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual\n        (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding ->\n    To.Parsetree.module_binding\n  =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc =\n        (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr ->\n    To.Parsetree.module_expr\n  =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc =\n        (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc ->\n    To.Parsetree.module_expr_desc\n  =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure\n        (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack\n        (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension\n        (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type ->\n    To.Parsetree.module_type\n  =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc =\n        (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc ->\n    To.Parsetree.module_type_desc\n  =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature\n        (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof\n        (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension\n        (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident\n           x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint ->\n    To.Parsetree.with_constraint\n  =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc\n            copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc\n            copy_longident x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc\n             copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature ->\n    To.Parsetree.signature\n  = fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item ->\n    To.Parsetree.signature_item\n  =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc =\n        (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type (type_declarations x0 x1)\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description ->\n    To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type ->\n    To.Parsetree.class_type\n  =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc =\n        (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc ->\n    To.Parsetree.class_type_desc\n  =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          inject_predef_option x0 (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension\n        (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature ->\n    To.Parsetree.class_signature\n  =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field\n           pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field ->\n    To.Parsetree.class_type_field\n  =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc =\n        (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit\n        (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension\n        (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension ->\n    To.Parsetree.extension\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload (from_loc x0) x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos ->\n        'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc =\n          (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag ->\n    To.Asttypes.virtual_flag\n  =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc =\n          (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description ->\n    To.Parsetree.open_description\n  =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident\n           popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc =\n        (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag ->\n    To.Asttypes.override_flag\n  =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc =\n        (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc =\n        (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension ->\n    To.Parsetree.type_extension\n  =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident\n           ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind (from_loc pext_name) pext_kind);\n      To.Parsetree.pext_loc =\n        (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind loc :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments loc x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident\n           x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration ->\n    To.Parsetree.type_declaration\n  =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc =\n        (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag ->\n    To.Asttypes.private_flag\n  =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind ->\n    To.Parsetree.type_kind\n  =\n  function\n  | From.Parsetree.Ptype_abstract  ->\n      To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  ->\n      To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments (from_loc pcd_name) pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc =\n        (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments loc :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.core_type list\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      List.map copy_core_type x0\n  | From.Parsetree.Pcstr_record _x0 ->\n      migration_error loc Def.Pcstr_record\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration ->\n    To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc =\n        (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag ->\n    To.Asttypes.mutable_flag\n  =\n  function\n  | From.Asttypes.Immutable  ->\n      To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  ->\n      To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  ->\n      To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  ->\n      To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description ->\n    To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim =\n        (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc =\n        (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> string\n  =\n  function\n  | From.Asttypes.Nolabel  -> \"\"\n  | From.Asttypes.Labelled x0 -> x0\n  | From.Asttypes.Optional x0 -> \"?\" ^ x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag ->\n    To.Asttypes.closed_flag\n  =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label =\n  fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  ->\n      To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  ->\n      To.Asttypes.Recursive\n\nand copy_constant loc :\n  From.Parsetree.constant -> To.Asttypes.constant\n  =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n     begin match x1 with\n     | None -> To.Asttypes.Const_int (int_of_string x0)\n     | Some 'l' ->\n         To.Asttypes.Const_int32 (Int32.of_string x0)\n     | Some 'L' ->\n         To.Asttypes.Const_int64 (Int64.of_string x0)\n     | Some 'n' ->\n         To.Asttypes.Const_nativeint (Nativeint.of_string x0)\n     | Some _ -> migration_error loc Def.Pconst_integer\n     end\n  | From.Parsetree.Pconst_char x0 ->\n      To.Asttypes.Const_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Asttypes.Const_string (x0,x1)\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      begin match x1 with\n      | None -> To.Asttypes.Const_float x0\n      | Some _ -> migration_error loc Def.Pconst_float\n      end\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident : From.Longident.t -> To.Longident.t = function\n  | From.Longident.Lident x0 ->\n      To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot\n        ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun\n      { From.Asttypes.txt = txt;\n        From.Asttypes.loc = loc }\n       ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = copy_location loc\n      }\n\nand copy_location :\n  From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nand type_declarations recflag types =\n  match\n    (recflag, List.map copy_type_declaration types)\n  with\n  | From.Asttypes.Recursive, types -> types\n  | From.Asttypes.Nonrecursive, [] -> []\n  | From.Asttypes.Nonrecursive, (x :: xs) ->\n      let pos = {Lexing. pos_fname = \"_none_\"; pos_lnum = 1;\n                 pos_bol = 0; pos_cnum = -1} in\n      let loc = {To.Location. loc_start = pos; loc_end = pos;\n                 loc_ghost = true} in\n      let ptype_attributes =\n        ({To.Asttypes.txt = \"nonrec\"; loc}, To.Parsetree.PStr []) ::\n        x.To.Parsetree.ptype_attributes\n      in\n      {x with To.Parsetree.ptype_attributes} :: xs\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 -> copy_out_val_decl x0\n  | From.Outcometree.Osig_ellipsis ->\n      To.Outcometree.Osig_value (\"...\", To.Outcometree.Otyp_abstract, [])\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_sig_item =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = _ }\n     ->\n       To.Outcometree.Osig_value (\n         oval_name,\n         copy_out_type oval_type,\n         List.map (fun x  -> x) oval_prims\n       )\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = _;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      (*To.Outcometree.otype_immediate = (copy_bool otype_immediate);*)\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (_x0,_x1) ->\n      To.Outcometree.Otyp_abstract\n      (*To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))*)\n\n(*and copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }*)\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_name (x0,x1) ->\n      To.Outcometree.Ovar_name\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument ->\n    To.Parsetree.directive_argument\n  =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,_x1) ->\n      To.Parsetree.Pdir_int (int_of_string x0)\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*                          Benoit Vaugon, ENSTA                          *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Padding position. *)\ntype padty =\n  | Left   (* Text is left justified ('-' option).               *)\n  | Right  (* Text is right justified (no '-' option).           *)\n  | Zeros  (* Text is right justified by zeros (see '0' option). *)\n\n(***)\n\n(* Integer conversion. *)\ntype int_conv =\n  | Int_d | Int_pd | Int_sd        (*  %d | %+d | % d  *)\n  | Int_i | Int_pi | Int_si        (*  %i | %+i | % i  *)\n  | Int_x | Int_Cx                 (*  %x | %#x        *)\n  | Int_X | Int_CX                 (*  %X | %#X        *)\n  | Int_o | Int_Co                 (*  %o | %#o        *)\n  | Int_u                          (*  %u              *)\n\n(* Float conversion. *)\ntype float_conv =\n  | Float_f | Float_pf | Float_sf  (*  %f | %+f | % f  *)\n  | Float_e | Float_pe | Float_se  (*  %e | %+e | % e  *)\n  | Float_E | Float_pE | Float_sE  (*  %E | %+E | % E  *)\n  | Float_g | Float_pg | Float_sg  (*  %g | %+g | % g  *)\n  | Float_G | Float_pG | Float_sG  (*  %G | %+G | % G  *)\n  | Float_F                        (*  %F              *)\n  | Float_h | Float_ph | Float_sh  (*  %h | %+h | % h  *)\n  | Float_H | Float_pH | Float_sH  (*  %H | %+H | % H  *)\n\n(***)\n\n(* Char sets (see %[...]) are bitmaps implemented as 32-char strings. *)\ntype char_set = string\n\n(***)\n\n(* Counter used in Scanf. *)\ntype counter =\n  | Line_counter     (*  %l      *)\n  | Char_counter     (*  %n      *)\n  | Token_counter    (*  %N, %L  *)\n\n(***)\n\n(* Padding of strings and numbers. *)\ntype ('a, 'b) padding =\n  (* No padding (ex: \"%d\") *)\n  | No_padding  : ('a, 'a) padding\n  (* Literal padding (ex: \"%8d\") *)\n  | Lit_padding : padty * int -> ('a, 'a) padding\n  (* Padding as extra argument (ex: \"%*d\") *)\n  | Arg_padding : padty -> (int -> 'a, 'a) padding\n\n(* Some formats, such as %_d,\n   only accept an optional number as padding option (no extra argument) *)\ntype pad_option = int option\n\n(* Precision of floats and '0'-padding of integers. *)\ntype ('a, 'b) precision =\n  (* No precision (ex: \"%f\") *)\n  | No_precision : ('a, 'a) precision\n  (* Literal precision (ex: \"%.3f\") *)\n  | Lit_precision : int -> ('a, 'a) precision\n  (* Precision as extra argument (ex: \"%.*f\") *)\n  | Arg_precision : (int -> 'a, 'a) precision\n\n(* Some formats, such as %_f,\n   only accept an optional number as precision option (no extra argument) *)\ntype prec_option = int option\n\n(* see the Custom format combinator *)\ntype ('a, 'b, 'c) custom_arity =\n  | Custom_zero : ('a, string, 'a) custom_arity\n  | Custom_succ : ('a, 'b, 'c) custom_arity ->\n    ('a, 'x -> 'b, 'x -> 'c) custom_arity\n\n(***)\n\n(*        Relational format types\n\nIn the first format+gadts implementation, the type for %(..%) in the\nfmt GADT was as follows:\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option * ('d1, 'q1, 'd2, 'q2) reader_nb_unifier *\n    ('x, 'b, 'c, 'd1, 'q1, 'u) fmtty *\n    ('u, 'b, 'c, 'q1, 'e1, 'f) fmt ->\n      (('x, 'b, 'c, 'd2, 'q2, 'u) format6 -> 'x, 'b, 'c, 'd1, 'e1, 'f) fmt\n\nNotice that the 'u parameter in 'f position in the format argument\n(('x, .., 'u) format6 -> ..) is equal to the 'u parameter in 'a\nposition in the format tail (('u, .., 'f) fmt). This means that the\ntype of the expected format parameter depends of where the %(...%)\nare in the format string:\n\n  # Printf.printf \"%(%)\"\n  - : (unit, out_channel, unit, '_a, '_a, unit)\n      CamlinternalFormatBasics.format6 -> unit\n  = <fun>\n  # Printf.printf \"%(%)%d\"\n  - : (int -> unit, out_channel, unit, '_a, '_a, int -> unit)\n      CamlinternalFormatBasics.format6 -> int -> unit\n  = <fun>\n\nOn the contrary, the legacy typer gives a clever type that does not\ndepend on the position of %(..%) in the format string. For example,\n%(%) will have the polymorphic type ('a, 'b, 'c, 'd, 'd, 'a): it can\nbe concatenated to any format type, and only enforces the constraint\nthat its 'a and 'f parameters are equal (no format arguments) and 'd\nand 'e are equal (no reader argument).\n\nThe weakening of this parameter type in the GADT version broke user\ncode (in fact it essentially made %(...%) unusable except at the last\nposition of a format). In particular, the following would not work\nanymore:\n\n  fun sep ->\n    Format.printf \"foo%(%)bar%(%)baz\" sep sep\n\nAs the type-checker would require two *incompatible* types for the %(%)\nin different positions.\n\nThe solution to regain a general type for %(..%) is to generalize this\ntechnique, not only on the 'd, 'e parameters, but on all six\nparameters of a format: we introduce a \"relational\" type\n  ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n   'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\nwhose values are proofs that ('a1, .., 'f1) and ('a2, .., 'f2) morally\ncorrespond to the same format type: 'a1 is obtained from 'f1,'b1,'c1\nin the exact same way that 'a2 is obtained from 'f2,'b2,'c2, etc.\n\nFor example, the relation between two format types beginning with a Char\nparameter is as follows:\n\n| Char_ty :                                                 (* %c  *)\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\nIn the general case, the term structure of fmtty_rel is (almost[1])\nisomorphic to the fmtty of the previous implementation: every\nconstructor is re-read with a binary, relational type, instead of the\nprevious unary typing. fmtty can then be re-defined as the diagonal of\nfmtty_rel:\n\n  type ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n       ('a, 'b, 'c, 'd, 'e, 'f,\n        'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\n\nOnce we have this fmtty_rel type in place, we can give the more\ngeneral type to %(...%):\n\n| Format_subst :                                           (* %(...%) *)\n    pad_option *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n    ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\nWe accept any format (('g, 'h, 'i, 'j, 'k, 'l) format6) (this is\ncompletely unrelated to the type of the current format), but also\nrequire a proof that this format is in relation to another format that\nis concatenable to the format tail. When executing a %(...%) format\n(in camlinternalFormat.ml:make_printf or scanf.ml:make_scanf), we\ntranstype the format along this relation using the 'recast' function\nto transpose between related format types.\n\n  val recast :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1) fmt\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmt\n\nNOTE [1]: the typing of Format_subst_ty requires not one format type, but\ntwo, one to establish the link between the format argument and the\nfirst six parameters, and the other for the link between the format\nargumant and the last six parameters.\n\n| Format_subst_ty :                                         (* %(...%) *)\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n    ('g, 'h, 'i, 'j, 'k, 'l,\n     'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n    ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n    (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n     ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2) fmtty_rel\n\nWhen we generate a format AST, we generate exactly the same witness\nfor both relations, and the witness-conversion functions in\ncamlinternalFormat do rely on this invariant. For example, the\nfunction that proves that the relation is transitive\n\n  val trans :\n     ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  -> ('a2, 'b2, 'c2, 'd2, 'e2, 'f2,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n  -> ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n      'a3, 'b3, 'c3, 'd3, 'e3, 'f3) fmtty_rel\n\ndoes assume that the two input have exactly the same term structure\n(and is only every used for argument witnesses of the\nFormat_subst_ty constructor).\n*)\n\n(* Type of a block used by the Format pretty-printer. *)\ntype block_type =\n  | Pp_hbox   (* Horizontal block no line breaking *)\n  | Pp_vbox   (* Vertical block each break leads to a new line *)\n  | Pp_hvbox  (* Horizontal-vertical block: same as vbox, except if this block\n                 is small enough to fit on a single line *)\n  | Pp_hovbox (* Horizontal or Vertical block: breaks lead to new line\n                 only when necessary to print the content of the block *)\n  | Pp_box    (* Horizontal or Indent block: breaks lead to new line\n                 only when necessary to print the content of the block, or\n                 when it leads to a new indentation of the current line *)\n  | Pp_fits   (* Internal usage: when a block fits on a single line *)\n\n(* Formatting element used by the Format pretty-printter. *)\ntype formatting_lit =\n  | Close_box                                           (* @]   *)\n  | Close_tag                                           (* @}   *)\n  | Break of string * int * int          (* @, | @  | @; | @;<> *)\n  | FFlush                                              (* @?   *)\n  | Force_newline                                       (* @\\n  *)\n  | Flush_newline                                       (* @.   *)\n  | Magic_size of string * int                          (* @<n> *)\n  | Escaped_at                                          (* @@   *)\n  | Escaped_percent                                     (* @%%  *)\n  | Scan_indic of char                                  (* @X   *)\n\n(* Formatting element used by the Format pretty-printter. *)\ntype ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen =\n  | Open_tag : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @{   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n  | Open_box : ('a, 'b, 'c, 'd, 'e, 'f) format6 ->      (* @[   *)\n    ('a, 'b, 'c, 'd, 'e, 'f) formatting_gen\n\n(***)\n\n(* List of format type elements. *)\n(* In particular used to represent %(...%) and %{...%} contents. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmtty =\n     ('a, 'b, 'c, 'd, 'e, 'f,\n      'a, 'b, 'c, 'd, 'e, 'f) fmtty_rel\nand ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel =\n  | Char_ty :                                                 (* %c  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (char -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       char -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | String_ty :                                               (* %s  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (string -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       string -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int_ty :                                                  (* %d  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int32_ty :                                                (* %ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int32 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int32 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Nativeint_ty :                                            (* %nd *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (nativeint -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       nativeint -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Int64_ty :                                                (* %Ld *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (int64 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       int64 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Float_ty :                                                (* %f  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (float -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       float -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Bool_ty :                                                 (* %B  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (bool -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       bool -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  | Format_arg_ty :                                           (* %{...%} *)\n      ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2)\n           fmtty_rel\n  | Format_subst_ty :                                         (* %(...%) *)\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g1, 'b1, 'c1, 'j1, 'd1, 'a1) fmtty_rel *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b2, 'c2, 'j2, 'd2, 'a2) fmtty_rel *\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g1, 'b1, 'c1, 'j1, 'e1, 'f1,\n       ('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b2, 'c2, 'j2, 'e2, 'f2)\n           fmtty_rel\n\n  (* Printf and Format specific constructors. *)\n  | Alpha_ty :                                                (* %a  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'x -> 'c1) -> 'x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'x -> 'c2) -> 'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Theta_ty :                                                (* %t  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      (('b1 -> 'c1) -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       ('b2 -> 'c2) -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n  | Any_ty :                                    (* Used for custom formats *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel\n\n  (* Scanf specific constructor. *)\n  | Reader_ty :                                               (* %r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('x -> 'a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'x -> 'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n  | Ignored_reader_ty :                                       (* %_r  *)\n      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel ->\n      ('a1, 'b1, 'c1, ('b1 -> 'x) -> 'd1, 'e1, 'f1,\n       'a2, 'b2, 'c2, ('b2 -> 'x) -> 'd2, 'e2, 'f2) fmtty_rel\n\n  | End_of_fmtty :\n      ('f1, 'b1, 'c1, 'd1, 'd1, 'f1,\n       'f2, 'b2, 'c2, 'd2, 'd2, 'f2) fmtty_rel\n\n(***)\n\n(* List of format elements. *)\nand ('a, 'b, 'c, 'd, 'e, 'f) fmt =\n  | Char :                                                   (* %c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_char :                                              (* %C *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | String :                                                 (* %s *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Caml_string :                                            (* %S *)\n      ('x, string -> 'a) padding * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int :                                                    (* %[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int32 :                                                  (* %l[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int32 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Nativeint :                                              (* %n[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, nativeint -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Int64 :                                                  (* %L[dixXuo] *)\n      int_conv * ('x, 'y) padding * ('y, int64 -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Float :                                                  (* %[feEgGF] *)\n      float_conv * ('x, 'y) padding * ('y, float -> 'a) precision *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x, 'b, 'c, 'd, 'e, 'f) fmt\n  | Bool :                                                   (* %[bB] *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (bool -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Flush :                                                  (* %! *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | String_literal :                                         (* abc *)\n      string * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Char_literal :                                           (* x *)\n      char * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  | Format_arg :                                             (* %{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Format_subst :                                           (* %(...%) *)\n      pad_option *\n      ('g, 'h, 'i, 'j, 'k, 'l,\n       'g2, 'b, 'c, 'j2, 'd, 'a) fmtty_rel *\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (('g, 'h, 'i, 'j, 'k, 'l) format6 -> 'g2, 'b, 'c, 'j2, 'e, 'f) fmt\n\n  (* Printf and Format specific constructor. *)\n  | Alpha :                                                  (* %a *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'x -> 'c) -> 'x -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Theta :                                                  (* %t *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (('b -> 'c) -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Format specific constructor: *)\n  | Formatting_lit :                                         (* @_ *)\n      formatting_lit * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Formatting_gen :                                             (* @_ *)\n      ('a1, 'b, 'c, 'd1, 'e1, 'f1) formatting_gen *\n      ('f1, 'b, 'c, 'e1, 'e2, 'f2) fmt -> ('a1, 'b, 'c, 'd1, 'e2, 'f2) fmt\n\n  (* Scanf specific constructors: *)\n  | Reader :                                                 (* %r *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        ('x -> 'a, 'b, 'c, ('b -> 'x) -> 'd, 'e, 'f) fmt\n  | Scan_char_set :                                          (* %[...] *)\n      pad_option * char_set * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (string -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_get_counter :                                       (* %[nlNL] *)\n      counter * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n        (int -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Scan_next_char :                                         (* %0c *)\n      ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      (char -> 'a, 'b, 'c, 'd, 'e, 'f) fmt\n  | Ignored_param :                                          (* %_ *)\n      ('a, 'b, 'c, 'd, 'y, 'x) ignored * ('x, 'b, 'c, 'y, 'e, 'f) fmt ->\n        ('a, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* Custom printing format (PR#6452, GPR#140)\n\n     We include a type Custom of \"custom converters\", where an\n     arbitrary function can be used to convert one or more\n     arguments. There is no syntax for custom converters, it is only\n     inteded for custom processors that wish to rely on the\n     stdlib-defined format GADTs.\n\n     For instance a pre-processor could choose to interpret strings\n     prefixed with [\"!\"] as format strings where [%{{ ... }}] is\n     a special form to pass a to_string function, so that one could\n     write:\n\n     {[\n       type t = { x : int; y : int }\n\n       let string_of_t t = Printf.sprintf \"{ x = %d; y = %d }\" t.x t.y\n\n       Printf.printf !\"t = %{{string_of_t}}\" { x = 42; y = 42 }\n     ]}\n  *)\n  | Custom :\n      ('a, 'x, 'y) custom_arity * (unit -> 'x) * ('a, 'b, 'c, 'd, 'e, 'f) fmt ->\n      ('y, 'b, 'c, 'd, 'e, 'f) fmt\n\n  (* end of a format specification *)\n  | End_of_format :\n        ('f, 'b, 'c, 'e, 'e, 'f) fmt\n\n(***)\n\n(* Type for ignored parameters (see \"%_\"). *)\nand ('a, 'b, 'c, 'd, 'e, 'f) ignored =\n  | Ignored_char :                                           (* %_c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_char :                                      (* %_C *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_string :                                         (* %_s *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_caml_string :                                    (* %_S *)\n      pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int :                                            (* %_d *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int32 :                                          (* %_ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_nativeint :                                      (* %_nd *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_int64 :                                          (* %_Ld *)\n      int_conv * pad_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_float :                                          (* %_f *)\n      pad_option * prec_option -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_bool :                                           (* %_B *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_arg :                                     (* %_{...%} *)\n      pad_option * ('g, 'h, 'i, 'j, 'k, 'l) fmtty ->\n        ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_format_subst :                                   (* %_(...%) *)\n      pad_option * ('a, 'b, 'c, 'd, 'e, 'f) fmtty ->\n        ('a, 'b, 'c, 'd, 'e, 'f) ignored\n  | Ignored_reader :                                         (* %_r *)\n      ('a, 'b, 'c, ('b -> 'x) -> 'd, 'd, 'a) ignored\n  | Ignored_scan_char_set :                                  (* %_[...] *)\n      pad_option * char_set -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_get_counter :                               (* %_[nlNL] *)\n      counter -> ('a, 'b, 'c, 'd, 'd, 'a) ignored\n  | Ignored_scan_next_char :                                 (* %_0c *)\n      ('a, 'b, 'c, 'd, 'd, 'a) ignored\n\nand ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n  Format of ('a, 'b, 'c, 'd, 'e, 'f) fmt * string\n\nlet rec erase_rel : type a b c d e f g h i j k l .\n  (a, b, c, d, e, f,\n   g, h, i, j, k, l) fmtty_rel -> (a, b, c, d, e, f) fmtty\n= function\n  | Char_ty rest ->\n    Char_ty (erase_rel rest)\n  | String_ty rest ->\n    String_ty (erase_rel rest)\n  | Int_ty rest ->\n    Int_ty (erase_rel rest)\n  | Int32_ty rest ->\n    Int32_ty (erase_rel rest)\n  | Int64_ty rest ->\n    Int64_ty (erase_rel rest)\n  | Nativeint_ty rest ->\n    Nativeint_ty (erase_rel rest)\n  | Float_ty rest ->\n    Float_ty (erase_rel rest)\n  | Bool_ty rest ->\n    Bool_ty (erase_rel rest)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, erase_rel rest)\n  | Format_subst_ty (ty1, _ty2, rest) ->\n    Format_subst_ty (ty1, ty1, erase_rel rest)\n  | Alpha_ty rest ->\n    Alpha_ty (erase_rel rest)\n  | Theta_ty rest ->\n    Theta_ty (erase_rel rest)\n  | Any_ty rest ->\n    Any_ty (erase_rel rest)\n  | Reader_ty rest ->\n    Reader_ty (erase_rel rest)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (erase_rel rest)\n  | End_of_fmtty -> End_of_fmtty\n\n(******************************************************************************)\n                         (* Format type concatenation *)\n\n(* Concatenate two format types. *)\n(* Used by:\n   * reader_nb_unifier_of_fmtty to count readers in an fmtty,\n   * Scanf.take_fmtty_format_readers to extract readers inside %(...%),\n   * CamlinternalFormat.fmtty_of_ignored_format to extract format type. *)\n\n(*\nlet rec concat_fmtty : type a b c d e f g h .\n    (a, b, c, d, e, f) fmtty ->\n    (f, b, c, e, g, h) fmtty ->\n    (a, b, c, d, g, h) fmtty =\n*)\nlet rec concat_fmtty :\n  type a1 b1 c1 d1 e1 f1\n       a2 b2 c2 d2 e2 f2\n       g1 j1 g2 j2\n  .\n    (g1, b1, c1, j1, d1, a1,\n     g2, b2, c2, j2, d2, a2) fmtty_rel ->\n    (a1, b1, c1, d1, e1, f1,\n     a2, b2, c2, d2, e2, f2) fmtty_rel ->\n    (g1, b1, c1, j1, e1, f1,\n     g2, b2, c2, j2, e2, f2) fmtty_rel =\nfun fmtty1 fmtty2 -> match fmtty1 with\n  | Char_ty rest ->\n    Char_ty (concat_fmtty rest fmtty2)\n  | String_ty rest ->\n    String_ty (concat_fmtty rest fmtty2)\n  | Int_ty rest ->\n    Int_ty (concat_fmtty rest fmtty2)\n  | Int32_ty rest ->\n    Int32_ty (concat_fmtty rest fmtty2)\n  | Nativeint_ty rest ->\n    Nativeint_ty (concat_fmtty rest fmtty2)\n  | Int64_ty rest ->\n    Int64_ty (concat_fmtty rest fmtty2)\n  | Float_ty rest ->\n    Float_ty (concat_fmtty rest fmtty2)\n  | Bool_ty rest ->\n    Bool_ty (concat_fmtty rest fmtty2)\n  | Alpha_ty rest ->\n    Alpha_ty (concat_fmtty rest fmtty2)\n  | Theta_ty rest ->\n    Theta_ty (concat_fmtty rest fmtty2)\n  | Any_ty rest ->\n    Any_ty (concat_fmtty rest fmtty2)\n  | Reader_ty rest ->\n    Reader_ty (concat_fmtty rest fmtty2)\n  | Ignored_reader_ty rest ->\n    Ignored_reader_ty (concat_fmtty rest fmtty2)\n  | Format_arg_ty (ty, rest) ->\n    Format_arg_ty (ty, concat_fmtty rest fmtty2)\n  | Format_subst_ty (ty1, ty2, rest) ->\n    Format_subst_ty (ty1, ty2, concat_fmtty rest fmtty2)\n  | End_of_fmtty -> fmtty2\n\n(******************************************************************************)\n                           (* Format concatenation *)\n\n(* Concatenate two formats. *)\nlet rec concat_fmt : type a b c d e f g h .\n    (a, b, c, d, e, f) fmt ->\n    (f, b, c, e, g, h) fmt ->\n    (a, b, c, d, g, h) fmt =\nfun fmt1 fmt2 -> match fmt1 with\n  | String (pad, rest) ->\n    String (pad, concat_fmt rest fmt2)\n  | Caml_string (pad, rest) ->\n    Caml_string (pad, concat_fmt rest fmt2)\n\n  | Int (iconv, pad, prec, rest) ->\n    Int (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int32 (iconv, pad, prec, rest) ->\n    Int32 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Nativeint (iconv, pad, prec, rest) ->\n    Nativeint (iconv, pad, prec, concat_fmt rest fmt2)\n  | Int64 (iconv, pad, prec, rest) ->\n    Int64 (iconv, pad, prec, concat_fmt rest fmt2)\n  | Float (fconv, pad, prec, rest) ->\n    Float (fconv, pad, prec, concat_fmt rest fmt2)\n\n  | Char (rest) ->\n    Char (concat_fmt rest fmt2)\n  | Caml_char rest ->\n    Caml_char (concat_fmt rest fmt2)\n  | Bool rest ->\n    Bool (concat_fmt rest fmt2)\n  | Alpha rest ->\n    Alpha (concat_fmt rest fmt2)\n  | Theta rest ->\n    Theta (concat_fmt rest fmt2)\n  | Custom (arity, f, rest) ->\n    Custom (arity, f, concat_fmt rest fmt2)\n  | Reader rest ->\n    Reader (concat_fmt rest fmt2)\n  | Flush rest ->\n    Flush (concat_fmt rest fmt2)\n\n  | String_literal (str, rest) ->\n    String_literal (str, concat_fmt rest fmt2)\n  | Char_literal (chr, rest) ->\n    Char_literal   (chr, concat_fmt rest fmt2)\n\n  | Format_arg (pad, fmtty, rest) ->\n    Format_arg   (pad, fmtty, concat_fmt rest fmt2)\n  | Format_subst (pad, fmtty, rest) ->\n    Format_subst (pad, fmtty, concat_fmt rest fmt2)\n\n  | Scan_char_set (width_opt, char_set, rest) ->\n    Scan_char_set (width_opt, char_set, concat_fmt rest fmt2)\n  | Scan_get_counter (counter, rest) ->\n    Scan_get_counter (counter, concat_fmt rest fmt2)\n  | Scan_next_char (rest) ->\n    Scan_next_char (concat_fmt rest fmt2)\n  | Ignored_param (ign, rest) ->\n    Ignored_param (ign, concat_fmt rest fmt2)\n\n  | Formatting_lit (fmting_lit, rest) ->\n    Formatting_lit (fmting_lit, concat_fmt rest fmt2)\n  | Formatting_gen (fmting_gen, rest) ->\n    Formatting_gen (fmting_gen, concat_fmt rest fmt2)\n\n  | End_of_format ->\n    fmt2\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* type 'a option = None | Some of 'a *)\n\n(* Exceptions *)\n\nexternal register_named_value : string -> 'a -> unit\n                              = \"caml_register_named_value\"\n\nlet () =\n  (* for asmrun/fail.c *)\n  register_named_value \"Pervasives.array_bound_error\"\n    (Invalid_argument \"index out of bounds\")\n\n\nexternal raise : exn -> 'a = \"%raise\"\nexternal raise_notrace : exn -> 'a = \"%raise_notrace\"\n\nlet failwith s = raise(Failure s)\nlet invalid_arg s = raise(Invalid_argument s)\n\nexception Exit\n\n(* Composition operators *)\n\nexternal ( |> ) : 'a -> ('a -> 'b) -> 'b = \"%revapply\"\nexternal ( @@ ) : ('a -> 'b) -> 'a -> 'b = \"%apply\"\n\n(* Debugging *)\n\nexternal __LOC__ : string = \"%loc_LOC\"\nexternal __FILE__ : string = \"%loc_FILE\"\nexternal __LINE__ : int = \"%loc_LINE\"\nexternal __MODULE__ : string = \"%loc_MODULE\"\nexternal __POS__ : string * int * int * int = \"%loc_POS\"\n\nexternal __LOC_OF__ : 'a -> string * 'a = \"%loc_LOC\"\nexternal __LINE_OF__ : 'a -> int * 'a = \"%loc_LINE\"\nexternal __POS_OF__ : 'a -> (string * int * int * int) * 'a = \"%loc_POS\"\n\n(* Comparisons *)\n\nexternal ( = ) : 'a -> 'a -> bool = \"%equal\"\nexternal ( <> ) : 'a -> 'a -> bool = \"%notequal\"\nexternal ( < ) : 'a -> 'a -> bool = \"%lessthan\"\nexternal ( > ) : 'a -> 'a -> bool = \"%greaterthan\"\nexternal ( <= ) : 'a -> 'a -> bool = \"%lessequal\"\nexternal ( >= ) : 'a -> 'a -> bool = \"%greaterequal\"\nexternal compare : 'a -> 'a -> int = \"%compare\"\n\nlet min x y = if x <= y then x else y\nlet max x y = if x >= y then x else y\n\nexternal ( == ) : 'a -> 'a -> bool = \"%eq\"\nexternal ( != ) : 'a -> 'a -> bool = \"%noteq\"\n\n(* Boolean operations *)\n\nexternal not : bool -> bool = \"%boolnot\"\nexternal ( & ) : bool -> bool -> bool = \"%sequand\"\nexternal ( && ) : bool -> bool -> bool = \"%sequand\"\nexternal ( or ) : bool -> bool -> bool = \"%sequor\"\nexternal ( || ) : bool -> bool -> bool = \"%sequor\"\n\n(* Integer operations *)\n\nexternal ( ~- ) : int -> int = \"%negint\"\nexternal ( ~+ ) : int -> int = \"%identity\"\nexternal succ : int -> int = \"%succint\"\nexternal pred : int -> int = \"%predint\"\nexternal ( + ) : int -> int -> int = \"%addint\"\nexternal ( - ) : int -> int -> int = \"%subint\"\nexternal ( * ) : int -> int -> int = \"%mulint\"\nexternal ( / ) : int -> int -> int = \"%divint\"\nexternal ( mod ) : int -> int -> int = \"%modint\"\n\nlet abs x = if x >= 0 then x else -x\n\nexternal ( land ) : int -> int -> int = \"%andint\"\nexternal ( lor ) : int -> int -> int = \"%orint\"\nexternal ( lxor ) : int -> int -> int = \"%xorint\"\n\nlet lnot x = x lxor (-1)\n\nexternal ( lsl ) : int -> int -> int = \"%lslint\"\nexternal ( lsr ) : int -> int -> int = \"%lsrint\"\nexternal ( asr ) : int -> int -> int = \"%asrint\"\n\nlet max_int = (-1) lsr 1\nlet min_int = max_int + 1\n\n(* Floating-point operations *)\n\nexternal ( ~-. ) : float -> float = \"%negfloat\"\nexternal ( ~+. ) : float -> float = \"%identity\"\nexternal ( +. ) : float -> float -> float = \"%addfloat\"\nexternal ( -. ) : float -> float -> float = \"%subfloat\"\nexternal ( *. ) : float -> float -> float = \"%mulfloat\"\nexternal ( /. ) : float -> float -> float = \"%divfloat\"\nexternal ( ** ) : float -> float -> float = \"caml_power_float\" \"pow\"\n  [@@unboxed] [@@noalloc]\nexternal exp : float -> float = \"caml_exp_float\" \"exp\" [@@unboxed] [@@noalloc]\nexternal expm1 : float -> float = \"caml_expm1_float\" \"caml_expm1\"\n  [@@unboxed] [@@noalloc]\nexternal acos : float -> float = \"caml_acos_float\" \"acos\"\n  [@@unboxed] [@@noalloc]\nexternal asin : float -> float = \"caml_asin_float\" \"asin\"\n  [@@unboxed] [@@noalloc]\nexternal atan : float -> float = \"caml_atan_float\" \"atan\"\n  [@@unboxed] [@@noalloc]\nexternal atan2 : float -> float -> float = \"caml_atan2_float\" \"atan2\"\n  [@@unboxed] [@@noalloc]\nexternal hypot : float -> float -> float\n               = \"caml_hypot_float\" \"caml_hypot\" [@@unboxed] [@@noalloc]\nexternal cos : float -> float = \"caml_cos_float\" \"cos\" [@@unboxed] [@@noalloc]\nexternal cosh : float -> float = \"caml_cosh_float\" \"cosh\"\n  [@@unboxed] [@@noalloc]\nexternal log : float -> float = \"caml_log_float\" \"log\" [@@unboxed] [@@noalloc]\nexternal log10 : float -> float = \"caml_log10_float\" \"log10\"\n  [@@unboxed] [@@noalloc]\nexternal log1p : float -> float = \"caml_log1p_float\" \"caml_log1p\"\n  [@@unboxed] [@@noalloc]\nexternal sin : float -> float = \"caml_sin_float\" \"sin\" [@@unboxed] [@@noalloc]\nexternal sinh : float -> float = \"caml_sinh_float\" \"sinh\"\n  [@@unboxed] [@@noalloc]\nexternal sqrt : float -> float = \"caml_sqrt_float\" \"sqrt\"\n  [@@unboxed] [@@noalloc]\nexternal tan : float -> float = \"caml_tan_float\" \"tan\" [@@unboxed] [@@noalloc]\nexternal tanh : float -> float = \"caml_tanh_float\" \"tanh\"\n  [@@unboxed] [@@noalloc]\nexternal ceil : float -> float = \"caml_ceil_float\" \"ceil\"\n  [@@unboxed] [@@noalloc]\nexternal floor : float -> float = \"caml_floor_float\" \"floor\"\n  [@@unboxed] [@@noalloc]\nexternal abs_float : float -> float = \"%absfloat\"\nexternal copysign : float -> float -> float\n                  = \"caml_copysign_float\" \"caml_copysign\"\n                  [@@unboxed] [@@noalloc]\nexternal mod_float : float -> float -> float = \"caml_fmod_float\" \"fmod\"\n  [@@unboxed] [@@noalloc]\nexternal frexp : float -> float * int = \"caml_frexp_float\"\nexternal ldexp : (float [@unboxed]) -> (int [@untagged]) -> (float [@unboxed]) =\n  \"caml_ldexp_float\" \"caml_ldexp_float_unboxed\" [@@noalloc]\nexternal modf : float -> float * float = \"caml_modf_float\"\nexternal float : int -> float = \"%floatofint\"\nexternal float_of_int : int -> float = \"%floatofint\"\nexternal truncate : float -> int = \"%intoffloat\"\nexternal int_of_float : float -> int = \"%intoffloat\"\nexternal float_of_bits : int64 -> float = \"caml_int64_float_of_bits\"\nlet infinity =\n  float_of_bits 0x7F_F0_00_00_00_00_00_00L\nlet neg_infinity =\n  float_of_bits 0xFF_F0_00_00_00_00_00_00L\nlet nan =\n  float_of_bits 0x7F_F0_00_00_00_00_00_01L\nlet max_float =\n  float_of_bits 0x7F_EF_FF_FF_FF_FF_FF_FFL\nlet min_float =\n  float_of_bits 0x00_10_00_00_00_00_00_00L\nlet epsilon_float =\n  float_of_bits 0x3C_B0_00_00_00_00_00_00L\n\ntype fpclass =\n    FP_normal\n  | FP_subnormal\n  | FP_zero\n  | FP_infinite\n  | FP_nan\nexternal classify_float : (float [@unboxed]) -> fpclass =\n  \"caml_classify_float\" \"caml_classify_float_unboxed\" [@@noalloc]\n\n(* String and byte sequence operations -- more in modules String and Bytes *)\n\nexternal string_length : string -> int = \"%string_length\"\nexternal bytes_length : bytes -> int = \"%string_length\"\nexternal bytes_create : int -> bytes = \"caml_create_bytes\"\nexternal string_blit : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal bytes_blit : bytes -> int -> bytes -> int -> int -> unit\n                        = \"caml_blit_bytes\" [@@noalloc]\nexternal bytes_unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet ( ^ ) s1 s2 =\n  let l1 = string_length s1 and l2 = string_length s2 in\n  let s = bytes_create (l1 + l2) in\n  string_blit s1 0 s 0 l1;\n  string_blit s2 0 s l1 l2;\n  bytes_unsafe_to_string s\n\n(* Character operations -- more in module Char *)\n\nexternal int_of_char : char -> int = \"%identity\"\nexternal unsafe_char_of_int : int -> char = \"%identity\"\nlet char_of_int n =\n  if n < 0 || n > 255 then invalid_arg \"char_of_int\" else unsafe_char_of_int n\n\n(* Unit operations *)\n\nexternal ignore : 'a -> unit = \"%ignore\"\n\n(* Pair operations *)\n\nexternal fst : 'a * 'b -> 'a = \"%field0\"\nexternal snd : 'a * 'b -> 'b = \"%field1\"\n\n(* References *)\n\ntype 'a ref = { mutable contents : 'a }\nexternal ref : 'a -> 'a ref = \"%makemutable\"\nexternal ( ! ) : 'a ref -> 'a = \"%field0\"\nexternal ( := ) : 'a ref -> 'a -> unit = \"%setfield0\"\nexternal incr : int ref -> unit = \"%incr\"\nexternal decr : int ref -> unit = \"%decr\"\n\n(* Result type *)\n\ntype ('a,'b) result = Ok of 'a | Error of 'b\n\n(* String conversion functions *)\n\nexternal format_int : string -> int -> string = \"caml_format_int\"\nexternal format_float : string -> float -> string = \"caml_format_float\"\n\nlet string_of_bool b =\n  if b then \"true\" else \"false\"\nlet bool_of_string = function\n  | \"true\" -> true\n  | \"false\" -> false\n  | _ -> invalid_arg \"bool_of_string\"\n\nlet string_of_int n =\n  format_int \"%d\" n\n\nexternal int_of_string : string -> int = \"caml_int_of_string\"\nexternal string_get : string -> int -> char = \"%string_safe_get\"\n\nlet valid_float_lexem s =\n  let l = string_length s in\n  let rec loop i =\n    if i >= l then s ^ \".\" else\n    match string_get s i with\n    | '0' .. '9' | '-' -> loop (i + 1)\n    | _ -> s\n  in\n  loop 0\n\n\nlet string_of_float f = valid_float_lexem (format_float \"%.12g\" f)\n\nexternal float_of_string : string -> float = \"caml_float_of_string\"\n\n(* List operations -- more in module List *)\n\nlet rec ( @ ) l1 l2 =\n  match l1 with\n    [] -> l2\n  | hd :: tl -> hd :: (tl @ l2)\n\n(* I/O operations *)\n\ntype in_channel\ntype out_channel\n\nexternal open_descriptor_out : int -> out_channel\n                             = \"caml_ml_open_descriptor_out\"\nexternal open_descriptor_in : int -> in_channel = \"caml_ml_open_descriptor_in\"\n\nlet stdin = open_descriptor_in 0\nlet stdout = open_descriptor_out 1\nlet stderr = open_descriptor_out 2\n\n(* General output functions *)\n\ntype open_flag =\n    Open_rdonly | Open_wronly | Open_append\n  | Open_creat | Open_trunc | Open_excl\n  | Open_binary | Open_text | Open_nonblock\n\nexternal open_desc : string -> open_flag list -> int -> int = \"caml_sys_open\"\n\nexternal set_out_channel_name: out_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_out_gen mode perm name =\n  let c = open_descriptor_out(open_desc name mode perm) in\n  set_out_channel_name c name;\n  c\n\nlet open_out name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_text] 0o666 name\n\nlet open_out_bin name =\n  open_out_gen [Open_wronly; Open_creat; Open_trunc; Open_binary] 0o666 name\n\nexternal flush : out_channel -> unit = \"caml_ml_flush\"\n\nexternal out_channels_list : unit -> out_channel list\n                           = \"caml_ml_out_channels_list\"\n\nlet flush_all () =\n  let rec iter = function\n      [] -> ()\n    | a :: l -> (try flush a with _ -> ()); iter l\n  in iter (out_channels_list ())\n\nexternal unsafe_output : out_channel -> bytes -> int -> int -> unit\n                       = \"caml_ml_output_bytes\"\nexternal unsafe_output_string : out_channel -> string -> int -> int -> unit\n                              = \"caml_ml_output\"\n\nexternal output_char : out_channel -> char -> unit = \"caml_ml_output_char\"\n\nlet output_bytes oc s =\n  unsafe_output oc s 0 (bytes_length s)\n\nlet output_string oc s =\n  unsafe_output_string oc s 0 (string_length s)\n\nlet output oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"output\"\n  else unsafe_output oc s ofs len\n\nlet output_substring oc s ofs len =\n  if ofs < 0 || len < 0 || ofs > string_length s - len\n  then invalid_arg \"output_substring\"\n  else unsafe_output_string oc s ofs len\n\nexternal output_byte : out_channel -> int -> unit = \"caml_ml_output_char\"\nexternal output_binary_int : out_channel -> int -> unit = \"caml_ml_output_int\"\n\nexternal marshal_to_channel : out_channel -> 'a -> unit list -> unit\n     = \"caml_output_value\"\nlet output_value chan v = marshal_to_channel chan v []\n\nexternal seek_out : out_channel -> int -> unit = \"caml_ml_seek_out\"\nexternal pos_out : out_channel -> int = \"caml_ml_pos_out\"\nexternal out_channel_length : out_channel -> int = \"caml_ml_channel_size\"\nexternal close_out_channel : out_channel -> unit = \"caml_ml_close_channel\"\nlet close_out oc = flush oc; close_out_channel oc\nlet close_out_noerr oc =\n  (try flush oc with _ -> ());\n  (try close_out_channel oc with _ -> ())\nexternal set_binary_mode_out : out_channel -> bool -> unit\n                             = \"caml_ml_set_binary_mode\"\n\n(* General input functions *)\n\nexternal set_in_channel_name: in_channel -> string -> unit =\n  \"caml_ml_set_channel_name\"\n\nlet open_in_gen mode perm name =\n  let c = open_descriptor_in(open_desc name mode perm) in\n  set_in_channel_name c name;\n  c\n\nlet open_in name =\n  open_in_gen [Open_rdonly; Open_text] 0 name\n\nlet open_in_bin name =\n  open_in_gen [Open_rdonly; Open_binary] 0 name\n\nexternal input_char : in_channel -> char = \"caml_ml_input_char\"\n\nexternal unsafe_input : in_channel -> bytes -> int -> int -> int\n                      = \"caml_ml_input\"\n\nlet input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"input\"\n  else unsafe_input ic s ofs len\n\nlet rec unsafe_really_input ic s ofs len =\n  if len <= 0 then () else begin\n    let r = unsafe_input ic s ofs len in\n    if r = 0\n    then raise End_of_file\n    else unsafe_really_input ic s (ofs + r) (len - r)\n  end\n\nlet really_input ic s ofs len =\n  if ofs < 0 || len < 0 || ofs > bytes_length s - len\n  then invalid_arg \"really_input\"\n  else unsafe_really_input ic s ofs len\n\nlet really_input_string ic len =\n  let s = bytes_create len in\n  really_input ic s 0 len;\n  bytes_unsafe_to_string s\n\nexternal input_scan_line : in_channel -> int = \"caml_ml_input_scan_line\"\n\nlet input_line chan =\n  let rec build_result buf pos = function\n    [] -> buf\n  | hd :: tl ->\n      let len = bytes_length hd in\n      bytes_blit hd 0 buf (pos - len) len;\n      build_result buf (pos - len) tl in\n  let rec scan accu len =\n    let n = input_scan_line chan in\n    if n = 0 then begin                   (* n = 0: we are at EOF *)\n      match accu with\n        [] -> raise End_of_file\n      | _  -> build_result (bytes_create len) len accu\n    end else if n > 0 then begin          (* n > 0: newline found in buffer *)\n      let res = bytes_create (n - 1) in\n      ignore (unsafe_input chan res 0 (n - 1));\n      ignore (input_char chan);           (* skip the newline *)\n      match accu with\n        [] -> res\n      |  _ -> let len = len + n - 1 in\n              build_result (bytes_create len) len (res :: accu)\n    end else begin                        (* n < 0: newline not found *)\n      let beg = bytes_create (-n) in\n      ignore(unsafe_input chan beg 0 (-n));\n      scan (beg :: accu) (len - n)\n    end\n  in bytes_unsafe_to_string (scan [] 0)\n\nexternal input_byte : in_channel -> int = \"caml_ml_input_char\"\nexternal input_binary_int : in_channel -> int = \"caml_ml_input_int\"\nexternal input_value : in_channel -> 'a = \"caml_input_value\"\nexternal seek_in : in_channel -> int -> unit = \"caml_ml_seek_in\"\nexternal pos_in : in_channel -> int = \"caml_ml_pos_in\"\nexternal in_channel_length : in_channel -> int = \"caml_ml_channel_size\"\nexternal close_in : in_channel -> unit = \"caml_ml_close_channel\"\nlet close_in_noerr ic = (try close_in ic with _ -> ())\nexternal set_binary_mode_in : in_channel -> bool -> unit\n                            = \"caml_ml_set_binary_mode\"\n\n(* Output functions on standard output *)\n\nlet print_char c = output_char stdout c\nlet print_string s = output_string stdout s\nlet print_bytes s = output_bytes stdout s\nlet print_int i = output_string stdout (string_of_int i)\nlet print_float f = output_string stdout (string_of_float f)\nlet print_endline s =\n  output_string stdout s; output_char stdout '\\n'; flush stdout\nlet print_newline () = output_char stdout '\\n'; flush stdout\n\n(* Output functions on standard error *)\n\nlet prerr_char c = output_char stderr c\nlet prerr_string s = output_string stderr s\nlet prerr_bytes s = output_bytes stderr s\nlet prerr_int i = output_string stderr (string_of_int i)\nlet prerr_float f = output_string stderr (string_of_float f)\nlet prerr_endline s =\n  output_string stderr s; output_char stderr '\\n'; flush stderr\nlet prerr_newline () = output_char stderr '\\n'; flush stderr\n\n(* Input functions on standard input *)\n\nlet read_line () = flush stdout; input_line stdin\nlet read_int () = int_of_string(read_line())\nlet read_float () = float_of_string(read_line())\n\n(* Operations on large files *)\n\nmodule LargeFile =\n  struct\n    external seek_out : out_channel -> int64 -> unit = \"caml_ml_seek_out_64\"\n    external pos_out : out_channel -> int64 = \"caml_ml_pos_out_64\"\n    external out_channel_length : out_channel -> int64\n                                = \"caml_ml_channel_size_64\"\n    external seek_in : in_channel -> int64 -> unit = \"caml_ml_seek_in_64\"\n    external pos_in : in_channel -> int64 = \"caml_ml_pos_in_64\"\n    external in_channel_length : in_channel -> int64 = \"caml_ml_channel_size_64\"\n  end\n\n(* Formats *)\n\ntype ('a, 'b, 'c, 'd, 'e, 'f) format6\n   = ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6\n   = Format of ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.fmt\n               * string\n\ntype ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6\n\ntype ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4\n\nlet string_of_format (Format (_fmt, str)) = str\n\nexternal format_of_string :\n ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n ('a, 'b, 'c, 'd, 'e, 'f) format6 = \"%identity\"\n\nlet ( ^^ ) (Format (fmt1, str1)) (Format (fmt2, str2)) =\n  Format (CamlinternalFormatBasics.concat_fmt fmt1 fmt2,\n          str1 ^ \"%,\" ^ str2)\n\n(* Miscellaneous *)\n\nexternal sys_exit : int -> 'a = \"caml_sys_exit\"\n\nlet exit_function = ref flush_all\n\nlet at_exit f =\n  let g = !exit_function in\n  exit_function := (fun () -> f(); g())\n\nlet do_at_exit () = (!exit_function) ()\n\nlet exit retcode =\n  do_at_exit ();\n  sys_exit retcode\n\nlet _ = register_named_value \"Pervasives.do_at_exit\" do_at_exit\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* List operations *)\n\nlet rec length_aux len = function\n    [] -> len\n  | _::l -> length_aux (len + 1) l\n\nlet length l = length_aux 0 l\n\nlet cons a l = a::l\n\nlet hd = function\n    [] -> failwith \"hd\"\n  | a::_ -> a\n\nlet tl = function\n    [] -> failwith \"tl\"\n  | _::l -> l\n\nlet nth l n =\n  if n < 0 then invalid_arg \"List.nth\" else\n  let rec nth_aux l n =\n    match l with\n    | [] -> failwith \"nth\"\n    | a::l -> if n = 0 then a else nth_aux l (n-1)\n  in nth_aux l n\n\nlet append = (@)\n\nlet rec rev_append l1 l2 =\n  match l1 with\n    [] -> l2\n  | a :: l -> rev_append l (a :: l2)\n\nlet rev l = rev_append l []\n\nlet rec flatten = function\n    [] -> []\n  | l::r -> l @ flatten r\n\nlet concat = flatten\n\nlet rec map f = function\n    [] -> []\n  | a::l -> let r = f a in r :: map f l\n\nlet rec mapi i f = function\n    [] -> []\n  | a::l -> let r = f i a in r :: mapi (i + 1) f l\n\nlet mapi f l = mapi 0 f l\n\nlet rev_map f l =\n  let rec rmap_f accu = function\n    | [] -> accu\n    | a::l -> rmap_f (f a :: accu) l\n  in\n  rmap_f [] l\n\n\nlet rec iter f = function\n    [] -> ()\n  | a::l -> f a; iter f l\n\nlet rec iteri i f = function\n    [] -> ()\n  | a::l -> f i a; iteri (i + 1) f l\n\nlet iteri f l = iteri 0 f l\n\nlet rec fold_left f accu l =\n  match l with\n    [] -> accu\n  | a::l -> fold_left f (f accu a) l\n\nlet rec fold_right f l accu =\n  match l with\n    [] -> accu\n  | a::l -> f a (fold_right f l accu)\n\nlet rec map2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> let r = f a1 a2 in r :: map2 f l1 l2\n  | (_, _) -> invalid_arg \"List.map2\"\n\nlet rev_map2 f l1 l2 =\n  let rec rmap2_f accu l1 l2 =\n    match (l1, l2) with\n    | ([], []) -> accu\n    | (a1::l1, a2::l2) -> rmap2_f (f a1 a2 :: accu) l1 l2\n    | (_, _) -> invalid_arg \"List.rev_map2\"\n  in\n  rmap2_f [] l1 l2\n\n\nlet rec iter2 f l1 l2 =\n  match (l1, l2) with\n    ([], []) -> ()\n  | (a1::l1, a2::l2) -> f a1 a2; iter2 f l1 l2\n  | (_, _) -> invalid_arg \"List.iter2\"\n\nlet rec fold_left2 f accu l1 l2 =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> fold_left2 f (f accu a1 a2) l1 l2\n  | (_, _) -> invalid_arg \"List.fold_left2\"\n\nlet rec fold_right2 f l1 l2 accu =\n  match (l1, l2) with\n    ([], []) -> accu\n  | (a1::l1, a2::l2) -> f a1 a2 (fold_right2 f l1 l2 accu)\n  | (_, _) -> invalid_arg \"List.fold_right2\"\n\nlet rec for_all p = function\n    [] -> true\n  | a::l -> p a && for_all p l\n\nlet rec exists p = function\n    [] -> false\n  | a::l -> p a || exists p l\n\nlet rec for_all2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> true\n  | (a1::l1, a2::l2) -> p a1 a2 && for_all2 p l1 l2\n  | (_, _) -> invalid_arg \"List.for_all2\"\n\nlet rec exists2 p l1 l2 =\n  match (l1, l2) with\n    ([], []) -> false\n  | (a1::l1, a2::l2) -> p a1 a2 || exists2 p l1 l2\n  | (_, _) -> invalid_arg \"List.exists2\"\n\nlet rec mem x = function\n    [] -> false\n  | a::l -> compare a x = 0 || mem x l\n\nlet rec memq x = function\n    [] -> false\n  | a::l -> a == x || memq x l\n\nlet rec assoc x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if compare a x = 0 then b else assoc x l\n\nlet rec assq x = function\n    [] -> raise Not_found\n  | (a,b)::l -> if a == x then b else assq x l\n\nlet rec mem_assoc x = function\n  | [] -> false\n  | (a, _) :: l -> compare a x = 0 || mem_assoc x l\n\nlet rec mem_assq x = function\n  | [] -> false\n  | (a, _) :: l -> a == x || mem_assq x l\n\nlet rec remove_assoc x = function\n  | [] -> []\n  | (a, _ as pair) :: l ->\n      if compare a x = 0 then l else pair :: remove_assoc x l\n\nlet rec remove_assq x = function\n  | [] -> []\n  | (a, _ as pair) :: l -> if a == x then l else pair :: remove_assq x l\n\nlet rec find p = function\n  | [] -> raise Not_found\n  | x :: l -> if p x then x else find p l\n\nlet find_all p =\n  let rec find accu = function\n  | [] -> rev accu\n  | x :: l -> if p x then find (x :: accu) l else find accu l in\n  find []\n\nlet filter = find_all\n\nlet partition p l =\n  let rec part yes no = function\n  | [] -> (rev yes, rev no)\n  | x :: l -> if p x then part (x :: yes) no l else part yes (x :: no) l in\n  part [] [] l\n\nlet rec split = function\n    [] -> ([], [])\n  | (x,y)::l ->\n      let (rx, ry) = split l in (x::rx, y::ry)\n\nlet rec combine l1 l2 =\n  match (l1, l2) with\n    ([], []) -> []\n  | (a1::l1, a2::l2) -> (a1, a2) :: combine l1 l2\n  | (_, _) -> invalid_arg \"List.combine\"\n\n(** sorting *)\n\nlet rec merge cmp l1 l2 =\n  match l1, l2 with\n  | [], l2 -> l2\n  | l1, [] -> l1\n  | h1 :: t1, h2 :: t2 ->\n      if cmp h1 h2 <= 0\n      then h1 :: merge cmp t1 l2\n      else h2 :: merge cmp l1 t2\n\n\nlet rec chop k l =\n  if k = 0 then l else begin\n    match l with\n    | _::t -> chop (k-1) t\n    | _ -> assert false\n  end\n\n\nlet stable_sort cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 <= 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        if cmp h1 h2 > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       if cmp x1 x2 <= 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       if cmp x1 x2 <= 0 then begin\n         if cmp x2 x3 <= 0 then [x1; x2; x3]\n         else if cmp x1 x3 <= 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         if cmp x1 x3 <= 0 then [x2; x1; x3]\n         else if cmp x2 x3 <= 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = rev_sort n1 l in\n       let s2 = rev_sort n2 l2 in\n       rev_merge_rev s1 s2 []\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       if cmp x1 x2 > 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       if cmp x1 x2 > 0 then begin\n         if cmp x2 x3 > 0 then [x1; x2; x3]\n         else if cmp x1 x3 > 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         if cmp x1 x3 > 0 then [x2; x1; x3]\n         else if cmp x2 x3 > 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = sort n1 l in\n       let s2 = sort n2 l2 in\n       rev_merge s1 s2 []\n  in\n  let len = length l in\n  if len < 2 then l else sort len l\n\n\nlet sort = stable_sort\nlet fast_sort = stable_sort\n\n(* Note: on a list of length between about 100000 (depending on the minor\n   heap size and the type of the list) and Sys.max_array_size, it is\n   actually faster to use the following, but it might also use more memory\n   because the argument list cannot be deallocated incrementally.\n\n   Also, there seems to be a bug in this code or in the\n   implementation of obj_truncate.\n\nexternal obj_truncate : 'a array -> int -> unit = \"caml_obj_truncate\"\n\nlet array_to_list_in_place a =\n  let l = Array.length a in\n  let rec loop accu n p =\n    if p <= 0 then accu else begin\n      if p = n then begin\n        obj_truncate a p;\n        loop (a.(p-1) :: accu) (n-1000) (p-1)\n      end else begin\n        loop (a.(p-1) :: accu) n (p-1)\n      end\n    end\n  in\n  loop [] (l-1000) l\n\n\nlet stable_sort cmp l =\n  let a = Array.of_list l in\n  Array.stable_sort cmp a;\n  array_to_list_in_place a\n\n*)\n\n\n(** sorting + removing duplicates *)\n\nlet sort_uniq cmp l =\n  let rec rev_merge l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge t1 t2 (h1::accu)\n        else if c < 0\n        then rev_merge t1 l2 (h1::accu)\n        else rev_merge l1 t2 (h2::accu)\n  in\n  let rec rev_merge_rev l1 l2 accu =\n    match l1, l2 with\n    | [], l2 -> rev_append l2 accu\n    | l1, [] -> rev_append l1 accu\n    | h1::t1, h2::t2 ->\n        let c = cmp h1 h2 in\n        if c = 0 then rev_merge_rev t1 t2 (h1::accu)\n        else if c > 0\n        then rev_merge_rev t1 l2 (h1::accu)\n        else rev_merge_rev l1 t2 (h2::accu)\n  in\n  let rec sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then [x1]\n       else if c < 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x2]\n         else if c < 0 then [x2; x3] else [x3; x2]\n       end else if c < 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x1; x2]\n         else if c < 0 then [x1; x2; x3]\n         else let c = cmp x1 x3 in\n         if c = 0 then [x1; x2]\n         else if c < 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         let c = cmp x1 x3 in\n         if c = 0 then [x2; x1]\n         else if c < 0 then [x2; x1; x3]\n         else let c = cmp x2 x3 in\n         if c = 0 then [x2; x1]\n         else if c < 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = rev_sort n1 l in\n       let s2 = rev_sort n2 l2 in\n       rev_merge_rev s1 s2 []\n  and rev_sort n l =\n    match n, l with\n    | 2, x1 :: x2 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then [x1]\n       else if c > 0 then [x1; x2] else [x2; x1]\n    | 3, x1 :: x2 :: x3 :: _ ->\n       let c = cmp x1 x2 in\n       if c = 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x2]\n         else if c > 0 then [x2; x3] else [x3; x2]\n       end else if c > 0 then begin\n         let c = cmp x2 x3 in\n         if c = 0 then [x1; x2]\n         else if c > 0 then [x1; x2; x3]\n         else let c = cmp x1 x3 in\n         if c = 0 then [x1; x2]\n         else if c > 0 then [x1; x3; x2]\n         else [x3; x1; x2]\n       end else begin\n         let c = cmp x1 x3 in\n         if c = 0 then [x2; x1]\n         else if c > 0 then [x2; x1; x3]\n         else let c = cmp x2 x3 in\n         if c = 0 then [x2; x1]\n         else if c > 0 then [x2; x3; x1]\n         else [x3; x2; x1]\n       end\n    | n, l ->\n       let n1 = n asr 1 in\n       let n2 = n - n1 in\n       let l2 = chop n1 l in\n       let s1 = sort n1 l in\n       let s2 = sort n2 l2 in\n       rev_merge s1 s2 []\n  in\n  let len = length l in\n  if len < 2 then l else sort len l\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Character operations *)\n\nexternal code: char -> int = \"%identity\"\nexternal unsafe_chr: int -> char = \"%identity\"\n\nlet chr n =\n  if n < 0 || n > 255 then invalid_arg \"Char.chr\" else unsafe_chr n\n\nexternal bytes_create: int -> bytes = \"caml_create_bytes\"\nexternal bytes_unsafe_set : bytes -> int -> char -> unit\n                           = \"%bytes_unsafe_set\"\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\n\nlet escaped = function\n  | '\\'' -> \"\\\\'\"\n  | '\\\\' -> \"\\\\\\\\\"\n  | '\\n' -> \"\\\\n\"\n  | '\\t' -> \"\\\\t\"\n  | '\\r' -> \"\\\\r\"\n  | '\\b' -> \"\\\\b\"\n  | ' ' .. '~' as c ->\n      let s = bytes_create 1 in\n      bytes_unsafe_set s 0 c;\n      unsafe_to_string s\n  | c ->\n      let n = code c in\n      let s = bytes_create 4 in\n      bytes_unsafe_set s 0 '\\\\';\n      bytes_unsafe_set s 1 (unsafe_chr (48 + n / 100));\n      bytes_unsafe_set s 2 (unsafe_chr (48 + (n / 10) mod 10));\n      bytes_unsafe_set s 3 (unsafe_chr (48 + n mod 10));\n      unsafe_to_string s\n\nlet lowercase c =\n  if (c >= 'A' && c <= 'Z')\n  || (c >= '\\192' && c <= '\\214')\n  || (c >= '\\216' && c <= '\\222')\n  then unsafe_chr(code c + 32)\n  else c\n\nlet uppercase c =\n  if (c >= 'a' && c <= 'z')\n  || (c >= '\\224' && c <= '\\246')\n  || (c >= '\\248' && c <= '\\254')\n  then unsafe_chr(code c - 32)\n  else c\n\nlet lowercase_ascii c =\n  if (c >= 'A' && c <= 'Z')\n  then unsafe_chr(code c + 32)\n  else c\n\nlet uppercase_ascii c =\n  if (c >= 'a' && c <= 'z')\n  then unsafe_chr(code c - 32)\n  else c\n\ntype t = char\n\nlet compare c1 c2 = code c1 - code c2\nlet equal (c1: t) (c2: t) = compare c1 c2 = 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in string.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in string.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : bytes -> int = \"%bytes_length\"\nexternal string_length : string -> int = \"%string_length\"\nexternal get : bytes -> int -> char = \"%bytes_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%bytes_safe_set\"\nexternal create : int -> bytes = \"caml_create_bytes\"\nexternal unsafe_get : bytes -> int -> char = \"%bytes_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%bytes_unsafe_set\"\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_bytes\" [@@noalloc]\nexternal unsafe_to_string : bytes -> string = \"%bytes_to_string\"\nexternal unsafe_of_string : string -> bytes = \"%bytes_of_string\"\n\nexternal unsafe_blit : bytes -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_bytes\" [@@noalloc]\nexternal unsafe_blit_string : string -> int -> bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\n\nlet make n c =\n  let s = create n in\n  unsafe_fill s 0 n c;\n  s\n\nlet init n f =\n  let s = create n in\n  for i = 0 to n - 1 do\n    unsafe_set s i (f i)\n  done;\n  s\n\nlet empty = create 0\n\nlet copy s =\n  let len = length s in\n  let r = create len in\n  unsafe_blit s 0 r 0 len;\n  r\n\nlet to_string b = unsafe_to_string (copy b)\nlet of_string s = copy (unsafe_of_string s)\n\nlet sub s ofs len =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.sub / Bytes.sub\"\n  else begin\n    let r = create len in\n    unsafe_blit s ofs r 0 len;\n    r\n  end\n\nlet sub_string b ofs len = unsafe_to_string (sub b ofs len)\n\nlet extend s left right =\n  let len = length s + left + right in\n  let r = create len in\n  let (srcoff, dstoff) = if left < 0 then -left, 0 else 0, left in\n  let cpylen = min (length s - srcoff) (len - dstoff) in\n  if cpylen > 0 then unsafe_blit s srcoff r dstoff cpylen;\n  r\n\nlet fill s ofs len c =\n  if ofs < 0 || len < 0 || ofs > length s - len\n  then invalid_arg \"String.fill / Bytes.fill\"\n  else unsafe_fill s ofs len c\n\nlet blit s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"Bytes.blit\"\n  else unsafe_blit s1 ofs1 s2 ofs2 len\n\nlet blit_string s1 ofs1 s2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > string_length s1 - len\n             || ofs2 < 0 || ofs2 > length s2 - len\n  then invalid_arg \"String.blit / Bytes.blit_string\"\n  else unsafe_blit_string s1 ofs1 s2 ofs2 len\n\n(* duplicated in string.ml *)\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\n(* duplicated in string.ml *)\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet ensure_ge x y = if x >= y then x else invalid_arg \"Bytes.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> empty\n  | l -> let seplen = length sep in\n          unsafe_blits \n            (create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\nlet cat s1 s2 =\n  let l1 = length s1 in\n  let l2 = length s2 in\n  let r = create (l1 + l2) in\n  unsafe_blit s1 0 r 0 l1;\n  unsafe_blit s2 0 r l1 l2;\n  r\n\n\nexternal char_code: char -> int = \"%identity\"\nexternal char_chr: int -> char = \"%identity\"\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  let len = length s in\n  let i = ref 0 in\n  while !i < len && is_space (unsafe_get s !i) do\n    incr i\n  done;\n  let j = ref (len - 1) in\n  while !j >= !i && is_space (unsafe_get s !j) do\n    decr j\n  done;\n  if !j >= !i then\n    sub s !i (!j - !i + 1)\n  else\n    empty\n\nlet escaped s =\n  let n = ref 0 in\n  for i = 0 to length s - 1 do\n    n := !n +\n      (match unsafe_get s i with\n       | '\\\"' | '\\\\' | '\\n' | '\\t' | '\\r' | '\\b' -> 2\n       | ' ' .. '~' -> 1\n       | _ -> 4)\n  done;\n  if !n = length s then copy s else begin\n    let s' = create !n in\n    n := 0;\n    for i = 0 to length s - 1 do\n      begin match unsafe_get s i with\n      | ('\\\"' | '\\\\') as c ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n c\n      | '\\n' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'n'\n      | '\\t' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 't'\n      | '\\r' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'r'\n      | '\\b' ->\n          unsafe_set s' !n '\\\\'; incr n; unsafe_set s' !n 'b'\n      | (' ' .. '~') as c -> unsafe_set s' !n c\n      | c ->\n          let a = char_code c in\n          unsafe_set s' !n '\\\\';\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a / 100));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + (a / 10) mod 10));\n          incr n;\n          unsafe_set s' !n (char_chr (48 + a mod 10));\n      end;\n      incr n\n    done;\n    s'\n  end\n\nlet map f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f (unsafe_get s i)) done;\n    r\n  end\n\nlet mapi f s =\n  let l = length s in\n  if l = 0 then s else begin\n    let r = create l in\n    for i = 0 to l - 1 do unsafe_set r i (f i (unsafe_get s i)) done;\n    r\n  end\n\nlet uppercase_ascii s = map Char.uppercase_ascii s\nlet lowercase_ascii s = map Char.lowercase_ascii s\n\nlet apply1 f s =\n  if length s = 0 then s else begin\n    let r = copy s in\n    unsafe_set r 0 (f(unsafe_get s 0));\n    r\n  end\n\nlet capitalize_ascii s = apply1 Char.uppercase_ascii s\nlet uncapitalize_ascii s = apply1 Char.lowercase_ascii s\n\n(* duplicated in string.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in string.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in string.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n  index_rec s l i c\n\n(* duplicated in string.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in string.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in string.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n\n(* duplicated in string.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n\n(* duplicated in string.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in string.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\n\ntype t = bytes\n\nlet compare (x: t) (y: t) = Pervasives.compare x y\nexternal equal : t -> t -> bool = \"caml_bytes_equal\"\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s = map Char.uppercase s\nlet lowercase s = map Char.lowercase s\n\nlet capitalize s = apply1 Char.uppercase s\nlet uncapitalize s = apply1 Char.lowercase s\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*           Damien Doligez, projet Gallium, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 2014 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* String operations, based on byte sequence operations *)\n\n(* WARNING: Some functions in this file are duplicated in bytes.ml for\n   efficiency reasons. When you modify the one in this file you need to\n   modify its duplicate in bytes.ml.\n   These functions have a \"duplicated\" comment above their definition.\n*)\n\nexternal length : string -> int = \"%string_length\"\nexternal get : string -> int -> char = \"%string_safe_get\"\nexternal set : bytes -> int -> char -> unit = \"%string_safe_set\"\nexternal create : int -> bytes = \"caml_create_string\"\nexternal unsafe_get : string -> int -> char = \"%string_unsafe_get\"\nexternal unsafe_set : bytes -> int -> char -> unit = \"%string_unsafe_set\"\nexternal unsafe_blit : string -> int ->  bytes -> int -> int -> unit\n                     = \"caml_blit_string\" [@@noalloc]\nexternal unsafe_fill : bytes -> int -> int -> char -> unit\n                     = \"caml_fill_string\" [@@noalloc]\n\nmodule B = Bytes\n\nlet bts = B.unsafe_to_string\nlet bos = B.unsafe_of_string\n\nlet make n c =\n  B.make n c |> bts\nlet init n f =\n  B.init n f |> bts\nlet copy s =\n  B.copy (bos s) |> bts\nlet sub s ofs len =\n  B.sub (bos s) ofs len |> bts\nlet fill =\n  B.fill\nlet blit =\n  B.blit_string\n\nlet ensure_ge x y = if x >= y then x else invalid_arg \"String.concat\"\n\nlet rec sum_lengths acc seplen = function\n  | [] -> acc\n  | hd :: [] -> length hd + acc\n  | hd :: tl -> sum_lengths (ensure_ge (length hd + seplen + acc) acc) seplen tl\n\nlet rec unsafe_blits dst pos sep seplen = function\n    [] -> dst\n  | hd :: [] ->\n    unsafe_blit hd 0 dst pos (length hd); dst\n  | hd :: tl ->\n    unsafe_blit hd 0 dst pos (length hd);\n    unsafe_blit sep 0 dst (pos + length hd) seplen;\n    unsafe_blits dst (pos + length hd + seplen) sep seplen tl\n\nlet concat sep = function\n    [] -> \"\"\n  | l -> let seplen = length sep in bts @@\n          unsafe_blits \n            (B.create (sum_lengths 0 seplen l))\n            0 sep seplen l\n\n(* duplicated in bytes.ml *)\nlet iter f s =\n  for i = 0 to length s - 1 do f (unsafe_get s i) done\n\n(* duplicated in bytes.ml *)\nlet iteri f s =\n  for i = 0 to length s - 1 do f i (unsafe_get s i) done\n\nlet map f s =\n  B.map f (bos s) |> bts\nlet mapi f s =\n  B.mapi f (bos s) |> bts\n\n(* Beware: we cannot use B.trim or B.escape because they always make a\n   copy, but String.mli spells out some cases where we are not allowed\n   to make a copy. *)\n\nlet is_space = function\n  | ' ' | '\\012' | '\\n' | '\\r' | '\\t' -> true\n  | _ -> false\n\nlet trim s =\n  if s = \"\" then s\n  else if is_space (unsafe_get s 0) || is_space (unsafe_get s (length s - 1))\n    then bts (B.trim (bos s))\n  else s\n\nlet escaped s =\n  let rec needs_escape i =\n    if i >= length s then false else\n      match unsafe_get s i with\n      | '\\\"' | '\\\\' | '\\n' | '\\t' | '\\r' | '\\b' -> true\n      | ' ' .. '~' -> needs_escape (i+1)\n      | _ -> true\n  in\n  if needs_escape 0 then\n    bts (B.escaped (bos s))\n  else\n    s\n\n(* duplicated in bytes.ml *)\nlet rec index_rec s lim i c =\n  if i >= lim then raise Not_found else\n  if unsafe_get s i = c then i else index_rec s lim (i + 1) c\n\n(* duplicated in bytes.ml *)\nlet index s c = index_rec s (length s) 0 c\n\n(* duplicated in bytes.ml *)\nlet index_from s i c =\n  let l = length s in\n  if i < 0 || i > l then invalid_arg \"String.index_from / Bytes.index_from\" else\n    index_rec s l i c\n\n(* duplicated in bytes.ml *)\nlet rec rindex_rec s i c =\n  if i < 0 then raise Not_found else\n  if unsafe_get s i = c then i else rindex_rec s (i - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex s c = rindex_rec s (length s - 1) c\n\n(* duplicated in bytes.ml *)\nlet rindex_from s i c =\n  if i < -1 || i >= length s then\n    invalid_arg \"String.rindex_from / Bytes.rindex_from\"\n  else\n    rindex_rec s i c\n\n(* duplicated in bytes.ml *)\nlet contains_from s i c =\n  let l = length s in\n  if i < 0 || i > l then\n    invalid_arg \"String.contains_from / Bytes.contains_from\"\n  else\n    try ignore (index_rec s l i c); true with Not_found -> false\n\n(* duplicated in bytes.ml *)\nlet contains s c = contains_from s 0 c\n\n(* duplicated in bytes.ml *)\nlet rcontains_from s i c =\n  if i < 0 || i >= length s then\n    invalid_arg \"String.rcontains_from / Bytes.rcontains_from\"\n  else\n    try ignore (rindex_rec s i c); true with Not_found -> false\n\nlet uppercase_ascii s =\n  B.uppercase_ascii (bos s) |> bts\nlet lowercase_ascii s =\n  B.lowercase_ascii (bos s) |> bts\nlet capitalize_ascii s =\n  B.capitalize_ascii (bos s) |> bts\nlet uncapitalize_ascii s =\n  B.uncapitalize_ascii (bos s) |> bts\n\ntype t = string\n\nlet compare (x: t) (y: t) = Pervasives.compare x y\nexternal equal : string -> string -> bool = \"caml_string_equal\"\n\nlet split_on_char sep s =\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if unsafe_get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\n(* Deprecated functions implemented via other deprecated functions *)\n[@@@ocaml.warning \"-3\"]\nlet uppercase s =\n  B.uppercase (bos s) |> bts\nlet lowercase s =\n  B.lowercase (bos s) |> bts\nlet capitalize s =\n  B.capitalize (bos s) |> bts\nlet uncapitalize s =\n  B.uncapitalize (bos s) |> bts\n","#2 \"stdlib/sys.mlp\"\n(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* WARNING: sys.ml is generated from sys.mlp.  DO NOT EDIT sys.ml or\n   your changes will be lost.\n*)\n\ntype backend_type =\n  | Native\n  | Bytecode\n  | Other of string\n(* System interface *)\n\nexternal get_config: unit -> string * int * bool = \"caml_sys_get_config\"\nexternal get_argv: unit -> string * string array = \"caml_sys_get_argv\"\nexternal big_endian : unit -> bool = \"%big_endian\"\nexternal word_size : unit -> int = \"%word_size\"\nexternal int_size : unit -> int = \"%int_size\"\nexternal max_wosize : unit -> int = \"%max_wosize\"\nexternal unix : unit -> bool = \"%ostype_unix\"\nexternal win32 : unit -> bool = \"%ostype_win32\"\nexternal cygwin : unit -> bool = \"%ostype_cygwin\"\nexternal get_backend_type : unit -> backend_type = \"%backend_type\"\n\nlet (executable_name, argv) = get_argv()\nlet (os_type, _, _) = get_config()\nlet backend_type = get_backend_type ()\nlet big_endian = big_endian ()\nlet word_size = word_size ()\nlet int_size = int_size ()\nlet unix = unix ()\nlet win32 = win32 ()\nlet cygwin = cygwin ()\nlet max_array_length = max_wosize ()\nlet max_string_length = word_size / 8 * max_array_length - 1\nexternal runtime_variant : unit -> string = \"caml_runtime_variant\"\nexternal runtime_parameters : unit -> string = \"caml_runtime_parameters\"\n\nexternal file_exists: string -> bool = \"caml_sys_file_exists\"\nexternal is_directory : string -> bool = \"caml_sys_is_directory\"\nexternal remove: string -> unit = \"caml_sys_remove\"\nexternal rename : string -> string -> unit = \"caml_sys_rename\"\nexternal getenv: string -> string = \"caml_sys_getenv\"\nexternal command: string -> int = \"caml_sys_system_command\"\nexternal time: unit -> (float [@unboxed]) =\n  \"caml_sys_time\" \"caml_sys_time_unboxed\" [@@noalloc]\nexternal chdir: string -> unit = \"caml_sys_chdir\"\nexternal getcwd: unit -> string = \"caml_sys_getcwd\"\nexternal readdir : string -> string array = \"caml_sys_read_directory\"\n\nlet interactive = ref false\n\ntype signal_behavior =\n    Signal_default\n  | Signal_ignore\n  | Signal_handle of (int -> unit)\n\nexternal signal : int -> signal_behavior -> signal_behavior\n                = \"caml_install_signal_handler\"\n\nlet set_signal sig_num sig_beh = ignore(signal sig_num sig_beh)\n\nlet sigabrt = -1\nlet sigalrm = -2\nlet sigfpe = -3\nlet sighup = -4\nlet sigill = -5\nlet sigint = -6\nlet sigkill = -7\nlet sigpipe = -8\nlet sigquit = -9\nlet sigsegv = -10\nlet sigterm = -11\nlet sigusr1 = -12\nlet sigusr2 = -13\nlet sigchld = -14\nlet sigcont = -15\nlet sigstop = -16\nlet sigtstp = -17\nlet sigttin = -18\nlet sigttou = -19\nlet sigvtalrm = -20\nlet sigprof = -21\nlet sigbus = -22\nlet sigpoll = -23\nlet sigsys = -24\nlet sigtrap = -25\nlet sigurg = -26\nlet sigxcpu = -27\nlet sigxfsz = -28\n\nexception Break\n\nlet catch_break on =\n  if on then\n    set_signal sigint (Signal_handle(fun _ -> raise Break))\n  else\n    set_signal sigint Signal_default\n\n\nexternal enable_runtime_warnings: bool -> unit =\n  \"caml_ml_enable_runtime_warnings\"\nexternal runtime_warnings_enabled: unit -> bool =\n  \"caml_ml_runtime_warnings_enabled\"\n\n(* The version string is found in file ../VERSION *)\n\nlet ocaml_version = \"4.04.2\"\n\n(* Optimization *)\n\nexternal opaque_identity : 'a -> 'a = \"%opaque\"\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1997 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ntype extern_flags =\n    No_sharing\n  | Closures\n  | Compat_32\n(* note: this type definition is used in 'byterun/debugger.c' *)\n\nexternal to_channel: out_channel -> 'a -> extern_flags list -> unit\n    = \"caml_output_value\"\nexternal to_bytes: 'a -> extern_flags list -> bytes\n    = \"caml_output_value_to_string\"\nexternal to_string: 'a -> extern_flags list -> string\n    = \"caml_output_value_to_string\"\nexternal to_buffer_unsafe:\n      bytes -> int -> int -> 'a -> extern_flags list -> int\n    = \"caml_output_value_to_buffer\"\n\nlet to_buffer buff ofs len v flags =\n  if ofs < 0 || len < 0 || ofs > Bytes.length buff - len\n  then invalid_arg \"Marshal.to_buffer: substring out of bounds\"\n  else to_buffer_unsafe buff ofs len v flags\n\n(* The functions below use byte sequences as input, never using any\n   mutation. It makes sense to use non-mutated [bytes] rather than\n   [string], because we really work with sequences of bytes, not\n   a text representation.\n*)\n\nexternal from_channel: in_channel -> 'a = \"caml_input_value\"\nexternal from_bytes_unsafe: bytes -> int -> 'a\n                           = \"caml_input_value_from_string\"\nexternal data_size_unsafe: bytes -> int -> int = \"caml_marshal_data_size\"\n\nlet header_size = 20\nlet data_size buff ofs =\n  if ofs < 0 || ofs > Bytes.length buff - header_size\n  then invalid_arg \"Marshal.data_size\"\n  else data_size_unsafe buff ofs\nlet total_size buff ofs = header_size + data_size buff ofs\n\nlet from_bytes buff ofs =\n  if ofs < 0 || ofs > Bytes.length buff - header_size\n  then invalid_arg \"Marshal.from_bytes\"\n  else begin\n    let len = data_size_unsafe buff ofs in\n    if ofs > Bytes.length buff - (header_size + len)\n    then invalid_arg \"Marshal.from_bytes\"\n    else from_bytes_unsafe buff ofs\n  end\n\nlet from_string buff ofs =\n  (* Bytes.unsafe_of_string is safe here, as the produced byte\n     sequence is never mutated *)\n  from_bytes (Bytes.unsafe_of_string buff) ofs\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Operations on internal representations of values *)\n\ntype t\n\nexternal repr : 'a -> t = \"%identity\"\nexternal obj : t -> 'a = \"%identity\"\nexternal magic : 'a -> 'b = \"%identity\"\nexternal is_int : t -> bool = \"%obj_is_int\"\nlet [@inline always] is_block a = not (is_int a)\nexternal tag : t -> int = \"caml_obj_tag\"\nexternal set_tag : t -> int -> unit = \"caml_obj_set_tag\"\nexternal size : t -> int = \"%obj_size\"\nexternal reachable_words : t -> int = \"caml_obj_reachable_words\"\nexternal field : t -> int -> t = \"%obj_field\"\nexternal set_field : t -> int -> t -> unit = \"%obj_set_field\"\nexternal array_get: 'a array -> int -> 'a = \"%array_safe_get\"\nexternal array_set: 'a array -> int -> 'a -> unit = \"%array_safe_set\"\nlet [@inline always] double_field x i = array_get (obj x : float array) i\nlet [@inline always] set_double_field x i v =\n  array_set (obj x : float array) i v\nexternal new_block : int -> int -> t = \"caml_obj_block\"\nexternal dup : t -> t = \"caml_obj_dup\"\nexternal truncate : t -> int -> unit = \"caml_obj_truncate\"\nexternal add_offset : t -> Int32.t -> t = \"caml_obj_add_offset\"\n\nlet marshal (obj : t) =\n  Marshal.to_bytes obj []\nlet unmarshal str pos =\n  (Marshal.from_bytes str pos, pos + Marshal.total_size str pos)\n\nlet first_non_constant_constructor_tag = 0\nlet last_non_constant_constructor_tag = 245\n\nlet lazy_tag = 246\nlet closure_tag = 247\nlet object_tag = 248\nlet infix_tag = 249\nlet forward_tag = 250\n\nlet no_scan_tag = 251\n\nlet abstract_tag = 251\nlet string_tag = 252\nlet double_tag = 253\nlet double_array_tag = 254\nlet custom_tag = 255\nlet final_tag = custom_tag\n\n\nlet int_tag = 1000\nlet out_of_heap_tag = 1001\nlet unaligned_tag = 1002\n\nlet extension_constructor x =\n  let x = repr x in\n  let slot =\n    if (is_block x) && (tag x) <> object_tag && (size x) >= 1 then field x 0\n    else x\n  in\n  let name =\n    if (is_block slot) && (tag slot) = object_tag then field slot 0\n    else invalid_arg \"Obj.extension_constructor\"\n  in\n    if (tag name) = string_tag then (obj slot : extension_constructor)\n    else invalid_arg \"Obj.extension_constructor\"\n\nlet [@inline always] extension_name (slot : extension_constructor) =\n  (obj (field (repr slot) 0) : string)\n\nlet [@inline always] extension_id (slot : extension_constructor) =\n  (obj (field (repr slot) 1) : int)\n\nmodule Ephemeron = struct\n  type obj_t = t\n\n  type t (** ephemeron *)\n\n  external create: int -> t = \"caml_ephe_create\"\n\n  let length x = size(repr x) - 2\n\n  external get_key: t -> int -> obj_t option = \"caml_ephe_get_key\"\n  external get_key_copy: t -> int -> obj_t option = \"caml_ephe_get_key_copy\"\n  external set_key: t -> int -> obj_t -> unit = \"caml_ephe_set_key\"\n  external unset_key: t -> int -> unit = \"caml_ephe_unset_key\"\n  external check_key: t -> int -> bool = \"caml_ephe_check_key\"\n  external blit_key : t -> int -> t -> int -> int -> unit\n    = \"caml_ephe_blit_key\"\n\n  external get_data: t -> obj_t option = \"caml_ephe_get_data\"\n  external get_data_copy: t -> obj_t option = \"caml_ephe_get_data_copy\"\n  external set_data: t -> obj_t -> unit = \"caml_ephe_set_data\"\n  external unset_data: t -> unit = \"caml_ephe_unset_data\"\n  external check_data: t -> bool = \"caml_ephe_check_data\"\n  external blit_data : t -> t -> unit = \"caml_ephe_blit_data\"\n\n\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Array operations *)\n\nexternal length : 'a array -> int = \"%array_length\"\nexternal get: 'a array -> int -> 'a = \"%array_safe_get\"\nexternal set: 'a array -> int -> 'a -> unit = \"%array_safe_set\"\nexternal unsafe_get: 'a array -> int -> 'a = \"%array_unsafe_get\"\nexternal unsafe_set: 'a array -> int -> 'a -> unit = \"%array_unsafe_set\"\nexternal make: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal create: int -> 'a -> 'a array = \"caml_make_vect\"\nexternal unsafe_sub : 'a array -> int -> int -> 'a array = \"caml_array_sub\"\nexternal append_prim : 'a array -> 'a array -> 'a array = \"caml_array_append\"\nexternal concat : 'a array list -> 'a array = \"caml_array_concat\"\nexternal unsafe_blit :\n  'a array -> int -> 'a array -> int -> int -> unit = \"caml_array_blit\"\nexternal create_float: int -> float array = \"caml_make_float_vect\"\nlet make_float = create_float\n\nlet init l f =\n  if l = 0 then [||] else\n  if l < 0 then invalid_arg \"Array.init\"\n  (* See #6575. We could also check for maximum array size, but this depends\n     on whether we create a float array or a regular one... *)\n  else\n   let res = create l (f 0) in\n   for i = 1 to pred l do\n     unsafe_set res i (f i)\n   done;\n   res\n\nlet make_matrix sx sy init =\n  let res = create sx [||] in\n  for x = 0 to pred sx do\n    unsafe_set res x (create sy init)\n  done;\n  res\n\nlet create_matrix = make_matrix\n\nlet copy a =\n  let l = length a in if l = 0 then [||] else unsafe_sub a 0 l\n\nlet append a1 a2 =\n  let l1 = length a1 in\n  if l1 = 0 then copy a2\n  else if length a2 = 0 then unsafe_sub a1 0 l1\n  else append_prim a1 a2\n\nlet sub a ofs len =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.sub\"\n  else unsafe_sub a ofs len\n\nlet fill a ofs len v =\n  if ofs < 0 || len < 0 || ofs > length a - len\n  then invalid_arg \"Array.fill\"\n  else for i = ofs to ofs + len - 1 do unsafe_set a i v done\n\nlet blit a1 ofs1 a2 ofs2 len =\n  if len < 0 || ofs1 < 0 || ofs1 > length a1 - len\n             || ofs2 < 0 || ofs2 > length a2 - len\n  then invalid_arg \"Array.blit\"\n  else unsafe_blit a1 ofs1 a2 ofs2 len\n\nlet iter f a =\n  for i = 0 to length a - 1 do f(unsafe_get a i) done\n\nlet iter2 f a b =\n  if length a <> length b then\n    invalid_arg \"Array.iter2: arrays must have the same length\"\n  else\n    for i = 0 to length a - 1 do f (unsafe_get a i) (unsafe_get b i) done\n\nlet map f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f(unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f(unsafe_get a i))\n    done;\n    r\n  end\n\nlet map2 f a b =\n  let la = length a in\n  let lb = length b in\n  if la <> lb then\n    invalid_arg \"Array.map2: arrays must have the same length\"\n  else begin\n    if la = 0 then [||] else begin\n      let r = create la (f (unsafe_get a 0) (unsafe_get b 0)) in\n      for i = 1 to la - 1 do\n        unsafe_set r i (f (unsafe_get a i) (unsafe_get b i))\n      done;\n      r\n    end\n  end\n\nlet iteri f a =\n  for i = 0 to length a - 1 do f i (unsafe_get a i) done\n\nlet mapi f a =\n  let l = length a in\n  if l = 0 then [||] else begin\n    let r = create l (f 0 (unsafe_get a 0)) in\n    for i = 1 to l - 1 do\n      unsafe_set r i (f i (unsafe_get a i))\n    done;\n    r\n  end\n\nlet to_list a =\n  let rec tolist i res =\n    if i < 0 then res else tolist (i - 1) (unsafe_get a i :: res) in\n  tolist (length a - 1) []\n\n(* Cannot use List.length here because the List module depends on Array. *)\nlet rec list_length accu = function\n  | [] -> accu\n  | _::t -> list_length (succ accu) t\n\nlet of_list = function\n    [] -> [||]\n  | hd::tl as l ->\n      let a = create (list_length 0 l) hd in\n      let rec fill i = function\n          [] -> a\n        | hd::tl -> unsafe_set a i hd; fill (i+1) tl in\n      fill 1 tl\n\nlet fold_left f x a =\n  let r = ref x in\n  for i = 0 to length a - 1 do\n    r := f !r (unsafe_get a i)\n  done;\n  !r\n\nlet fold_right f a x =\n  let r = ref x in\n  for i = length a - 1 downto 0 do\n    r := f (unsafe_get a i) !r\n  done;\n  !r\n\nlet exists p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if p (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nlet for_all p a =\n  let n = length a in\n  let rec loop i =\n    if i = n then true\n    else if p (unsafe_get a i) then loop (succ i)\n    else false in\n  loop 0\n\nlet mem x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if compare (unsafe_get a i) x = 0 then true\n    else loop (succ i) in\n  loop 0\n\nlet memq x a =\n  let n = length a in\n  let rec loop i =\n    if i = n then false\n    else if x == (unsafe_get a i) then true\n    else loop (succ i) in\n  loop 0\n\nexception Bottom of int\nlet sort cmp a =\n  let maxson l i =\n    let i31 = i+i+i+1 in\n    let x = ref i31 in\n    if i31+2 < l then begin\n      if cmp (get a i31) (get a (i31+1)) < 0 then x := i31+1;\n      if cmp (get a !x) (get a (i31+2)) < 0 then x := i31+2;\n      !x\n    end else\n      if i31+1 < l && cmp (get a i31) (get a (i31+1)) < 0\n      then i31+1\n      else if i31 < l then i31 else raise (Bottom i)\n  in\n  let rec trickledown l i e =\n    let j = maxson l i in\n    if cmp (get a j) e > 0 then begin\n      set a i (get a j);\n      trickledown l j e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let trickle l i e = try trickledown l i e with Bottom i -> set a i e in\n  let rec bubbledown l i =\n    let j = maxson l i in\n    set a i (get a j);\n    bubbledown l j\n  in\n  let bubble l i = try bubbledown l i with Bottom i -> i in\n  let rec trickleup i e =\n    let father = (i - 1) / 3 in\n    assert (i <> father);\n    if cmp (get a father) e < 0 then begin\n      set a i (get a father);\n      if father > 0 then trickleup father e else set a 0 e;\n    end else begin\n      set a i e;\n    end;\n  in\n  let l = length a in\n  for i = (l + 1) / 3 - 1 downto 0 do trickle l i (get a i); done;\n  for i = l - 1 downto 2 do\n    let e = (get a i) in\n    set a i (get a 0);\n    trickleup (bubble i 0) e;\n  done;\n  if l > 1 then (let e = (get a 1) in set a 1 (get a 0); set a 0 e)\n\n\nlet cutoff = 5\nlet stable_sort cmp a =\n  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =\n    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in\n    let rec loop i1 s1 i2 s2 d =\n      if cmp s1 s2 <= 0 then begin\n        set dst d s1;\n        let i1 = i1 + 1 in\n        if i1 < src1r then\n          loop i1 (get a i1) i2 s2 (d + 1)\n        else\n          blit src2 i2 dst (d + 1) (src2r - i2)\n      end else begin\n        set dst d s2;\n        let i2 = i2 + 1 in\n        if i2 < src2r then\n          loop i1 s1 i2 (get src2 i2) (d + 1)\n        else\n          blit a i1 dst (d + 1) (src1r - i1)\n      end\n    in loop src1ofs (get a src1ofs) src2ofs (get src2 src2ofs) dstofs;\n  in\n  let isortto srcofs dst dstofs len =\n    for i = 0 to len - 1 do\n      let e = (get a (srcofs + i)) in\n      let j = ref (dstofs + i - 1) in\n      while (!j >= dstofs && cmp (get dst !j) e > 0) do\n        set dst (!j + 1) (get dst !j);\n        decr j;\n      done;\n      set dst (!j + 1) e;\n    done;\n  in\n  let rec sortto srcofs dst dstofs len =\n    if len <= cutoff then isortto srcofs dst dstofs len else begin\n      let l1 = len / 2 in\n      let l2 = len - l1 in\n      sortto (srcofs + l1) dst (dstofs + l1) l2;\n      sortto srcofs a (srcofs + l2) l1;\n      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs;\n    end;\n  in\n  let l = length a in\n  if l <= cutoff then isortto 0 a 0 l else begin\n    let l1 = l / 2 in\n    let l2 = l - l1 in\n    let t = make l2 (get a 0) in\n    sortto l1 t 0 l2;\n    sortto 0 a l2 l1;\n    merge l2 l1 t 0 l2 a 0;\n  end\n\n\nlet fast_sort = stable_sort\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Module [Int32]: 32-bit integers *)\n\nexternal neg : int32 -> int32 = \"%int32_neg\"\nexternal add : int32 -> int32 -> int32 = \"%int32_add\"\nexternal sub : int32 -> int32 -> int32 = \"%int32_sub\"\nexternal mul : int32 -> int32 -> int32 = \"%int32_mul\"\nexternal div : int32 -> int32 -> int32 = \"%int32_div\"\nexternal rem : int32 -> int32 -> int32 = \"%int32_mod\"\nexternal logand : int32 -> int32 -> int32 = \"%int32_and\"\nexternal logor : int32 -> int32 -> int32 = \"%int32_or\"\nexternal logxor : int32 -> int32 -> int32 = \"%int32_xor\"\nexternal shift_left : int32 -> int -> int32 = \"%int32_lsl\"\nexternal shift_right : int32 -> int -> int32 = \"%int32_asr\"\nexternal shift_right_logical : int32 -> int -> int32 = \"%int32_lsr\"\nexternal of_int : int -> int32 = \"%int32_of_int\"\nexternal to_int : int32 -> int = \"%int32_to_int\"\nexternal of_float : float -> int32\n  = \"caml_int32_of_float\" \"caml_int32_of_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal to_float : int32 -> float\n  = \"caml_int32_to_float\" \"caml_int32_to_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal bits_of_float : float -> int32\n  = \"caml_int32_bits_of_float\" \"caml_int32_bits_of_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal float_of_bits : int32 -> float\n  = \"caml_int32_float_of_bits\" \"caml_int32_float_of_bits_unboxed\"\n  [@@unboxed] [@@noalloc]\n\nlet zero = 0l\nlet one = 1l\nlet minus_one = -1l\nlet succ n = add n 1l\nlet pred n = sub n 1l\nlet abs n = if n >= 0l then n else neg n\nlet min_int = 0x80000000l\nlet max_int = 0x7FFFFFFFl\nlet lognot n = logxor n (-1l)\n\nexternal format : string -> int32 -> string = \"caml_int32_format\"\nlet to_string n = format \"%d\" n\n\nexternal of_string : string -> int32 = \"caml_int32_of_string\"\n\ntype t = int32\n\nlet compare (x: t) (y: t) = Pervasives.compare x y\nlet equal (x: t) (y: t) = compare x y = 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Module [Int64]: 64-bit integers *)\n\nexternal neg : int64 -> int64 = \"%int64_neg\"\nexternal add : int64 -> int64 -> int64 = \"%int64_add\"\nexternal sub : int64 -> int64 -> int64 = \"%int64_sub\"\nexternal mul : int64 -> int64 -> int64 = \"%int64_mul\"\nexternal div : int64 -> int64 -> int64 = \"%int64_div\"\nexternal rem : int64 -> int64 -> int64 = \"%int64_mod\"\nexternal logand : int64 -> int64 -> int64 = \"%int64_and\"\nexternal logor : int64 -> int64 -> int64 = \"%int64_or\"\nexternal logxor : int64 -> int64 -> int64 = \"%int64_xor\"\nexternal shift_left : int64 -> int -> int64 = \"%int64_lsl\"\nexternal shift_right : int64 -> int -> int64 = \"%int64_asr\"\nexternal shift_right_logical : int64 -> int -> int64 = \"%int64_lsr\"\nexternal of_int : int -> int64 = \"%int64_of_int\"\nexternal to_int : int64 -> int = \"%int64_to_int\"\nexternal of_float : float -> int64\n  = \"caml_int64_of_float\" \"caml_int64_of_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal to_float : int64 -> float\n  = \"caml_int64_to_float\" \"caml_int64_to_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal of_int32 : int32 -> int64 = \"%int64_of_int32\"\nexternal to_int32 : int64 -> int32 = \"%int64_to_int32\"\nexternal of_nativeint : nativeint -> int64 = \"%int64_of_nativeint\"\nexternal to_nativeint : int64 -> nativeint = \"%int64_to_nativeint\"\n\nlet zero = 0L\nlet one = 1L\nlet minus_one = -1L\nlet succ n = add n 1L\nlet pred n = sub n 1L\nlet abs n = if n >= 0L then n else neg n\nlet min_int = 0x8000000000000000L\nlet max_int = 0x7FFFFFFFFFFFFFFFL\nlet lognot n = logxor n (-1L)\n\nexternal format : string -> int64 -> string = \"caml_int64_format\"\nlet to_string n = format \"%d\" n\n\nexternal of_string : string -> int64 = \"caml_int64_of_string\"\n\nexternal bits_of_float : float -> int64\n  = \"caml_int64_bits_of_float\" \"caml_int64_bits_of_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal float_of_bits : int64 -> float\n  = \"caml_int64_float_of_bits\" \"caml_int64_float_of_bits_unboxed\"\n  [@@unboxed] [@@noalloc]\n\ntype t = int64\n\nlet compare (x: t) (y: t) = Pervasives.compare x y\nlet equal (x: t) (y: t) = compare x y = 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Module [Nativeint]: processor-native integers *)\n\nexternal neg: nativeint -> nativeint = \"%nativeint_neg\"\nexternal add: nativeint -> nativeint -> nativeint = \"%nativeint_add\"\nexternal sub: nativeint -> nativeint -> nativeint = \"%nativeint_sub\"\nexternal mul: nativeint -> nativeint -> nativeint = \"%nativeint_mul\"\nexternal div: nativeint -> nativeint -> nativeint = \"%nativeint_div\"\nexternal rem: nativeint -> nativeint -> nativeint = \"%nativeint_mod\"\nexternal logand: nativeint -> nativeint -> nativeint = \"%nativeint_and\"\nexternal logor: nativeint -> nativeint -> nativeint = \"%nativeint_or\"\nexternal logxor: nativeint -> nativeint -> nativeint = \"%nativeint_xor\"\nexternal shift_left: nativeint -> int -> nativeint = \"%nativeint_lsl\"\nexternal shift_right: nativeint -> int -> nativeint = \"%nativeint_asr\"\nexternal shift_right_logical: nativeint -> int -> nativeint = \"%nativeint_lsr\"\nexternal of_int: int -> nativeint = \"%nativeint_of_int\"\nexternal to_int: nativeint -> int = \"%nativeint_to_int\"\nexternal of_float : float -> nativeint\n  = \"caml_nativeint_of_float\" \"caml_nativeint_of_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal to_float : nativeint -> float\n  = \"caml_nativeint_to_float\" \"caml_nativeint_to_float_unboxed\"\n  [@@unboxed] [@@noalloc]\nexternal of_int32: int32 -> nativeint = \"%nativeint_of_int32\"\nexternal to_int32: nativeint -> int32 = \"%nativeint_to_int32\"\n\nlet zero = 0n\nlet one = 1n\nlet minus_one = -1n\nlet succ n = add n 1n\nlet pred n = sub n 1n\nlet abs n = if n >= 0n then n else neg n\nlet size = Sys.word_size\nlet min_int = shift_left 1n (size - 1)\nlet max_int = sub min_int 1n\nlet lognot n = logxor n (-1n)\n\nexternal format : string -> nativeint -> string = \"caml_nativeint_format\"\nlet to_string n = format \"%d\" n\n\nexternal of_string: string -> nativeint = \"caml_nativeint_of_string\"\n\ntype t = nativeint\n\nlet compare (x: t) (y: t) = Pervasives.compare x y\nlet equal (x: t) (y: t) = compare x y = 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* The parsing engine *)\n\nopen Lexing\n\n(* Internal interface to the parsing engine *)\n\ntype parser_env =\n  { mutable s_stack : int array;        (* States *)\n    mutable v_stack : Obj.t array;      (* Semantic attributes *)\n    mutable symb_start_stack : position array; (* Start positions *)\n    mutable symb_end_stack : position array;   (* End positions *)\n    mutable stacksize : int;            (* Size of the stacks *)\n    mutable stackbase : int;            (* Base sp for current parse *)\n    mutable curr_char : int;            (* Last token read *)\n    mutable lval : Obj.t;               (* Its semantic attribute *)\n    mutable symb_start : position;      (* Start pos. of the current symbol*)\n    mutable symb_end : position;        (* End pos. of the current symbol *)\n    mutable asp : int;                  (* The stack pointer for attributes *)\n    mutable rule_len : int;             (* Number of rhs items in the rule *)\n    mutable rule_number : int;          (* Rule number to reduce by *)\n    mutable sp : int;                   (* Saved sp for parse_engine *)\n    mutable state : int;                (* Saved state for parse_engine *)\n    mutable errflag : int }             (* Saved error flag for parse_engine *)\n\ntype parse_tables =\n  { actions : (parser_env -> Obj.t) array;\n    transl_const : int array;\n    transl_block : int array;\n    lhs : string;\n    len : string;\n    defred : string;\n    dgoto : string;\n    sindex : string;\n    rindex : string;\n    gindex : string;\n    tablesize : int;\n    table : string;\n    check : string;\n    error_function : string -> unit;\n    names_const : string;\n    names_block : string }\n\nexception YYexit of Obj.t\nexception Parse_error\n\ntype parser_input =\n    Start\n  | Token_read\n  | Stacks_grown_1\n  | Stacks_grown_2\n  | Semantic_action_computed\n  | Error_detected\n\ntype parser_output =\n    Read_token\n  | Raise_parse_error\n  | Grow_stacks_1\n  | Grow_stacks_2\n  | Compute_semantic_action\n  | Call_error_function\n\n(* to avoid warnings *)\nlet _ = [Read_token; Raise_parse_error; Grow_stacks_1; Grow_stacks_2;\n         Compute_semantic_action; Call_error_function]\n\nexternal parse_engine :\n    parse_tables -> parser_env -> parser_input -> Obj.t -> parser_output\n    = \"caml_parse_engine\"\n\nexternal set_trace: bool -> bool\n    = \"caml_set_parser_trace\"\n\nlet env =\n  { s_stack = Array.make 100 0;\n    v_stack = Array.make 100 (Obj.repr ());\n    symb_start_stack = Array.make 100 dummy_pos;\n    symb_end_stack = Array.make 100 dummy_pos;\n    stacksize = 100;\n    stackbase = 0;\n    curr_char = 0;\n    lval = Obj.repr ();\n    symb_start = dummy_pos;\n    symb_end = dummy_pos;\n    asp = 0;\n    rule_len = 0;\n    rule_number = 0;\n    sp = 0;\n    state = 0;\n    errflag = 0 }\n\nlet grow_stacks() =\n  let oldsize = env.stacksize in\n  let newsize = oldsize * 2 in\n  let new_s = Array.make newsize 0\n  and new_v = Array.make newsize (Obj.repr ())\n  and new_start = Array.make newsize dummy_pos\n  and new_end = Array.make newsize dummy_pos in\n    Array.blit env.s_stack 0 new_s 0 oldsize;\n    env.s_stack <- new_s;\n    Array.blit env.v_stack 0 new_v 0 oldsize;\n    env.v_stack <- new_v;\n    Array.blit env.symb_start_stack 0 new_start 0 oldsize;\n    env.symb_start_stack <- new_start;\n    Array.blit env.symb_end_stack 0 new_end 0 oldsize;\n    env.symb_end_stack <- new_end;\n    env.stacksize <- newsize\n\nlet clear_parser() =\n  Array.fill env.v_stack 0 env.stacksize (Obj.repr ());\n  env.lval <- Obj.repr ()\n\nlet current_lookahead_fun = ref (fun (_ : Obj.t) -> false)\n\nlet yyparse tables start lexer lexbuf =\n  let rec loop cmd arg =\n    match parse_engine tables env cmd arg with\n      Read_token ->\n        let t = Obj.repr(lexer lexbuf) in\n        env.symb_start <- lexbuf.lex_start_p;\n        env.symb_end <- lexbuf.lex_curr_p;\n        loop Token_read t\n    | Raise_parse_error ->\n        raise Parse_error\n    | Compute_semantic_action ->\n        let (action, value) =\n          try\n            (Semantic_action_computed, tables.actions.(env.rule_number) env)\n          with Parse_error ->\n            (Error_detected, Obj.repr ()) in\n        loop action value\n    | Grow_stacks_1 ->\n        grow_stacks(); loop Stacks_grown_1 (Obj.repr ())\n    | Grow_stacks_2 ->\n        grow_stacks(); loop Stacks_grown_2 (Obj.repr ())\n    | Call_error_function ->\n        tables.error_function \"syntax error\";\n        loop Error_detected (Obj.repr ()) in\n  let init_asp = env.asp\n  and init_sp = env.sp\n  and init_stackbase = env.stackbase\n  and init_state = env.state\n  and init_curr_char = env.curr_char\n  and init_lval = env.lval\n  and init_errflag = env.errflag in\n  env.stackbase <- env.sp + 1;\n  env.curr_char <- start;\n  env.symb_end <- lexbuf.lex_curr_p;\n  try\n    loop Start (Obj.repr ())\n  with exn ->\n    let curr_char = env.curr_char in\n    env.asp <- init_asp;\n    env.sp <- init_sp;\n    env.stackbase <- init_stackbase;\n    env.state <- init_state;\n    env.curr_char <- init_curr_char;\n    env.lval <- init_lval;\n    env.errflag <- init_errflag;\n    match exn with\n      YYexit v ->\n        Obj.magic v\n    | _ ->\n        current_lookahead_fun :=\n          (fun tok ->\n            if Obj.is_block tok\n            then tables.transl_block.(Obj.tag tok) = curr_char\n            else tables.transl_const.(Obj.magic tok) = curr_char);\n        raise exn\n\nlet peek_val env n =\n  Obj.magic env.v_stack.(env.asp - n)\n\nlet symbol_start_pos () =\n  let rec loop i =\n    if i <= 0 then env.symb_end_stack.(env.asp)\n    else begin\n      let st = env.symb_start_stack.(env.asp - i + 1) in\n      let en = env.symb_end_stack.(env.asp - i + 1) in\n      if st <> en then st else loop (i - 1)\n    end\n  in\n  loop env.rule_len\n\nlet symbol_end_pos () = env.symb_end_stack.(env.asp)\nlet rhs_start_pos n = env.symb_start_stack.(env.asp - (env.rule_len - n))\nlet rhs_end_pos n = env.symb_end_stack.(env.asp - (env.rule_len - n))\n\nlet symbol_start () = (symbol_start_pos ()).pos_cnum\nlet symbol_end () = (symbol_end_pos ()).pos_cnum\nlet rhs_start n = (rhs_start_pos n).pos_cnum\nlet rhs_end n = (rhs_end_pos n).pos_cnum\n\nlet is_current_lookahead tok =\n  (!current_lookahead_fun)(Obj.repr tok)\n\nlet parse_error (_ : string) = ()\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Sets over ordered types *)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type elt\n    type t\n    val empty: t\n    val is_empty: t -> bool\n    val mem: elt -> t -> bool\n    val add: elt -> t -> t\n    val singleton: elt -> t\n    val remove: elt -> t -> t\n    val union: t -> t -> t\n    val inter: t -> t -> t\n    val diff: t -> t -> t\n    val compare: t -> t -> int\n    val equal: t -> t -> bool\n    val subset: t -> t -> bool\n    val iter: (elt -> unit) -> t -> unit\n    val map: (elt -> elt) -> t -> t\n    val fold: (elt -> 'a -> 'a) -> t -> 'a -> 'a\n    val for_all: (elt -> bool) -> t -> bool\n    val exists: (elt -> bool) -> t -> bool\n    val filter: (elt -> bool) -> t -> t\n    val partition: (elt -> bool) -> t -> t * t\n    val cardinal: t -> int\n    val elements: t -> elt list\n    val min_elt: t -> elt\n    val max_elt: t -> elt\n    val choose: t -> elt\n    val split: elt -> t -> t * bool * t\n    val find: elt -> t -> elt\n    val of_list: elt list -> t\n  end\n\nmodule Make(Ord: OrderedType) =\n  struct\n    type elt = Ord.t\n    type t = Empty | Node of t * elt * t * int\n\n    (* Sets are represented by balanced binary trees (the heights of the\n       children differ by at most 2 *)\n\n    let height = function\n        Empty -> 0\n      | Node(_, _, _, h) -> h\n\n    (* Creates a new node with left son l, value v and right son r.\n       We must have all elements of l < v < all elements of r.\n       l and r must be balanced and | height l - height r | <= 2.\n       Inline expansion of height for better speed. *)\n\n    let create l v r =\n      let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h in\n      let hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in\n      Node(l, v, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    (* Same as create, but performs one step of rebalancing if necessary.\n       Assumes l and r balanced and | height l - height r | <= 3.\n       Inline expansion of create for better speed in the most frequent case\n       where no rebalancing is required. *)\n\n    let bal l v r =\n      let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h in\n      let hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Set.bal\"\n        | Node(ll, lv, lr, _) ->\n            if height ll >= height lr then\n              create ll lv (create lr v r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Set.bal\"\n              | Node(lrl, lrv, lrr, _)->\n                  create (create ll lv lrl) lrv (create lrr v r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Set.bal\"\n        | Node(rl, rv, rr, _) ->\n            if height rr >= height rl then\n              create (create l v rl) rv rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Set.bal\"\n              | Node(rll, rlv, rlr, _) ->\n                  create (create l v rll) rlv (create rlr rv rr)\n            end\n      end else\n        Node(l, v, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    (* Insertion of one element *)\n\n    let rec add x = function\n        Empty -> Node(Empty, x, Empty, 1)\n      | Node(l, v, r, _) as t ->\n          let c = Ord.compare x v in\n          if c = 0 then t else\n          if c < 0 then\n            let ll = add x l in\n            if l == ll then t else bal ll v r\n          else\n            let rr = add x r in\n            if r == rr then t else bal l v rr\n\n    let singleton x = Node(Empty, x, Empty, 1)\n\n    (* Beware: those two functions assume that the added v is *strictly*\n       smaller (or bigger) than all the present elements in the tree; it\n       does not test for equality with the current min (or max) element.\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_element v = function\n      | Empty -> singleton v\n      | Node (l, x, r, _h) ->\n        bal (add_min_element v l) x r\n\n    let rec add_max_element v = function\n      | Empty -> singleton v\n      | Node (l, x, r, _h) ->\n        bal l x (add_max_element v r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v r =\n      match (l, r) with\n        (Empty, _) -> add_min_element v r\n      | (_, Empty) -> add_max_element v l\n      | (Node(ll, lv, lr, lh), Node(rl, rv, rr, rh)) ->\n          if lh > rh + 2 then bal ll lv (join lr v r) else\n          if rh > lh + 2 then bal (join l v rl) rv rr else\n          create l v r\n\n    (* Smallest and greatest element of a set *)\n\n    let rec min_elt = function\n        Empty -> raise Not_found\n      | Node(Empty, v, _, _) -> v\n      | Node(l, _, _, _) -> min_elt l\n\n    let rec max_elt = function\n        Empty -> raise Not_found\n      | Node(_, v, Empty, _) -> v\n      | Node(_, _, r, _) -> max_elt r\n\n    (* Remove the smallest element of the given set *)\n\n    let rec remove_min_elt = function\n        Empty -> invalid_arg \"Set.remove_min_elt\"\n      | Node(Empty, _, r, _) -> r\n      | Node(l, v, r, _) -> bal (remove_min_elt l) v r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       Assume | height l - height r | <= 2. *)\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) -> bal t1 (min_elt t2) (remove_min_elt t2)\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) -> join t1 (min_elt t2) (remove_min_elt t2)\n\n    (* Splitting.  split x s returns a triple (l, present, r) where\n        - l is the set of elements of s that are < x\n        - r is the set of elements of s that are > x\n        - present is false if s contains no element equal to x,\n          or true if s contains an element equal to x. *)\n\n    let rec split x = function\n        Empty ->\n          (Empty, false, Empty)\n      | Node(l, v, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, true, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v r)\n          else\n            let (lr, pres, rr) = split x r in (join l v lr, pres, rr)\n\n    (* Implementation of the set operations *)\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec mem x = function\n        Empty -> false\n      | Node(l, v, r, _) ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec remove x = function\n        Empty -> Empty\n      | (Node(l, v, r, _) as t) ->\n          let c = Ord.compare x v in\n          if c = 0 then merge l r\n          else\n            if c < 0 then\n              let ll = remove x l in\n              if l == ll then t\n              else bal ll v r\n            else\n              let rr = remove x r in\n              if r == rr then t\n              else bal l v rr\n\n    let rec union s1 s2 =\n      match (s1, s2) with\n        (Empty, t2) -> t2\n      | (t1, Empty) -> t1\n      | (Node(l1, v1, r1, h1), Node(l2, v2, r2, h2)) ->\n          if h1 >= h2 then\n            if h2 = 1 then add v2 s1 else begin\n              let (l2, _, r2) = split v1 s2 in\n              join (union l1 l2) v1 (union r1 r2)\n            end\n          else\n            if h1 = 1 then add v1 s2 else begin\n              let (l1, _, r1) = split v2 s1 in\n              join (union l1 l2) v2 (union r1 r2)\n            end\n\n    let rec inter s1 s2 =\n      match (s1, s2) with\n        (Empty, _) -> Empty\n      | (_, Empty) -> Empty\n      | (Node(l1, v1, r1, _), t2) ->\n          match split v1 t2 with\n            (l2, false, r2) ->\n              concat (inter l1 l2) (inter r1 r2)\n          | (l2, true, r2) ->\n              join (inter l1 l2) v1 (inter r1 r2)\n\n    let rec diff s1 s2 =\n      match (s1, s2) with\n        (Empty, _) -> Empty\n      | (t1, Empty) -> t1\n      | (Node(l1, v1, r1, _), t2) ->\n          match split v1 t2 with\n            (l2, false, r2) ->\n              join (diff l1 l2) v1 (diff r1 r2)\n          | (l2, true, r2) ->\n              concat (diff l1 l2) (diff r1 r2)\n\n    type enumeration = End | More of elt * t * enumeration\n\n    let rec cons_enum s e =\n      match s with\n        Empty -> e\n      | Node(l, v, r, _) -> cons_enum l (More(v, r, e))\n\n    let rec compare_aux e1 e2 =\n        match (e1, e2) with\n        (End, End) -> 0\n      | (End, _)  -> -1\n      | (_, End) -> 1\n      | (More(v1, r1, e1), More(v2, r2, e2)) ->\n          let c = Ord.compare v1 v2 in\n          if c <> 0\n          then c\n          else compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n\n    let compare s1 s2 =\n      compare_aux (cons_enum s1 End) (cons_enum s2 End)\n\n    let equal s1 s2 =\n      compare s1 s2 = 0\n\n    let rec subset s1 s2 =\n      match (s1, s2) with\n        Empty, _ ->\n          true\n      | _, Empty ->\n          false\n      | Node (l1, v1, r1, _), (Node (l2, v2, r2, _) as t2) ->\n          let c = Ord.compare v1 v2 in\n          if c = 0 then\n            subset l1 l2 && subset r1 r2\n          else if c < 0 then\n            subset (Node (l1, v1, Empty, 0)) l2 && subset r1 t2\n          else\n            subset (Node (Empty, v1, r1, 0)) r2 && subset l1 t2\n\n    let rec iter f = function\n        Empty -> ()\n      | Node(l, v, r, _) -> iter f l; f v; iter f r\n\n    let rec fold f s accu =\n      match s with\n        Empty -> accu\n      | Node(l, v, r, _) -> fold f r (f v (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node(l, v, r, _) -> p v && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node(l, v, r, _) -> p v || exists p l || exists p r\n\n    let rec filter p = function\n        Empty -> Empty\n      | (Node(l, v, r, _)) as t ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pv = p v in\n          let r' = filter p r in\n          if pv then\n            if l==l' && r==r' then t else join l' v r'\n          else concat l' r'\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node(l, v, r, _) ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pv = p v in\n          let (rt, rf) = partition p r in\n          if pv\n          then (join lt v rt, concat lf rf)\n          else (concat lt rt, join lf v rf)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node(l, _, r, _) -> cardinal l + 1 + cardinal r\n\n    let rec elements_aux accu = function\n        Empty -> accu\n      | Node(l, v, r, _) -> elements_aux (v :: elements_aux accu r) l\n\n    let elements s =\n      elements_aux [] s\n\n    let choose = min_elt\n\n    let rec find x = function\n        Empty -> raise Not_found\n      | Node(l, v, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then v\n          else find x (if c < 0 then l else r)\n\n    let try_join l v r =\n      (* [join l v r] can only be called when (elements of l < v <\n         elements of r); use [try_join l v r] when this property may\n         not hold, but you hope it does hold in the common case *)\n      if (l = Empty || Ord.compare (max_elt l) v < 0)\n      && (r = Empty || Ord.compare v (min_elt r) < 0)\n      then join l v r\n      else union l (add v r)\n\n    let rec map f = function\n      | Empty -> Empty\n      | Node (l, v, r, _) as t ->\n         (* enforce left-to-right evaluation order *)\n         let l' = map f l in\n         let v' = f v in\n         let r' = map f r in\n         if l == l' && v == v' && r == r' then t\n         else try_join l' v' r'\n\n    let of_sorted_list l =\n      let rec sub n l =\n        match n, l with\n        | 0, l -> Empty, l\n        | 1, x0 :: l -> Node (Empty, x0, Empty, 1), l\n        | 2, x0 :: x1 :: l -> Node (Node(Empty, x0, Empty, 1), x1, Empty, 2), l\n        | 3, x0 :: x1 :: x2 :: l ->\n            Node (Node(Empty, x0, Empty, 1), x1, Node(Empty, x2, Empty, 1), 2),l\n        | n, l ->\n          let nl = n / 2 in\n          let left, l = sub nl l in\n          match l with\n          | [] -> assert false\n          | mid :: l ->\n            let right, l = sub (n - nl - 1) l in\n            create left mid right, l\n      in\n      fst (sub (List.length l) l)\n\n    let of_list l =\n      match l with\n      | [] -> empty\n      | [x0] -> singleton x0\n      | [x0; x1] -> add x1 (singleton x0)\n      | [x0; x1; x2] -> add x2 (add x1 (singleton x0))\n      | [x0; x1; x2; x3] -> add x3 (add x2 (add x1 (singleton x0)))\n      | [x0; x1; x2; x3; x4] -> add x4 (add x3 (add x2 (add x1 (singleton x0))))\n      | _ -> of_sorted_list (List.sort_uniq Ord.compare l)\n  end\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule type OrderedType =\n  sig\n    type t\n    val compare: t -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type +'a t\n    val empty: 'a t\n    val is_empty: 'a t -> bool\n    val mem:  key -> 'a t -> bool\n    val add: key -> 'a -> 'a t -> 'a t\n    val singleton: key -> 'a -> 'a t\n    val remove: key -> 'a t -> 'a t\n    val merge:\n          (key -> 'a option -> 'b option -> 'c option) -> 'a t -> 'b t -> 'c t\n    val union: (key -> 'a -> 'a -> 'a option) -> 'a t -> 'a t -> 'a t\n    val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int\n    val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val for_all: (key -> 'a -> bool) -> 'a t -> bool\n    val exists: (key -> 'a -> bool) -> 'a t -> bool\n    val filter: (key -> 'a -> bool) -> 'a t -> 'a t\n    val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t\n    val cardinal: 'a t -> int\n    val bindings: 'a t -> (key * 'a) list\n    val min_binding: 'a t -> (key * 'a)\n    val max_binding: 'a t -> (key * 'a)\n    val choose: 'a t -> (key * 'a)\n    val split: key -> 'a t -> 'a t * 'a option * 'a t\n    val find: key -> 'a t -> 'a\n    val map: ('a -> 'b) -> 'a t -> 'b t\n    val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t\n  end\n\nmodule Make(Ord: OrderedType) = struct\n\n    type key = Ord.t\n\n    type 'a t =\n        Empty\n      | Node of 'a t * key * 'a * 'a t * int\n\n    let height = function\n        Empty -> 0\n      | Node(_,_,_,_,h) -> h\n\n    let create l x d r =\n      let hl = height l and hr = height r in\n      Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    let singleton x d = Node(Empty, x, d, Empty, 1)\n\n    let bal l x d r =\n      let hl = match l with Empty -> 0 | Node(_,_,_,_,h) -> h in\n      let hr = match r with Empty -> 0 | Node(_,_,_,_,h) -> h in\n      if hl > hr + 2 then begin\n        match l with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node(ll, lv, ld, lr, _) ->\n            if height ll >= height lr then\n              create ll lv ld (create lr x d r)\n            else begin\n              match lr with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node(lrl, lrv, lrd, lrr, _)->\n                  create (create ll lv ld lrl) lrv lrd (create lrr x d r)\n            end\n      end else if hr > hl + 2 then begin\n        match r with\n          Empty -> invalid_arg \"Map.bal\"\n        | Node(rl, rv, rd, rr, _) ->\n            if height rr >= height rl then\n              create (create l x d rl) rv rd rr\n            else begin\n              match rl with\n                Empty -> invalid_arg \"Map.bal\"\n              | Node(rll, rlv, rld, rlr, _) ->\n                  create (create l x d rll) rlv rld (create rlr rv rd rr)\n            end\n      end else\n        Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))\n\n    let empty = Empty\n\n    let is_empty = function Empty -> true | _ -> false\n\n    let rec add x data = function\n        Empty ->\n          Node(Empty, x, data, Empty, 1)\n      | Node(l, v, d, r, h) as m ->\n          let c = Ord.compare x v in\n          if c = 0 then\n            if d == data then m else Node(l, x, data, r, h)\n          else if c < 0 then\n            let ll = add x data l in\n            if l == ll then m else bal ll v d r\n          else\n            let rr = add x data r in\n            if r == rr then m else bal l v d rr\n\n    let rec find x = function\n        Empty ->\n          raise Not_found\n      | Node(l, v, d, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then d\n          else find x (if c < 0 then l else r)\n\n    let rec mem x = function\n        Empty ->\n          false\n      | Node(l, v, _, r, _) ->\n          let c = Ord.compare x v in\n          c = 0 || mem x (if c < 0 then l else r)\n\n    let rec min_binding = function\n        Empty -> raise Not_found\n      | Node(Empty, x, d, _, _) -> (x, d)\n      | Node(l, _, _, _, _) -> min_binding l\n\n    let rec max_binding = function\n        Empty -> raise Not_found\n      | Node(_, x, d, Empty, _) -> (x, d)\n      | Node(_, _, _, r, _) -> max_binding r\n\n    let rec remove_min_binding = function\n        Empty -> invalid_arg \"Map.remove_min_elt\"\n      | Node(Empty, _, _, r, _) -> r\n      | Node(l, x, d, r, _) -> bal (remove_min_binding l) x d r\n\n    let merge t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          bal t1 x d (remove_min_binding t2)\n\n    let rec remove x = function\n        Empty ->\n          Empty\n      | (Node(l, v, d, r, _) as t) ->\n          let c = Ord.compare x v in\n          if c = 0 then merge l r\n          else if c < 0 then\n            let ll = remove x l in if l == ll then t else bal ll v d r\n          else\n            let rr = remove x r in if r == rr then t else bal l v d rr\n\n    let rec iter f = function\n        Empty -> ()\n      | Node(l, v, d, r, _) ->\n          iter f l; f v d; iter f r\n\n    let rec map f = function\n        Empty ->\n          Empty\n      | Node(l, v, d, r, h) ->\n          let l' = map f l in\n          let d' = f d in\n          let r' = map f r in\n          Node(l', v, d', r', h)\n\n    let rec mapi f = function\n        Empty ->\n          Empty\n      | Node(l, v, d, r, h) ->\n          let l' = mapi f l in\n          let d' = f v d in\n          let r' = mapi f r in\n          Node(l', v, d', r', h)\n\n    let rec fold f m accu =\n      match m with\n        Empty -> accu\n      | Node(l, v, d, r, _) ->\n          fold f r (f v d (fold f l accu))\n\n    let rec for_all p = function\n        Empty -> true\n      | Node(l, v, d, r, _) -> p v d && for_all p l && for_all p r\n\n    let rec exists p = function\n        Empty -> false\n      | Node(l, v, d, r, _) -> p v d || exists p l || exists p r\n\n    (* Beware: those two functions assume that the added k is *strictly*\n       smaller (or bigger) than all the present keys in the tree; it\n       does not test for equality with the current min (or max) key.\n\n       Indeed, they are only used during the \"join\" operation which\n       respects this precondition.\n    *)\n\n    let rec add_min_binding k v = function\n      | Empty -> singleton k v\n      | Node (l, x, d, r, _) ->\n        bal (add_min_binding k v l) x d r\n\n    let rec add_max_binding k v = function\n      | Empty -> singleton k v\n      | Node (l, x, d, r, _) ->\n        bal l x d (add_max_binding k v r)\n\n    (* Same as create and bal, but no assumptions are made on the\n       relative heights of l and r. *)\n\n    let rec join l v d r =\n      match (l, r) with\n        (Empty, _) -> add_min_binding v d r\n      | (_, Empty) -> add_max_binding v d l\n      | (Node(ll, lv, ld, lr, lh), Node(rl, rv, rd, rr, rh)) ->\n          if lh > rh + 2 then bal ll lv ld (join lr v d r) else\n          if rh > lh + 2 then bal (join l v d rl) rv rd rr else\n          create l v d r\n\n    (* Merge two trees l and r into one.\n       All elements of l must precede the elements of r.\n       No assumption on the heights of l and r. *)\n\n    let concat t1 t2 =\n      match (t1, t2) with\n        (Empty, t) -> t\n      | (t, Empty) -> t\n      | (_, _) ->\n          let (x, d) = min_binding t2 in\n          join t1 x d (remove_min_binding t2)\n\n    let concat_or_join t1 v d t2 =\n      match d with\n      | Some d -> join t1 v d t2\n      | None -> concat t1 t2\n\n    let rec split x = function\n        Empty ->\n          (Empty, None, Empty)\n      | Node(l, v, d, r, _) ->\n          let c = Ord.compare x v in\n          if c = 0 then (l, Some d, r)\n          else if c < 0 then\n            let (ll, pres, rl) = split x l in (ll, pres, join rl v d r)\n          else\n            let (lr, pres, rr) = split x r in (join l v d lr, pres, rr)\n\n    let rec merge f s1 s2 =\n      match (s1, s2) with\n        (Empty, Empty) -> Empty\n      | (Node (l1, v1, d1, r1, h1), _) when h1 >= height s2 ->\n          let (l2, d2, r2) = split v1 s2 in\n          concat_or_join (merge f l1 l2) v1 (f v1 (Some d1) d2) (merge f r1 r2)\n      | (_, Node (l2, v2, d2, r2, _)) ->\n          let (l1, d1, r1) = split v2 s1 in\n          concat_or_join (merge f l1 l2) v2 (f v2 d1 (Some d2)) (merge f r1 r2)\n      | _ ->\n          assert false\n\n    let rec union f s1 s2 =\n      match (s1, s2) with\n      | (Empty, s) | (s, Empty) -> s\n      | (Node (l1, v1, d1, r1, h1), Node (l2, v2, d2, r2, h2)) ->\n          if h1 >= h2 then\n            let (l2, d2, r2) = split v1 s2 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d2 with\n            | None -> join l v1 d1 r\n            | Some d2 -> concat_or_join l v1 (f v1 d1 d2) r\n          else\n            let (l1, d1, r1) = split v2 s1 in\n            let l = union f l1 l2 and r = union f r1 r2 in\n            match d1 with\n            | None -> join l v2 d2 r\n            | Some d1 -> concat_or_join l v2 (f v2 d1 d2) r\n\n    let rec filter p = function\n        Empty -> Empty\n      | Node(l, v, d, r, _) as t ->\n          (* call [p] in the expected left-to-right order *)\n          let l' = filter p l in\n          let pvd = p v d in\n          let r' = filter p r in\n          if pvd then if l==l' && r==r' then t else join l' v d r'\n          else concat l' r'\n\n    let rec partition p = function\n        Empty -> (Empty, Empty)\n      | Node(l, v, d, r, _) ->\n          (* call [p] in the expected left-to-right order *)\n          let (lt, lf) = partition p l in\n          let pvd = p v d in\n          let (rt, rf) = partition p r in\n          if pvd\n          then (join lt v d rt, concat lf rf)\n          else (concat lt rt, join lf v d rf)\n\n    type 'a enumeration = End | More of key * 'a * 'a t * 'a enumeration\n\n    let rec cons_enum m e =\n      match m with\n        Empty -> e\n      | Node(l, v, d, r, _) -> cons_enum l (More(v, d, r, e))\n\n    let compare cmp m1 m2 =\n      let rec compare_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> 0\n        | (End, _)  -> -1\n        | (_, End) -> 1\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            let c = Ord.compare v1 v2 in\n            if c <> 0 then c else\n            let c = cmp d1 d2 in\n            if c <> 0 then c else\n            compare_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in compare_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let equal cmp m1 m2 =\n      let rec equal_aux e1 e2 =\n          match (e1, e2) with\n          (End, End) -> true\n        | (End, _)  -> false\n        | (_, End) -> false\n        | (More(v1, d1, r1, e1), More(v2, d2, r2, e2)) ->\n            Ord.compare v1 v2 = 0 && cmp d1 d2 &&\n            equal_aux (cons_enum r1 e1) (cons_enum r2 e2)\n      in equal_aux (cons_enum m1 End) (cons_enum m2 End)\n\n    let rec cardinal = function\n        Empty -> 0\n      | Node(l, _, _, r, _) -> cardinal l + 1 + cardinal r\n\n    let rec bindings_aux accu = function\n        Empty -> accu\n      | Node(l, v, d, r, _) -> bindings_aux ((v, d) :: bindings_aux accu r) l\n\n    let bindings s =\n      bindings_aux [] s\n\n    let choose = min_binding\n\nend\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*         Francois Pottier, projet Cristal, INRIA Rocquencourt           *)\n(*                  Jeremie Dimino, Jane Street Europe                    *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nexception Empty\n\ntype 'a cell =\n  | Nil\n  | Cons of { content: 'a; mutable next: 'a cell }\n\ntype 'a t = {\n  mutable length: int;\n  mutable first: 'a cell;\n  mutable last: 'a cell\n}\n\nlet create () = {\n  length = 0;\n  first = Nil;\n  last = Nil\n}\n\nlet clear q =\n  q.length <- 0;\n  q.first <- Nil;\n  q.last <- Nil\n\nlet add x q =\n  let cell = Cons {\n    content = x;\n    next = Nil\n  } in\n  match q.last with\n  | Nil ->\n    q.length <- 1;\n    q.first <- cell;\n    q.last <- cell\n  | Cons last ->\n    q.length <- q.length + 1;\n    last.next <- cell;\n    q.last <- cell\n\nlet push =\n  add\n\nlet peek q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content } -> content\n\nlet top =\n  peek\n\nlet take q =\n  match q.first with\n  | Nil -> raise Empty\n  | Cons { content; next = Nil } ->\n    clear q;\n    content\n  | Cons { content; next } ->\n    q.length <- q.length - 1;\n    q.first <- next;\n    content\n\nlet pop =\n  take\n\nlet copy =\n  let rec copy q_res prev cell =\n    match cell with\n    | Nil -> q_res.last <- prev; q_res\n    | Cons { content; next } ->\n      let res = Cons { content; next = Nil } in\n      begin match prev with\n      | Nil -> q_res.first <- res\n      | Cons p -> p.next <- res\n      end;\n      copy q_res res next\n  in\n  fun q -> copy { length = q.length; first = Nil; last = Nil } Nil q.first\n\nlet is_empty q =\n  q.length = 0\n\nlet length q =\n  q.length\n\nlet iter =\n  let rec iter f cell =\n    match cell with\n    | Nil -> ()\n    | Cons { content; next } ->\n      f content;\n      iter f next\n  in\n  fun f q -> iter f q.first\n\nlet fold =\n  let rec fold f accu cell =\n    match cell with\n    | Nil -> accu\n    | Cons { content; next } ->\n      let accu = f accu content in\n      fold f accu next\n  in\n  fun f accu q -> fold f accu q.first\n\nlet transfer q1 q2 =\n  if q1.length > 0 then\n    match q2.last with\n    | Nil ->\n      q2.length <- q1.length;\n      q2.first <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n    | Cons last ->\n      q2.length <- q2.length + q1.length;\n      last.next <- q1.first;\n      q2.last <- q1.last;\n      clear q1\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Damien Doligez, projet Para, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1997 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Internals of forcing lazy values. *)\n\nexception Undefined\n\nlet raise_undefined = Obj.repr (fun () -> raise Undefined)\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  try\n    let result = closure () in\n    (* do set_field BEFORE set_tag *)\n    Obj.set_field (Obj.repr blk) 0 (Obj.repr result);\n    Obj.set_tag (Obj.repr blk) Obj.forward_tag;\n    result\n  with e ->\n    Obj.set_field (Obj.repr blk) 0 (Obj.repr (fun () -> raise e));\n    raise e\n\n\n(* Assume [blk] is a block with tag lazy *)\nlet force_val_lazy_block (blk : 'arg lazy_t) =\n  let closure = (Obj.obj (Obj.field (Obj.repr blk) 0) : unit -> 'arg) in\n  Obj.set_field (Obj.repr blk) 0 raise_undefined;\n  let result = closure () in\n  (* do set_field BEFORE set_tag *)\n  Obj.set_field (Obj.repr blk) 0 (Obj.repr result);\n  Obj.set_tag (Obj.repr blk) (Obj.forward_tag);\n  result\n\n\n(* [force] is not used, since [Lazy.force] is declared as a primitive\n   whose code inlines the tag tests of its argument.  This function is\n   here for the sake of completeness, and for debugging purpose. *)\n\nlet force (lzv : 'arg lazy_t) =\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_lazy_block lzv\n\n\nlet force_val (lzv : 'arg lazy_t) =\n  let x = Obj.repr lzv in\n  let t = Obj.tag x in\n  if t = Obj.forward_tag then (Obj.obj (Obj.field x 0) : 'arg) else\n  if t <> Obj.lazy_tag then (Obj.obj x : 'arg)\n  else force_val_lazy_block lzv\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*    Pierre Weis and Xavier Leroy, projet Cristal, INRIA Rocquencourt    *)\n(*                                                                        *)\n(*   Copyright 1999 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Extensible buffers *)\n\ntype t =\n {mutable buffer : bytes;\n  mutable position : int;\n  mutable length : int;\n  initial_buffer : bytes}\n\nlet create n =\n let n = if n < 1 then 1 else n in\n let n = if n > Sys.max_string_length then Sys.max_string_length else n in\n let s = Bytes.create n in\n {buffer = s; position = 0; length = n; initial_buffer = s}\n\nlet contents b = Bytes.sub_string b.buffer 0 b.position\nlet to_bytes b = Bytes.sub b.buffer 0 b.position\n\nlet sub b ofs len =\n  if ofs < 0 || len < 0 || ofs > b.position - len\n  then invalid_arg \"Buffer.sub\"\n  else Bytes.sub_string b.buffer ofs len\n\n\nlet blit src srcoff dst dstoff len =\n  if len < 0 || srcoff < 0 || srcoff > src.position - len\n             || dstoff < 0 || dstoff > (Bytes.length dst) - len\n  then invalid_arg \"Buffer.blit\"\n  else\n    Bytes.unsafe_blit src.buffer srcoff dst dstoff len\n\n\nlet nth b ofs =\n  if ofs < 0 || ofs >= b.position then\n   invalid_arg \"Buffer.nth\"\n  else Bytes.unsafe_get b.buffer ofs\n\n\nlet length b = b.position\n\nlet clear b = b.position <- 0\n\nlet reset b =\n  b.position <- 0; b.buffer <- b.initial_buffer;\n  b.length <- Bytes.length b.buffer\n\nlet resize b more =\n  let len = b.length in\n  let new_len = ref len in\n  while b.position + more > !new_len do new_len := 2 * !new_len done;\n  if !new_len > Sys.max_string_length then begin\n    if b.position + more <= Sys.max_string_length\n    then new_len := Sys.max_string_length\n    else failwith \"Buffer.add: cannot grow buffer\"\n  end;\n  let new_buffer = Bytes.create !new_len in\n  (* PR#6148: let's keep using [blit] rather than [unsafe_blit] in\n     this tricky function that is slow anyway. *)\n  Bytes.blit b.buffer 0 new_buffer 0 b.position;\n  b.buffer <- new_buffer;\n  b.length <- !new_len\n\nlet add_char b c =\n  let pos = b.position in\n  if pos >= b.length then resize b 1;\n  Bytes.unsafe_set b.buffer pos c;\n  b.position <- pos + 1\n\nlet add_substring b s offset len =\n  if offset < 0 || len < 0 || offset > String.length s - len\n  then invalid_arg \"Buffer.add_substring/add_subbytes\";\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.blit_string s offset b.buffer b.position len;\n  b.position <- new_position\n\nlet add_subbytes b s offset len =\n  add_substring b (Bytes.unsafe_to_string s) offset len\n\nlet add_string b s =\n  let len = String.length s in\n  let new_position = b.position + len in\n  if new_position > b.length then resize b len;\n  Bytes.blit_string s 0 b.buffer b.position len;\n  b.position <- new_position\n\nlet add_bytes b s = add_string b (Bytes.unsafe_to_string s)\n\nlet add_buffer b bs =\n  add_subbytes b bs.buffer 0 bs.position\n\n(* read up to [len] bytes from [ic] into [b]. *)\nlet rec add_channel_rec b ic len =\n  if len > 0 then (\n    let n = input ic b.buffer b.position len in\n    b.position <- b.position + n;\n    if n = 0 then raise End_of_file\n    else add_channel_rec b ic (len-n)   (* n <= len *)\n  )\n\nlet add_channel b ic len =\n  if len < 0 || len > Sys.max_string_length then   (* PR#5004 *)\n    invalid_arg \"Buffer.add_channel\";\n  if b.position + len > b.length then resize b len;\n  add_channel_rec b ic len\n\nlet output_buffer oc b =\n  output oc b.buffer 0 b.position\n\nlet closing = function\n  | '(' -> ')'\n  | '{' -> '}'\n  | _ -> assert false\n\n(* opening and closing: open and close characters, typically ( and )\n   k: balance of opening and closing chars\n   s: the string where we are searching\n   start: the index where we start the search. *)\nlet advance_to_closing opening closing k s start =\n  let rec advance k i lim =\n    if i >= lim then raise Not_found else\n    if s.[i] = opening then advance (k + 1) (i + 1) lim else\n    if s.[i] = closing then\n      if k = 0 then i else advance (k - 1) (i + 1) lim\n    else advance k (i + 1) lim in\n  advance k start (String.length s)\n\nlet advance_to_non_alpha s start =\n  let rec advance i lim =\n    if i >= lim then lim else\n    match s.[i] with\n    | 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' -> advance (i + 1) lim\n    | _ -> i in\n  advance start (String.length s)\n\n(* We are just at the beginning of an ident in s, starting at start. *)\nlet find_ident s start lim =\n  if start >= lim then raise Not_found else\n  match s.[start] with\n  (* Parenthesized ident ? *)\n  | '(' | '{' as c ->\n     let new_start = start + 1 in\n     let stop = advance_to_closing c (closing c) 0 s new_start in\n     String.sub s new_start (stop - start - 1), stop + 1\n  (* Regular ident *)\n  | _ ->\n     let stop = advance_to_non_alpha s (start + 1) in\n     String.sub s start (stop - start), stop\n\n(* Substitute $ident, $(ident), or ${ident} in s,\n    according to the function mapping f. *)\nlet add_substitute b f s =\n  let lim = String.length s in\n  let rec subst previous i =\n    if i < lim then begin\n      match s.[i] with\n      | '$' as current when previous = '\\\\' ->\n         add_char b current;\n         subst ' ' (i + 1)\n      | '$' ->\n         let j = i + 1 in\n         let ident, next_i = find_ident s j lim in\n         add_string b (f ident);\n         subst ' ' next_i\n      | current when previous == '\\\\' ->\n         add_char b '\\\\';\n         add_char b current;\n         subst ' ' (i + 1)\n      | '\\\\' as current ->\n         subst current (i + 1)\n      | current ->\n         add_char b current;\n         subst current (i + 1)\n    end else\n    if previous = '\\\\' then add_char b previous in\n  subst ' ' 0\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*   Xavier Leroy and Pierre Weis, projet Cristal, INRIA Rocquencourt     *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\nlet kfprintf k o (Format (fmt, _)) =\n  make_printf (fun o acc -> output_acc o acc; k o) o End_of_acc fmt\nlet kbprintf k b (Format (fmt, _)) =\n  make_printf (fun b acc -> bufput_acc b acc; k b) b End_of_acc fmt\nlet ikfprintf k oc (Format (fmt, _)) =\n  make_iprintf k oc fmt\n\nlet fprintf oc fmt = kfprintf ignore oc fmt\nlet bprintf b fmt = kbprintf ignore b fmt\nlet ifprintf oc fmt = ikfprintf ignore oc fmt\nlet printf fmt = fprintf stdout fmt\nlet eprintf fmt = fprintf stderr fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let k' () acc =\n    let buf = Buffer.create 64 in\n    strput_acc buf acc;\n    k (Buffer.contents buf) in\n  make_printf k' () End_of_acc fmt\n\nlet sprintf fmt = ksprintf (fun s -> s) fmt\n\nlet kprintf = ksprintf\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Message digest (MD5) *)\n\ntype t = string\n\nlet compare = String.compare\nlet equal = String.equal\n\nexternal unsafe_string: string -> int -> int -> t = \"caml_md5_string\"\nexternal channel: in_channel -> int -> t = \"caml_md5_chan\"\n\nlet string str =\n  unsafe_string str 0 (String.length str)\n\nlet bytes b = string (Bytes.unsafe_to_string b)\n\nlet substring str ofs len =\n  if ofs < 0 || len < 0 || ofs > String.length str - len\n  then invalid_arg \"Digest.substring\"\n  else unsafe_string str ofs len\n\nlet subbytes b ofs len = substring (Bytes.unsafe_to_string b) ofs len\n\nlet file filename =\n  let ic = open_in_bin filename in\n  match channel ic (-1) with\n    | d -> close_in ic; d\n    | exception e -> close_in ic; raise e\n\nlet output chan digest =\n  output_string chan digest\n\nlet input chan = really_input_string chan 16\n\nlet char_hex n =\n  Char.unsafe_chr (n + if n < 10 then Char.code '0' else (Char.code 'a' - 10))\n\nlet to_hex d =\n  let result = Bytes.create 32 in\n  for i = 0 to 15 do\n    let x = Char.code d.[i] in\n    Bytes.unsafe_set result (i*2) (char_hex (x lsr 4));\n    Bytes.unsafe_set result (i*2+1) (char_hex (x land 0x0f));\n  done;\n  Bytes.unsafe_to_string result\n\nlet from_hex s =\n  if String.length s <> 32 then raise (Invalid_argument \"Digest.from_hex\");\n  let digit c =\n    match c with\n    | '0'..'9' -> Char.code c - Char.code '0'\n    | 'A'..'F' -> Char.code c - Char.code 'A' + 10\n    | 'a'..'f' -> Char.code c - Char.code 'a' + 10\n    | _ -> raise (Invalid_argument \"Digest.from_hex\")\n  in\n  let byte i = digit s.[i] lsl 4 + digit s.[i+1] in\n  let result = Bytes.create 16 in\n  for i = 0 to 15 do\n    Bytes.set result i (Char.chr (byte (2 * i)));\n  done;\n  Bytes.unsafe_to_string result\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*               Damien Doligez, projet Para, INRIA Rocquencourt          *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Pseudo-random number generator\n   This is a lagged-Fibonacci F(55, 24, +) with a modified addition\n   function to enhance the mixing of bits.\n   If we use normal addition, the low-order bit fails tests 1 and 7\n   of the Diehard test suite, and bits 1 and 2 also fail test 7.\n   If we use multiplication as suggested by Marsaglia, it doesn't fare\n   much better.\n   By mixing the bits of one of the numbers before addition (XOR the\n   5 high-order bits into the low-order bits), we get a generator that\n   passes all the Diehard tests.\n*)\n\nexternal random_seed: unit -> int array = \"caml_sys_random_seed\"\n\nmodule State = struct\n\n  type t = { st : int array; mutable idx : int }\n\n  let new_state () = { st = Array.make 55 0; idx = 0 }\n  let assign st1 st2 =\n    Array.blit st2.st 0 st1.st 0 55;\n    st1.idx <- st2.idx\n\n\n  let full_init s seed =\n    let combine accu x = Digest.string (accu ^ string_of_int x) in\n    let extract d =\n      Char.code d.[0] + (Char.code d.[1] lsl 8) + (Char.code d.[2] lsl 16)\n      + (Char.code d.[3] lsl 24)\n    in\n    let seed = if Array.length seed = 0 then [| 0 |] else seed in\n    let l = Array.length seed in\n    for i = 0 to 54 do\n      s.st.(i) <- i;\n    done;\n    let accu = ref \"x\" in\n    for i = 0 to 54 + max 55 l do\n      let j = i mod 55 in\n      let k = i mod l in\n      accu := combine !accu seed.(k);\n      s.st.(j) <- (s.st.(j) lxor extract !accu) land 0x3FFFFFFF;  (* PR#5575 *)\n    done;\n    s.idx <- 0\n\n\n  let make seed =\n    let result = new_state () in\n    full_init result seed;\n    result\n\n\n  let make_self_init () = make (random_seed ())\n\n  let copy s =\n    let result = new_state () in\n    assign result s;\n    result\n\n\n  (* Returns 30 random bits as an integer 0 <= x < 1073741824 *)\n  let bits s =\n    s.idx <- (s.idx + 1) mod 55;\n    let curval = s.st.(s.idx) in\n    let newval = s.st.((s.idx + 24) mod 55)\n                 + (curval lxor ((curval lsr 25) land 0x1F)) in\n    let newval30 = newval land 0x3FFFFFFF in  (* PR#5575 *)\n    s.st.(s.idx) <- newval30;\n    newval30\n\n\n  let rec intaux s n =\n    let r = bits s in\n    let v = r mod n in\n    if r - v > 0x3FFFFFFF - n + 1 then intaux s n else v\n\n  let int s bound =\n    if bound > 0x3FFFFFFF || bound <= 0\n    then invalid_arg \"Random.int\"\n    else intaux s bound\n\n\n  let rec int32aux s n =\n    let b1 = Int32.of_int (bits s) in\n    let b2 = Int32.shift_left (Int32.of_int (bits s land 1)) 30 in\n    let r = Int32.logor b1 b2 in\n    let v = Int32.rem r n in\n    if Int32.sub r v > Int32.add (Int32.sub Int32.max_int n) 1l\n    then int32aux s n\n    else v\n\n  let int32 s bound =\n    if bound <= 0l\n    then invalid_arg \"Random.int32\"\n    else int32aux s bound\n\n\n  let rec int64aux s n =\n    let b1 = Int64.of_int (bits s) in\n    let b2 = Int64.shift_left (Int64.of_int (bits s)) 30 in\n    let b3 = Int64.shift_left (Int64.of_int (bits s land 7)) 60 in\n    let r = Int64.logor b1 (Int64.logor b2 b3) in\n    let v = Int64.rem r n in\n    if Int64.sub r v > Int64.add (Int64.sub Int64.max_int n) 1L\n    then int64aux s n\n    else v\n\n  let int64 s bound =\n    if bound <= 0L\n    then invalid_arg \"Random.int64\"\n    else int64aux s bound\n\n\n  let nativeint =\n    if Nativeint.size = 32\n    then fun s bound -> Nativeint.of_int32 (int32 s (Nativeint.to_int32 bound))\n    else fun s bound -> Int64.to_nativeint (int64 s (Int64.of_nativeint bound))\n\n\n  (* Returns a float 0 <= x <= 1 with at most 60 bits of precision. *)\n  let rawfloat s =\n    let scale = 1073741824.0  (* 2^30 *)\n    and r1 = Pervasives.float (bits s)\n    and r2 = Pervasives.float (bits s)\n    in (r1 /. scale +. r2) /. scale\n\n\n  let float s bound = rawfloat s *. bound\n\n  let bool s = (bits s land 1 = 0)\n\nend\n\n(* This is the state you get with [init 27182818] and then applying\n   the \"land 0x3FFFFFFF\" filter to them.  See #5575, #5793, #5977. *)\nlet default = {\n  State.st = [|\n      0x3ae2522b; 0x1d8d4634; 0x15b4fad0; 0x18b14ace; 0x12f8a3c4; 0x3b086c47;\n      0x16d467d6; 0x101d91c7; 0x321df177; 0x0176c193; 0x1ff72bf1; 0x1e889109;\n      0x0b464b18; 0x2b86b97c; 0x0891da48; 0x03137463; 0x085ac5a1; 0x15d61f2f;\n      0x3bced359; 0x29c1c132; 0x3a86766e; 0x366d8c86; 0x1f5b6222; 0x3ce1b59f;\n      0x2ebf78e1; 0x27cd1b86; 0x258f3dc3; 0x389a8194; 0x02e4c44c; 0x18c43f7d;\n      0x0f6e534f; 0x1e7df359; 0x055d0b7e; 0x10e84e7e; 0x126198e4; 0x0e7722cb;\n      0x1cbede28; 0x3391b964; 0x3d40e92a; 0x0c59933d; 0x0b8cd0b7; 0x24efff1c;\n      0x2803fdaa; 0x08ebc72e; 0x0f522e32; 0x05398edc; 0x2144a04c; 0x0aef3cbd;\n      0x01ad4719; 0x35b93cd6; 0x2a559d4f; 0x1e6fd768; 0x26e27f36; 0x186f18c3;\n      0x2fbf967a;\n    |];\n  State.idx = 0;\n}\n\nlet bits () = State.bits default\nlet int bound = State.int default bound\nlet int32 bound = State.int32 default bound\nlet nativeint bound = State.nativeint default bound\nlet int64 bound = State.int64 default bound\nlet float scale = State.float default scale\nlet bool () = State.bool default\n\nlet full_init seed = State.full_init default seed\nlet init seed = State.full_init default [| seed |]\nlet self_init () = full_init (random_seed())\n\n(* Manipulating the current state. *)\n\nlet get_state () = State.copy default\nlet set_state s = State.assign default s\n\n(********************\n\n(* Test functions.  Not included in the library.\n   The [chisquare] function should be called with n > 10r.\n   It returns a triple (low, actual, high).\n   If low <= actual <= high, the [g] function passed the test,\n   otherwise it failed.\n\n  Some results:\n\ninit 27182818; chisquare int 100000 1000\ninit 27182818; chisquare int 100000 100\ninit 27182818; chisquare int 100000 5000\ninit 27182818; chisquare int 1000000 1000\ninit 27182818; chisquare int 100000 1024\ninit 299792643; chisquare int 100000 1024\ninit 14142136; chisquare int 100000 1024\ninit 27182818; init_diff 1024; chisquare diff 100000 1024\ninit 27182818; init_diff 100; chisquare diff 100000 100\ninit 27182818; init_diff2 1024; chisquare diff2 100000 1024\ninit 27182818; init_diff2 100; chisquare diff2 100000 100\ninit 14142136; init_diff2 100; chisquare diff2 100000 100\ninit 299792643; init_diff2 100; chisquare diff2 100000 100\n- : float * float * float = (936.754446796632465, 997.5, 1063.24555320336754)\n# - : float * float * float = (80., 89.7400000000052387, 120.)\n# - : float * float * float = (4858.57864376269, 5045.5, 5141.42135623731)\n# - : float * float * float =\n(936.754446796632465, 944.805999999982305, 1063.24555320336754)\n# - : float * float * float = (960., 1019.19744000000355, 1088.)\n# - : float * float * float = (960., 1059.31776000000536, 1088.)\n# - : float * float * float = (960., 1039.98463999999512, 1088.)\n# - : float * float * float = (960., 1054.38207999999577, 1088.)\n# - : float * float * float = (80., 90.096000000005, 120.)\n# - : float * float * float = (960., 1076.78720000000612, 1088.)\n# - : float * float * float = (80., 85.1760000000067521, 120.)\n# - : float * float * float = (80., 85.2160000000003492, 120.)\n# - : float * float * float = (80., 80.6220000000030268, 120.)\n\n*)\n\n(* Return the sum of the squares of v[i0,i1[ *)\nlet rec sumsq v i0 i1 =\n  if i0 >= i1 then 0.0\n  else if i1 = i0 + 1 then Pervasives.float v.(i0) *. Pervasives.float v.(i0)\n  else sumsq v i0 ((i0+i1)/2) +. sumsq v ((i0+i1)/2) i1\n\n\nlet chisquare g n r =\n  if n <= 10 * r then invalid_arg \"chisquare\";\n  let f = Array.make r 0 in\n  for i = 1 to n do\n    let t = g r in\n    f.(t) <- f.(t) + 1\n  done;\n  let t = sumsq f 0 r\n  and r = Pervasives.float r\n  and n = Pervasives.float n in\n  let sr = 2.0 *. sqrt r in\n  (r -. sr,   (r *. t /. n) -. n,   r +. sr)\n\n\n(* This is to test for linear dependencies between successive random numbers.\n*)\nlet st = ref 0\nlet init_diff r = st := int r\nlet diff r =\n  let x1 = !st\n  and x2 = int r\n  in\n  st := x2;\n  if x1 >= x2 then\n    x1 - x2\n  else\n    r + x1 - x2\n\n\nlet st1 = ref 0\nand st2 = ref 0\n\n\n(* This is to test for quadratic dependencies between successive random\n   numbers.\n*)\nlet init_diff2 r = st1 := int r; st2 := int r\nlet diff2 r =\n  let x1 = !st1\n  and x2 = !st2\n  and x3 = int r\n  in\n  st1 := x2;\n  st2 := x3;\n  (x3 - x2 - x2 + x1 + 2*r) mod r\n\n\n********************)\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Hash tables *)\n\nexternal seeded_hash_param :\n  int -> int -> int -> 'a -> int = \"caml_hash\" [@@noalloc]\nexternal old_hash_param :\n  int -> int -> 'a -> int = \"caml_hash_univ_param\" [@@noalloc]\n\nlet hash x = seeded_hash_param 10 100 0 x\nlet hash_param n1 n2 x = seeded_hash_param n1 n2 0 x\nlet seeded_hash seed x = seeded_hash_param 10 100 seed x\n\n(* We do dynamic hashing, and resize the table and rehash the elements\n   when buckets become too long. *)\n\ntype ('a, 'b) t =\n  { mutable size: int;                        (* number of entries *)\n    mutable data: ('a, 'b) bucketlist array;  (* the buckets *)\n    mutable seed: int;                        (* for randomization *)\n    mutable initial_size: int;                (* initial array size *)\n  }\n\nand ('a, 'b) bucketlist =\n    Empty\n  | Cons of { mutable key: 'a;\n              mutable data: 'b;\n              mutable next: ('a, 'b) bucketlist }\n\n(* The sign of initial_size encodes the fact that a traversal is\n   ongoing or not.\n\n   This disables the efficient in place implementation of resizing.\n*)\n\nlet ongoing_traversal h =\n  Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n  || h.initial_size < 0\n\nlet flip_ongoing_traversal h =\n  h.initial_size <- - h.initial_size\n\n(* To pick random seeds if requested *)\n\nlet randomized_default =\n  let params =\n    try Sys.getenv \"OCAMLRUNPARAM\" with Not_found ->\n    try Sys.getenv \"CAMLRUNPARAM\" with Not_found -> \"\" in\n  String.contains params 'R'\n\nlet randomized = ref randomized_default\n\nlet randomize () = randomized := true\nlet is_randomized () = !randomized\n\nlet prng = lazy (Random.State.make_self_init())\n\n(* Creating a fresh, empty table *)\n\nlet rec power_2_above x n =\n  if x >= n then x\n  else if x * 2 > Sys.max_array_length then x\n  else power_2_above (x * 2) n\n\nlet create ?(random = !randomized) initial_size =\n  let s = power_2_above 16 initial_size in\n  let seed = if random then Random.State.bits (Lazy.force prng) else 0 in\n  { initial_size = s; size = 0; seed = seed; data = Array.make s Empty }\n\nlet clear h =\n  h.size <- 0;\n  let len = Array.length h.data in\n  for i = 0 to len - 1 do\n    h.data.(i) <- Empty\n  done\n\nlet reset h =\n  let len = Array.length h.data in\n  if Obj.size (Obj.repr h) < 4 (* compatibility with old hash tables *)\n    || len = abs h.initial_size then\n    clear h\n  else begin\n    h.size <- 0;\n    h.data <- Array.make (abs h.initial_size) Empty\n  end\n\nlet copy_bucketlist = function\n  | Empty -> Empty\n  | Cons {key; data; next} ->\n      let rec loop prec = function\n        | Empty -> ()\n        | Cons {key; data; next} ->\n            let r = Cons {key; data; next} in\n            begin match prec with\n            | Empty -> assert false\n            | Cons prec ->  prec.next <- r\n            end;\n            loop r next\n      in\n      let r = Cons {key; data; next} in\n      loop r next;\n      r\n\nlet copy h = { h with data = Array.map copy_bucketlist h.data }\n\nlet length h = h.size\n\nlet resize indexfun h =\n  let odata = h.data in\n  let osize = Array.length odata in\n  let nsize = osize * 2 in\n  if nsize < Sys.max_array_length then begin\n    let ndata = Array.make nsize Empty in\n    let ndata_tail = Array.make nsize Empty in\n    let inplace = not (ongoing_traversal h) in\n    h.data <- ndata;          (* so that indexfun sees the new bucket count *)\n    let rec insert_bucket = function\n      | Empty -> ()\n      | Cons {key; data; next} as cell ->\n          let cell =\n            if inplace then cell\n            else Cons {key; data; next = Empty}\n          in\n          let nidx = indexfun h key in\n          begin match ndata_tail.(nidx) with\n          | Empty -> ndata.(nidx) <- cell;\n          | Cons tail -> tail.next <- cell;\n          end;\n          ndata_tail.(nidx) <- cell;\n          insert_bucket next\n    in\n    for i = 0 to osize - 1 do\n      insert_bucket odata.(i)\n    done;\n    if inplace then\n      for i = 0 to nsize - 1 do\n        match ndata_tail.(i) with\n        | Empty -> ()\n        | Cons tail -> tail.next <- Empty\n      done;\n  end\n\nlet key_index h key =\n  (* compatibility with old hash tables *)\n  if Obj.size (Obj.repr h) >= 3\n  then (seeded_hash_param 10 100 h.seed key) land (Array.length h.data - 1)\n  else (old_hash_param 10 100 key) mod (Array.length h.data)\n\nlet add h key data =\n  let i = key_index h key in\n  let bucket = Cons{key; data; next=h.data.(i)} in\n  h.data.(i) <- bucket;\n  h.size <- h.size + 1;\n  if h.size > Array.length h.data lsl 1 then resize key_index h\n\nlet rec remove_bucket h i key prec = function\n  | Empty ->\n      ()\n  | (Cons {key=k; next}) as c ->\n      if compare k key = 0\n      then begin\n        h.size <- h.size - 1;\n        match prec with\n        | Empty -> h.data.(i) <- next\n        | Cons c -> c.next <- next\n      end\n      else remove_bucket h i key c next\n\nlet remove h key =\n  let i = key_index h key in\n  remove_bucket h i key Empty h.data.(i)\n\nlet rec find_rec key = function\n  | Empty ->\n      raise Not_found\n  | Cons{key=k; data; next} ->\n      if compare key k = 0 then data else find_rec key next\n\nlet find h key =\n  match h.data.(key_index h key) with\n  | Empty -> raise Not_found\n  | Cons{key=k1; data=d1; next=next1} ->\n      if compare key k1 = 0 then d1 else\n      match next1 with\n      | Empty -> raise Not_found\n      | Cons{key=k2; data=d2; next=next2} ->\n          if compare key k2 = 0 then d2 else\n          match next2 with\n          | Empty -> raise Not_found\n          | Cons{key=k3; data=d3; next=next3} ->\n              if compare key k3 = 0 then d3 else find_rec key next3\n\nlet find_all h key =\n  let rec find_in_bucket = function\n  | Empty ->\n      []\n  | Cons{key=k; data; next} ->\n      if compare k key = 0\n      then data :: find_in_bucket next\n      else find_in_bucket next in\n  find_in_bucket h.data.(key_index h key)\n\nlet rec replace_bucket key data = function\n  | Empty ->\n      true\n  | Cons ({key=k; next} as slot) ->\n      if compare k key = 0\n      then (slot.key <- key; slot.data <- data; false)\n      else replace_bucket key data next\n\nlet replace h key data =\n  let i = key_index h key in\n  let l = h.data.(i) in\n  if replace_bucket key data l then begin\n    h.data.(i) <- Cons{key; data; next=l};\n    h.size <- h.size + 1;\n    if h.size > Array.length h.data lsl 1 then resize key_index h\n  end\n\nlet mem h key =\n  let rec mem_in_bucket = function\n  | Empty ->\n      false\n  | Cons{key=k; next} ->\n      compare k key = 0 || mem_in_bucket next in\n  mem_in_bucket h.data.(key_index h key)\n\nlet iter f h =\n  let rec do_bucket = function\n    | Empty ->\n        ()\n    | Cons{key; data; next} ->\n        f key data; do_bucket next in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    for i = 0 to Array.length d - 1 do\n      do_bucket d.(i)\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet rec filter_map_inplace_bucket f h i prec = function\n  | Empty ->\n      begin match prec with\n      | Empty -> h.data.(i) <- Empty\n      | Cons c -> c.next <- Empty\n      end\n  | (Cons ({key; data; next} as c)) as slot ->\n      begin match f key data with\n      | None ->\n          h.size <- h.size - 1;\n          filter_map_inplace_bucket f h i prec next\n      | Some data ->\n          begin match prec with\n          | Empty -> h.data.(i) <- slot\n          | Cons c -> c.next <- slot\n          end;\n          c.data <- data;\n          filter_map_inplace_bucket f h i slot next\n      end\n\nlet filter_map_inplace f h =\n  let d = h.data in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    for i = 0 to Array.length d - 1 do\n      filter_map_inplace_bucket f h i Empty h.data.(i)\n    done\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\nlet fold f h init =\n  let rec do_bucket b accu =\n    match b with\n      Empty ->\n        accu\n    | Cons{key; data; next} ->\n        do_bucket next (f key data accu) in\n  let old_trav = ongoing_traversal h in\n  if not old_trav then flip_ongoing_traversal h;\n  try\n    let d = h.data in\n    let accu = ref init in\n    for i = 0 to Array.length d - 1 do\n      accu := do_bucket d.(i) !accu\n    done;\n    if not old_trav then flip_ongoing_traversal h;\n    !accu\n  with exn when not old_trav ->\n    flip_ongoing_traversal h;\n    raise exn\n\ntype statistics = {\n  num_bindings: int;\n  num_buckets: int;\n  max_bucket_length: int;\n  bucket_histogram: int array\n}\n\nlet rec bucket_length accu = function\n  | Empty -> accu\n  | Cons{next} -> bucket_length (accu + 1) next\n\nlet stats h =\n  let mbl =\n    Array.fold_left (fun m b -> max m (bucket_length 0 b)) 0 h.data in\n  let histo = Array.make (mbl + 1) 0 in\n  Array.iter\n    (fun b ->\n      let l = bucket_length 0 b in\n      histo.(l) <- histo.(l) + 1)\n    h.data;\n  { num_bindings = h.size;\n    num_buckets = Array.length h.data;\n    max_bucket_length = mbl;\n    bucket_histogram = histo }\n\n(* Functorial interface *)\n\nmodule type HashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: t -> int\n  end\n\nmodule type SeededHashedType =\n  sig\n    type t\n    val equal: t -> t -> bool\n    val hash: int -> t -> int\n  end\n\nmodule type S =\n  sig\n    type key\n    type 'a t\n    val create: int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy: 'a t -> 'a t\n    val add: 'a t -> key -> 'a -> unit\n    val remove: 'a t -> key -> unit\n    val find: 'a t -> key -> 'a\n    val find_all: 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter: (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length: 'a t -> int\n    val stats: 'a t -> statistics\n  end\n\nmodule type SeededS =\n  sig\n    type key\n    type 'a t\n    val create : ?random:bool -> int -> 'a t\n    val clear : 'a t -> unit\n    val reset : 'a t -> unit\n    val copy : 'a t -> 'a t\n    val add : 'a t -> key -> 'a -> unit\n    val remove : 'a t -> key -> unit\n    val find : 'a t -> key -> 'a\n    val find_all : 'a t -> key -> 'a list\n    val replace : 'a t -> key -> 'a -> unit\n    val mem : 'a t -> key -> bool\n    val iter : (key -> 'a -> unit) -> 'a t -> unit\n    val filter_map_inplace: (key -> 'a -> 'a option) -> 'a t -> unit\n    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b\n    val length : 'a t -> int\n    val stats: 'a t -> statistics\n  end\n\nmodule MakeSeeded(H: SeededHashedType): (SeededS with type key = H.t) =\n  struct\n    type key = H.t\n    type 'a hashtbl = (key, 'a) t\n    type 'a t = 'a hashtbl\n    let create = create\n    let clear = clear\n    let reset = reset\n    let copy = copy\n\n    let key_index h key =\n      (H.hash h.seed key) land (Array.length h.data - 1)\n\n    let add h key data =\n      let i = key_index h key in\n      let bucket = Cons{key; data; next=h.data.(i)} in\n      h.data.(i) <- bucket;\n      h.size <- h.size + 1;\n      if h.size > Array.length h.data lsl 1 then resize key_index h\n\n    let rec remove_bucket h i key prec = function\n      | Empty ->\n          ()\n      | (Cons {key=k; next}) as c ->\n          if H.equal k key\n          then begin\n            h.size <- h.size - 1;\n            match prec with\n            | Empty -> h.data.(i) <- next\n            | Cons c -> c.next <- next\n          end\n          else remove_bucket h i key c next\n\n    let remove h key =\n      let i = key_index h key in\n      remove_bucket h i key Empty h.data.(i)\n\n    let rec find_rec key = function\n      | Empty ->\n          raise Not_found\n      | Cons{key=k; data; next} ->\n          if H.equal key k then data else find_rec key next\n\n    let find h key =\n      match h.data.(key_index h key) with\n      | Empty -> raise Not_found\n      | Cons{key=k1; data=d1; next=next1} ->\n          if H.equal key k1 then d1 else\n          match next1 with\n          | Empty -> raise Not_found\n          | Cons{key=k2; data=d2; next=next2} ->\n              if H.equal key k2 then d2 else\n              match next2 with\n              | Empty -> raise Not_found\n              | Cons{key=k3; data=d3; next=next3} ->\n                  if H.equal key k3 then d3 else find_rec key next3\n\n    let find_all h key =\n      let rec find_in_bucket = function\n      | Empty ->\n          []\n      | Cons{key=k; data=d; next} ->\n          if H.equal k key\n          then d :: find_in_bucket next\n          else find_in_bucket next in\n      find_in_bucket h.data.(key_index h key)\n\n    let rec replace_bucket key data = function\n      | Empty ->\n          true\n      | Cons ({key=k; next} as slot) ->\n          if H.equal k key\n          then (slot.key <- key; slot.data <- data; false)\n          else replace_bucket key data next\n\n    let replace h key data =\n      let i = key_index h key in\n      let l = h.data.(i) in\n      if replace_bucket key data l then begin\n        h.data.(i) <- Cons{key; data; next=l};\n        h.size <- h.size + 1;\n        if h.size > Array.length h.data lsl 1 then resize key_index h\n      end\n\n    let mem h key =\n      let rec mem_in_bucket = function\n      | Empty ->\n          false\n      | Cons{key=k; next} ->\n          H.equal k key || mem_in_bucket next in\n      mem_in_bucket h.data.(key_index h key)\n\n    let iter = iter\n    let filter_map_inplace = filter_map_inplace\n    let fold = fold\n    let length = length\n    let stats = stats\n  end\n\nmodule Make(H: HashedType): (S with type key = H.t) =\n  struct\n    include MakeSeeded(struct\n        type t = H.t\n        let equal = H.equal\n        let hash (_seed: int) x = H.hash x\n      end)\n    let create sz = create ~random:false sz\n  end\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Pierre Weis, projet Cristal, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* A pretty-printing facility and definition of formatters for 'parallel'\n   (i.e. unrelated or independent) pretty-printing on multiple out channels. *)\n\n(*\n   The pretty-printing engine internal data structures.\n*)\n\n(* A devoted type for sizes to avoid confusion\n   between sizes and mere integers. *)\ntype size\n\nexternal size_of_int : int -> size = \"%identity\"\n\nexternal int_of_size : size -> int = \"%identity\"\n\n\n(* The pretty-printing boxes definition:\n   a pretty-printing box is either\n   - hbox: horizontal (no split in the line)\n   - vbox: vertical (the line is splitted at every break hint)\n   - hvbox: horizontal/vertical\n     (the box behaves as an horizontal box if it fits on\n      the current line, otherwise the box behaves as a vertical box)\n   - hovbox: horizontal or vertical\n     (the box is compacting material, printing as much material on every\n     lines)\n   - box: horizontal or vertical with box enhanced structure\n     (the box behaves as an horizontal or vertical box but break hints split\n      the line if splitting would move to the left)\n*)\ntype box_type = CamlinternalFormatBasics.block_type =\n  | Pp_hbox | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits\n\n\n(* The pretty-printing tokens definition:\n   are either text to print or pretty printing\n   elements that drive indentation and line splitting. *)\ntype pp_token =\n  | Pp_text of string          (* normal text *)\n  | Pp_break of int * int      (* complete break *)\n  | Pp_tbreak of int * int     (* go to next tabulation *)\n  | Pp_stab                    (* set a tabulation *)\n  | Pp_begin of int * box_type (* beginning of a box *)\n  | Pp_end                     (* end of a box *)\n  | Pp_tbegin of tbox          (* beginning of a tabulation box *)\n  | Pp_tend                    (* end of a tabulation box *)\n  | Pp_newline                 (* to force a newline inside a box *)\n  | Pp_if_newline              (* to do something only if this very\n                                  line has been broken *)\n  | Pp_open_tag of tag         (* opening a tag name *)\n  | Pp_close_tag               (* closing the most recently opened tag *)\n\nand tag = string\n\nand tbox = Pp_tbox of int list ref  (* Tabulation box *)\n\n\n(* The pretty-printer queue definition:\n   pretty-printing material is not written in the output as soon as emitted;\n   instead, the material is simply recorded in the pretty-printer queue,\n   until the enclosing box has a known computed size and proper splitting\n   decisions can be made.\n\n   To define the pretty-printer queue, we first define polymorphic queues,\n   then pretty-printer queue elements.\n*)\n\n(* The pretty-printer queue: polymorphic queue definition. *)\ntype 'a queue_elem =\n  | Nil\n  | Cons of {\n      head : 'a;\n      mutable tail : 'a queue_elem;\n    }\n\n\ntype 'a queue = {\n  mutable insert : 'a queue_elem;\n  mutable body : 'a queue_elem;\n}\n\n\n(* The pretty-printer queue: queue element definition.\n   The pretty-printer queue contains formatting elements to be printed.\n   Each formatting element is a tuple (size, token, length), where\n   - length is the declared length of the token,\n   - size is effective size of the token when it is printed\n     (size is set when the size of the box is known, so that size of break\n      hints are definitive). *)\ntype pp_queue_elem = {\n  mutable elem_size : size;\n  token : pp_token;\n  length : int;\n}\n\n\n(* The pretty-printer queue definition. *)\ntype pp_queue = pp_queue_elem queue\n\n(* The pretty-printer scanning stack. *)\n\n(* The pretty-printer scanning stack: scanning element definition.\n   Each element is (left_total, queue element) where left_total\n   is the value of pp_left_total when the element has been enqueued. *)\ntype pp_scan_elem = Scan_elem of int * pp_queue_elem\n\n(* The pretty-printer scanning stack definition. *)\ntype pp_scan_stack = pp_scan_elem list\n\n(* The pretty-printer formatting stack:\n   the formatting stack contains the description of all the currently active\n   boxes; the pretty-printer formatting stack is used to split the lines\n   while printing tokens. *)\n\n(* The pretty-printer formatting stack: formatting stack element definition.\n   Each stack element describes a pretty-printing box. *)\ntype pp_format_elem = Format_elem of box_type * int\n\n(* The pretty-printer formatting stack definition. *)\ntype pp_format_stack = pp_format_elem list\n\n(* The pretty-printer semantics tag stack definition. *)\ntype pp_tag_stack = tag list\n\n(* The formatter definition.\n   Each formatter value is a pretty-printer instance with all its\n   machinery. *)\ntype formatter = {\n  (* The various stacks. *)\n  mutable pp_scan_stack : pp_scan_stack;\n  mutable pp_format_stack : pp_format_stack;\n  mutable pp_tbox_stack : tbox list;\n  mutable pp_tag_stack : pp_tag_stack;\n  mutable pp_mark_stack : pp_tag_stack;\n  (* Value of right margin. *)\n  mutable pp_margin : int;\n  (* Minimal space left before margin, when opening a box. *)\n  mutable pp_min_space_left : int;\n  (* Maximum value of indentation:\n     no box can be opened further. *)\n  mutable pp_max_indent : int;\n  (* Space remaining on the current line. *)\n  mutable pp_space_left : int;\n  (* Current value of indentation. *)\n  mutable pp_current_indent : int;\n  (* True when the line has been broken by the pretty-printer. *)\n  mutable pp_is_new_line : bool;\n  (* Total width of tokens already printed. *)\n  mutable pp_left_total : int;\n  (* Total width of tokens ever put in queue. *)\n  mutable pp_right_total : int;\n  (* Current number of opened boxes. *)\n  mutable pp_curr_depth : int;\n  (* Maximum number of boxes which can be simultaneously opened. *)\n  mutable pp_max_boxes : int;\n  (* Ellipsis string. *)\n  mutable pp_ellipsis : string;\n  (* Output function. *)\n  mutable pp_out_string : string -> int -> int -> unit;\n  (* Flushing function. *)\n  mutable pp_out_flush : unit -> unit;\n  (* Output of new lines. *)\n  mutable pp_out_newline : unit -> unit;\n  (* Output of indentation spaces. *)\n  mutable pp_out_spaces : int -> unit;\n  (* Are tags printed ? *)\n  mutable pp_print_tags : bool;\n  (* Are tags marked ? *)\n  mutable pp_mark_tags : bool;\n  (* Find opening and closing markers of tags. *)\n  mutable pp_mark_open_tag : tag -> string;\n  mutable pp_mark_close_tag : tag -> string;\n  mutable pp_print_open_tag : tag -> unit;\n  mutable pp_print_close_tag : tag -> unit;\n  (* The pretty-printer queue. *)\n  mutable pp_queue : pp_queue;\n}\n\n\n(* The formatter specific tag handling functions. *)\ntype formatter_tag_functions = {\n  mark_open_tag : tag -> string;\n  mark_close_tag : tag -> string;\n  print_open_tag : tag -> unit;\n  print_close_tag : tag -> unit;\n}\n\n\n(* The formatter functions to output material. *)\ntype formatter_out_functions = {\n  out_string : string -> int -> int -> unit;\n  out_flush : unit -> unit;\n  out_newline : unit -> unit;\n  out_spaces : int -> unit;\n}\n\n\n(*\n\n  Auxiliaries and basic functions.\n\n*)\n\n(* Queues auxiliaries. *)\n\nlet make_queue () = { insert = Nil; body = Nil; }\n\nlet clear_queue q = q.insert <- Nil; q.body <- Nil\n\nlet add_queue x q =\n  let c = Cons { head = x; tail = Nil; } in\n  match q with\n  | { insert = Cons cell; body = _; } ->\n    q.insert <- c; cell.tail <- c\n  (* Invariant: when insert is Nil body should be Nil. *)\n  | { insert = Nil; body = _; } ->\n    q.insert <- c; q.body <- c\n\n\nexception Empty_queue\n\nlet peek_queue = function\n  | { body = Cons { head = x; tail = _; }; _ } -> x\n  | { body = Nil; insert = _; } -> raise Empty_queue\n\n\nlet take_queue = function\n  | { body = Cons { head = x; tail = tl; }; _ } as q ->\n    q.body <- tl;\n    if tl = Nil then q.insert <- Nil; (* Maintain the invariant. *)\n    x\n  | { body = Nil; insert = _; } -> raise Empty_queue\n\n\n(* Enter a token in the pretty-printer queue. *)\nlet pp_enqueue state ({ length = len; _} as token) =\n  state.pp_right_total <- state.pp_right_total + len;\n  add_queue token state.pp_queue\n\n\nlet pp_clear_queue state =\n  state.pp_left_total <- 1; state.pp_right_total <- 1;\n  clear_queue state.pp_queue\n\n\n(* Pp_infinity: large value for default tokens size.\n\n   Pp_infinity is documented as being greater than 1e10; to avoid\n   confusion about the word 'greater', we choose pp_infinity greater\n   than 1e10 + 1; for correct handling of tests in the algorithm,\n   pp_infinity must be even one more than 1e10 + 1; let's stand on the\n   safe side by choosing 1.e10+10.\n\n   Pp_infinity could probably be 1073741823 that is 2^30 - 1, that is\n   the minimal upper bound for integers; now that max_int is defined,\n   this limit could also be defined as max_int - 1.\n\n   However, before setting pp_infinity to something around max_int, we\n   must carefully double-check all the integer arithmetic operations\n   that involve pp_infinity, since any overflow would wreck havoc the\n   pretty-printing algorithm's invariants. Given that this arithmetic\n   correctness check is difficult and error prone and given that 1e10\n   + 1 is in practice large enough, there is no need to attempt to set\n   pp_infinity to the theoretically maximum limit. It is not worth the\n   burden ! *)\nlet pp_infinity = 1000000010\n\n(* Output functions for the formatter. *)\nlet pp_output_string state s = state.pp_out_string s 0 (String.length s)\nand pp_output_newline state = state.pp_out_newline ()\nand pp_output_spaces state n = state.pp_out_spaces n\n\n(* To format a break, indenting a new line. *)\nlet break_new_line state offset width =\n  pp_output_newline state;\n  state.pp_is_new_line <- true;\n  let indent = state.pp_margin - width + offset in\n  (* Don't indent more than pp_max_indent. *)\n  let real_indent = min state.pp_max_indent indent in\n  state.pp_current_indent <- real_indent;\n  state.pp_space_left <- state.pp_margin - state.pp_current_indent;\n  pp_output_spaces state state.pp_current_indent\n\n\n(* To force a line break inside a box: no offset is added. *)\nlet break_line state width = break_new_line state 0 width\n\n(* To format a break that fits on the current line. *)\nlet break_same_line state width =\n  state.pp_space_left <- state.pp_space_left - width;\n  pp_output_spaces state width\n\n\n(* To indent no more than pp_max_indent, if one tries to open a box\n   beyond pp_max_indent, then the box is rejected on the left\n   by simulating a break. *)\nlet pp_force_break_line state =\n  match state.pp_format_stack with\n  | Format_elem (bl_ty, width) :: _ ->\n    if width > state.pp_space_left then\n      (match bl_ty with\n       | Pp_fits -> () | Pp_hbox -> ()\n       | Pp_vbox | Pp_hvbox | Pp_hovbox | Pp_box ->\n         break_line state width)\n  | [] -> pp_output_newline state\n\n\n(* To skip a token, if the previous line has been broken. *)\nlet pp_skip_token state =\n  (* When calling pp_skip_token the queue cannot be empty. *)\n  match take_queue state.pp_queue with\n  | { elem_size = size; length = len; token = _; } ->\n    state.pp_left_total <- state.pp_left_total - len;\n    state.pp_space_left <- state.pp_space_left + int_of_size size\n\n\n(*\n\n  The main pretty printing functions.\n\n*)\n\n(* Formatting a token with a given size. *)\nlet format_pp_token state size = function\n\n  | Pp_text s ->\n    state.pp_space_left <- state.pp_space_left - size;\n    pp_output_string state s;\n    state.pp_is_new_line <- false\n\n  | Pp_begin (off, ty) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    if insertion_point > state.pp_max_indent then\n      (* can not open a box right there. *)\n      begin pp_force_break_line state end;\n    let offset = state.pp_space_left - off in\n    let bl_type =\n      begin match ty with\n      | Pp_vbox -> Pp_vbox\n      | Pp_hbox | Pp_hvbox | Pp_hovbox | Pp_box | Pp_fits ->\n        if size > state.pp_space_left then ty else Pp_fits\n      end in\n    state.pp_format_stack <-\n      Format_elem (bl_type, offset) :: state.pp_format_stack\n\n  | Pp_end ->\n    begin match state.pp_format_stack with\n    | _ :: ls -> state.pp_format_stack <- ls\n    | [] -> () (* No more box to close. *)\n    end\n\n  | Pp_tbegin (Pp_tbox _ as tbox) ->\n    state.pp_tbox_stack <- tbox :: state.pp_tbox_stack\n\n  | Pp_tend ->\n    begin match state.pp_tbox_stack with\n    | _ :: ls -> state.pp_tbox_stack <- ls\n    | [] -> () (* No more tabulation box to close. *)\n    end\n\n  | Pp_stab ->\n    begin match state.pp_tbox_stack with\n    | Pp_tbox tabs :: _ ->\n      let rec add_tab n = function\n        | [] -> [n]\n        | x :: l as ls -> if n < x then n :: ls else x :: add_tab n l in\n      tabs := add_tab (state.pp_margin - state.pp_space_left) !tabs\n    | [] -> () (* No opened tabulation box. *)\n    end\n\n  | Pp_tbreak (n, off) ->\n    let insertion_point = state.pp_margin - state.pp_space_left in\n    begin match state.pp_tbox_stack with\n    | Pp_tbox tabs :: _ ->\n      let rec find n = function\n        | x :: l -> if x >= n then x else find n l\n        | [] -> raise Not_found in\n      let tab =\n        match !tabs with\n        | x :: _ ->\n          begin\n            try find insertion_point !tabs with\n            | Not_found -> x\n          end\n        | _ -> insertion_point in\n      let offset = tab - insertion_point in\n      if offset >= 0\n      then break_same_line state (offset + n)\n      else break_new_line state (tab + off) state.pp_margin\n    | [] -> () (* No opened tabulation box. *)\n    end\n\n  | Pp_newline ->\n    begin match state.pp_format_stack with\n    | Format_elem (_, width) :: _ -> break_line state width\n    | [] -> pp_output_newline state (* No opened box. *)\n    end\n\n  | Pp_if_newline ->\n    if state.pp_current_indent != state.pp_margin - state.pp_space_left\n    then pp_skip_token state\n\n  | Pp_break (n, off) ->\n    begin match state.pp_format_stack with\n    | Format_elem (ty, width) :: _ ->\n      begin match ty with\n      | Pp_hovbox ->\n        if size > state.pp_space_left\n        then break_new_line state off width\n        else break_same_line state n\n      | Pp_box ->\n        (* Have the line just been broken here ? *)\n        if state.pp_is_new_line then break_same_line state n else\n        if size > state.pp_space_left\n         then break_new_line state off width else\n        (* break the line here leads to new indentation ? *)\n        if state.pp_current_indent > state.pp_margin - width + off\n        then break_new_line state off width\n        else break_same_line state n\n      | Pp_hvbox -> break_new_line state off width\n      | Pp_fits -> break_same_line state n\n      | Pp_vbox -> break_new_line state off width\n      | Pp_hbox -> break_same_line state n\n      end\n    | [] -> () (* No opened box. *)\n    end\n\n   | Pp_open_tag tag_name ->\n     let marker = state.pp_mark_open_tag tag_name in\n     pp_output_string state marker;\n     state.pp_mark_stack <- tag_name :: state.pp_mark_stack\n\n   | Pp_close_tag ->\n     begin match state.pp_mark_stack with\n     | tag_name :: tags ->\n       let marker = state.pp_mark_close_tag tag_name in\n       pp_output_string state marker;\n       state.pp_mark_stack <- tags\n     | [] -> () (* No more tag to close. *)\n     end\n\n\n(* Print if token size is known else printing is delayed.\n   Size is known when not negative.\n   Printing is delayed when the text waiting in the queue requires\n   more room to format than exists on the current line.\n\n   Note: [advance_loop] must be tail recursive to prevent stack overflows. *)\nlet rec advance_loop state =\n  match peek_queue state.pp_queue with\n  | {elem_size = size; token = tok; length = len} ->\n    let size = int_of_size size in\n    if not\n         (size < 0 &&\n          (state.pp_right_total - state.pp_left_total < state.pp_space_left))\n    then begin\n      ignore (take_queue state.pp_queue);\n      format_pp_token state (if size < 0 then pp_infinity else size) tok;\n      state.pp_left_total <- len + state.pp_left_total;\n      advance_loop state\n    end\n\n\nlet advance_left state =\n  try advance_loop state with\n  | Empty_queue -> ()\n\n\n(* To enqueue a token : try to advance. *)\nlet enqueue_advance state tok = pp_enqueue state tok; advance_left state\n\n(* Building pretty-printer queue elements. *)\nlet make_queue_elem size tok len =\n  { elem_size = size; token = tok; length = len; }\n\n\n(* To enqueue strings. *)\nlet enqueue_string_as state size s =\n  let len = int_of_size size in\n  enqueue_advance state (make_queue_elem size (Pp_text s) len)\n\n\nlet enqueue_string state s =\n  let len = String.length s in\n  enqueue_string_as state (size_of_int len) s\n\n\n(* Routines for scan stack\n   determine size of boxes. *)\n\n(* The scan_stack is never empty. *)\nlet scan_stack_bottom =\n  let q_elem = make_queue_elem (size_of_int (-1)) (Pp_text \"\") 0 in\n  [Scan_elem (-1, q_elem)]\n\n\n(* Clearing the pretty-printer scanning stack. *)\nlet clear_scan_stack state = state.pp_scan_stack <- scan_stack_bottom\n\n(* Setting the size of boxes on scan stack:\n   if ty = true then size of break is set else size of box is set;\n   in each case pp_scan_stack is popped.\n\n   Note:\n   Pattern matching on scan stack is exhaustive, since scan_stack is never\n   empty.\n   Pattern matching on token in scan stack is also exhaustive,\n   since scan_push is used on breaks and opening of boxes. *)\nlet set_size state ty =\n  match state.pp_scan_stack with\n  | Scan_elem\n      (left_tot,\n       ({ elem_size = size; token = tok; length = _; } as queue_elem)) :: t ->\n    let size = int_of_size size in\n    (* test if scan stack contains any data that is not obsolete. *)\n    if left_tot < state.pp_left_total then clear_scan_stack state else\n      begin match tok with\n      | Pp_break (_, _) | Pp_tbreak (_, _) ->\n        if ty then\n        begin\n          queue_elem.elem_size <- size_of_int (state.pp_right_total + size);\n          state.pp_scan_stack <- t\n        end\n      | Pp_begin (_, _) ->\n        if not ty then\n        begin\n          queue_elem.elem_size <- size_of_int (state.pp_right_total + size);\n          state.pp_scan_stack <- t\n        end\n      | Pp_text _ | Pp_stab | Pp_tbegin _ | Pp_tend | Pp_end\n      | Pp_newline | Pp_if_newline\n      | Pp_open_tag _ | Pp_close_tag ->\n        () (* scan_push is only used for breaks and boxes. *)\n      end\n  | [] -> () (* scan_stack is never empty. *)\n\n\n(* Push a token on pretty-printer scanning stack.\n   If b is true set_size is called. *)\nlet scan_push state b tok =\n  pp_enqueue state tok;\n  if b then set_size state true;\n  state.pp_scan_stack <-\n    Scan_elem (state.pp_right_total, tok) :: state.pp_scan_stack\n\n\n(* To open a new box :\n   the user may set the depth bound pp_max_boxes\n   any text nested deeper is printed as the ellipsis string. *)\nlet pp_open_box_gen state indent br_ty =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem =\n      make_queue_elem\n        (size_of_int (- state.pp_right_total))\n        (Pp_begin (indent, br_ty))\n        0 in\n    scan_push state false elem else\n  if state.pp_curr_depth = state.pp_max_boxes\n  then enqueue_string state state.pp_ellipsis\n\n\n(* The box which is always opened. *)\nlet pp_open_sys_box state = pp_open_box_gen state 0 Pp_hovbox\n\n(* Close a box, setting sizes of its sub boxes. *)\nlet pp_close_box state () =\n  if state.pp_curr_depth > 1 then\n  begin\n    if state.pp_curr_depth < state.pp_max_boxes then\n    begin\n      pp_enqueue state\n        { elem_size = size_of_int 0; token = Pp_end; length = 0; };\n      set_size state true; set_size state false\n    end;\n    state.pp_curr_depth <- state.pp_curr_depth - 1;\n  end\n\n\n(* Open a tag, pushing it on the tag stack. *)\nlet pp_open_tag state tag_name =\n  if state.pp_print_tags then\n  begin\n    state.pp_tag_stack <- tag_name :: state.pp_tag_stack;\n    state.pp_print_open_tag tag_name\n  end;\n  if state.pp_mark_tags then\n    pp_enqueue state {\n      elem_size = size_of_int 0;\n      token = Pp_open_tag tag_name;\n      length = 0;\n    }\n\n\n(* Close a tag, popping it from the tag stack. *)\nlet pp_close_tag state () =\n  if state.pp_mark_tags then\n    pp_enqueue state {\n      elem_size = size_of_int 0;\n      token = Pp_close_tag;\n      length = 0;\n    };\n  if state.pp_print_tags then\n  begin\n    match state.pp_tag_stack with\n    | tag_name :: tags ->\n      state.pp_print_close_tag tag_name;\n      state.pp_tag_stack <- tags\n    | _ -> () (* No more tag to close. *)\n  end\n\n\nlet pp_set_print_tags state b = state.pp_print_tags <- b\nlet pp_set_mark_tags state b = state.pp_mark_tags <- b\nlet pp_get_print_tags state () = state.pp_print_tags\nlet pp_get_mark_tags state () = state.pp_mark_tags\nlet pp_set_tags state b =\n  pp_set_print_tags state b; pp_set_mark_tags state b\n\n\n(* Handling tag handling functions: get/set functions. *)\nlet pp_get_formatter_tag_functions state () = {\n  mark_open_tag = state.pp_mark_open_tag;\n  mark_close_tag = state.pp_mark_close_tag;\n  print_open_tag = state.pp_print_open_tag;\n  print_close_tag = state.pp_print_close_tag;\n}\n\n\nlet pp_set_formatter_tag_functions state {\n     mark_open_tag = mot;\n     mark_close_tag = mct;\n     print_open_tag = pot;\n     print_close_tag = pct;\n  } =\n  state.pp_mark_open_tag <- mot;\n  state.pp_mark_close_tag <- mct;\n  state.pp_print_open_tag <- pot;\n  state.pp_print_close_tag <- pct\n\n\n(* Initialize pretty-printer. *)\nlet pp_rinit state =\n  pp_clear_queue state;\n  clear_scan_stack state;\n  state.pp_format_stack <- [];\n  state.pp_tbox_stack <- [];\n  state.pp_tag_stack <- [];\n  state.pp_mark_stack <- [];\n  state.pp_current_indent <- 0;\n  state.pp_curr_depth <- 0;\n  state.pp_space_left <- state.pp_margin;\n  pp_open_sys_box state\n\n\n(* Flushing pretty-printer queue. *)\nlet pp_flush_queue state b =\n  while state.pp_curr_depth > 1 do\n    pp_close_box state ()\n  done;\n  state.pp_right_total <- pp_infinity;\n  advance_left state;\n  if b then pp_output_newline state;\n  pp_rinit state\n\n\n(*\n\n  Procedures to format values and use boxes.\n\n*)\n\n(* To format a string. *)\nlet pp_print_as_size state size s =\n  if state.pp_curr_depth < state.pp_max_boxes\n  then enqueue_string_as state size s\n\n\nlet pp_print_as state isize s =\n  pp_print_as_size state (size_of_int isize) s\n\n\nlet pp_print_string state s =\n  pp_print_as state (String.length s) s\n\n\n(* To format an integer. *)\nlet pp_print_int state i = pp_print_string state (string_of_int i)\n\n(* To format a float. *)\nlet pp_print_float state f = pp_print_string state (string_of_float f)\n\n(* To format a boolean. *)\nlet pp_print_bool state b = pp_print_string state (string_of_bool b)\n\n(* To format a char. *)\nlet pp_print_char state c =\n  pp_print_as state 1 (String.make 1 c)\n\n\n(* Opening boxes. *)\nlet pp_open_hbox state () = pp_open_box_gen state 0 Pp_hbox\nand pp_open_vbox state indent = pp_open_box_gen state indent Pp_vbox\n\nand pp_open_hvbox state indent = pp_open_box_gen state indent Pp_hvbox\nand pp_open_hovbox state indent = pp_open_box_gen state indent Pp_hovbox\nand pp_open_box state indent = pp_open_box_gen state indent Pp_box\n\n\n(* Printing all queued text.\n   [print_newline] prints a new line after flushing the queue.\n   [print_flush] on flush the queue without adding a newline. *)\nlet pp_print_newline state () =\n  pp_flush_queue state true; state.pp_out_flush ()\nand pp_print_flush state () =\n  pp_flush_queue state false; state.pp_out_flush ()\n\n\n(* To get a newline when one does not want to close the current box. *)\nlet pp_force_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state (make_queue_elem (size_of_int 0) Pp_newline 0)\n\n\n(* To format something, only in case the line has just been broken. *)\nlet pp_print_if_newline state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    enqueue_advance state (make_queue_elem (size_of_int 0) Pp_if_newline 0)\n\n\n(* Printing break hints:\n   A break hint indicates where a box may be broken.\n   If line is broken then offset is added to the indentation of the current\n   box else (the value of) width blanks are printed. *)\nlet pp_print_break state width offset =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem =\n      make_queue_elem\n        (size_of_int (- state.pp_right_total))\n        (Pp_break (width, offset))\n        width in\n    scan_push state true elem\n\n\n(* Print a space :\n   a space is a break hint that prints a single space if the break does not\n   split the line;\n   a cut is a break hint that prints nothing if the break does not split the\n   line. *)\nlet pp_print_space state () = pp_print_break state 1 0\nand pp_print_cut state () = pp_print_break state 0 0\n\n\n(* Tabulation boxes. *)\nlet pp_open_tbox state () =\n  state.pp_curr_depth <- state.pp_curr_depth + 1;\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem =\n      make_queue_elem (size_of_int 0) (Pp_tbegin (Pp_tbox (ref []))) 0 in\n    enqueue_advance state elem\n\n\n(* Close a tabulation box. *)\nlet pp_close_tbox state () =\n  if state.pp_curr_depth > 1 then\n  begin\n   if state.pp_curr_depth < state.pp_max_boxes then\n     let elem = make_queue_elem (size_of_int 0) Pp_tend 0 in\n     enqueue_advance state elem;\n     state.pp_curr_depth <- state.pp_curr_depth - 1\n  end\n\n\n(* Print a tabulation break. *)\nlet pp_print_tbreak state width offset =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem =\n      make_queue_elem\n        (size_of_int (- state.pp_right_total))\n        (Pp_tbreak (width, offset))\n        width in\n    scan_push state true elem\n\n\nlet pp_print_tab state () = pp_print_tbreak state 0 0\n\nlet pp_set_tab state () =\n  if state.pp_curr_depth < state.pp_max_boxes then\n    let elem =\n      make_queue_elem (size_of_int 0) Pp_stab 0 in\n    enqueue_advance state elem\n\n\n(*\n\n  Procedures to control the pretty-printers\n\n*)\n\n(* Set_max_boxes. *)\nlet pp_set_max_boxes state n = if n > 1 then state.pp_max_boxes <- n\n\n(* To know the current maximum number of boxes allowed. *)\nlet pp_get_max_boxes state () = state.pp_max_boxes\n\nlet pp_over_max_boxes state () = state.pp_curr_depth = state.pp_max_boxes\n\n(* Ellipsis. *)\nlet pp_set_ellipsis_text state s = state.pp_ellipsis <- s\nand pp_get_ellipsis_text state () = state.pp_ellipsis\n\n\n(* To set the margin of pretty-printer. *)\nlet pp_limit n =\n  if n < pp_infinity then n else pred pp_infinity\n\n\n(* Internal pretty-printer functions. *)\nlet pp_set_min_space_left state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_min_space_left <- n;\n    state.pp_max_indent <- state.pp_margin - state.pp_min_space_left;\n    pp_rinit state\n\n\n(* Initially, we have :\n   pp_max_indent = pp_margin - pp_min_space_left, and\n   pp_space_left = pp_margin. *)\nlet pp_set_max_indent state n =\n  pp_set_min_space_left state (state.pp_margin - n)\n\n\nlet pp_get_max_indent state () = state.pp_max_indent\n\nlet pp_set_margin state n =\n  if n >= 1 then\n    let n = pp_limit n in\n    state.pp_margin <- n;\n    let new_max_indent =\n      (* Try to maintain max_indent to its actual value. *)\n      if state.pp_max_indent <= state.pp_margin\n      then state.pp_max_indent else\n      (* If possible maintain pp_min_space_left to its actual value,\n         if this leads to a too small max_indent, take half of the\n         new margin, if it is greater than 1. *)\n       max (max (state.pp_margin - state.pp_min_space_left)\n                (state.pp_margin / 2)) 1 in\n    (* Rebuild invariants. *)\n    pp_set_max_indent state new_max_indent\n\n\nlet pp_get_margin state () = state.pp_margin\n\n(* Setting a formatter basic output functions. *)\nlet pp_set_formatter_out_functions state {\n      out_string = f;\n      out_flush = g;\n      out_newline = h;\n      out_spaces = i;\n    } =\n  state.pp_out_string <- f;\n  state.pp_out_flush <- g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i\n\n\nlet pp_get_formatter_out_functions state () = {\n  out_string = state.pp_out_string;\n  out_flush = state.pp_out_flush;\n  out_newline = state.pp_out_newline;\n  out_spaces = state.pp_out_spaces;\n}\n\n\n(* Setting a formatter basic string output and flush functions. *)\nlet pp_set_formatter_output_functions state f g =\n  state.pp_out_string <- f; state.pp_out_flush <- g\n\nlet pp_get_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush)\n\n\nlet pp_flush_formatter state =\n  pp_flush_queue state false\n\n(* The default function to output new lines. *)\nlet display_newline state () = state.pp_out_string \"\\n\" 0  1\n\n(* The default function to output spaces. *)\nlet blank_line = String.make 80 ' '\nlet rec display_blanks state n =\n  if n > 0 then\n  if n <= 80 then state.pp_out_string blank_line 0 n else\n  begin\n    state.pp_out_string blank_line 0 80;\n    display_blanks state (n - 80)\n  end\n\n\n(* Setting a formatter basic output functions as printing to a given\n   [Pervasive.out_channel] value. *)\nlet pp_set_formatter_out_channel state os =\n  state.pp_out_string <- output_substring os;\n  state.pp_out_flush <- (fun () -> flush os);\n  state.pp_out_newline <- display_newline state;\n  state.pp_out_spaces <- display_blanks state\n\n\n(*\n\n  Defining specific formatters\n\n*)\n\nlet default_pp_mark_open_tag s = \"<\" ^ s ^ \">\"\nlet default_pp_mark_close_tag s = \"</\" ^ s ^ \">\"\n\nlet default_pp_print_open_tag = ignore\nlet default_pp_print_close_tag = ignore\n\n(* Bulding a formatter given its basic output functions.\n   Other fields get reasonable default values. *)\nlet pp_make_formatter f g h i =\n  (* The initial state of the formatter contains a dummy box. *)\n  let pp_queue = make_queue () in\n  let sys_tok =\n    make_queue_elem (size_of_int (-1)) (Pp_begin (0, Pp_hovbox)) 0 in\n  add_queue sys_tok pp_queue;\n  let sys_scan_stack =\n    Scan_elem (1, sys_tok) :: scan_stack_bottom in\n  let pp_margin = 78\n  and pp_min_space_left = 10 in\n  {\n    pp_scan_stack = sys_scan_stack;\n    pp_format_stack = [];\n    pp_tbox_stack = [];\n    pp_tag_stack = [];\n    pp_mark_stack = [];\n    pp_margin = pp_margin;\n    pp_min_space_left = pp_min_space_left;\n    pp_max_indent = pp_margin - pp_min_space_left;\n    pp_space_left = pp_margin;\n    pp_current_indent = 0;\n    pp_is_new_line = true;\n    pp_left_total = 1;\n    pp_right_total = 1;\n    pp_curr_depth = 1;\n    pp_max_boxes = max_int;\n    pp_ellipsis = \".\";\n    pp_out_string = f;\n    pp_out_flush = g;\n    pp_out_newline = h;\n    pp_out_spaces = i;\n    pp_print_tags = false;\n    pp_mark_tags = false;\n    pp_mark_open_tag = default_pp_mark_open_tag;\n    pp_mark_close_tag = default_pp_mark_close_tag;\n    pp_print_open_tag = default_pp_print_open_tag;\n    pp_print_close_tag = default_pp_print_close_tag;\n    pp_queue = pp_queue;\n  }\n\n\n(* Make a formatter with default functions to output spaces and new lines. *)\nlet make_formatter output flush =\n  let ppf = pp_make_formatter output flush ignore ignore in\n  ppf.pp_out_newline <- display_newline ppf;\n  ppf.pp_out_spaces <- display_blanks ppf;\n  ppf\n\n\n(* Make a formatter writing to a given [Pervasive.out_channel] value. *)\nlet formatter_of_out_channel oc =\n  make_formatter (output_substring oc) (fun () -> flush oc)\n\n\n(* Make a formatter writing to a given [Buffer.t] value. *)\nlet formatter_of_buffer b =\n  make_formatter (Buffer.add_substring b) ignore\n\n\n(* Allocating buffer for pretty-printing purposes.\n   Default buffer size is pp_buffer_size or 512.\n*)\nlet pp_buffer_size = 512\nlet pp_make_buffer () = Buffer.create pp_buffer_size\n\n(* The standard (shared) buffer. *)\nlet stdbuf = pp_make_buffer ()\n\n(* Predefined formatters standard formatter to print\n   to [Pervasives.stdout], [Pervasives.stderr], and {!stdbuf}. *)\nlet std_formatter = formatter_of_out_channel Pervasives.stdout\nand err_formatter = formatter_of_out_channel Pervasives.stderr\nand str_formatter = formatter_of_buffer stdbuf\n\n\n(* [flush_buffer_formatter buf ppf] flushes formatter [ppf],\n   then return the contents of buffer [buff] thst is reset.\n   Formatter [ppf] is supposed to print to buffer [buf], otherwise this\n   function is not really useful. *)\nlet flush_buffer_formatter buf ppf =\n  pp_flush_queue ppf false;\n  let s = Buffer.contents buf in\n  Buffer.reset buf;\n  s\n\n\n(* Flush [str_formatter] and get the contents of [stdbuf]. *)\nlet flush_str_formatter () = flush_buffer_formatter stdbuf str_formatter\n\n(*\n\n  Basic functions on the 'standard' formatter\n  (the formatter that prints to [Pervasives.stdout]).\n\n*)\n\nlet open_hbox = pp_open_hbox std_formatter\nand open_vbox = pp_open_vbox std_formatter\nand open_hvbox = pp_open_hvbox std_formatter\nand open_hovbox = pp_open_hovbox std_formatter\nand open_box = pp_open_box std_formatter\nand close_box = pp_close_box std_formatter\nand open_tag = pp_open_tag std_formatter\nand close_tag = pp_close_tag std_formatter\nand print_as = pp_print_as std_formatter\nand print_string = pp_print_string std_formatter\nand print_int = pp_print_int std_formatter\nand print_float = pp_print_float std_formatter\nand print_char = pp_print_char std_formatter\nand print_bool = pp_print_bool std_formatter\nand print_break = pp_print_break std_formatter\nand print_cut = pp_print_cut std_formatter\nand print_space = pp_print_space std_formatter\nand force_newline = pp_force_newline std_formatter\nand print_flush = pp_print_flush std_formatter\nand print_newline = pp_print_newline std_formatter\nand print_if_newline = pp_print_if_newline std_formatter\n\nand open_tbox = pp_open_tbox std_formatter\nand close_tbox = pp_close_tbox std_formatter\nand print_tbreak = pp_print_tbreak std_formatter\n\nand set_tab = pp_set_tab std_formatter\nand print_tab = pp_print_tab std_formatter\n\nand set_margin = pp_set_margin std_formatter\nand get_margin = pp_get_margin std_formatter\n\nand set_max_indent = pp_set_max_indent std_formatter\nand get_max_indent = pp_get_max_indent std_formatter\n\nand set_max_boxes = pp_set_max_boxes std_formatter\nand get_max_boxes = pp_get_max_boxes std_formatter\nand over_max_boxes = pp_over_max_boxes std_formatter\n\nand set_ellipsis_text = pp_set_ellipsis_text std_formatter\nand get_ellipsis_text = pp_get_ellipsis_text std_formatter\n\nand set_formatter_out_channel =\n  pp_set_formatter_out_channel std_formatter\n\nand set_formatter_out_functions =\n  pp_set_formatter_out_functions std_formatter\nand get_formatter_out_functions =\n  pp_get_formatter_out_functions std_formatter\n\nand set_formatter_output_functions =\n  pp_set_formatter_output_functions std_formatter\nand get_formatter_output_functions =\n  pp_get_formatter_output_functions std_formatter\n\nand set_formatter_tag_functions =\n  pp_set_formatter_tag_functions std_formatter\nand get_formatter_tag_functions =\n  pp_get_formatter_tag_functions std_formatter\nand set_print_tags =\n  pp_set_print_tags std_formatter\nand get_print_tags =\n  pp_get_print_tags std_formatter\nand set_mark_tags =\n  pp_set_mark_tags std_formatter\nand get_mark_tags =\n  pp_get_mark_tags std_formatter\nand set_tags =\n  pp_set_tags std_formatter\n\n\n(* Convenience functions *)\n\n(* To format a list *)\nlet rec pp_print_list ?(pp_sep = pp_print_cut) pp_v ppf = function\n  | [] -> ()\n  | [v] -> pp_v ppf v\n  | v :: vs ->\n    pp_v ppf v;\n    pp_sep ppf ();\n    pp_print_list ~pp_sep pp_v ppf vs\n\n(* To format free-flowing text *)\nlet pp_print_text ppf s =\n  let len = String.length s in\n  let left = ref 0 in\n  let right = ref 0 in\n  let flush () =\n    pp_print_string ppf (String.sub s !left (!right - !left));\n    incr right; left := !right;\n  in\n  while (!right <> len) do\n    match s.[!right] with\n      | '\\n' ->\n        flush ();\n        pp_force_newline ppf ()\n      | ' ' ->\n        flush (); pp_print_space ppf ()\n      (* there is no specific support for '\\t'\n         as it is unclear what a right semantics would be *)\n      | _ -> incr right\n  done;\n  if !left <> len then flush ()\n\n (**************************************************************)\n\nlet compute_tag output tag_acc =\n  let buf = Buffer.create 16 in\n  let ppf = formatter_of_buffer buf in\n  output ppf tag_acc;\n  pp_print_flush ppf ();\n  let len = Buffer.length buf in\n  if len < 2 then Buffer.contents buf\n  else Buffer.sub buf 1 (len - 2)\n\n (**************************************************************\n\n  Defining continuations to be passed as arguments of\n  CamlinternalFormat.make_printf.\n\n  **************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\n(* Interpret a formatting entity on a formatter. *)\nlet output_formatting_lit ppf fmting_lit = match fmting_lit with\n  | Close_box                 -> pp_close_box ppf ()\n  | Close_tag                 -> pp_close_tag ppf ()\n  | Break (_, width, offset)  -> pp_print_break ppf width offset\n  | FFlush                    -> pp_print_flush ppf ()\n  | Force_newline             -> pp_force_newline ppf ()\n  | Flush_newline             -> pp_print_newline ppf ()\n  | Magic_size (_, _)         -> ()\n  | Escaped_at                -> pp_print_char ppf '@'\n  | Escaped_percent           -> pp_print_char ppf '%'\n  | Scan_indic c              -> pp_print_char ppf '@'; pp_print_char ppf c\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in an output_stream. *)\n(* Differ from Printf.output_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec output_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (size_of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    output_acc ppf p;\n    pp_print_as_size ppf (size_of_int size) (String.make 1 c);\n  | Acc_formatting_lit (p, f) ->\n    output_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    output_acc ppf p;\n    pp_open_tag ppf (compute_tag output_acc acc')\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    output_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag output_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> output_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> output_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> output_acc ppf p; f ppf;\n  | Acc_flush p              -> output_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> output_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(* Recursively output an \"accumulator\" containing a reversed list of\n   printing entities (string, char, flus, ...) in a buffer. *)\n(* Differ from Printf.bufput_acc by the interpretation of formatting. *)\n(* Used as a continuation of CamlinternalFormat.make_printf. *)\nlet rec strput_acc ppf acc = match acc with\n  | Acc_string_literal (Acc_formatting_lit (p, Magic_size (_, size)), s)\n  | Acc_data_string (Acc_formatting_lit (p, Magic_size (_, size)), s) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (size_of_int size) s;\n  | Acc_char_literal (Acc_formatting_lit (p, Magic_size (_, size)), c)\n  | Acc_data_char (Acc_formatting_lit (p, Magic_size (_, size)), c) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (size_of_int size) (String.make 1 c);\n  | Acc_delay (Acc_formatting_lit (p, Magic_size (_, size)), f) ->\n    strput_acc ppf p;\n    pp_print_as_size ppf (size_of_int size) (f ());\n  | Acc_formatting_lit (p, f) ->\n    strput_acc ppf p;\n    output_formatting_lit ppf f;\n  | Acc_formatting_gen (p, Acc_open_tag acc') ->\n    strput_acc ppf p;\n    pp_open_tag ppf (compute_tag strput_acc acc')\n  | Acc_formatting_gen (p, Acc_open_box acc') ->\n    strput_acc ppf p;\n    let (indent, bty) = open_box_of_string (compute_tag strput_acc acc') in\n    pp_open_box_gen ppf indent bty\n  | Acc_string_literal (p, s)\n  | Acc_data_string (p, s)   -> strput_acc ppf p; pp_print_string ppf s;\n  | Acc_char_literal (p, c)\n  | Acc_data_char (p, c)     -> strput_acc ppf p; pp_print_char ppf c;\n  | Acc_delay (p, f)         -> strput_acc ppf p; pp_print_string ppf (f ());\n  | Acc_flush p              -> strput_acc ppf p; pp_print_flush ppf ();\n  | Acc_invalid_arg (p, msg) -> strput_acc ppf p; invalid_arg msg;\n  | End_of_acc               -> ()\n\n(*\n\n  Defining [fprintf] and various flavors of [fprintf].\n\n*)\n\nlet kfprintf k ppf (Format (fmt, _)) =\n  make_printf\n    (fun ppf acc -> output_acc ppf acc; k ppf)\n    ppf End_of_acc fmt\n\nand ikfprintf k ppf (Format (fmt, _)) =\n  make_iprintf k ppf fmt\n\nlet fprintf ppf = kfprintf ignore ppf\nlet ifprintf ppf = ikfprintf ignore ppf\nlet printf fmt = fprintf std_formatter fmt\nlet eprintf fmt = fprintf err_formatter fmt\n\nlet ksprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k () acc =\n    strput_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k () End_of_acc fmt\n\n\nlet sprintf fmt = ksprintf (fun s -> s) fmt\n\nlet kasprintf k (Format (fmt, _)) =\n  let b = pp_make_buffer () in\n  let ppf = formatter_of_buffer b in\n  let k ppf acc =\n    output_acc ppf acc;\n    k (flush_buffer_formatter b ppf) in\n  make_printf k ppf End_of_acc fmt\n\n\nlet asprintf fmt = kasprintf (fun s -> s) fmt\n\n(* Output everything left in the pretty printer queue at end of execution. *)\nlet () = at_exit print_flush\n\n\n(*\n\n  Deprecated stuff.\n\n*)\n\n(* Deprecated : subsumed by pp_set_formatter_out_functions *)\nlet pp_set_all_formatter_output_functions state\n    ~out:f ~flush:g ~newline:h ~spaces:i =\n  pp_set_formatter_output_functions state f g;\n  state.pp_out_newline <- h;\n  state.pp_out_spaces <- i\n\n\n(* Deprecated : subsumed by pp_get_formatter_out_functions *)\nlet pp_get_all_formatter_output_functions state () =\n  (state.pp_out_string, state.pp_out_flush,\n   state.pp_out_newline, state.pp_out_spaces)\n\n\n(* Deprecated : subsumed by set_formatter_out_functions *)\nlet set_all_formatter_output_functions =\n  pp_set_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : subsumed by get_formatter_out_functions *)\nlet get_all_formatter_output_functions =\n  pp_get_all_formatter_output_functions std_formatter\n\n\n(* Deprecated : error prone function, do not use it.\n   Define a formatter of your own writing to the buffer,\n   as in\n   let ppf = formatter_of_buffer b\n   then use {!fprintf ppf} as useual. *)\nlet bprintf b (Format (fmt, _) : ('a, formatter, unit) format) =\n  let k ppf acc = output_acc ppf acc; pp_flush_queue ppf false in\n  make_printf k (formatter_of_buffer b) End_of_acc fmt\n\n\n(* Deprecated : alias for ksprintf. *)\nlet kprintf = ksprintf\n","type asts =\n  | REI (\n      Migrate_parsetree.Ast_404.Parsetree.signature,\n      Reason_pprint_ast.commentWithCategory\n    )\n  | RE (\n      Migrate_parsetree.Ast_404.Parsetree.structure,\n      Reason_pprint_ast.commentWithCategory\n    )\n  | ML (\n      Migrate_parsetree.Ast_404.Parsetree.structure,\n      Reason_pprint_ast.commentWithCategory\n    )\n  | MLI (\n      Migrate_parsetree.Ast_404.Parsetree.signature,\n      Reason_pprint_ast.commentWithCategory\n    );\n\ntype parseResult =\n  | Ast asts\n  | Error exn;\n\ntype language =\n  | ML\n  | RE\n  | UnknownLang;\n\nlet languageOfString str =>\n  switch str {\n  | \"ML\" => ML\n  | \"RE\" => RE\n  | _ => UnknownLang\n  };\n\nlet stringOfLanguage lang =>\n  switch lang {\n  | ML => \"ML\"\n  | RE => \"RE\"\n  | UnknownLang => \"Unkown\"\n  };\n\ntype codeType =\n  | Implementation\n  | Interface\n  | UnknownType;\n\nlet typeOfString str =>\n  switch str {\n  | \"implementation\" => Implementation\n  | \"interface\" => Interface\n  | _ => UnknownType\n  };\n\nlet string_of_code printer code => {\n  ignore (Format.flush_str_formatter ());\n  let f = Format.str_formatter;\n  printer f code;\n  Format.flush_str_formatter ()\n};\n\nlet parseRE code =>\n  Ast (\n    RE (\n      Reason_toolchain.JS.canonical_implementation_with_comments (\n        Lexing.from_string code\n      )\n    )\n  );\n\nlet parseML code =>\n  Ast (\n    ML (\n      Reason_toolchain.ML.canonical_implementation_with_comments (\n        Lexing.from_string code\n      )\n    )\n  );\n\nlet parseREI code =>\n  Ast (\n    REI (\n      Reason_toolchain.JS.canonical_interface_with_comments (\n        Lexing.from_string code\n      )\n    )\n  );\n\nlet parseMLI code =>\n  Ast (\n    MLI (\n      Reason_toolchain.ML.canonical_interface_with_comments (\n        Lexing.from_string code\n      )\n    )\n  );\n\nlet printML implementation =>\n  string_of_code\n    Reason_toolchain.ML.print_canonical_implementation_with_comments\n    implementation;\n\nlet printMLI signature =>\n  string_of_code\n    Reason_toolchain.ML.print_canonical_interface_with_comments signature;\n\nlet printRE =\n  string_of_code Reason_toolchain.JS.print_canonical_implementation_with_comments;\n\nlet printREI =\n  string_of_code Reason_toolchain.JS.print_canonical_interface_with_comments;\n\n/* |>   */\nlet (>!) (loc1: Location.t) (loc2: Location.t) => {\n  let (_, line1, col1) = Location.get_pos_info loc1.loc_start;\n  let (_, line2, col2) = Location.get_pos_info loc2.loc_start;\n  line1 === line2 ? col1 > col2 : line1 > line2\n};\n\nlet genErrors errors => {\n  let error =\n    List.fold_left\n      (\n        fun ((prevLoc, _, _) as prev) error => {\n          let (optionLoc, _, _) as curr =\n            switch error {\n            | Syntaxerr.Error error =>\n              /* ML */\n              let loc = Syntaxerr.location_of_error error;\n              let error = string_of_code Syntaxerr.report_error error;\n              (Some loc, error, ML)\n            | Syntax_util.Error loc error =>\n              /* RE */\n              let error = string_of_code Syntax_util.report_error error;\n              (Some loc, error, RE)\n            | finalExn => (None, Printexc.to_string finalExn, UnknownLang)\n            };\n          switch (optionLoc, prevLoc) {\n          | (Some loc, Some prevLoc) => loc >! prevLoc ? curr : prev\n          | (Some _, None) => curr\n          | _ => prev\n          }\n        }\n      )\n      (None, \"\", UnknownLang)\n      errors;\n  switch error {\n  | (None, message, inLang) => (inLang, UnknownLang, message)\n  /* Reason error message printer doesn't include location, ML does */\n  | (Some loc, message, inLang) when inLang == RE => (\n      inLang,\n      UnknownLang,\n      string_of_code Location.print_loc loc ^ \":\\n\" ^ message\n    )\n  | (_, message, inLang) => (inLang, UnknownLang, message)\n  }\n};\n\nlet attempts inLang inType =>\n  switch (inLang, inType) {\n  | (ML, Implementation) => [parseML]\n  | (ML, Interface) => [parseMLI]\n  | (RE, Implementation) => [parseRE]\n  | (RE, Interface) => [parseREI]\n  | (UnknownLang, Implementation) => [parseML, parseRE]\n  | (UnknownLang, Interface) => [parseMLI, parseREI]\n  | (ML, UnknownType) => [parseML, parseMLI]\n  | (RE, UnknownType) => [parseRE, parseREI]\n  | (UnknownLang, UnknownType) => [parseML, parseRE, parseMLI, parseREI]\n  };\n\nlet refmt code inLang inType outLang => {\n  let parsersToTry = attempts inLang inType;\n  let results =\n    List.map\n      (\n        fun parser =>\n          try {\n            let a = parser code;\n            a\n          } {\n          | exn => Error exn\n          }\n      )\n      parsersToTry;\n  try {\n    let result =\n      List.find\n        (\n          fun res =>\n            switch res {\n            | Error _ => false\n            | _ => true\n            }\n        )\n        results;\n    let (trueOut, printedResult) =\n      switch (outLang, result) {\n      | (RE, Ast (ML ast))\n      | (RE, Ast (RE ast))\n      | (UnknownLang, Ast (ML ast)) => (RE, printRE ast)\n      | (ML, Ast (ML ast))\n      | (ML, Ast (RE ast))\n      | (UnknownLang, Ast (RE ast)) => (ML, printML ast)\n      | (RE, Ast (MLI ast))\n      | (RE, Ast (REI ast))\n      | (UnknownLang, Ast (MLI ast)) => (RE, printREI ast)\n      | (ML, Ast (MLI ast))\n      | (ML, Ast (REI ast))\n      | (UnknownLang, Ast (REI ast)) => (ML, printMLI ast)\n      | _ => (UnknownLang, \"could not transform\")\n      };\n    let trueIn =\n      switch result {\n      | Ast (ML _)\n      | Ast (MLI _) => ML\n      | Ast (RE _)\n      | Ast (REI _) => RE\n      | _ => UnknownLang\n      };\n    (trueIn, trueOut, printedResult)\n  } {\n  | exn =>\n    let fold =\n      List.fold_left\n        (\n          fun acc res =>\n            switch res {\n            | Error err => [err, ...acc]\n            | _ => acc\n            }\n        )\n        [];\n    results |> fold |> genErrors\n  }\n};\n\nlet refmtJS jsString inLang inType outLang => {\n  let (trueIn, trueOut, s) =\n    refmt\n      (Js.to_string jsString)\n      (languageOfString (Js.to_string inLang))\n      (typeOfString (Js.to_string inType))\n      (languageOfString (Js.to_string outLang));\n  Js.array [|\n    Js.string (stringOfLanguage trueIn ^ \"to\" ^ stringOfLanguage trueOut),\n    Js.string s\n  |]\n};\n\nJs.export \"refmt\" refmtJS;\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Pierre Weis, projet Cristal, INRIA Rocquencourt            *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen CamlinternalFormatBasics\nopen CamlinternalFormat\n\n(* alias to avoid warning for ambiguity between\n   Pervasives.format6\n   and CamlinternalFormatBasics.format6\n\n   (the former is in fact an alias for the latter,\n    but the ambiguity warning doesn't care)\n*)\ntype ('a, 'b, 'c, 'd, 'e, 'f) format6 =\n  ('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6\n\n\n(* The run-time library for scanners. *)\n\n(* Scanning buffers. *)\nmodule type SCANNING = sig\n\n  type in_channel\n\n  type scanbuf = in_channel\n\n  type file_name = string\n\n  val stdin : in_channel\n  (* The scanning buffer reading from [Pervasives.stdin].\n     [stdib] is equivalent to [Scanning.from_channel Pervasives.stdin]. *)\n\n  val stdib : in_channel\n  (* An alias for [Scanf.stdin], the scanning buffer reading from\n     [Pervasives.stdin]. *)\n\n  val next_char : scanbuf -> char\n  (* [Scanning.next_char ib] advance the scanning buffer for\n     one character.\n     If no more character can be read, sets a end of file condition and\n     returns '\\000'. *)\n\n  val invalidate_current_char : scanbuf -> unit\n  (* [Scanning.invalidate_current_char ib] mark the current_char as already\n     scanned. *)\n\n  val peek_char : scanbuf -> char\n  (* [Scanning.peek_char ib] returns the current char available in\n     the buffer or reads one if necessary (when the current character is\n     already scanned).\n     If no character can be read, sets an end of file condition and\n     returns '\\000'. *)\n\n  val checked_peek_char : scanbuf -> char\n  (* Same as [Scanning.peek_char] above but always returns a valid char or\n     fails: instead of returning a null char when the reading method of the\n     input buffer has reached an end of file, the function raises exception\n     [End_of_file]. *)\n\n  val store_char : int -> scanbuf -> char -> int\n  (* [Scanning.store_char lim ib c] adds [c] to the token buffer\n     of the scanning buffer [ib]. It also advances the scanning buffer for\n     one character and returns [lim - 1], indicating the new limit for the\n     length of the current token. *)\n\n  val skip_char : int -> scanbuf -> int\n  (* [Scanning.skip_char lim ib] ignores the current character. *)\n\n  val ignore_char : int -> scanbuf -> int\n  (* [Scanning.ignore_char ib lim] ignores the current character and\n     decrements the limit. *)\n\n  val token : scanbuf -> string\n  (* [Scanning.token ib] returns the string stored into the token\n     buffer of the scanning buffer: it returns the token matched by the\n     format. *)\n\n  val reset_token : scanbuf -> unit\n  (* [Scanning.reset_token ib] resets the token buffer of\n     the given scanning buffer. *)\n\n  val char_count : scanbuf -> int\n  (* [Scanning.char_count ib] returns the number of characters\n     read so far from the given buffer. *)\n\n  val line_count : scanbuf -> int\n  (* [Scanning.line_count ib] returns the number of new line\n     characters read so far from the given buffer. *)\n\n  val token_count : scanbuf -> int\n  (* [Scanning.token_count ib] returns the number of tokens read\n     so far from [ib]. *)\n\n  val eof : scanbuf -> bool\n  (* [Scanning.eof ib] returns the end of input condition\n     of the given buffer. *)\n\n  val end_of_input : scanbuf -> bool\n  (* [Scanning.end_of_input ib] tests the end of input condition\n     of the given buffer (if no char has ever been read, an attempt to\n     read one is performed). *)\n\n  val beginning_of_input : scanbuf -> bool\n  (* [Scanning.beginning_of_input ib] tests the beginning of input\n     condition of the given buffer. *)\n\n  val name_of_input : scanbuf -> string\n  (* [Scanning.name_of_input ib] returns the name of the character\n     source for input buffer [ib]. *)\n\n  val open_in : file_name -> in_channel\n  val open_in_bin : file_name -> in_channel\n  val from_file : file_name -> in_channel\n  val from_file_bin : file_name -> in_channel\n  val from_string : string -> in_channel\n  val from_function : (unit -> char) -> in_channel\n  val from_channel : Pervasives.in_channel -> in_channel\n\n  val close_in : in_channel -> unit\n\n  val memo_from_channel : Pervasives.in_channel -> in_channel\n  (* Obsolete. *)\n\nend\n\n\nmodule Scanning : SCANNING = struct\n\n  (* The run-time library for scanf. *)\n\n  type file_name = string\n\n  type in_channel_name =\n    | From_channel of Pervasives.in_channel\n    | From_file of file_name * Pervasives.in_channel\n    | From_function\n    | From_string\n\n\n  type in_channel = {\n    mutable ic_eof : bool;\n    mutable ic_current_char : char;\n    mutable ic_current_char_is_valid : bool;\n    mutable ic_char_count : int;\n    mutable ic_line_count : int;\n    mutable ic_token_count : int;\n    mutable ic_get_next_char : unit -> char;\n    ic_token_buffer : Buffer.t;\n    ic_input_name : in_channel_name;\n  }\n\n\n  type scanbuf = in_channel\n\n  let null_char = '\\000'\n\n  (* Reads a new character from input buffer.\n     Next_char never fails, even in case of end of input:\n     it then simply sets the end of file condition. *)\n  let next_char ib =\n    try\n      let c = ib.ic_get_next_char () in\n      ib.ic_current_char <- c;\n      ib.ic_current_char_is_valid <- true;\n      ib.ic_char_count <- succ ib.ic_char_count;\n      if c = '\\n' then ib.ic_line_count <- succ ib.ic_line_count;\n      c with\n    | End_of_file ->\n      let c = null_char in\n      ib.ic_current_char <- c;\n      ib.ic_current_char_is_valid <- false;\n      ib.ic_eof <- true;\n      c\n\n\n  let peek_char ib =\n    if ib.ic_current_char_is_valid\n    then ib.ic_current_char\n    else next_char ib\n\n\n  (* Returns a valid current char for the input buffer. In particular\n     no irrelevant null character (as set by [next_char] in case of end\n     of input) is returned, since [End_of_file] is raised when\n     [next_char] sets the end of file condition while trying to read a\n     new character. *)\n  let checked_peek_char ib =\n    let c = peek_char ib in\n    if ib.ic_eof then raise End_of_file;\n    c\n\n\n  let end_of_input ib =\n    ignore (peek_char ib);\n    ib.ic_eof\n\n\n  let eof ib = ib.ic_eof\n\n  let beginning_of_input ib = ib.ic_char_count = 0\n\n  let name_of_input ib =\n    match ib.ic_input_name with\n    | From_channel _ic -> \"unnamed Pervasives input channel\"\n    | From_file (fname, _ic) -> fname\n    | From_function -> \"unnamed function\"\n    | From_string -> \"unnamed character string\"\n\n\n  let char_count ib =\n    if ib.ic_current_char_is_valid\n    then ib.ic_char_count - 1\n    else ib.ic_char_count\n\n\n  let line_count ib = ib.ic_line_count\n\n  let reset_token ib = Buffer.reset ib.ic_token_buffer\n\n  let invalidate_current_char ib = ib.ic_current_char_is_valid <- false\n\n  let token ib =\n    let token_buffer = ib.ic_token_buffer in\n    let tok = Buffer.contents token_buffer in\n    Buffer.clear token_buffer;\n    ib.ic_token_count <- succ ib.ic_token_count;\n    tok\n\n\n  let token_count ib = ib.ic_token_count\n\n  let skip_char width ib =\n    invalidate_current_char ib;\n    width\n\n\n  let ignore_char width ib = skip_char (width - 1) ib\n\n  let store_char width ib c =\n    Buffer.add_char ib.ic_token_buffer c;\n    ignore_char width ib\n\n\n  let default_token_buffer_size = 1024\n\n  let create iname next = {\n    ic_eof = false;\n    ic_current_char = null_char;\n    ic_current_char_is_valid = false;\n    ic_char_count = 0;\n    ic_line_count = 0;\n    ic_token_count = 0;\n    ic_get_next_char = next;\n    ic_token_buffer = Buffer.create default_token_buffer_size;\n    ic_input_name = iname;\n  }\n\n\n  let from_string s =\n    let i = ref 0 in\n    let len = String.length s in\n    let next () =\n      if !i >= len then raise End_of_file else\n      let c = s.[!i] in\n      incr i;\n      c in\n    create From_string next\n\n\n  let from_function = create From_function\n\n  (* Scanning from an input channel. *)\n\n  (* Position of the problem:\n\n     We cannot prevent the scanning mechanism to use one lookahead character,\n     if needed by the semantics of the format string specifications (e.g. a\n     trailing 'skip space' specification in the format string); in this case,\n     the mandatory lookahead character is indeed read from the input and not\n     used to return the token read. It is thus mandatory to be able to store\n     an unused lookahead character somewhere to get it as the first character\n     of the next scan.\n\n     To circumvent this problem, all the scanning functions get a low level\n     input buffer argument where they store the lookahead character when\n     needed; additionally, the input buffer is the only source of character of\n     a scanner. The [scanbuf] input buffers are defined in module {!Scanning}.\n\n     Now we understand that it is extremely important that related and\n     successive calls to scanners indeed read from the same input buffer.\n     In effect, if a scanner [scan1] is reading from [ib1] and stores an\n     unused lookahead character [c1] into its input buffer [ib1], then\n     another scanner [scan2] not reading from the same buffer [ib1] will miss\n     the character [c1], seemingly vanished in the air from the point of view\n     of [scan2].\n\n     This mechanism works perfectly to read from strings, from files, and from\n     functions, since in those cases, allocating two buffers reading from the\n     same source is unnatural.\n\n     Still, there is a difficulty in the case of scanning from an input\n     channel. In effect, when scanning from an input channel [ic], this channel\n     may not have been allocated from within this library. Hence, it may be\n     shared (two functions of the user's program may successively read from\n     [ic]). This is highly error prone since, one of the function may seek the\n     input channel, while the other function has still an unused lookahead\n     character in its input buffer. In conclusion, you should never mix direct\n     low level reading and high level scanning from the same input channel.\n\n  *)\n\n  (* Perform bufferized input to improve efficiency. *)\n  let file_buffer_size = ref 1024\n\n  (* The scanner closes the input channel at end of input. *)\n  let scan_close_at_end ic = Pervasives.close_in ic; raise End_of_file\n\n  (* The scanner does not close the input channel at end of input:\n     it just raises [End_of_file]. *)\n  let scan_raise_at_end _ic = raise End_of_file\n\n  let from_ic scan_close_ic iname ic =\n    let len = !file_buffer_size in\n    let buf = Bytes.create len in\n    let i = ref 0 in\n    let lim = ref 0 in\n    let eof = ref false in\n    let next () =\n      if !i < !lim then begin let c = Bytes.get buf !i in incr i; c end else\n      if !eof then raise End_of_file else begin\n        lim := input ic buf 0 len;\n        if !lim = 0 then begin eof := true; scan_close_ic ic end else begin\n          i := 1;\n          Bytes.get buf 0\n        end\n      end in\n    create iname next\n\n\n  let from_ic_close_at_end = from_ic scan_close_at_end\n  let from_ic_raise_at_end = from_ic scan_raise_at_end\n\n  (* The scanning buffer reading from [Pervasives.stdin].\n     One could try to define [stdib] as a scanning buffer reading a character\n     at a time (no bufferization at all), but unfortunately the top-level\n     interaction would be wrong. This is due to some kind of\n     'race condition' when reading from [Pervasives.stdin],\n     since the interactive compiler and [Scanf.scanf] will simultaneously\n     read the material they need from [Pervasives.stdin]; then, confusion\n     will result from what should be read by the top-level and what should be\n     read by [Scanf.scanf].\n     This is even more complicated by the one character lookahead that\n     [Scanf.scanf] is sometimes obliged to maintain: the lookahead character\n     will be available for the next [Scanf.scanf] entry, seemingly coming from\n     nowhere.\n     Also no [End_of_file] is raised when reading from stdin: if not enough\n     characters have been read, we simply ask to read more. *)\n  let stdin =\n    from_ic scan_raise_at_end\n      (From_file (\"-\", Pervasives.stdin)) Pervasives.stdin\n\n\n  let stdib = stdin\n\n  let open_in_file open_in fname =\n    match fname with\n    | \"-\" -> stdin\n    | fname ->\n      let ic = open_in fname in\n      from_ic_close_at_end (From_file (fname, ic)) ic\n\n\n  let open_in = open_in_file Pervasives.open_in\n  let open_in_bin = open_in_file Pervasives.open_in_bin\n\n  let from_file = open_in\n  let from_file_bin = open_in_bin\n\n  let from_channel ic =\n    from_ic_raise_at_end (From_channel ic) ic\n\n\n  let close_in ib =\n    match ib.ic_input_name with\n    | From_channel ic ->\n      Pervasives.close_in ic\n    | From_file (_fname, ic) -> Pervasives.close_in ic\n    | From_function | From_string -> ()\n\n\n  (*\n     Obsolete: a memo [from_channel] version to build a [Scanning.in_channel]\n     scanning buffer out of a [Pervasives.in_channel].\n     This function was used to try to preserve the scanning\n     semantics for the (now obsolete) function [fscanf].\n     Given that all scanner must read from a [Scanning.in_channel] scanning\n     buffer, [fscanf] must read from one!\n     More precisely, given [ic], all successive calls [fscanf ic] must read\n     from the same scanning buffer.\n     This obliged this library to allocated scanning buffers that were\n     not properly garbbage collectable, hence leading to memory leaks.\n     If you need to read from a [Pervasives.in_channel] input channel\n     [ic], simply define a [Scanning.in_channel] formatted input channel as in\n     [let ib = Scanning.from_channel ic], then use [Scanf.bscanf ib] as usual.\n  *)\n  let memo_from_ic =\n    let memo = ref [] in\n    (fun scan_close_ic ic ->\n     try List.assq ic !memo with\n     | Not_found ->\n       let ib =\n         from_ic scan_close_ic (From_channel ic) ic in\n       memo := (ic, ib) :: !memo;\n       ib)\n\n\n  (* Obsolete: see {!memo_from_ic} above. *)\n  let memo_from_channel = memo_from_ic scan_raise_at_end\n\nend\n\n\n(* Formatted input functions. *)\n\ntype ('a, 'b, 'c, 'd) scanner =\n     ('a, Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c\n\n\n(* Reporting errors. *)\nexception Scan_failure of string\n\nlet bad_input s = raise (Scan_failure s)\n\nlet bad_input_escape c =\n  bad_input (Printf.sprintf \"illegal escape character %C\" c)\n\n\nlet bad_token_length message =\n  bad_input\n    (Printf.sprintf\n       \"scanning of %s failed: \\\n        the specified length was too short for token\"\n       message)\n\n\nlet bad_end_of_input message =\n  bad_input\n    (Printf.sprintf\n       \"scanning of %s failed: \\\n        premature end of file occurred before end of token\"\n       message)\n\n\nlet bad_float () =\n  bad_input \"no dot or exponent part found in float token\"\n\n\nlet bad_hex_float () =\n  bad_input \"not a valid float in hexadecimal notation\"\n\n\nlet character_mismatch_err c ci =\n  Printf.sprintf \"looking for %C, found %C\" c ci\n\n\nlet character_mismatch c ci =\n  bad_input (character_mismatch_err c ci)\n\n\nlet rec skip_whites ib =\n  let c = Scanning.peek_char ib in\n  if not (Scanning.eof ib) then begin\n    match c with\n    | ' ' | '\\t' | '\\n' | '\\r' ->\n      Scanning.invalidate_current_char ib; skip_whites ib\n    | _ -> ()\n  end\n\n\n(* Checking that [c] is indeed in the input, then skips it.\n   In this case, the character [c] has been explicitly specified in the\n   format as being mandatory in the input; hence we should fail with\n   [End_of_file] in case of end_of_input.\n   (Remember that [Scan_failure] is raised only when (we can prove by\n   evidence) that the input does not match the format string given. We must\n   thus differentiate [End_of_file] as an error due to lack of input, and\n   [Scan_failure] which is due to provably wrong input. I am not sure this is\n   worth the burden: it is complex and somehow subliminal; should be clearer\n   to fail with Scan_failure \"Not enough input to complete scanning\"!)\n\n   That's why, waiting for a better solution, we use checked_peek_char here.\n   We are also careful to treat \"\\r\\n\" in the input as an end of line marker:\n   it always matches a '\\n' specification in the input format string. *)\nlet rec check_char ib c =\n  match c with\n  | ' ' -> skip_whites ib\n  | '\\n' -> check_newline ib\n  | c -> check_this_char ib c\n\nand check_this_char ib c =\n  let ci = Scanning.checked_peek_char ib in\n  if ci = c then Scanning.invalidate_current_char ib else\n  character_mismatch c ci\n\nand check_newline ib =\n  let ci = Scanning.checked_peek_char ib in\n  match ci with\n  | '\\n' -> Scanning.invalidate_current_char ib\n  | '\\r' -> Scanning.invalidate_current_char ib; check_this_char ib '\\n'\n  | _ -> character_mismatch '\\n' ci\n\n\n(* Extracting tokens from the output token buffer. *)\n\nlet token_char ib = (Scanning.token ib).[0]\n\nlet token_string = Scanning.token\n\nlet token_bool ib =\n  match Scanning.token ib with\n  | \"true\" -> true\n  | \"false\" -> false\n  | s -> bad_input (Printf.sprintf \"invalid boolean '%s'\" s)\n\n\n(* The type of integer conversions. *)\ntype integer_conversion =\n  | B_conversion (* Unsigned binary conversion *)\n  | D_conversion (* Signed decimal conversion *)\n  | I_conversion (* Signed integer conversion *)\n  | O_conversion (* Unsigned octal conversion *)\n  | U_conversion (* Unsigned decimal conversion *)\n  | X_conversion (* Unsigned hexadecimal conversion *)\n\n\nlet integer_conversion_of_char = function\n  | 'b' -> B_conversion\n  | 'd' -> D_conversion\n  | 'i' -> I_conversion\n  | 'o' -> O_conversion\n  | 'u' -> U_conversion\n  | 'x' | 'X' -> X_conversion\n  | _ -> assert false\n\n\n(* Extract an integer literal token.\n   Since the functions Pervasives.*int*_of_string do not accept a leading +,\n   we skip it if necessary. *)\nlet token_int_literal conv ib =\n  let tok =\n    match conv with\n    | D_conversion | I_conversion -> Scanning.token ib\n    | U_conversion -> \"0u\" ^ Scanning.token ib\n    | O_conversion -> \"0o\" ^ Scanning.token ib\n    | X_conversion -> \"0x\" ^ Scanning.token ib\n    | B_conversion -> \"0b\" ^ Scanning.token ib in\n  let l = String.length tok in\n  if l = 0 || tok.[0] <> '+' then tok else String.sub tok 1 (l - 1)\n\n\n(* All the functions that convert a string to a number raise the exception\n   Failure when the conversion is not possible.\n   This exception is then trapped in [kscanf]. *)\nlet token_int conv ib = int_of_string (token_int_literal conv ib)\n\nlet token_float ib = float_of_string (Scanning.token ib)\n\n(* To scan native ints, int32 and int64 integers.\n   We cannot access to conversions to/from strings for those types,\n   Nativeint.of_string, Int32.of_string, and Int64.of_string,\n   since those modules are not available to [Scanf].\n   However, we can bind and use the corresponding primitives that are\n   available in the runtime. *)\nexternal nativeint_of_string : string -> nativeint\n  = \"caml_nativeint_of_string\"\n\nexternal int32_of_string : string -> int32\n  = \"caml_int32_of_string\"\n\nexternal int64_of_string : string -> int64\n  = \"caml_int64_of_string\"\n\n\nlet token_nativeint conv ib = nativeint_of_string (token_int_literal conv ib)\nlet token_int32 conv ib = int32_of_string (token_int_literal conv ib)\nlet token_int64 conv ib = int64_of_string (token_int_literal conv ib)\n\n(* Scanning numbers. *)\n\n(* Digits scanning functions suppose that one character has been checked and\n   is available, since they return at end of file with the currently found\n   token selected.\n\n   Put it in another way, the digits scanning functions scan for a possibly\n   empty sequence of digits, (hence, a successful scanning from one of those\n   functions does not imply that the token is a well-formed number: to get a\n   true number, it is mandatory to check that at least one valid digit is\n   available before calling one of the digit scanning functions). *)\n\n(* The decimal case is treated especially for optimization purposes. *)\nlet rec scan_decimal_digit_star width ib =\n  if width = 0 then width else\n  let c = Scanning.peek_char ib in\n  if Scanning.eof ib then width else\n  match c with\n  | '0' .. '9' as c ->\n    let width = Scanning.store_char width ib c in\n    scan_decimal_digit_star width ib\n  | '_' ->\n    let width = Scanning.ignore_char width ib in\n    scan_decimal_digit_star width ib\n  | _ -> width\n\n\nlet scan_decimal_digit_plus width ib =\n  if width = 0 then bad_token_length \"decimal digits\" else\n  let c = Scanning.checked_peek_char ib in\n  match c with\n  | '0' .. '9' ->\n    let width = Scanning.store_char width ib c in\n    scan_decimal_digit_star width ib\n  | c ->\n    bad_input (Printf.sprintf \"character %C is not a decimal digit\" c)\n\n\n(* To scan numbers from other bases, we use a predicate argument to\n   scan digits. *)\nlet scan_digit_star digitp width ib =\n  let rec scan_digits width ib =\n    if width = 0 then width else\n    let c = Scanning.peek_char ib in\n    if Scanning.eof ib then width else\n    match c with\n    | c when digitp c ->\n      let width = Scanning.store_char width ib c in\n      scan_digits width ib\n    | '_' ->\n      let width = Scanning.ignore_char width ib in\n      scan_digits width ib\n    | _ -> width in\n  scan_digits width ib\n\n\nlet scan_digit_plus basis digitp width ib =\n  (* Ensure we have got enough width left,\n     and read at list one digit. *)\n  if width = 0 then bad_token_length \"digits\" else\n  let c = Scanning.checked_peek_char ib in\n  if digitp c then\n    let width = Scanning.store_char width ib c in\n    scan_digit_star digitp width ib\n  else\n    bad_input (Printf.sprintf \"character %C is not a valid %s digit\" c basis)\n\n\nlet is_binary_digit = function\n  | '0' .. '1' -> true\n  | _ -> false\n\n\nlet scan_binary_int = scan_digit_plus \"binary\" is_binary_digit\n\nlet is_octal_digit = function\n  | '0' .. '7' -> true\n  | _ -> false\n\n\nlet scan_octal_int = scan_digit_plus \"octal\" is_octal_digit\n\nlet is_hexa_digit = function\n  | '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' -> true\n  | _ -> false\n\n\nlet scan_hexadecimal_int = scan_digit_plus \"hexadecimal\" is_hexa_digit\n\n(* Scan a decimal integer. *)\nlet scan_unsigned_decimal_int = scan_decimal_digit_plus\n\nlet scan_sign width ib =\n  let c = Scanning.checked_peek_char ib in\n  match c with\n  | '+' -> Scanning.store_char width ib c\n  | '-' -> Scanning.store_char width ib c\n  | _ -> width\n\n\nlet scan_optionally_signed_decimal_int width ib =\n  let width = scan_sign width ib in\n  scan_unsigned_decimal_int width ib\n\n\n(* Scan an unsigned integer that could be given in any (common) basis.\n   If digits are prefixed by one of 0x, 0X, 0o, or 0b, the number is\n   assumed to be written respectively in hexadecimal, hexadecimal,\n   octal, or binary. *)\nlet scan_unsigned_int width ib =\n  match Scanning.checked_peek_char ib with\n  | '0' as c ->\n    let width = Scanning.store_char width ib c in\n    if width = 0 then width else\n    let c = Scanning.peek_char ib in\n    if Scanning.eof ib then width else\n    begin match c with\n    | 'x' | 'X' -> scan_hexadecimal_int (Scanning.store_char width ib c) ib\n    | 'o' -> scan_octal_int (Scanning.store_char width ib c) ib\n    | 'b' -> scan_binary_int (Scanning.store_char width ib c) ib\n    | _ -> scan_decimal_digit_star width ib end\n  | _ -> scan_unsigned_decimal_int width ib\n\n\nlet scan_optionally_signed_int width ib =\n  let width = scan_sign width ib in\n  scan_unsigned_int width ib\n\n\nlet scan_int_conversion conv width ib =\n  match conv with\n  | B_conversion -> scan_binary_int width ib\n  | D_conversion -> scan_optionally_signed_decimal_int width ib\n  | I_conversion -> scan_optionally_signed_int width ib\n  | O_conversion -> scan_octal_int width ib\n  | U_conversion -> scan_unsigned_decimal_int width ib\n  | X_conversion -> scan_hexadecimal_int width ib\n\n\n(* Scanning floating point numbers. *)\n\n(* Fractional part is optional and can be reduced to 0 digits. *)\nlet scan_fractional_part width ib =\n  if width = 0 then width else\n  let c = Scanning.peek_char ib in\n  if Scanning.eof ib then width else\n  match c with\n  | '0' .. '9' as c ->\n    scan_decimal_digit_star (Scanning.store_char width ib c) ib\n  | _ -> width\n\n\n(* Exp part is optional and can be reduced to 0 digits. *)\nlet scan_exponent_part width ib =\n  if width = 0 then width else\n  let c = Scanning.peek_char ib in\n  if Scanning.eof ib then width else\n  match c with\n  | 'e' | 'E' as c ->\n    scan_optionally_signed_decimal_int (Scanning.store_char width ib c) ib\n  | _ -> width\n\n\n(* Scan the integer part of a floating point number, (not using the\n   OCaml lexical convention since the integer part can be empty):\n   an optional sign, followed by a possibly empty sequence of decimal\n   digits (e.g. -.1). *)\nlet scan_integer_part width ib =\n  let width = scan_sign width ib in\n  scan_decimal_digit_star width ib\n\n\n(*\n   For the time being we have (as found in scanf.mli):\n   the field width is composed of an optional integer literal\n   indicating the maximal width of the token to read.\n   Unfortunately, the type-checker let the user write an optional precision,\n   since this is valid for printf format strings.\n\n   Thus, the next step for Scanf is to support a full width and precision\n   indication, more or less similar to the one for printf, possibly extended\n   to the specification of a [max, min] range for the width of the token read\n   for strings. Something like the following spec for scanf.mli:\n\n   The optional [width] is an integer indicating the maximal\n   width of the token read. For instance, [%6d] reads an integer,\n   having at most 6 characters.\n\n   The optional [precision] is a dot [.] followed by an integer:\n\n   - in the floating point number conversions ([%f], [%e], [%g], [%F], [%E],\n   and [%F] conversions, the [precision] indicates the maximum number of\n   digits that may follow the decimal point. For instance, [%.4f] reads a\n   [float] with at most 4 fractional digits,\n\n   - in the string conversions ([%s], [%S], [%\\[ range \\]]), and in the\n   integer number conversions ([%i], [%d], [%u], [%x], [%o], and their\n   [int32], [int64], and [native_int] correspondent), the [precision]\n   indicates the required minimum width of the token read,\n\n   - on all other conversions, the width and precision specify the [max, min]\n   range for the width of the token read.\n*)\nlet scan_float width precision ib =\n  let width = scan_integer_part width ib in\n  if width = 0 then width, precision else\n  let c = Scanning.peek_char ib in\n  if Scanning.eof ib then width, precision else\n  match c with\n  | '.' ->\n    let width = Scanning.store_char width ib c in\n    let precision = min width precision in\n    let width = width - (precision - scan_fractional_part precision ib) in\n    scan_exponent_part width ib, precision\n  | _ ->\n    scan_exponent_part width ib, precision\n\n\nlet check_case_insensitive_string width ib error str =\n  let lowercase c =\n    match c with\n    | 'A' .. 'Z' ->\n      char_of_int (int_of_char c - int_of_char 'A' + int_of_char 'a')\n    | _ -> c in\n  let len = String.length str in\n  let width = ref width in\n  for i = 0 to len - 1 do\n    let c = Scanning.peek_char ib in\n    if lowercase c <> lowercase str.[i] then error ();\n    if !width = 0 then error ();\n    width := Scanning.store_char !width ib c;\n  done;\n  !width\n\n\nlet scan_hex_float width precision ib =\n  if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n  let width = scan_sign width ib in\n  if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n  match Scanning.peek_char ib with\n  | '0' as c -> (\n    let width = Scanning.store_char width ib c in\n    if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n    let width = check_case_insensitive_string width ib bad_hex_float \"x\" in\n    if width = 0 || Scanning.end_of_input ib then width else\n      let width = match Scanning.peek_char ib with\n        | '.' | 'p' | 'P' -> width\n        | _ -> scan_hexadecimal_int width ib in\n      if width = 0 || Scanning.end_of_input ib then width else\n        let width = match Scanning.peek_char ib with\n          | '.' as c -> (\n            let width = Scanning.store_char width ib c in\n            if width = 0 || Scanning.end_of_input ib then width else\n              match Scanning.peek_char ib with\n              | 'p' | 'P' -> width\n              | _ ->\n                let precision = min width precision in\n                width - (precision - scan_hexadecimal_int precision ib)\n          )\n          | _ -> width in\n        if width = 0 || Scanning.end_of_input ib then width else\n          match Scanning.peek_char ib with\n          | 'p' | 'P' as c ->\n            let width = Scanning.store_char width ib c in\n            if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n            scan_optionally_signed_decimal_int width ib\n          | _ -> width\n  )\n  | 'n' | 'N' as c ->\n    let width = Scanning.store_char width ib c in\n    if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n    check_case_insensitive_string width ib bad_hex_float \"an\"\n  | 'i' | 'I' as c ->\n    let width = Scanning.store_char width ib c in\n    if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n    check_case_insensitive_string width ib bad_hex_float \"nfinity\"\n  | _ -> bad_hex_float ()\n\n\nlet scan_caml_float_rest width precision ib =\n  if width = 0 || Scanning.end_of_input ib then bad_float ();\n  let width = scan_decimal_digit_star width ib in\n  if width = 0 || Scanning.end_of_input ib then bad_float ();\n  let c = Scanning.peek_char ib in\n  match c with\n  | '.' ->\n    let width = Scanning.store_char width ib c in\n    (* The effective width available for scanning the fractional part is\n       the minimum of declared precision and width left. *)\n    let precision = min width precision in\n    (* After scanning the fractional part with [precision] provisional width,\n       [width_precision] is left. *)\n    let width_precision = scan_fractional_part precision ib in\n    (* Hence, scanning the fractional part took exactly\n       [precision - width_precision] chars. *)\n    let frac_width = precision - width_precision in\n    (* And new provisional width is [width - width_precision. *)\n    let width = width - frac_width in\n    scan_exponent_part width ib\n  | 'e' | 'E' ->\n    scan_exponent_part width ib\n  | _ -> bad_float ()\n\n\nlet scan_caml_float width precision ib =\n  if width = 0 || Scanning.end_of_input ib then bad_float ();\n  let width = scan_sign width ib in\n  if width = 0 || Scanning.end_of_input ib then bad_float ();\n  match Scanning.peek_char ib with\n  | '0' as c -> (\n    let width = Scanning.store_char width ib c in\n    if width = 0 || Scanning.end_of_input ib then bad_float ();\n    match Scanning.peek_char ib with\n    | 'x' | 'X' as c -> (\n      let width = Scanning.store_char width ib c in\n      if width = 0 || Scanning.end_of_input ib then bad_float ();\n      let width = scan_hexadecimal_int width ib in\n      if width = 0 || Scanning.end_of_input ib then bad_float ();\n      let width = match Scanning.peek_char ib with\n        | '.' as c -> (\n          let width = Scanning.store_char width ib c in\n          if width = 0 || Scanning.end_of_input ib then width else\n            match Scanning.peek_char ib with\n            | 'p' | 'P' -> width\n            | _ ->\n              let precision = min width precision in\n              width - (precision - scan_hexadecimal_int precision ib)\n        )\n        | 'p' | 'P' -> width\n        | _ -> bad_float () in\n      if width = 0 || Scanning.end_of_input ib then width else\n        match Scanning.peek_char ib with\n        | 'p' | 'P' as c ->\n          let width = Scanning.store_char width ib c in\n          if width = 0 || Scanning.end_of_input ib then bad_hex_float ();\n          scan_optionally_signed_decimal_int width ib\n        | _ -> width\n    )\n    | _ ->\n      scan_caml_float_rest width precision ib\n  )\n  | '1' .. '9' as c ->\n    let width = Scanning.store_char width ib c in\n    if width = 0 || Scanning.end_of_input ib then bad_float ();\n    scan_caml_float_rest width precision ib\n(* Special case of nan and infinity:\n  | 'i' ->\n  | 'n' ->\n*)\n  | _ -> bad_float ()\n\n\n(* Scan a regular string:\n   stops when encountering a space, if no scanning indication has been given;\n   otherwise, stops when encountering the characters in the scanning\n   indication [stp].\n   It also stops at end of file or when the maximum number of characters has\n   been read. *)\nlet scan_string stp width ib =\n  let rec loop width =\n    if width = 0 then width else\n    let c = Scanning.peek_char ib in\n    if Scanning.eof ib then width else\n      match stp with\n      | Some c' when c = c' -> Scanning.skip_char width ib\n      | Some _ -> loop (Scanning.store_char width ib c)\n      | None ->\n        match c with\n        | ' ' | '\\t' | '\\n' | '\\r' -> width\n        | _ -> loop (Scanning.store_char width ib c) in\n  loop width\n\n\n(* Scan a char: peek strictly one character in the input, whatsoever. *)\nlet scan_char width ib =\n  (* The case width = 0 could not happen here, since it is tested before\n     calling scan_char, in the main scanning function.\n    if width = 0 then bad_token_length \"a character\" else *)\n  Scanning.store_char width ib (Scanning.checked_peek_char ib)\n\n\nlet char_for_backslash = function\n  | 'n' -> '\\010'\n  | 'r' -> '\\013'\n  | 'b' -> '\\008'\n  | 't' -> '\\009'\n  | c -> c\n\n\n(* The integer value corresponding to the facial value of a valid\n   decimal digit character. *)\nlet decimal_value_of_char c = int_of_char c - int_of_char '0'\n\nlet char_for_decimal_code c0 c1 c2 =\n  let c =\n    100 * decimal_value_of_char c0 +\n     10 * decimal_value_of_char c1 +\n          decimal_value_of_char c2 in\n  if c < 0 || c > 255 then\n    bad_input\n      (Printf.sprintf\n         \"bad character decimal encoding \\\\%c%c%c\" c0 c1 c2) else\n  char_of_int c\n\n\n(* The integer value corresponding to the facial value of a valid\n   hexadecimal digit character. *)\nlet hexadecimal_value_of_char c =\n  let d = int_of_char c in\n  (* Could also be:\n    if d <= int_of_char '9' then d - int_of_char '0' else\n    if d <= int_of_char 'F' then 10 + d - int_of_char 'A' else\n    if d <= int_of_char 'f' then 10 + d - int_of_char 'a' else assert false\n  *)\n  if d >= int_of_char 'a' then\n    d - 87 (* 10 + int_of_char c - int_of_char 'a' *) else\n  if d >= int_of_char 'A' then\n    d - 55  (* 10 + int_of_char c - int_of_char 'A' *) else\n    d - int_of_char '0'\n\n\nlet char_for_hexadecimal_code c1 c2 =\n  let c =\n    16 * hexadecimal_value_of_char c1 +\n         hexadecimal_value_of_char c2 in\n  if c < 0 || c > 255 then\n    bad_input\n      (Printf.sprintf \"bad character hexadecimal encoding \\\\%c%c\" c1 c2) else\n  char_of_int c\n\n\n(* Called in particular when encountering '\\\\' as starter of a char.\n   Stops before the corresponding '\\''. *)\nlet check_next_char message width ib =\n  if width = 0 then bad_token_length message else\n  let c = Scanning.peek_char ib in\n  if Scanning.eof ib then bad_end_of_input message else\n  c\n\n\nlet check_next_char_for_char = check_next_char \"a Char\"\nlet check_next_char_for_string = check_next_char \"a String\"\n\nlet scan_backslash_char width ib =\n  match check_next_char_for_char width ib with\n  | '\\\\' | '\\'' | '\\\"' | 'n' | 't' | 'b' | 'r' as c ->\n    Scanning.store_char width ib (char_for_backslash c)\n  | '0' .. '9' as c ->\n    let get_digit () =\n      let c = Scanning.next_char ib in\n      match c with\n      | '0' .. '9' as c -> c\n      | c -> bad_input_escape c in\n    let c0 = c in\n    let c1 = get_digit () in\n    let c2 = get_digit () in\n    Scanning.store_char (width - 2) ib (char_for_decimal_code c0 c1 c2)\n  | 'x' ->\n    let get_digit () =\n      let c = Scanning.next_char ib in\n      match c with\n      | '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' as c -> c\n      | c -> bad_input_escape c in\n    let c1 = get_digit () in\n    let c2 = get_digit () in\n    Scanning.store_char (width - 2) ib (char_for_hexadecimal_code c1 c2)\n  | c ->\n    bad_input_escape c\n\n\n(* Scan a character (an OCaml token). *)\nlet scan_caml_char width ib =\n\n  let rec find_start width =\n    match Scanning.checked_peek_char ib with\n    | '\\'' -> find_char (Scanning.ignore_char width ib)\n    | c -> character_mismatch '\\'' c\n\n  and find_char width =\n    match check_next_char_for_char width ib with\n    | '\\\\' ->\n      find_stop (scan_backslash_char (Scanning.ignore_char width ib) ib)\n    | c ->\n      find_stop (Scanning.store_char width ib c)\n\n  and find_stop width =\n    match check_next_char_for_char width ib with\n    | '\\'' -> Scanning.ignore_char width ib\n    | c -> character_mismatch '\\'' c in\n\n  find_start width\n\n\n(* Scan a delimited string (an OCaml token). *)\nlet scan_caml_string width ib =\n\n  let rec find_start width =\n    match Scanning.checked_peek_char ib with\n    | '\\\"' -> find_stop (Scanning.ignore_char width ib)\n    | c -> character_mismatch '\\\"' c\n\n  and find_stop width =\n    match check_next_char_for_string width ib with\n    | '\\\"' -> Scanning.ignore_char width ib\n    | '\\\\' -> scan_backslash (Scanning.ignore_char width ib)\n    | c -> find_stop (Scanning.store_char width ib c)\n\n  and scan_backslash width =\n    match check_next_char_for_string width ib with\n    | '\\r' -> skip_newline (Scanning.ignore_char width ib)\n    | '\\n' -> skip_spaces (Scanning.ignore_char width ib)\n    | _ -> find_stop (scan_backslash_char width ib)\n\n  and skip_newline width =\n    match check_next_char_for_string width ib with\n    | '\\n' -> skip_spaces (Scanning.ignore_char width ib)\n    | _ -> find_stop (Scanning.store_char width ib '\\r')\n\n  and skip_spaces width =\n    match check_next_char_for_string width ib with\n    | ' ' -> skip_spaces (Scanning.ignore_char width ib)\n    | _ -> find_stop width in\n\n  find_start width\n\n\n(* Scan a boolean (an OCaml token). *)\nlet scan_bool ib =\n  let c = Scanning.checked_peek_char ib in\n  let m =\n    match c with\n    | 't' -> 4\n    | 'f' -> 5\n    | c ->\n      bad_input\n        (Printf.sprintf \"the character %C cannot start a boolean\" c) in\n  scan_string None m ib\n\n\n(* Scan a string containing elements in char_set and terminated by scan_indic\n   if provided. *)\nlet scan_chars_in_char_set char_set scan_indic width ib =\n  let rec scan_chars i stp =\n    let c = Scanning.peek_char ib in\n    if i > 0 && not (Scanning.eof ib) &&\n       is_in_char_set char_set c &&\n       int_of_char c <> stp then\n      let _ = Scanning.store_char max_int ib c in\n      scan_chars (i - 1) stp in\n  match scan_indic with\n  | None -> scan_chars width (-1);\n  | Some c ->\n    scan_chars width (int_of_char c);\n    if not (Scanning.eof ib) then\n      let ci = Scanning.peek_char ib in\n      if c = ci\n      then Scanning.invalidate_current_char ib\n      else character_mismatch c ci\n\n\n(* The global error report function for [Scanf]. *)\nlet scanf_bad_input ib = function\n  | Scan_failure s | Failure s ->\n    let i = Scanning.char_count ib in\n    bad_input (Printf.sprintf \"scanf: bad input at char number %i: %s\" i s)\n  | x -> raise x\n\n\n(* Get the content of a counter from an input buffer. *)\nlet get_counter ib counter =\n  match counter with\n  | Line_counter -> Scanning.line_count ib\n  | Char_counter -> Scanning.char_count ib\n  | Token_counter -> Scanning.token_count ib\n\n\n(* Compute the width of a padding option (see \"%42{\" and \"%123(\"). *)\nlet width_of_pad_opt pad_opt = match pad_opt with\n  | None -> max_int\n  | Some width -> width\n\n\nlet stopper_of_formatting_lit fmting =\n  if fmting = Escaped_percent then '%', \"\" else\n    let str = string_of_formatting_lit fmting in\n    let stp = str.[1] in\n    let sub_str = String.sub str 2 (String.length str - 2) in\n    stp, sub_str\n\n\n(******************************************************************************)\n                           (* Readers managment *)\n\n(* A call to take_format_readers on a format is evaluated into functions\n   taking readers as arguments and aggregate them into an heterogeneous list *)\n(* When all readers are taken, finally pass the list of the readers to the\n   continuation k. *)\nlet rec take_format_readers : type a c d e f .\n    ((d, e) heter_list -> e) -> (a, Scanning.in_channel, c, d, e, f) fmt ->\n    d =\nfun k fmt -> match fmt with\n  | Reader fmt_rest ->\n    fun reader ->\n      let new_k readers_rest = k (Cons (reader, readers_rest)) in\n      take_format_readers new_k fmt_rest\n  | Char rest                        -> take_format_readers k rest\n  | Caml_char rest                   -> take_format_readers k rest\n  | String (_, rest)                 -> take_format_readers k rest\n  | Caml_string (_, rest)            -> take_format_readers k rest\n  | Int (_, _, _, rest)              -> take_format_readers k rest\n  | Int32 (_, _, _, rest)            -> take_format_readers k rest\n  | Nativeint (_, _, _, rest)        -> take_format_readers k rest\n  | Int64 (_, _, _, rest)            -> take_format_readers k rest\n  | Float (_, _, _, rest)            -> take_format_readers k rest\n  | Bool rest                        -> take_format_readers k rest\n  | Alpha rest                       -> take_format_readers k rest\n  | Theta rest                       -> take_format_readers k rest\n  | Flush rest                       -> take_format_readers k rest\n  | String_literal (_, rest)         -> take_format_readers k rest\n  | Char_literal (_, rest)           -> take_format_readers k rest\n  | Custom (_, _, rest)              -> take_format_readers k rest\n\n  | Scan_char_set (_, _, rest)       -> take_format_readers k rest\n  | Scan_get_counter (_, rest)       -> take_format_readers k rest\n  | Scan_next_char rest              -> take_format_readers k rest\n\n  | Formatting_lit (_, rest)         -> take_format_readers k rest\n  | Formatting_gen (Open_tag (Format (fmt, _)), rest) ->\n      take_format_readers k (concat_fmt fmt rest)\n  | Formatting_gen (Open_box (Format (fmt, _)), rest) ->\n      take_format_readers k (concat_fmt fmt rest)\n\n  | Format_arg (_, _, rest)          -> take_format_readers k rest\n  | Format_subst (_, fmtty, rest)    ->\n     take_fmtty_format_readers k (erase_rel (symm fmtty)) rest\n  | Ignored_param (ign, rest)        -> take_ignored_format_readers k ign rest\n\n  | End_of_format                    -> k Nil\n\n(* Take readers associated to an fmtty coming from a Format_subst \"%(...%)\". *)\nand take_fmtty_format_readers : type x y a c d e f .\n    ((d, e) heter_list -> e) -> (a, Scanning.in_channel, c, d, x, y) fmtty ->\n      (y, Scanning.in_channel, c, x, e, f) fmt -> d =\nfun k fmtty fmt -> match fmtty with\n  | Reader_ty fmt_rest ->\n    fun reader ->\n      let new_k readers_rest = k (Cons (reader, readers_rest)) in\n      take_fmtty_format_readers new_k fmt_rest fmt\n  | Ignored_reader_ty fmt_rest ->\n    fun reader ->\n      let new_k readers_rest = k (Cons (reader, readers_rest)) in\n      take_fmtty_format_readers new_k fmt_rest fmt\n  | Char_ty rest                -> take_fmtty_format_readers k rest fmt\n  | String_ty rest              -> take_fmtty_format_readers k rest fmt\n  | Int_ty rest                 -> take_fmtty_format_readers k rest fmt\n  | Int32_ty rest               -> take_fmtty_format_readers k rest fmt\n  | Nativeint_ty rest           -> take_fmtty_format_readers k rest fmt\n  | Int64_ty rest               -> take_fmtty_format_readers k rest fmt\n  | Float_ty rest               -> take_fmtty_format_readers k rest fmt\n  | Bool_ty rest                -> take_fmtty_format_readers k rest fmt\n  | Alpha_ty rest               -> take_fmtty_format_readers k rest fmt\n  | Theta_ty rest               -> take_fmtty_format_readers k rest fmt\n  | Any_ty rest                 -> take_fmtty_format_readers k rest fmt\n  | Format_arg_ty (_, rest)     -> take_fmtty_format_readers k rest fmt\n  | End_of_fmtty                -> take_format_readers k fmt\n  | Format_subst_ty (ty1, ty2, rest) ->\n    let ty = trans (symm ty1) ty2 in\n    take_fmtty_format_readers k (concat_fmtty ty rest) fmt\n\n(* Take readers associated to an ignored parameter. *)\nand take_ignored_format_readers : type x y a c d e f .\n    ((d, e) heter_list -> e) -> (a, Scanning.in_channel, c, d, x, y) ignored ->\n      (y, Scanning.in_channel, c, x, e, f) fmt -> d =\nfun k ign fmt -> match ign with\n  | Ignored_reader ->\n    fun reader ->\n      let new_k readers_rest = k (Cons (reader, readers_rest)) in\n      take_format_readers new_k fmt\n  | Ignored_char                    -> take_format_readers k fmt\n  | Ignored_caml_char               -> take_format_readers k fmt\n  | Ignored_string _                -> take_format_readers k fmt\n  | Ignored_caml_string _           -> take_format_readers k fmt\n  | Ignored_int (_, _)              -> take_format_readers k fmt\n  | Ignored_int32 (_, _)            -> take_format_readers k fmt\n  | Ignored_nativeint (_, _)        -> take_format_readers k fmt\n  | Ignored_int64 (_, _)            -> take_format_readers k fmt\n  | Ignored_float (_, _)            -> take_format_readers k fmt\n  | Ignored_bool                    -> take_format_readers k fmt\n  | Ignored_format_arg _            -> take_format_readers k fmt\n  | Ignored_format_subst (_, fmtty) -> take_fmtty_format_readers k fmtty fmt\n  | Ignored_scan_char_set _         -> take_format_readers k fmt\n  | Ignored_scan_get_counter _      -> take_format_readers k fmt\n  | Ignored_scan_next_char          -> take_format_readers k fmt\n\n(******************************************************************************)\n                          (* Generic scanning *)\n\n(* Make a generic scanning function. *)\n(* Scan a stream according to a format and readers obtained by\n   take_format_readers, and aggegate scanned values into an\n   heterogeneous list. *)\n(* Return the heterogeneous list of scanned values. *)\nlet rec make_scanf : type a c d e f.\n    Scanning.in_channel -> (a, Scanning.in_channel, c, d, e, f) fmt ->\n      (d, e) heter_list -> (a, f) heter_list =\nfun ib fmt readers -> match fmt with\n  | Char rest ->\n    let _ = scan_char 0 ib in\n    let c = token_char ib in\n    Cons (c, make_scanf ib rest readers)\n  | Caml_char rest ->\n    let _ = scan_caml_char 0 ib in\n    let c = token_char ib in\n    Cons (c, make_scanf ib rest readers)\n\n  | String (pad, Formatting_lit (fmting_lit, rest)) ->\n    let stp, str = stopper_of_formatting_lit fmting_lit in\n    let scan width _ ib = scan_string (Some stp) width ib in\n    let str_rest = String_literal (str, rest) in\n    pad_prec_scanf ib str_rest readers pad No_precision scan token_string\n  | String (pad, Formatting_gen (Open_tag (Format (fmt', _)), rest)) ->\n    let scan width _ ib = scan_string (Some '{') width ib in\n    pad_prec_scanf ib (concat_fmt fmt' rest) readers pad No_precision scan\n                   token_string\n  | String (pad, Formatting_gen (Open_box (Format (fmt', _)), rest)) ->\n    let scan width _ ib = scan_string (Some '[') width ib in\n    pad_prec_scanf ib (concat_fmt fmt' rest) readers pad No_precision scan\n                   token_string\n  | String (pad, rest) ->\n    let scan width _ ib = scan_string None width ib in\n    pad_prec_scanf ib rest readers pad No_precision scan token_string\n\n  | Caml_string (pad, rest) ->\n    let scan width _ ib = scan_caml_string width ib in\n    pad_prec_scanf ib rest readers pad No_precision scan token_string\n  | Int (iconv, pad, prec, rest) ->\n    let c = integer_conversion_of_char (char_of_iconv iconv) in\n    let scan width _ ib = scan_int_conversion c width ib in\n    pad_prec_scanf ib rest readers pad prec scan (token_int c)\n  | Int32 (iconv, pad, prec, rest) ->\n    let c = integer_conversion_of_char (char_of_iconv iconv) in\n    let scan width _ ib = scan_int_conversion c width ib in\n    pad_prec_scanf ib rest readers pad prec scan (token_int32 c)\n  | Nativeint (iconv, pad, prec, rest) ->\n    let c = integer_conversion_of_char (char_of_iconv iconv) in\n    let scan width _ ib = scan_int_conversion c width ib in\n    pad_prec_scanf ib rest readers pad prec scan (token_nativeint c)\n  | Int64 (iconv, pad, prec, rest) ->\n    let c = integer_conversion_of_char (char_of_iconv iconv) in\n    let scan width _ ib = scan_int_conversion c width ib in\n    pad_prec_scanf ib rest readers pad prec scan (token_int64 c)\n  | Float (Float_F, pad, prec, rest) ->\n    pad_prec_scanf ib rest readers pad prec scan_caml_float token_float\n  | Float ((Float_f | Float_pf | Float_sf | Float_e | Float_pe | Float_se\n               | Float_E | Float_pE | Float_sE | Float_g | Float_pg | Float_sg\n               | Float_G | Float_pG | Float_sG), pad, prec, rest) ->\n    pad_prec_scanf ib rest readers pad prec scan_float token_float\n  | Float ((Float_h | Float_ph | Float_sh | Float_H | Float_pH | Float_sH),\n           pad, prec, rest) ->\n    pad_prec_scanf ib rest readers pad prec scan_hex_float token_float\n  | Bool rest ->\n    let _ = scan_bool ib in\n    let b = token_bool ib in\n    Cons (b, make_scanf ib rest readers)\n  | Alpha _ ->\n    invalid_arg \"scanf: bad conversion \\\"%a\\\"\"\n  | Theta _ ->\n    invalid_arg \"scanf: bad conversion \\\"%t\\\"\"\n  | Custom _ ->\n    invalid_arg \"scanf: bad conversion \\\"%?\\\" (custom converter)\"\n  | Reader fmt_rest ->\n    begin match readers with\n    | Cons (reader, readers_rest) ->\n        let x = reader ib in\n        Cons (x, make_scanf ib fmt_rest readers_rest)\n    | Nil -> \n        invalid_arg \"scanf: missing reader\"\n    end\n  | Flush rest ->\n    if Scanning.end_of_input ib then make_scanf ib rest readers\n    else bad_input \"end of input not found\"\n\n  | String_literal (str, rest) ->\n    String.iter (check_char ib) str;\n    make_scanf ib rest readers\n  | Char_literal (chr, rest) ->\n    check_char ib chr;\n    make_scanf ib rest readers\n\n  | Format_arg (pad_opt, fmtty, rest) ->\n    let _ = scan_caml_string (width_of_pad_opt pad_opt) ib in\n    let s = token_string ib in\n    let fmt =\n      try format_of_string_fmtty s fmtty\n      with Failure msg -> bad_input msg\n    in\n    Cons (fmt, make_scanf ib rest readers)\n  | Format_subst (pad_opt, fmtty, rest) ->\n    let _ = scan_caml_string (width_of_pad_opt pad_opt) ib in\n    let s = token_string ib in\n    let fmt, fmt' =\n      try\n        let Fmt_EBB fmt = fmt_ebb_of_string s in\n        let Fmt_EBB fmt' = fmt_ebb_of_string s in\n        (* TODO: find a way to avoid reparsing twice *)\n\n        (* TODO: these type-checks below *can* fail because of type\n           ambiguity in presence of ignored-readers: \"%_r%d\" and \"%d%_r\"\n           are typed in the same way.\n\n           # Scanf.sscanf \"\\\"%_r%d\\\"3\" \"%(%d%_r%)\" ignore\n             (fun fmt n -> string_of_format fmt, n)\n           Exception: CamlinternalFormat.Type_mismatch.\n\n           We should properly catch this exception.\n        *)\n        type_format fmt (erase_rel fmtty),\n        type_format fmt' (erase_rel (symm fmtty))\n      with Failure msg -> bad_input msg\n    in\n    Cons (Format (fmt, s),\n          make_scanf ib (concat_fmt fmt' rest) readers)\n\n  | Scan_char_set (width_opt, char_set, Formatting_lit (fmting_lit, rest)) ->\n    let stp, str = stopper_of_formatting_lit fmting_lit in\n    let width = width_of_pad_opt width_opt in\n    scan_chars_in_char_set char_set (Some stp) width ib;\n    let s = token_string ib in\n    let str_rest = String_literal (str, rest) in\n    Cons (s, make_scanf ib str_rest readers)\n  | Scan_char_set (width_opt, char_set, rest) ->\n    let width = width_of_pad_opt width_opt in\n    scan_chars_in_char_set char_set None width ib;\n    let s = token_string ib in\n    Cons (s, make_scanf ib rest readers)\n  | Scan_get_counter (counter, rest) ->\n    let count = get_counter ib counter in\n    Cons (count, make_scanf ib rest readers)\n  | Scan_next_char rest ->\n    let c = Scanning.checked_peek_char ib in\n    Cons (c, make_scanf ib rest readers)\n\n  | Formatting_lit (formatting_lit, rest) ->\n    String.iter (check_char ib) (string_of_formatting_lit formatting_lit);\n    make_scanf ib rest readers\n  | Formatting_gen (Open_tag (Format (fmt', _)), rest) ->\n    check_char ib '@'; check_char ib '{';\n    make_scanf ib (concat_fmt fmt' rest) readers\n  | Formatting_gen (Open_box (Format (fmt', _)), rest) ->\n    check_char ib '@'; check_char ib '[';\n    make_scanf ib (concat_fmt fmt' rest) readers\n\n  | Ignored_param (ign, rest) ->\n    let Param_format_EBB fmt' = param_format_of_ignored_format ign rest in\n    begin match make_scanf ib fmt' readers with\n    | Cons (_, arg_rest) -> arg_rest\n    | Nil -> assert false\n    end\n\n  | End_of_format ->\n    Nil\n\n(* Case analysis on padding and precision. *)\n(* Reject formats containing \"%*\" or \"%.*\". *)\n(* Pass padding and precision to the generic scanner `scan'. *)\nand pad_prec_scanf : type a c d e f x y z t .\n    Scanning.in_channel -> (a, Scanning.in_channel, c, d, e, f) fmt ->\n      (d, e) heter_list -> (x, y) padding -> (y, z -> a) precision ->\n      (int -> int -> Scanning.in_channel -> t) ->\n      (Scanning.in_channel -> z) ->\n      (x, f) heter_list =\nfun ib fmt readers pad prec scan token -> match pad, prec with\n  | No_padding, No_precision ->\n    let _ = scan max_int max_int ib in\n    let x = token ib in\n    Cons (x, make_scanf ib fmt readers)\n  | No_padding, Lit_precision p ->\n    let _ = scan max_int p ib in\n    let x = token ib in\n    Cons (x, make_scanf ib fmt readers)\n  | Lit_padding ((Right | Zeros), w), No_precision ->\n    let _ = scan w max_int ib in\n    let x = token ib in\n    Cons (x, make_scanf ib fmt readers)\n  | Lit_padding ((Right | Zeros), w), Lit_precision p ->\n    let _ = scan w p ib in\n    let x = token ib in\n    Cons (x, make_scanf ib fmt readers)\n  | Lit_padding (Left, _), _ ->\n    invalid_arg \"scanf: bad conversion \\\"%-\\\"\"\n  | Lit_padding ((Right | Zeros), _), Arg_precision ->\n    invalid_arg \"scanf: bad conversion \\\"%*\\\"\"\n  | Arg_padding _, _ ->\n    invalid_arg \"scanf: bad conversion \\\"%*\\\"\"\n  | No_padding, Arg_precision ->\n    invalid_arg \"scanf: bad conversion \\\"%*\\\"\"\n\n(******************************************************************************)\n            (* Defining [scanf] and various flavors of [scanf] *)\n\ntype 'a kscanf_result = Args of 'a | Exc of exn\n\nlet kscanf ib ef (Format (fmt, str)) =\n  let rec apply : type a b . a -> (a, b) heter_list -> b =\n    fun f args -> match args with\n    | Cons (x, r) -> apply (f x) r\n    | Nil -> f\n  in\n  let k readers f =\n    Scanning.reset_token ib;\n    match try Args (make_scanf ib fmt readers) with\n      | (Scan_failure _ | Failure _ | End_of_file) as exc -> Exc exc\n      | Invalid_argument msg ->\n        invalid_arg (msg ^ \" in format \\\"\" ^ String.escaped str ^ \"\\\"\")\n    with\n      | Args args -> apply f args\n      | Exc exc -> ef ib exc\n  in\n  take_format_readers k fmt\n\n(***)\n\nlet kbscanf = kscanf\nlet bscanf ib fmt = kbscanf ib scanf_bad_input fmt\n\nlet ksscanf s ef fmt = kbscanf (Scanning.from_string s) ef fmt\nlet sscanf s fmt = kbscanf (Scanning.from_string s) scanf_bad_input fmt\n\nlet scanf fmt = kscanf Scanning.stdib scanf_bad_input fmt\n\n(***)\n\n(* Scanning format strings. *)\nlet bscanf_format :\n  Scanning.in_channel -> ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g =\n  fun ib format f ->\n    let _ = scan_caml_string max_int ib in\n    let str = token_string ib in\n    let fmt' =\n      try format_of_string_format str format\n      with Failure msg -> bad_input msg in\n    f fmt'\n\n\nlet sscanf_format :\n  string -> ('a, 'b, 'c, 'd, 'e, 'f) format6 ->\n  (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g =\n  fun s format f -> bscanf_format (Scanning.from_string s) format f\n\n\nlet string_to_String s =\n  let l = String.length s in\n  let b = Buffer.create (l + 2) in\n  Buffer.add_char b '\\\"';\n  for i = 0 to l - 1 do\n    let c = s.[i] in\n    if c = '\\\"' then Buffer.add_char b '\\\\';\n    Buffer.add_char b c;\n  done;\n  Buffer.add_char b '\\\"';\n  Buffer.contents b\n\n\nlet format_from_string s fmt =\n  sscanf_format (string_to_String s) fmt (fun x -> x)\n\n\nlet unescaped s =\n  sscanf (\"\\\"\" ^ s ^ \"\\\"\") \"%S%!\" (fun x -> x)\n\n\n(* Deprecated *)\nlet kfscanf ic ef fmt = kbscanf (Scanning.memo_from_channel ic) ef fmt\nlet fscanf ic fmt = kscanf (Scanning.memo_from_channel ic) scanf_bad_input fmt\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Registering OCaml values with the C runtime for later callbacks *)\n\nexternal register_named_value : string -> Obj.t -> unit\n                              = \"caml_register_named_value\"\n\nlet register name v =\n  register_named_value name (Obj.repr v)\n\nlet register_exception name (exn : exn) =\n  let exn = Obj.repr exn in\n  let slot = if Obj.tag exn = Obj.object_tag then exn else Obj.field exn 0 in\n  register_named_value name slot\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*          Jerome Vouillon, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 2002 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nopen Obj\n\n(**** Object representation ****)\n\nexternal set_id: 'a -> 'a = \"caml_set_oo_id\" [@@noalloc]\n\n(**** Object copy ****)\n\nlet copy o =\n  let o = (Obj.obj (Obj.dup (Obj.repr o))) in\n  set_id o\n\n(**** Compression options ****)\n(* Parameters *)\ntype params = {\n    mutable compact_table : bool;\n    mutable copy_parent : bool;\n    mutable clean_when_copying : bool;\n    mutable retry_count : int;\n    mutable bucket_small_size : int\n  }\n\nlet params = {\n  compact_table = true;\n  copy_parent = true;\n  clean_when_copying = true;\n  retry_count = 3;\n  bucket_small_size = 16\n}\n\n(**** Parameters ****)\n\nlet initial_object_size = 2\n\n(**** Items ****)\n\ntype item = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\nlet dummy_item = (magic () : item)\n\n(**** Types ****)\n\ntype tag\ntype label = int\ntype closure = item\ntype t = DummyA | DummyB | DummyC of int\nlet _ = [DummyA; DummyB; DummyC 0] (* to avoid warnings *)\n\ntype obj = t array\nexternal ret : (obj -> 'a) -> closure = \"%identity\"\n\n(**** Labels ****)\n\nlet public_method_label s : tag =\n  let accu = ref 0 in\n  for i = 0 to String.length s - 1 do\n    accu := 223 * !accu + Char.code s.[i]\n  done;\n  (* reduce to 31 bits *)\n  accu := !accu land (1 lsl 31 - 1);\n  (* make it signed for 64 bits architectures *)\n  let tag = if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu in\n  (* Printf.eprintf \"%s = %d\\n\" s tag; flush stderr; *)\n  magic tag\n\n(**** Sparse array ****)\n\nmodule Vars =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype vars = int Vars.t\n\nmodule Meths =\n  Map.Make(struct type t = string let compare (x:t) y = compare x y end)\ntype meths = label Meths.t\nmodule Labs =\n  Map.Make(struct type t = label let compare (x:t) y = compare x y end)\ntype labs = bool Labs.t\n\n(* The compiler assumes that the first field of this structure is [size]. *)\ntype table =\n { mutable size: int;\n   mutable methods: closure array;\n   mutable methods_by_name: meths;\n   mutable methods_by_label: labs;\n   mutable previous_states:\n     (meths * labs * (label * item) list * vars *\n      label list * string list) list;\n   mutable hidden_meths: (label * item) list;\n   mutable vars: vars;\n   mutable initializers: (obj -> unit) list }\n\nlet dummy_table =\n  { methods = [| dummy_item |];\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = 0 }\n\nlet table_count = ref 0\n\n(* dummy_met should be a pointer, so use an atom *)\nlet dummy_met : item = obj (Obj.new_block 0 0)\n(* if debugging is needed, this could be a good idea: *)\n(* let dummy_met () = failwith \"Undefined method\" *)\n\nlet rec fit_size n =\n  if n <= 2 then n else\n  fit_size ((n+1)/2) * 2\n\nlet new_table pub_labels =\n  incr table_count;\n  let len = Array.length pub_labels in\n  let methods = Array.make (len*2+2) dummy_met in\n  methods.(0) <- magic len;\n  methods.(1) <- magic (fit_size len * Sys.word_size / 8 - 1);\n  for i = 0 to len - 1 do methods.(i*2+3) <- magic pub_labels.(i) done;\n  { methods = methods;\n    methods_by_name = Meths.empty;\n    methods_by_label = Labs.empty;\n    previous_states = [];\n    hidden_meths = [];\n    vars = Vars.empty;\n    initializers = [];\n    size = initial_object_size }\n\nlet resize array new_size =\n  let old_size = Array.length array.methods in\n  if new_size > old_size then begin\n    let new_buck = Array.make new_size dummy_met in\n    Array.blit array.methods 0 new_buck 0 old_size;\n    array.methods <- new_buck\n end\n\nlet put array label element =\n  resize array (label + 1);\n  array.methods.(label) <- element\n\n(**** Classes ****)\n\nlet method_count = ref 0\nlet inst_var_count = ref 0\n\n(* type t *)\ntype meth = item\n\nlet new_method table =\n  let index = Array.length table.methods in\n  resize table (index + 1);\n  index\n\nlet get_method_label table name =\n  try\n    Meths.find name table.methods_by_name\n  with Not_found ->\n    let label = new_method table in\n    table.methods_by_name <- Meths.add name label table.methods_by_name;\n    table.methods_by_label <- Labs.add label true table.methods_by_label;\n    label\n\nlet get_method_labels table names =\n  Array.map (get_method_label table) names\n\nlet set_method table label element =\n  incr method_count;\n  if Labs.find label table.methods_by_label then\n    put table label element\n  else\n    table.hidden_meths <- (label, element) :: table.hidden_meths\n\nlet get_method table label =\n  try List.assoc label table.hidden_meths\n  with Not_found -> table.methods.(label)\n\nlet to_list arr =\n  if arr == magic 0 then [] else Array.to_list arr\n\nlet narrow table vars virt_meths concr_meths =\n  let vars = to_list vars\n  and virt_meths = to_list virt_meths\n  and concr_meths = to_list concr_meths in\n  let virt_meth_labs = List.map (get_method_label table) virt_meths in\n  let concr_meth_labs = List.map (get_method_label table) concr_meths in\n  table.previous_states <-\n     (table.methods_by_name, table.methods_by_label, table.hidden_meths,\n      table.vars, virt_meth_labs, vars)\n     :: table.previous_states;\n  table.vars <-\n    Vars.fold\n      (fun lab info tvars ->\n        if List.mem lab vars then Vars.add lab info tvars else tvars)\n      table.vars Vars.empty;\n  let by_name = ref Meths.empty in\n  let by_label = ref Labs.empty in\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label :=\n          Labs.add label\n            (try Labs.find label table.methods_by_label with Not_found -> true)\n            !by_label)\n    concr_meths concr_meth_labs;\n  List.iter2\n    (fun met label ->\n       by_name := Meths.add met label !by_name;\n       by_label := Labs.add label false !by_label)\n    virt_meths virt_meth_labs;\n  table.methods_by_name <- !by_name;\n  table.methods_by_label <- !by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meth_labs then hm else met::hm)\n       table.hidden_meths\n       []\n\nlet widen table =\n  let (by_name, by_label, saved_hidden_meths, saved_vars, virt_meths, vars) =\n    List.hd table.previous_states\n  in\n  table.previous_states <- List.tl table.previous_states;\n  table.vars <-\n     List.fold_left\n       (fun s v -> Vars.add v (Vars.find v table.vars) s)\n       saved_vars vars;\n  table.methods_by_name <- by_name;\n  table.methods_by_label <- by_label;\n  table.hidden_meths <-\n     List.fold_right\n       (fun ((lab, _) as met) hm ->\n          if List.mem lab virt_meths then hm else met::hm)\n       table.hidden_meths\n       saved_hidden_meths\n\nlet new_slot table =\n  let index = table.size in\n  table.size <- index + 1;\n  index\n\nlet new_variable table name =\n  try Vars.find name table.vars\n  with Not_found ->\n    let index = new_slot table in\n    if name <> \"\" then table.vars <- Vars.add name index table.vars;\n    index\n\nlet to_array arr =\n  if arr = Obj.magic 0 then [||] else arr\n\nlet new_methods_variables table meths vals =\n  let meths = to_array meths in\n  let nmeths = Array.length meths and nvals = Array.length vals in\n  let res = Array.make (nmeths + nvals) 0 in\n  for i = 0 to nmeths - 1 do\n    res.(i) <- get_method_label table meths.(i)\n  done;\n  for i = 0 to nvals - 1 do\n    res.(i+nmeths) <- new_variable table vals.(i)\n  done;\n  res\n\nlet get_variable table name =\n  try Vars.find name table.vars with Not_found -> assert false\n\nlet get_variables table names =\n  Array.map (get_variable table) names\n\nlet add_initializer table f =\n  table.initializers <- f::table.initializers\n\n(*\nmodule Keys =\n  Map.Make(struct type t = tag array let compare (x:t) y = compare x y end)\nlet key_map = ref Keys.empty\nlet get_key tags : item =\n  try magic (Keys.find tags !key_map : tag array)\n  with Not_found ->\n    key_map := Keys.add tags tags !key_map;\n    magic tags\n*)\n\nlet create_table public_methods =\n  if public_methods == magic 0 then new_table [||] else\n  (* [public_methods] must be in ascending order for bytecode *)\n  let tags = Array.map public_method_label public_methods in\n  let table = new_table tags in\n  Array.iteri\n    (fun i met ->\n      let lab = i*2+2 in\n      table.methods_by_name  <- Meths.add met lab table.methods_by_name;\n      table.methods_by_label <- Labs.add lab true table.methods_by_label)\n    public_methods;\n  table\n\nlet init_class table =\n  inst_var_count := !inst_var_count + table.size - 1;\n  table.initializers <- List.rev table.initializers;\n  resize table (3 + magic table.methods.(1) * 16 / Sys.word_size)\n\nlet inherits cla vals virt_meths concr_meths (_, super, _, env) top =\n  narrow cla vals virt_meths concr_meths;\n  let init =\n    if top then super cla env else Obj.repr (super cla) in\n  widen cla;\n  Array.concat\n    [[| repr init |];\n     magic (Array.map (get_variable cla) (to_array vals) : int array);\n     Array.map\n       (fun nm -> repr (get_method cla (get_method_label cla nm) : closure))\n       (to_array concr_meths) ]\n\nlet make_class pub_meths class_init =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  (env_init (Obj.repr 0), class_init, env_init, Obj.repr 0)\n\ntype init_table = { mutable env_init: t; mutable class_init: table -> t }\n\nlet make_class_store pub_meths class_init init_table =\n  let table = create_table pub_meths in\n  let env_init = class_init table in\n  init_class table;\n  init_table.class_init <- class_init;\n  init_table.env_init <- env_init\n\nlet dummy_class loc =\n  let undef = fun _ -> raise (Undefined_recursive_module loc) in\n  (Obj.magic undef, undef, undef, Obj.repr 0)\n\n(**** Objects ****)\n\nlet create_object table =\n  (* XXX Appel de [obj_block] | Call to [obj_block]  *)\n  let obj = Obj.new_block Obj.object_tag table.size in\n  (* XXX Appel de [caml_modify] | Call to [caml_modify] *)\n  Obj.set_field obj 0 (Obj.repr table.methods);\n  Obj.obj (set_id obj)\n\nlet create_object_opt obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    (* XXX Appel de [obj_block] | Call to [obj_block]  *)\n    let obj = Obj.new_block Obj.object_tag table.size in\n    (* XXX Appel de [caml_modify] | Call to [caml_modify] *)\n    Obj.set_field obj 0 (Obj.repr table.methods);\n    Obj.obj (set_id obj)\n  end\n\nlet rec iter_f obj =\n  function\n    []   -> ()\n  | f::l -> f obj; iter_f obj l\n\nlet run_initializers obj table =\n  let inits = table.initializers in\n  if inits <> [] then\n    iter_f obj inits\n\nlet run_initializers_opt obj_0 obj table =\n  if (Obj.magic obj_0 : bool) then obj else begin\n    let inits = table.initializers in\n    if inits <> [] then iter_f obj inits;\n    obj\n  end\n\nlet create_object_and_run_initializers obj_0 table =\n  if (Obj.magic obj_0 : bool) then obj_0 else begin\n    let obj = create_object table in\n    run_initializers obj table;\n    obj\n  end\n\n(* Equivalent primitive below\nlet sendself obj lab =\n  (magic obj : (obj -> t) array array).(0).(lab) obj\n*)\nexternal send : obj -> tag -> 'a = \"%send\"\nexternal sendcache : obj -> tag -> t -> int -> 'a = \"%sendcache\"\nexternal sendself : obj -> label -> 'a = \"%sendself\"\nexternal get_public_method : obj -> tag -> closure\n    = \"caml_get_public_method\" [@@noalloc]\n\n(**** table collection access ****)\n\ntype tables =\n  | Empty\n  | Cons of {key : closure; mutable data: tables; mutable next: tables}\n\nlet set_data tables v = match tables with\n  | Empty -> assert false\n  | Cons tables -> tables.data <- v\nlet set_next tables v = match tables with\n  | Empty -> assert false\n  | Cons tables -> tables.next <- v\nlet get_key = function\n  | Empty -> assert false\n  | Cons tables -> tables.key\nlet get_data = function\n  | Empty -> assert false\n  | Cons tables -> tables.data\nlet get_next = function\n  | Empty -> assert false\n  | Cons tables -> tables.next\n\nlet build_path n keys tables =\n  let res = Cons {key = Obj.magic 0; data = Empty; next = Empty} in\n  let r = ref res in\n  for i = 0 to n do\n    r := Cons {key = keys.(i); data = !r; next = Empty}\n  done;\n  set_data tables !r;\n  res\n\nlet rec lookup_keys i keys tables =\n  if i < 0 then tables else\n  let key = keys.(i) in\n  let rec lookup_key (tables:tables) =\n    if get_key tables == key then\n      match get_data tables with\n      | Empty -> assert false\n      | Cons _ as tables_data ->\n          lookup_keys (i-1) keys tables_data\n    else\n      match get_next tables with\n      | Cons _ as next -> lookup_key next\n      | Empty ->\n          let next : tables = Cons {key; data = Empty; next = Empty} in\n          set_next tables next;\n          build_path (i-1) keys next\n  in\n  lookup_key tables\n\nlet lookup_tables root keys =\n  match get_data root with\n  | Cons _ as root_data ->\n    lookup_keys (Array.length keys - 1) keys root_data\n  | Empty ->\n    build_path (Array.length keys - 1) keys root\n\n(**** builtin methods ****)\n\nlet get_const x = ret (fun _obj -> x)\nlet get_var n   = ret (fun obj -> Array.unsafe_get obj n)\nlet get_env e n =\n  ret (fun obj ->\n    Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n)\nlet get_meth n  = ret (fun obj -> sendself obj n)\nlet set_var n   = ret (fun obj x -> Array.unsafe_set obj n x)\nlet app_const f x = ret (fun _obj -> f x)\nlet app_var f n   = ret (fun obj -> f (Array.unsafe_get obj n))\nlet app_env f e n =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_meth f n  = ret (fun obj -> f (sendself obj n))\nlet app_const_const f x y = ret (fun _obj -> f x y)\nlet app_const_var f x n   = ret (fun obj -> f x (Array.unsafe_get obj n))\nlet app_const_meth f x n = ret (fun obj -> f x (sendself obj n))\nlet app_var_const f n x = ret (fun obj -> f (Array.unsafe_get obj n) x)\nlet app_meth_const f n x = ret (fun obj -> f (sendself obj n) x)\nlet app_const_env f x e n =\n  ret (fun obj ->\n    f x (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n))\nlet app_env_const f e n x =\n  ret (fun obj ->\n    f (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) n) x)\nlet meth_app_const n x = ret (fun obj -> (sendself obj n : _ -> _) x)\nlet meth_app_var n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (Array.unsafe_get obj m))\nlet meth_app_env n e m =\n  ret (fun obj -> (sendself obj n : _ -> _)\n      (Array.unsafe_get (Obj.magic (Array.unsafe_get obj e) : obj) m))\nlet meth_app_meth n m =\n  ret (fun obj -> (sendself obj n : _ -> _) (sendself obj m))\nlet send_const m x c =\n  ret (fun obj -> sendcache x m (Array.unsafe_get obj 0) c)\nlet send_var m n c =\n  ret (fun obj ->\n    sendcache (Obj.magic (Array.unsafe_get obj n) : obj) m\n      (Array.unsafe_get obj 0) c)\nlet send_env m e n c =\n  ret (fun obj ->\n    sendcache\n      (Obj.magic (Array.unsafe_get\n                    (Obj.magic (Array.unsafe_get obj e) : obj) n) : obj)\n      m (Array.unsafe_get obj 0) c)\nlet send_meth m n c =\n  ret (fun obj ->\n    sendcache (sendself obj n) m (Array.unsafe_get obj 0) c)\nlet new_cache table =\n  let n = new_method table in\n  let n =\n    if n mod 2 = 0 || n > 2 + magic table.methods.(1) * 16 / Sys.word_size\n    then n else new_method table\n  in\n  table.methods.(n) <- Obj.magic 0;\n  n\n\ntype impl =\n    GetConst\n  | GetVar\n  | GetEnv\n  | GetMeth\n  | SetVar\n  | AppConst\n  | AppVar\n  | AppEnv\n  | AppMeth\n  | AppConstConst\n  | AppConstVar\n  | AppConstEnv\n  | AppConstMeth\n  | AppVarConst\n  | AppEnvConst\n  | AppMethConst\n  | MethAppConst\n  | MethAppVar\n  | MethAppEnv\n  | MethAppMeth\n  | SendConst\n  | SendVar\n  | SendEnv\n  | SendMeth\n  | Closure of closure\n\nlet method_impl table i arr =\n  let next () = incr i; magic arr.(!i) in\n  match next() with\n    GetConst -> let x : t = next() in get_const x\n  | GetVar   -> let n = next() in get_var n\n  | GetEnv   -> let e = next() in let n = next() in get_env e n\n  | GetMeth  -> let n = next() in get_meth n\n  | SetVar   -> let n = next() in set_var n\n  | AppConst -> let f = next() in let x = next() in app_const f x\n  | AppVar   -> let f = next() in let n = next () in app_var f n\n  | AppEnv   ->\n      let f = next() in  let e = next() in let n = next() in\n      app_env f e n\n  | AppMeth  -> let f = next() in let n = next () in app_meth f n\n  | AppConstConst ->\n      let f = next() in let x = next() in let y = next() in\n      app_const_const f x y\n  | AppConstVar ->\n      let f = next() in let x = next() in let n = next() in\n      app_const_var f x n\n  | AppConstEnv ->\n      let f = next() in let x = next() in let e = next () in let n = next() in\n      app_const_env f x e n\n  | AppConstMeth ->\n      let f = next() in let x = next() in let n = next() in\n      app_const_meth f x n\n  | AppVarConst ->\n      let f = next() in let n = next() in let x = next() in\n      app_var_const f n x\n  | AppEnvConst ->\n      let f = next() in let e = next () in let n = next() in let x = next() in\n      app_env_const f e n x\n  | AppMethConst ->\n      let f = next() in let n = next() in let x = next() in\n      app_meth_const f n x\n  | MethAppConst ->\n      let n = next() in let x = next() in meth_app_const n x\n  | MethAppVar ->\n      let n = next() in let m = next() in meth_app_var n m\n  | MethAppEnv ->\n      let n = next() in let e = next() in let m = next() in\n      meth_app_env n e m\n  | MethAppMeth ->\n      let n = next() in let m = next() in meth_app_meth n m\n  | SendConst ->\n      let m = next() in let x = next() in send_const m x (new_cache table)\n  | SendVar ->\n      let m = next() in let n = next () in send_var m n (new_cache table)\n  | SendEnv ->\n      let m = next() in let e = next() in let n = next() in\n      send_env m e n (new_cache table)\n  | SendMeth ->\n      let m = next() in let n = next () in send_meth m n (new_cache table)\n  | Closure _ as clo -> magic clo\n\nlet set_methods table methods =\n  let len = Array.length methods in let i = ref 0 in\n  while !i < len do\n    let label = methods.(!i) in let clo = method_impl table i methods in\n    set_method table label clo;\n    incr i\n  done\n\n(**** Statistics ****)\n\ntype stats =\n  { classes: int; methods: int; inst_vars: int; }\n\nlet stats () =\n  { classes = !table_count;\n    methods = !method_count; inst_vars = !inst_var_count; }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule From = Ast_402\nmodule To = Ast_403\n\nlet extract_predef_option label typ =\n  let open From in\n  let open Longident in\n  match label, typ.Parsetree.ptyp_desc with\n  | To.Asttypes.Optional _,\n    From.Parsetree.Ptyp_constr (\n      {Location.txt = Ldot (Lident \"*predef*\", \"option\"); _}, [d]) ->\n      d\n  | _ -> typ\n\nlet rec copy_expression :\n  From.Parsetree.expression ->\n    To.Parsetree.expression\n  =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc =\n        (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc =\n        (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes =\n        (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc ->\n    To.Parsetree.expression_desc\n  =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant\n        (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), x1)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert\n        (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy\n        (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (x0, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack\n        (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension\n        (copy_extension x0)\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag ->\n    To.Asttypes.direction_flag\n  =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs =\n        (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs =\n        (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding ->\n    To.Parsetree.value_binding\n  =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat =\n        (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc =\n        (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc =\n        (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc ->\n    To.Parsetree.pattern_desc\n  =\n  function\n  | From.Parsetree.Ppat_any  ->\n      To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant\n        (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension\n        (copy_extension x0)\n\nand copy_core_type :\n  From.Parsetree.core_type ->\n    To.Parsetree.core_type\n  =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc =\n        (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc ->\n    To.Parsetree.core_type_desc\n  =\n  function\n  | From.Parsetree.Ptyp_any  ->\n      To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 ->\n      To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      let label = copy_arg_label x0 in\n      To.Parsetree.Ptyp_arrow\n        (label,\n         copy_core_type (extract_predef_option label x1),\n         copy_core_type x2)\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (x0, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option\n             (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> x) x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package\n        (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension\n        (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type ->\n    To.Parsetree.package_type\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc\n                copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field ->\n    To.Parsetree.row_field\n  =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit\n        (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes ->\n    To.Parsetree.attributes\n  = fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute ->\n    To.Parsetree.attribute\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr\n        (copy_structure x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp\n        (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure ->\n    To.Parsetree.structure\n  = fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item ->\n    To.Parsetree.structure_item\n  =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc =\n        (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type x0 ->\n      let recflag, types = type_declarations x0 in\n      To.Parsetree.Pstr_type (recflag, types)\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration ->\n    To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr ->\n    To.Parsetree.class_expr\n  =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc =\n        (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc ->\n    To.Parsetree.class_expr_desc\n  =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension\n        (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure ->\n    To.Parsetree.class_structure\n  =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field ->\n    To.Parsetree.class_field\n  =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc =\n        (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc ->\n    To.Parsetree.class_field_desc\n  =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> x) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension\n        (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind ->\n    To.Parsetree.class_field_kind\n  =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual\n        (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding ->\n    To.Parsetree.module_binding\n  =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc =\n        (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr ->\n    To.Parsetree.module_expr\n  =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc =\n        (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc ->\n    To.Parsetree.module_expr_desc\n  =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure\n        (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack\n        (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension\n        (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type ->\n    To.Parsetree.module_type\n  =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc =\n        (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc ->\n    To.Parsetree.module_type_desc\n  =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature\n        (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof\n        (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension\n        (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident\n           x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint ->\n    To.Parsetree.with_constraint\n  =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc\n            copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc\n            copy_longident x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc\n             copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature ->\n    To.Parsetree.signature\n  = fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item ->\n    To.Parsetree.signature_item\n  =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc =\n        (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type x0 ->\n      let recflag, types = type_declarations x0 in\n      To.Parsetree.Psig_type (recflag, types)\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description ->\n    To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type ->\n    To.Parsetree.class_type\n  =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc =\n        (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc ->\n    To.Parsetree.class_type_desc\n  =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      let label = copy_arg_label x0 in\n      To.Parsetree.Pcty_arrow\n        (label,\n         copy_core_type (extract_predef_option label x1),\n         copy_class_type x2)\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension\n        (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature ->\n    To.Parsetree.class_signature\n  =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field\n           pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field ->\n    To.Parsetree.class_type_field\n  =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc =\n        (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit\n        (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension\n        (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension ->\n    To.Parsetree.extension\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos ->\n        'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc =\n          (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag ->\n    To.Asttypes.virtual_flag\n  =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc =\n          (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description ->\n    To.Parsetree.open_description\n  =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident\n           popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc =\n        (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag ->\n    To.Asttypes.override_flag\n  =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc =\n        (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc =\n        (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension ->\n    To.Parsetree.type_extension\n  =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident\n           ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc =\n        (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        (To.Parsetree.Pcstr_tuple (List.map copy_core_type x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident\n           x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration ->\n    To.Parsetree.type_declaration\n  =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc =\n        (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag ->\n    To.Asttypes.private_flag\n  =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind ->\n    To.Parsetree.type_kind\n  =\n  function\n  | From.Parsetree.Ptype_abstract  ->\n      To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  ->\n      To.Parsetree.Ptype_open\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration ->\n    To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc =\n        (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag ->\n    To.Asttypes.mutable_flag\n  =\n  function\n  | From.Asttypes.Immutable  ->\n      To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        To.Parsetree.Pcstr_tuple (List.map copy_core_type pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc =\n        (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  ->\n      To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  ->\n      To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  ->\n      To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description ->\n    To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim =\n        (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc =\n        (copy_location pval_loc)\n    }\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag ->\n    To.Asttypes.closed_flag\n  =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label =\n  fun x ->\n    x\n\nand copy_arg_label :\n  From.Asttypes.label -> To.Asttypes.arg_label =\n  fun x ->\n    if x <> \"\" then\n      if x.[0] = '?' then To.Asttypes.Optional (String.sub x 1 (String.length x - 1))\n      else To.Asttypes.Labelled x\n    else\n      To.Asttypes.Nolabel\n\n\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  ->\n      To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  ->\n      To.Asttypes.Recursive\n\nand copy_constant :\n  From.Asttypes.constant -> To.Parsetree.constant =\n  function\n  | From.Asttypes.Const_int x0 ->\n      To.Parsetree.Pconst_integer (string_of_int x0, None)\n  | From.Asttypes.Const_char x0 ->\n      To.Parsetree.Pconst_char x0\n  | From.Asttypes.Const_string (x0,x1) ->\n      To.Parsetree.Pconst_string\n        (x0, (copy_option (fun x  -> x) x1))\n  | From.Asttypes.Const_float x0 ->\n      To.Parsetree.Pconst_float (x0, None)\n  | From.Asttypes.Const_int32 x0 ->\n      To.Parsetree.Pconst_integer (Int32.to_string x0, Some 'l')\n  | From.Asttypes.Const_int64 x0 ->\n      To.Parsetree.Pconst_integer (Int64.to_string x0, Some 'L')\n  | From.Asttypes.Const_nativeint x0 ->\n      To.Parsetree.Pconst_integer (Nativeint.to_string x0, Some 'n')\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident :\n  From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 ->\n      To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun\n      { From.Asttypes.txt = txt;\n        From.Asttypes.loc = loc }\n       ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location :\n  From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nand type_declarations types =\n  let is_nonrec (attr,_) = attr.To.Location.txt = \"nonrec\" in\n  match List.map copy_type_declaration types with\n  | (x :: xs)\n    when List.exists is_nonrec x.To.Parsetree.ptype_attributes ->\n      let ptype_attributes =\n        List.filter (fun x -> not (is_nonrec x)) x.To.Parsetree.ptype_attributes\n      in\n      (To.Asttypes.Nonrecursive,\n       {x with To.Parsetree.ptype_attributes} :: xs)\n  | types -> (To.Asttypes.Recursive, types)\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value (x0,x1,x2) ->\n      To.Outcometree.Osig_value { To.Outcometree.\n                                  oval_name = x0;\n                                  oval_type = copy_out_type x1;\n                                  oval_prims = List.map (fun x -> x) x2;\n                                  oval_attributes = [] }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_private_flag otype_private);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n               (copy_out_type x1))) otype_cstrs);\n      To.Outcometree.otype_immediate = false;\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_private_flag oext_private)\n    }\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_name (x0,x1) ->\n      To.Outcometree.Ovar_name\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int x0 -> To.Parsetree.Pdir_int (string_of_int x0, None)\n  | From.Parsetree.Pdir_ident x0 -> To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 -> To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_402_403_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     (*$*)\n     payload\n   } as mapper) ->\n  let module R = Migrate_parsetree_403_402_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    (*$*)\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload Location.none x)))\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_403_402_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     (*$*)\n     payload\n   } as mapper) ->\n  let module R = Migrate_parsetree_402_403_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    (*$*)\n    payload = (fun _ x -> copy_payload Location.none (payload mapper (R.copy_payload x)))\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule From = Ast_403\nmodule To = Ast_404\n\nlet rec copy_expression :\n  From.Parsetree.expression ->\n    To.Parsetree.expression\n  =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc =\n        (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc =\n        (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes =\n        (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc ->\n    To.Parsetree.expression_desc\n  =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant\n        (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), x1)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert\n        (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy\n        (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (x0, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack\n        (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension\n        (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  ->\n      To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag ->\n    To.Asttypes.direction_flag\n  =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs =\n        (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs =\n        (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding ->\n    To.Parsetree.value_binding\n  =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat =\n        (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc =\n        (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc =\n        (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc ->\n    To.Parsetree.pattern_desc\n  =\n  function\n  | From.Parsetree.Ppat_any  ->\n      To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant\n        (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension\n        (copy_extension x0)\n\nand copy_core_type :\n  From.Parsetree.core_type ->\n    To.Parsetree.core_type\n  =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc =\n        (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc ->\n    To.Parsetree.core_type_desc\n  =\n  function\n  | From.Parsetree.Ptyp_any  ->\n      To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 ->\n      To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (x0, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option\n             (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> x) x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package\n        (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension\n        (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type ->\n    To.Parsetree.package_type\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc\n                copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field ->\n    To.Parsetree.row_field\n  =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit\n        (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes ->\n    To.Parsetree.attributes\n  = fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute ->\n    To.Parsetree.attribute\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr\n        (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig\n        (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp\n        (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure ->\n    To.Parsetree.structure\n  = fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item ->\n    To.Parsetree.structure_item\n  =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc =\n        (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration ->\n    To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr ->\n    To.Parsetree.class_expr\n  =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc =\n        (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc ->\n    To.Parsetree.class_expr_desc\n  =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension\n        (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure ->\n    To.Parsetree.class_structure\n  =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field ->\n    To.Parsetree.class_field\n  =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc =\n        (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc ->\n    To.Parsetree.class_field_desc\n  =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> x) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension\n        (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind ->\n    To.Parsetree.class_field_kind\n  =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual\n        (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding ->\n    To.Parsetree.module_binding\n  =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc =\n        (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr ->\n    To.Parsetree.module_expr\n  =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc =\n        (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc ->\n    To.Parsetree.module_expr_desc\n  =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure\n        (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack\n        (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension\n        (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type ->\n    To.Parsetree.module_type\n  =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc =\n        (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc ->\n    To.Parsetree.module_type_desc\n  =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature\n        (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof\n        (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension\n        (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident\n           x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint ->\n    To.Parsetree.with_constraint\n  =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc\n            copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc\n            copy_longident x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc\n             copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature ->\n    To.Parsetree.signature\n  = fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item ->\n    To.Parsetree.signature_item\n  =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc =\n        (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description ->\n    To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type ->\n    To.Parsetree.class_type\n  =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc =\n        (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc ->\n    To.Parsetree.class_type_desc\n  =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension\n        (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature ->\n    To.Parsetree.class_signature\n  =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field\n           pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field ->\n    To.Parsetree.class_type_field\n  =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc =\n        (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit\n        (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension\n        (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension ->\n    To.Parsetree.extension\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos ->\n        'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc =\n          (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag ->\n    To.Asttypes.virtual_flag\n  =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc =\n          (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description ->\n    To.Parsetree.open_description\n  =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident\n           popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc =\n        (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag ->\n    To.Asttypes.override_flag\n  =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc =\n        (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc =\n        (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension ->\n    To.Parsetree.type_extension\n  =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident\n           ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc =\n        (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident\n           x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration ->\n    To.Parsetree.type_declaration\n  =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc =\n        (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag ->\n    To.Asttypes.private_flag\n  =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind ->\n    To.Parsetree.type_kind\n  =\n  function\n  | From.Parsetree.Ptype_abstract  ->\n      To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  ->\n      To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc =\n        (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration ->\n    To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc =\n        (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag ->\n    To.Asttypes.mutable_flag\n  =\n  function\n  | From.Asttypes.Immutable  ->\n      To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  ->\n      To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  ->\n      To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  ->\n      To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description ->\n    To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim =\n        (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc =\n        (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label\n  =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 ->\n      To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 ->\n      To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag ->\n    To.Asttypes.closed_flag\n  =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label =\n  fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  ->\n      To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  ->\n      To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant\n  =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer\n        (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 ->\n      To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string\n        (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float\n        (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident :\n  From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 ->\n      To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot\n        ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun\n      { From.Asttypes.txt = txt;\n        From.Asttypes.loc = loc }\n       ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location :\n  From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_unboxed = false;\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_name (x0,x1) ->\n      To.Outcometree.Ovar_name\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir (x0, copy_directive_argument x1)\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, copy_option (fun x  -> x) x1)\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Def = Migrate_parsetree_def\nmodule From = Ast_404\nmodule To = Ast_403\n\nlet from_loc {From.Location. txt = _; loc} = loc\n\nlet migration_error location feature =\n  raise (Def.Migration_error (feature, location))\n\nlet rec copy_expression :\n  From.Parsetree.expression ->\n    To.Parsetree.expression\n  =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc =\n        (copy_expression_desc pexp_loc pexp_desc);\n      To.Parsetree.pexp_loc =\n        (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes =\n        (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc loc :\n  From.Parsetree.expression_desc ->\n    To.Parsetree.expression_desc\n  =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant\n        (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), x1)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_letexception _ ->\n      migration_error loc Def.Pexp_letexception\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert\n        (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy\n        (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (x0, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack\n        (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc\n             copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension\n        (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  ->\n      To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag ->\n    To.Asttypes.direction_flag\n  =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs =\n        (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs =\n        (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding ->\n    To.Parsetree.value_binding\n  =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat =\n        (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc =\n        (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_loc ppat_desc);\n      To.Parsetree.ppat_loc =\n        (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc loc :\n  From.Parsetree.pattern_desc ->\n    To.Parsetree.pattern_desc\n  =\n  function\n  | From.Parsetree.Ppat_any  ->\n      To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant\n        (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc\n            copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc\n                   copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception\n        (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension\n        (copy_extension x0)\n  | From.Parsetree.Ppat_open _ ->\n      migration_error loc Def.Ppat_open\nand copy_core_type :\n  From.Parsetree.core_type ->\n    To.Parsetree.core_type\n  =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc =\n        (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc ->\n    To.Parsetree.core_type_desc\n  =\n  function\n  | From.Parsetree.Ptyp_any  ->\n      To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 ->\n      To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (x0, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option\n             (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> x) x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package\n        (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension\n        (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type ->\n    To.Parsetree.package_type\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc\n                copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field ->\n    To.Parsetree.row_field\n  =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit\n        (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes ->\n    To.Parsetree.attributes\n  = fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute ->\n    To.Parsetree.attribute\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr\n        (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig\n        (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp\n        (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure ->\n    To.Parsetree.structure\n  = fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item ->\n    To.Parsetree.structure_item\n  =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc =\n        (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration ->\n    To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr ->\n    To.Parsetree.class_expr\n  =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc =\n        (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc ->\n    To.Parsetree.class_expr_desc\n  =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension\n        (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure ->\n    To.Parsetree.class_structure\n  =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field ->\n    To.Parsetree.class_field\n  =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc =\n        (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc ->\n    To.Parsetree.class_field_desc\n  =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> x) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension\n        (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind ->\n    To.Parsetree.class_field_kind\n  =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual\n        (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding ->\n    To.Parsetree.module_binding\n  =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc =\n        (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr ->\n    To.Parsetree.module_expr\n  =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc =\n        (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc ->\n    To.Parsetree.module_expr_desc\n  =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure\n        (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack\n        (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension\n        (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type ->\n    To.Parsetree.module_type\n  =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc =\n        (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc ->\n    To.Parsetree.module_type_desc\n  =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident\n           x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature\n        (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof\n        (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension\n        (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident\n           x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint ->\n    To.Parsetree.with_constraint\n  =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc\n            copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc\n            copy_longident x0),\n          (copy_loc\n             copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc\n             copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature ->\n    To.Parsetree.signature\n  = fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item ->\n    To.Parsetree.signature_item\n  =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc =\n        (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description ->\n    To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos\n      copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type ->\n    To.Parsetree.class_type\n  =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc =\n        (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc ->\n    To.Parsetree.class_type_desc\n  =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc\n            copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension\n        (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature ->\n    To.Parsetree.class_signature\n  =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field\n           pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field ->\n    To.Parsetree.class_type_field\n  =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc =\n        (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit\n        (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute\n        (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension\n        (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension ->\n    To.Parsetree.extension\n  =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos ->\n        'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc =\n          (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag ->\n    To.Asttypes.virtual_flag\n  =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos\n      copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc =\n          (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description ->\n    To.Parsetree.open_description\n  =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident\n           popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc =\n        (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag ->\n    To.Asttypes.override_flag\n  =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc =\n        (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc =\n        (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension ->\n    To.Parsetree.type_extension\n  =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident\n           ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc =\n        (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident\n           x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration ->\n    To.Parsetree.type_declaration\n  =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc =\n        (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag ->\n    To.Asttypes.private_flag\n  =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind ->\n    To.Parsetree.type_kind\n  =\n  function\n  | From.Parsetree.Ptype_abstract  ->\n      To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  ->\n      To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc =\n        (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration ->\n    To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc =\n        (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag ->\n    To.Asttypes.mutable_flag\n  =\n  function\n  | From.Asttypes.Immutable  ->\n      To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  ->\n      To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  ->\n      To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  ->\n      To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description ->\n    To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim =\n        (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc =\n        (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label\n  =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 ->\n      To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 ->\n      To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag ->\n    To.Asttypes.closed_flag\n  =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label =\n  fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  ->\n      To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  ->\n      To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant\n  =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer\n        (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 ->\n      To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string\n        (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float\n        (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident :\n  From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 ->\n      To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot\n        ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun\n      { From.Asttypes.txt = txt;\n        From.Asttypes.loc = loc }\n       ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location :\n  From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_unboxed = _otype_unboxed;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_name (x0,x1) ->\n      To.Outcometree.Ovar_name\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_403_404_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_404_403_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_404_403_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_403_404_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule From = Ast_404\nmodule To = Ast_405\n\nlet noloc x = { Location. txt = x; loc = Location.none }\n\nlet rec copy_expression :\n  From.Parsetree.expression -> To.Parsetree.expression =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc = (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), noloc x1)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_letexception (x0,x1) ->\n      To.Parsetree.Pexp_letexception\n        ((copy_extension_constructor x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (noloc x0, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs = (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding -> To.Parsetree.value_binding =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc = (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc = (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =\n  function\n  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension (copy_extension x0)\n  | From.Parsetree.Ppat_open (x0,x1) ->\n      To.Parsetree.Ppat_open\n        ((copy_loc copy_longident x0),\n          (copy_pattern x1))\n\nand copy_core_type :\n  From.Parsetree.core_type -> To.Parsetree.core_type =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =\n  function\n  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (noloc x0, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> noloc x) x0), (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type -> To.Parsetree.package_type =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field -> To.Parsetree.row_field =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes -> To.Parsetree.attributes =\n  fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute -> To.Parsetree.attribute =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure -> To.Parsetree.structure =\n  fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item -> To.Parsetree.structure_item =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc = (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration -> To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr -> To.Parsetree.class_expr =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc = (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure -> To.Parsetree.class_structure =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field -> To.Parsetree.class_field =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc = (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> noloc x) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding -> To.Parsetree.module_binding =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc = (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr -> To.Parsetree.module_expr =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc = (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type -> To.Parsetree.module_type =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc = (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc copy_longident x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature -> To.Parsetree.signature =\n  fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item -> To.Parsetree.signature_item =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc = (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description -> To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type -> To.Parsetree.class_type =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc = (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature -> To.Parsetree.class_signature =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc = (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (noloc x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (noloc x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension -> To.Parsetree.extension =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc = (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc = (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description -> To.Parsetree.open_description =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc = (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag -> To.Asttypes.override_flag =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc = (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension -> To.Parsetree.type_extension =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc = (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc = (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind -> To.Parsetree.type_kind =\n  function\n  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc = (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration -> To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc = (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =\n  function\n  | From.Asttypes.Immutable  -> To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  -> To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  -> To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description -> To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc = (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label = fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  -> To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident : From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 -> To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location : From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_unboxed = otype_unboxed;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_name (x0,x1) ->\n      To.Outcometree.Ovar_typ\n        (To.Outcometree.Otyp_constr\n           ((copy_out_ident x0),\n            (List.map copy_out_type x1)))\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule From = Ast_405\nmodule To = Ast_404\n\nlet rec copy_expression :\n  From.Parsetree.expression -> To.Parsetree.expression =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc =\n        (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc = (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes =\n        (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), x1.From.Asttypes.txt)\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_letexception (x0,x1) ->\n      To.Parsetree.Pexp_letexception\n        ((copy_extension_constructor x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        (x0.From.Asttypes.txt, (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs = (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding -> To.Parsetree.value_binding =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc = (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc = (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =\n  function\n  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension (copy_extension x0)\n  | From.Parsetree.Ppat_open (x0,x1) ->\n      To.Parsetree.Ppat_open\n        ((copy_loc copy_longident x0),\n          (copy_pattern x1))\n\nand copy_core_type :\n  From.Parsetree.core_type -> To.Parsetree.core_type =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =\n  function\n  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               (x0.From.Asttypes.txt, (copy_attributes x1),\n                 (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> x.From.Asttypes.txt) x0), (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type -> To.Parsetree.package_type =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field -> To.Parsetree.row_field =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes -> To.Parsetree.attributes =\n  fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute -> To.Parsetree.attribute =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure -> To.Parsetree.structure =\n  fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item -> To.Parsetree.structure_item =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc = (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration -> To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr -> To.Parsetree.class_expr =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc = (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure -> To.Parsetree.class_structure =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field -> To.Parsetree.class_field =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc = (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (fun x  -> x.From.Asttypes.txt) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding -> To.Parsetree.module_binding =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc = (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr -> To.Parsetree.module_expr =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc = (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type -> To.Parsetree.module_type =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc = (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc copy_longident x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature -> To.Parsetree.signature =\n  fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item -> To.Parsetree.signature_item =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc = (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description -> To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type -> To.Parsetree.class_type =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc = (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature -> To.Parsetree.class_signature =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc = (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (x0.From.Asttypes.txt, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (x0.From.Asttypes.txt, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension -> To.Parsetree.extension =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc = (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc = (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description -> To.Parsetree.open_description =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc = (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag -> To.Asttypes.override_flag =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc = (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension -> To.Parsetree.type_extension =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc = (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc = (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind -> To.Parsetree.type_kind =\n  function\n  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc = (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration -> To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc = (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =\n  function\n  | From.Asttypes.Immutable  -> To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  -> To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  -> To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description -> To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc = (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label = fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  -> To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident : From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 -> To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location : From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_unboxed = otype_unboxed;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_typ (From.Outcometree.Otyp_constr (id,tyl)) ->\n      To.Outcometree.Ovar_name (copy_out_ident id, List.map copy_out_type tyl)\n  | From.Outcometree.Ovar_typ x0 ->\n      To.Outcometree.Ovar_name\n        (To.Outcometree.Oide_ident \"\", [copy_out_type x0])\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_404_405_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_405_404_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_405_404_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_404_405_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule From = Ast_405\nmodule To = Ast_406\n\nlet rec copy_expression :\n  From.Parsetree.expression -> To.Parsetree.expression =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc = (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_letexception (x0,x1) ->\n      To.Parsetree.Pexp_letexception\n        ((copy_extension_constructor x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        ((copy_loc (fun x  -> x) x0), (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs = (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding -> To.Parsetree.value_binding =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc = (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc = (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =\n  function\n  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension (copy_extension x0)\n  | From.Parsetree.Ppat_open (x0,x1) ->\n      To.Parsetree.Ppat_open\n        ((copy_loc copy_longident x0),\n          (copy_pattern x1))\n\nand copy_core_type :\n  From.Parsetree.core_type -> To.Parsetree.core_type =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =\n  function\n  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1,x2) = x  in\n               To.Parsetree.Otag\n                 (copy_loc (fun x  -> x) x0, (copy_attributes x1),\n                  (copy_core_type x2))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> copy_loc (fun x  -> x) x) x0), (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type -> To.Parsetree.package_type =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field -> To.Parsetree.row_field =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        (({ txt = copy_label x0; loc = Location.none; }),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes -> To.Parsetree.attributes =\n  fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute -> To.Parsetree.attribute =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure -> To.Parsetree.structure =\n  fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item -> To.Parsetree.structure_item =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc = (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration -> To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr -> To.Parsetree.class_expr =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc = (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension (copy_extension x0)\n\nand copy_class_structure :\n  From.Parsetree.class_structure -> To.Parsetree.class_structure =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field -> To.Parsetree.class_field =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc = (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (copy_loc (fun x  -> x)) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding -> To.Parsetree.module_binding =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc = (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr -> To.Parsetree.module_expr =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc = (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type -> To.Parsetree.module_type =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc = (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc copy_longident x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature -> To.Parsetree.signature =\n  fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item -> To.Parsetree.signature_item =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc = (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description -> To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type -> To.Parsetree.class_type =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc = (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension (copy_extension x0)\n\nand copy_class_signature :\n  From.Parsetree.class_signature -> To.Parsetree.class_signature =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc = (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (copy_loc (fun x  -> x) x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (copy_loc (fun x  -> x) x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension -> To.Parsetree.extension =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc = (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc = (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description -> To.Parsetree.open_description =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc = (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag -> To.Asttypes.override_flag =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc = (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension -> To.Parsetree.type_extension =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc = (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc = (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind -> To.Parsetree.type_kind =\n  function\n  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc = (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration -> To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc = (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =\n  function\n  | From.Asttypes.Immutable  -> To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  -> To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  -> To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description -> To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc = (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label = fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  -> To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident : From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 -> To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location : From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_unboxed = otype_unboxed;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_typ x0 ->\n      To.Outcometree.Ovar_typ (copy_out_type x0)\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string x0 ->\n      To.Outcometree.Oval_string (x0, max_int, Ostr_string)\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                         Alain Frisch, LexiFi                           *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\nmodule Def = Migrate_parsetree_def\nmodule From = Ast_406\nmodule To = Ast_405\n\nlet migration_error location feature =\n  raise (Def.Migration_error (feature, location))\n\nlet rec copy_expression :\n  From.Parsetree.expression -> To.Parsetree.expression =\n  fun\n    { From.Parsetree.pexp_desc = pexp_desc;\n      From.Parsetree.pexp_loc = pexp_loc;\n      From.Parsetree.pexp_attributes = pexp_attributes }\n     ->\n    {\n      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);\n      To.Parsetree.pexp_loc = (copy_location pexp_loc);\n      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)\n    }\n\nand copy_expression_desc :\n  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =\n  function\n  | From.Parsetree.Pexp_ident x0 ->\n      To.Parsetree.Pexp_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_constant x0 ->\n      To.Parsetree.Pexp_constant (copy_constant x0)\n  | From.Parsetree.Pexp_let (x0,x1,x2) ->\n      To.Parsetree.Pexp_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_function x0 ->\n      To.Parsetree.Pexp_function\n        (List.map copy_case x0)\n  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pexp_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_expression x3))\n  | From.Parsetree.Pexp_apply (x0,x1) ->\n      To.Parsetree.Pexp_apply\n        ((copy_expression x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pexp_match (x0,x1) ->\n      To.Parsetree.Pexp_match\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_try (x0,x1) ->\n      To.Parsetree.Pexp_try\n        ((copy_expression x0),\n          (List.map copy_case x1))\n  | From.Parsetree.Pexp_tuple x0 ->\n      To.Parsetree.Pexp_tuple\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_construct (x0,x1) ->\n      To.Parsetree.Pexp_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_variant (x0,x1) ->\n      To.Parsetree.Pexp_variant\n        ((copy_label x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_record (x0,x1) ->\n      To.Parsetree.Pexp_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_expression x1))) x0),\n          (copy_option copy_expression x1))\n  | From.Parsetree.Pexp_field (x0,x1) ->\n      To.Parsetree.Pexp_field\n        ((copy_expression x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->\n      To.Parsetree.Pexp_setfield\n        ((copy_expression x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_array x0 ->\n      To.Parsetree.Pexp_array\n        (List.map copy_expression x0)\n  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->\n      To.Parsetree.Pexp_ifthenelse\n        ((copy_expression x0),\n          (copy_expression x1),\n          (copy_option copy_expression x2))\n  | From.Parsetree.Pexp_sequence (x0,x1) ->\n      To.Parsetree.Pexp_sequence\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_while (x0,x1) ->\n      To.Parsetree.Pexp_while\n        ((copy_expression x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->\n      To.Parsetree.Pexp_for\n        ((copy_pattern x0),\n          (copy_expression x1),\n          (copy_expression x2),\n          (copy_direction_flag x3),\n          (copy_expression x4))\n  | From.Parsetree.Pexp_constraint (x0,x1) ->\n      To.Parsetree.Pexp_constraint\n        ((copy_expression x0),\n          (copy_core_type x1))\n  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->\n      To.Parsetree.Pexp_coerce\n        ((copy_expression x0),\n          (copy_option copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Pexp_send (x0,x1) ->\n      To.Parsetree.Pexp_send\n        ((copy_expression x0), (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Pexp_new x0 ->\n      To.Parsetree.Pexp_new\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pexp_setinstvar (x0,x1) ->\n      To.Parsetree.Pexp_setinstvar\n        ((copy_loc (fun x  -> x) x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_override x0 ->\n      To.Parsetree.Pexp_override\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_loc (fun x  -> x) x0),\n                (copy_expression x1))) x0)\n  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->\n      To.Parsetree.Pexp_letmodule\n        ((copy_loc (fun x  -> x) x0),\n          (copy_module_expr x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_letexception (x0,x1) ->\n      To.Parsetree.Pexp_letexception\n        ((copy_extension_constructor x0),\n          (copy_expression x1))\n  | From.Parsetree.Pexp_assert x0 ->\n      To.Parsetree.Pexp_assert (copy_expression x0)\n  | From.Parsetree.Pexp_lazy x0 ->\n      To.Parsetree.Pexp_lazy (copy_expression x0)\n  | From.Parsetree.Pexp_poly (x0,x1) ->\n      To.Parsetree.Pexp_poly\n        ((copy_expression x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pexp_object x0 ->\n      To.Parsetree.Pexp_object\n        (copy_class_structure x0)\n  | From.Parsetree.Pexp_newtype (x0,x1) ->\n      To.Parsetree.Pexp_newtype\n        ((copy_loc (fun x  -> x) x0), (copy_expression x1))\n  | From.Parsetree.Pexp_pack x0 ->\n      To.Parsetree.Pexp_pack (copy_module_expr x0)\n  | From.Parsetree.Pexp_open (x0,x1,x2) ->\n      To.Parsetree.Pexp_open\n        ((copy_override_flag x0),\n          (copy_loc copy_longident x1),\n          (copy_expression x2))\n  | From.Parsetree.Pexp_extension x0 ->\n      To.Parsetree.Pexp_extension (copy_extension x0)\n  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable\n\nand copy_direction_flag :\n  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =\n  function\n  | From.Asttypes.Upto  -> To.Asttypes.Upto\n  | From.Asttypes.Downto  -> To.Asttypes.Downto\n\nand copy_case :\n  From.Parsetree.case -> To.Parsetree.case =\n  fun\n    { From.Parsetree.pc_lhs = pc_lhs;\n      From.Parsetree.pc_guard = pc_guard;\n      From.Parsetree.pc_rhs = pc_rhs }\n     ->\n    {\n      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);\n      To.Parsetree.pc_guard =\n        (copy_option copy_expression pc_guard);\n      To.Parsetree.pc_rhs = (copy_expression pc_rhs)\n    }\n\nand copy_value_binding :\n  From.Parsetree.value_binding -> To.Parsetree.value_binding =\n  fun\n    { From.Parsetree.pvb_pat = pvb_pat;\n      From.Parsetree.pvb_expr = pvb_expr;\n      From.Parsetree.pvb_attributes = pvb_attributes;\n      From.Parsetree.pvb_loc = pvb_loc }\n     ->\n    {\n      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);\n      To.Parsetree.pvb_expr =\n        (copy_expression pvb_expr);\n      To.Parsetree.pvb_attributes =\n        (copy_attributes pvb_attributes);\n      To.Parsetree.pvb_loc = (copy_location pvb_loc)\n    }\n\nand copy_pattern :\n  From.Parsetree.pattern -> To.Parsetree.pattern =\n  fun\n    { From.Parsetree.ppat_desc = ppat_desc;\n      From.Parsetree.ppat_loc = ppat_loc;\n      From.Parsetree.ppat_attributes = ppat_attributes }\n     ->\n    {\n      To.Parsetree.ppat_desc =\n        (copy_pattern_desc ppat_desc);\n      To.Parsetree.ppat_loc = (copy_location ppat_loc);\n      To.Parsetree.ppat_attributes =\n        (copy_attributes ppat_attributes)\n    }\n\nand copy_pattern_desc :\n  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =\n  function\n  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any\n  | From.Parsetree.Ppat_var x0 ->\n      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_alias (x0,x1) ->\n      To.Parsetree.Ppat_alias\n        ((copy_pattern x0),\n          (copy_loc (fun x  -> x) x1))\n  | From.Parsetree.Ppat_constant x0 ->\n      To.Parsetree.Ppat_constant (copy_constant x0)\n  | From.Parsetree.Ppat_interval (x0,x1) ->\n      To.Parsetree.Ppat_interval\n        ((copy_constant x0),\n          (copy_constant x1))\n  | From.Parsetree.Ppat_tuple x0 ->\n      To.Parsetree.Ppat_tuple\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_construct (x0,x1) ->\n      To.Parsetree.Ppat_construct\n        ((copy_loc copy_longident x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_variant (x0,x1) ->\n      To.Parsetree.Ppat_variant\n        ((copy_label x0),\n          (copy_option copy_pattern x1))\n  | From.Parsetree.Ppat_record (x0,x1) ->\n      To.Parsetree.Ppat_record\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               ((copy_loc copy_longident x0),\n                 (copy_pattern x1))) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ppat_array x0 ->\n      To.Parsetree.Ppat_array\n        (List.map copy_pattern x0)\n  | From.Parsetree.Ppat_or (x0,x1) ->\n      To.Parsetree.Ppat_or\n        ((copy_pattern x0),\n          (copy_pattern x1))\n  | From.Parsetree.Ppat_constraint (x0,x1) ->\n      To.Parsetree.Ppat_constraint\n        ((copy_pattern x0),\n          (copy_core_type x1))\n  | From.Parsetree.Ppat_type x0 ->\n      To.Parsetree.Ppat_type\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Ppat_lazy x0 ->\n      To.Parsetree.Ppat_lazy (copy_pattern x0)\n  | From.Parsetree.Ppat_unpack x0 ->\n      To.Parsetree.Ppat_unpack\n        (copy_loc (fun x  -> x) x0)\n  | From.Parsetree.Ppat_exception x0 ->\n      To.Parsetree.Ppat_exception (copy_pattern x0)\n  | From.Parsetree.Ppat_extension x0 ->\n      To.Parsetree.Ppat_extension (copy_extension x0)\n  | From.Parsetree.Ppat_open (x0,x1) ->\n      To.Parsetree.Ppat_open\n        ((copy_loc copy_longident x0),\n          (copy_pattern x1))\n\nand copy_core_type :\n  From.Parsetree.core_type -> To.Parsetree.core_type =\n  fun\n    { From.Parsetree.ptyp_desc = ptyp_desc;\n      From.Parsetree.ptyp_loc = ptyp_loc;\n      From.Parsetree.ptyp_attributes = ptyp_attributes }\n     ->\n    {\n      To.Parsetree.ptyp_desc =\n        (copy_core_type_desc ptyp_desc);\n      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);\n      To.Parsetree.ptyp_attributes =\n        (copy_attributes ptyp_attributes)\n    }\n\nand copy_core_type_desc :\n  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =\n  function\n  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any\n  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0\n  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->\n      To.Parsetree.Ptyp_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_core_type x2))\n  | From.Parsetree.Ptyp_tuple x0 ->\n      To.Parsetree.Ptyp_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Ptyp_constr (x0,x1) ->\n      To.Parsetree.Ptyp_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_object (x0,x1) ->\n      To.Parsetree.Ptyp_object\n        ((List.map\n            (function\n              | From.Parsetree.Otag (x0,x1,x2) ->\n               (copy_loc (fun x  -> x) x0, (copy_attributes x1),\n                (copy_core_type x2))\n              | From.Parsetree.Oinherit _ ->\n                migration_error Location.none Def.Oinherit) x0),\n          (copy_closed_flag x1))\n  | From.Parsetree.Ptyp_class (x0,x1) ->\n      To.Parsetree.Ptyp_class\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Ptyp_alias (x0,x1) ->\n      To.Parsetree.Ptyp_alias\n        ((copy_core_type x0), x1)\n  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->\n      To.Parsetree.Ptyp_variant\n        ((List.map copy_row_field x0),\n          (copy_closed_flag x1),\n          (copy_option (fun x  -> List.map copy_label x) x2))\n  | From.Parsetree.Ptyp_poly (x0,x1) ->\n      To.Parsetree.Ptyp_poly\n        ((List.map (fun x  -> copy_loc (fun x  -> x) x) x0), (copy_core_type x1))\n  | From.Parsetree.Ptyp_package x0 ->\n      To.Parsetree.Ptyp_package (copy_package_type x0)\n  | From.Parsetree.Ptyp_extension x0 ->\n      To.Parsetree.Ptyp_extension (copy_extension x0)\n\nand copy_package_type :\n  From.Parsetree.package_type -> To.Parsetree.package_type =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc copy_longident x0),\n      (List.map\n         (fun x  ->\n            let (x0,x1) = x  in\n            ((copy_loc copy_longident x0),\n              (copy_core_type x1))) x1))\n\nand copy_row_field :\n  From.Parsetree.row_field -> To.Parsetree.row_field =\n  function\n  | From.Parsetree.Rtag (x0,x1,x2,x3) ->\n      To.Parsetree.Rtag\n        ((copy_label x0.txt),\n          (copy_attributes x1), (copy_bool x2),\n          (List.map copy_core_type x3))\n  | From.Parsetree.Rinherit x0 ->\n      To.Parsetree.Rinherit (copy_core_type x0)\n\nand copy_attributes :\n  From.Parsetree.attributes -> To.Parsetree.attributes =\n  fun x  -> List.map copy_attribute x\n\nand copy_attribute :\n  From.Parsetree.attribute -> To.Parsetree.attribute =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_payload :\n  From.Parsetree.payload -> To.Parsetree.payload =\n  function\n  | From.Parsetree.PStr x0 ->\n      To.Parsetree.PStr (copy_structure x0)\n  | From.Parsetree.PSig x0 ->\n      To.Parsetree.PSig (copy_signature x0)\n  | From.Parsetree.PTyp x0 ->\n      To.Parsetree.PTyp (copy_core_type x0)\n  | From.Parsetree.PPat (x0,x1) ->\n      To.Parsetree.PPat\n        ((copy_pattern x0),\n          (copy_option copy_expression x1))\n\nand copy_structure :\n  From.Parsetree.structure -> To.Parsetree.structure =\n  fun x  -> List.map copy_structure_item x\n\nand copy_structure_item :\n  From.Parsetree.structure_item -> To.Parsetree.structure_item =\n  fun\n    { From.Parsetree.pstr_desc = pstr_desc;\n      From.Parsetree.pstr_loc = pstr_loc }\n     ->\n    {\n      To.Parsetree.pstr_desc =\n        (copy_structure_item_desc pstr_desc);\n      To.Parsetree.pstr_loc = (copy_location pstr_loc)\n    }\n\nand copy_structure_item_desc :\n  From.Parsetree.structure_item_desc ->\n    To.Parsetree.structure_item_desc\n  =\n  function\n  | From.Parsetree.Pstr_eval (x0,x1) ->\n      To.Parsetree.Pstr_eval\n        ((copy_expression x0),\n          (copy_attributes x1))\n  | From.Parsetree.Pstr_value (x0,x1) ->\n      To.Parsetree.Pstr_value\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1))\n  | From.Parsetree.Pstr_primitive x0 ->\n      To.Parsetree.Pstr_primitive\n        (copy_value_description x0)\n  | From.Parsetree.Pstr_type (x0,x1) ->\n      To.Parsetree.Pstr_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Pstr_typext x0 ->\n      To.Parsetree.Pstr_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Pstr_exception x0 ->\n      To.Parsetree.Pstr_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Pstr_module x0 ->\n      To.Parsetree.Pstr_module\n        (copy_module_binding x0)\n  | From.Parsetree.Pstr_recmodule x0 ->\n      To.Parsetree.Pstr_recmodule\n        (List.map copy_module_binding x0)\n  | From.Parsetree.Pstr_modtype x0 ->\n      To.Parsetree.Pstr_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Pstr_open x0 ->\n      To.Parsetree.Pstr_open\n        (copy_open_description x0)\n  | From.Parsetree.Pstr_class x0 ->\n      To.Parsetree.Pstr_class\n        (List.map copy_class_declaration x0)\n  | From.Parsetree.Pstr_class_type x0 ->\n      To.Parsetree.Pstr_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Pstr_include x0 ->\n      To.Parsetree.Pstr_include\n        (copy_include_declaration x0)\n  | From.Parsetree.Pstr_attribute x0 ->\n      To.Parsetree.Pstr_attribute (copy_attribute x0)\n  | From.Parsetree.Pstr_extension (x0,x1) ->\n      To.Parsetree.Pstr_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_include_declaration :\n  From.Parsetree.include_declaration ->\n    To.Parsetree.include_declaration\n  =\n  fun x  ->\n    copy_include_infos copy_module_expr x\n\nand copy_class_declaration :\n  From.Parsetree.class_declaration -> To.Parsetree.class_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_expr x\n\nand copy_class_expr :\n  From.Parsetree.class_expr -> To.Parsetree.class_expr =\n  fun\n    { From.Parsetree.pcl_desc = pcl_desc;\n      From.Parsetree.pcl_loc = pcl_loc;\n      From.Parsetree.pcl_attributes = pcl_attributes }\n     ->\n    {\n      To.Parsetree.pcl_desc =\n        (copy_class_expr_desc pcl_desc);\n      To.Parsetree.pcl_loc = (copy_location pcl_loc);\n      To.Parsetree.pcl_attributes =\n        (copy_attributes pcl_attributes)\n    }\n\nand copy_class_expr_desc :\n  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =\n  function\n  | From.Parsetree.Pcl_constr (x0,x1) ->\n      To.Parsetree.Pcl_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcl_structure x0 ->\n      To.Parsetree.Pcl_structure\n        (copy_class_structure x0)\n  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->\n      To.Parsetree.Pcl_fun\n        ((copy_arg_label x0),\n          (copy_option copy_expression x1),\n          (copy_pattern x2),\n          (copy_class_expr x3))\n  | From.Parsetree.Pcl_apply (x0,x1) ->\n      To.Parsetree.Pcl_apply\n        ((copy_class_expr x0),\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_arg_label x0),\n                  (copy_expression x1))) x1))\n  | From.Parsetree.Pcl_let (x0,x1,x2) ->\n      To.Parsetree.Pcl_let\n        ((copy_rec_flag x0),\n          (List.map copy_value_binding x1),\n          (copy_class_expr x2))\n  | From.Parsetree.Pcl_constraint (x0,x1) ->\n      To.Parsetree.Pcl_constraint\n        ((copy_class_expr x0),\n          (copy_class_type x1))\n  | From.Parsetree.Pcl_extension x0 ->\n      To.Parsetree.Pcl_extension (copy_extension x0)\n  | From.Parsetree.Pcl_open (_, loc, _) ->\n      migration_error loc.From.Location.loc Def.Pcl_open\n\nand copy_class_structure :\n  From.Parsetree.class_structure -> To.Parsetree.class_structure =\n  fun\n    { From.Parsetree.pcstr_self = pcstr_self;\n      From.Parsetree.pcstr_fields = pcstr_fields }\n     ->\n    {\n      To.Parsetree.pcstr_self =\n        (copy_pattern pcstr_self);\n      To.Parsetree.pcstr_fields =\n        (List.map copy_class_field pcstr_fields)\n    }\n\nand copy_class_field :\n  From.Parsetree.class_field -> To.Parsetree.class_field =\n  fun\n    { From.Parsetree.pcf_desc = pcf_desc;\n      From.Parsetree.pcf_loc = pcf_loc;\n      From.Parsetree.pcf_attributes = pcf_attributes }\n     ->\n    {\n      To.Parsetree.pcf_desc =\n        (copy_class_field_desc pcf_desc);\n      To.Parsetree.pcf_loc = (copy_location pcf_loc);\n      To.Parsetree.pcf_attributes =\n        (copy_attributes pcf_attributes)\n    }\n\nand copy_class_field_desc :\n  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =\n  function\n  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->\n      To.Parsetree.Pcf_inherit\n        ((copy_override_flag x0),\n          (copy_class_expr x1),\n          (copy_option (copy_loc (fun x  -> x)) x2))\n  | From.Parsetree.Pcf_val x0 ->\n      To.Parsetree.Pcf_val\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_mutable_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_method x0 ->\n      To.Parsetree.Pcf_method\n        (let (x0,x1,x2) = x0  in\n         ((copy_loc (fun x  -> x) x0),\n           (copy_private_flag x1),\n           (copy_class_field_kind x2)))\n  | From.Parsetree.Pcf_constraint x0 ->\n      To.Parsetree.Pcf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pcf_initializer x0 ->\n      To.Parsetree.Pcf_initializer\n        (copy_expression x0)\n  | From.Parsetree.Pcf_attribute x0 ->\n      To.Parsetree.Pcf_attribute (copy_attribute x0)\n  | From.Parsetree.Pcf_extension x0 ->\n      To.Parsetree.Pcf_extension (copy_extension x0)\n\nand copy_class_field_kind :\n  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =\n  function\n  | From.Parsetree.Cfk_virtual x0 ->\n      To.Parsetree.Cfk_virtual (copy_core_type x0)\n  | From.Parsetree.Cfk_concrete (x0,x1) ->\n      To.Parsetree.Cfk_concrete\n        ((copy_override_flag x0),\n          (copy_expression x1))\n\nand copy_module_binding :\n  From.Parsetree.module_binding -> To.Parsetree.module_binding =\n  fun\n    { From.Parsetree.pmb_name = pmb_name;\n      From.Parsetree.pmb_expr = pmb_expr;\n      From.Parsetree.pmb_attributes = pmb_attributes;\n      From.Parsetree.pmb_loc = pmb_loc }\n     ->\n    {\n      To.Parsetree.pmb_name =\n        (copy_loc (fun x  -> x) pmb_name);\n      To.Parsetree.pmb_expr =\n        (copy_module_expr pmb_expr);\n      To.Parsetree.pmb_attributes =\n        (copy_attributes pmb_attributes);\n      To.Parsetree.pmb_loc = (copy_location pmb_loc)\n    }\n\nand copy_module_expr :\n  From.Parsetree.module_expr -> To.Parsetree.module_expr =\n  fun\n    { From.Parsetree.pmod_desc = pmod_desc;\n      From.Parsetree.pmod_loc = pmod_loc;\n      From.Parsetree.pmod_attributes = pmod_attributes }\n     ->\n    {\n      To.Parsetree.pmod_desc =\n        (copy_module_expr_desc pmod_desc);\n      To.Parsetree.pmod_loc = (copy_location pmod_loc);\n      To.Parsetree.pmod_attributes =\n        (copy_attributes pmod_attributes)\n    }\n\nand copy_module_expr_desc :\n  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =\n  function\n  | From.Parsetree.Pmod_ident x0 ->\n      To.Parsetree.Pmod_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmod_structure x0 ->\n      To.Parsetree.Pmod_structure (copy_structure x0)\n  | From.Parsetree.Pmod_functor (x0,x1,x2) ->\n      To.Parsetree.Pmod_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_expr x2))\n  | From.Parsetree.Pmod_apply (x0,x1) ->\n      To.Parsetree.Pmod_apply\n        ((copy_module_expr x0),\n          (copy_module_expr x1))\n  | From.Parsetree.Pmod_constraint (x0,x1) ->\n      To.Parsetree.Pmod_constraint\n        ((copy_module_expr x0),\n          (copy_module_type x1))\n  | From.Parsetree.Pmod_unpack x0 ->\n      To.Parsetree.Pmod_unpack (copy_expression x0)\n  | From.Parsetree.Pmod_extension x0 ->\n      To.Parsetree.Pmod_extension (copy_extension x0)\n\nand copy_module_type :\n  From.Parsetree.module_type -> To.Parsetree.module_type =\n  fun\n    { From.Parsetree.pmty_desc = pmty_desc;\n      From.Parsetree.pmty_loc = pmty_loc;\n      From.Parsetree.pmty_attributes = pmty_attributes }\n     ->\n    {\n      To.Parsetree.pmty_desc =\n        (copy_module_type_desc pmty_desc);\n      To.Parsetree.pmty_loc = (copy_location pmty_loc);\n      To.Parsetree.pmty_attributes =\n        (copy_attributes pmty_attributes)\n    }\n\nand copy_module_type_desc :\n  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =\n  function\n  | From.Parsetree.Pmty_ident x0 ->\n      To.Parsetree.Pmty_ident\n        (copy_loc copy_longident x0)\n  | From.Parsetree.Pmty_signature x0 ->\n      To.Parsetree.Pmty_signature (copy_signature x0)\n  | From.Parsetree.Pmty_functor (x0,x1,x2) ->\n      To.Parsetree.Pmty_functor\n        ((copy_loc (fun x  -> x) x0),\n          (copy_option copy_module_type x1),\n          (copy_module_type x2))\n  | From.Parsetree.Pmty_with (x0,x1) ->\n      To.Parsetree.Pmty_with\n        ((copy_module_type x0),\n          (List.map copy_with_constraint x1))\n  | From.Parsetree.Pmty_typeof x0 ->\n      To.Parsetree.Pmty_typeof (copy_module_expr x0)\n  | From.Parsetree.Pmty_extension x0 ->\n      To.Parsetree.Pmty_extension (copy_extension x0)\n  | From.Parsetree.Pmty_alias x0 ->\n      To.Parsetree.Pmty_alias\n        (copy_loc copy_longident x0)\n\nand copy_with_constraint :\n  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =\n  function\n  | From.Parsetree.Pwith_type (x0,x1) ->\n      To.Parsetree.Pwith_type\n        ((copy_loc copy_longident x0),\n          (copy_type_declaration x1))\n  | From.Parsetree.Pwith_module (x0,x1) ->\n      To.Parsetree.Pwith_module\n        ((copy_loc copy_longident x0),\n          (copy_loc copy_longident x1))\n  | From.Parsetree.Pwith_typesubst x0 ->\n      To.Parsetree.Pwith_typesubst\n        (copy_type_declaration x0)\n  | From.Parsetree.Pwith_modsubst (x0,x1) ->\n      To.Parsetree.Pwith_modsubst\n        ((copy_loc (fun x  -> x) x0),\n          (copy_loc copy_longident x1))\n\nand copy_signature :\n  From.Parsetree.signature -> To.Parsetree.signature =\n  fun x  -> List.map copy_signature_item x\n\nand copy_signature_item :\n  From.Parsetree.signature_item -> To.Parsetree.signature_item =\n  fun\n    { From.Parsetree.psig_desc = psig_desc;\n      From.Parsetree.psig_loc = psig_loc }\n     ->\n    {\n      To.Parsetree.psig_desc =\n        (copy_signature_item_desc psig_desc);\n      To.Parsetree.psig_loc = (copy_location psig_loc)\n    }\n\nand copy_signature_item_desc :\n  From.Parsetree.signature_item_desc ->\n    To.Parsetree.signature_item_desc\n  =\n  function\n  | From.Parsetree.Psig_value x0 ->\n      To.Parsetree.Psig_value\n        (copy_value_description x0)\n  | From.Parsetree.Psig_type (x0,x1) ->\n      To.Parsetree.Psig_type\n        ((copy_rec_flag x0),\n          (List.map copy_type_declaration x1))\n  | From.Parsetree.Psig_typext x0 ->\n      To.Parsetree.Psig_typext\n        (copy_type_extension x0)\n  | From.Parsetree.Psig_exception x0 ->\n      To.Parsetree.Psig_exception\n        (copy_extension_constructor x0)\n  | From.Parsetree.Psig_module x0 ->\n      To.Parsetree.Psig_module\n        (copy_module_declaration x0)\n  | From.Parsetree.Psig_recmodule x0 ->\n      To.Parsetree.Psig_recmodule\n        (List.map copy_module_declaration x0)\n  | From.Parsetree.Psig_modtype x0 ->\n      To.Parsetree.Psig_modtype\n        (copy_module_type_declaration x0)\n  | From.Parsetree.Psig_open x0 ->\n      To.Parsetree.Psig_open\n        (copy_open_description x0)\n  | From.Parsetree.Psig_include x0 ->\n      To.Parsetree.Psig_include\n        (copy_include_description x0)\n  | From.Parsetree.Psig_class x0 ->\n      To.Parsetree.Psig_class\n        (List.map copy_class_description x0)\n  | From.Parsetree.Psig_class_type x0 ->\n      To.Parsetree.Psig_class_type\n        (List.map copy_class_type_declaration x0)\n  | From.Parsetree.Psig_attribute x0 ->\n      To.Parsetree.Psig_attribute (copy_attribute x0)\n  | From.Parsetree.Psig_extension (x0,x1) ->\n      To.Parsetree.Psig_extension\n        ((copy_extension x0),\n          (copy_attributes x1))\n\nand copy_class_type_declaration :\n  From.Parsetree.class_type_declaration ->\n    To.Parsetree.class_type_declaration\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_description :\n  From.Parsetree.class_description -> To.Parsetree.class_description\n  =\n  fun x  ->\n    copy_class_infos copy_class_type x\n\nand copy_class_type :\n  From.Parsetree.class_type -> To.Parsetree.class_type =\n  fun\n    { From.Parsetree.pcty_desc = pcty_desc;\n      From.Parsetree.pcty_loc = pcty_loc;\n      From.Parsetree.pcty_attributes = pcty_attributes }\n     ->\n    {\n      To.Parsetree.pcty_desc =\n        (copy_class_type_desc pcty_desc);\n      To.Parsetree.pcty_loc = (copy_location pcty_loc);\n      To.Parsetree.pcty_attributes =\n        (copy_attributes pcty_attributes)\n    }\n\nand copy_class_type_desc :\n  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =\n  function\n  | From.Parsetree.Pcty_constr (x0,x1) ->\n      To.Parsetree.Pcty_constr\n        ((copy_loc copy_longident x0),\n          (List.map copy_core_type x1))\n  | From.Parsetree.Pcty_signature x0 ->\n      To.Parsetree.Pcty_signature\n        (copy_class_signature x0)\n  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->\n      To.Parsetree.Pcty_arrow\n        ((copy_arg_label x0),\n          (copy_core_type x1),\n          (copy_class_type x2))\n  | From.Parsetree.Pcty_extension x0 ->\n      To.Parsetree.Pcty_extension (copy_extension x0)\n  | From.Parsetree.Pcty_open (_, loc, _) ->\n      migration_error loc.From.Location.loc Def.Pcty_open\n\nand copy_class_signature :\n  From.Parsetree.class_signature -> To.Parsetree.class_signature =\n  fun\n    { From.Parsetree.pcsig_self = pcsig_self;\n      From.Parsetree.pcsig_fields = pcsig_fields }\n     ->\n    {\n      To.Parsetree.pcsig_self =\n        (copy_core_type pcsig_self);\n      To.Parsetree.pcsig_fields =\n        (List.map copy_class_type_field pcsig_fields)\n    }\n\nand copy_class_type_field :\n  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =\n  fun\n    { From.Parsetree.pctf_desc = pctf_desc;\n      From.Parsetree.pctf_loc = pctf_loc;\n      From.Parsetree.pctf_attributes = pctf_attributes }\n     ->\n    {\n      To.Parsetree.pctf_desc =\n        (copy_class_type_field_desc pctf_desc);\n      To.Parsetree.pctf_loc = (copy_location pctf_loc);\n      To.Parsetree.pctf_attributes =\n        (copy_attributes pctf_attributes)\n    }\n\nand copy_class_type_field_desc :\n  From.Parsetree.class_type_field_desc ->\n    To.Parsetree.class_type_field_desc\n  =\n  function\n  | From.Parsetree.Pctf_inherit x0 ->\n      To.Parsetree.Pctf_inherit (copy_class_type x0)\n  | From.Parsetree.Pctf_val x0 ->\n      To.Parsetree.Pctf_val\n        (let (x0,x1,x2,x3) = x0  in\n         (copy_loc (fun x  -> x) x0, (copy_mutable_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_method x0 ->\n      To.Parsetree.Pctf_method\n        (let (x0,x1,x2,x3) = x0  in\n         (copy_loc (fun x  -> x) x0, (copy_private_flag x1),\n           (copy_virtual_flag x2),\n           (copy_core_type x3)))\n  | From.Parsetree.Pctf_constraint x0 ->\n      To.Parsetree.Pctf_constraint\n        (let (x0,x1) = x0  in\n         ((copy_core_type x0),\n           (copy_core_type x1)))\n  | From.Parsetree.Pctf_attribute x0 ->\n      To.Parsetree.Pctf_attribute (copy_attribute x0)\n  | From.Parsetree.Pctf_extension x0 ->\n      To.Parsetree.Pctf_extension (copy_extension x0)\n\nand copy_extension :\n  From.Parsetree.extension -> To.Parsetree.extension =\n  fun x  ->\n    let (x0,x1) = x  in\n    ((copy_loc (fun x  -> x) x0),\n      (copy_payload x1))\n\nand copy_class_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pci_virt = pci_virt;\n        From.Parsetree.pci_params = pci_params;\n        From.Parsetree.pci_name = pci_name;\n        From.Parsetree.pci_expr = pci_expr;\n        From.Parsetree.pci_loc = pci_loc;\n        From.Parsetree.pci_attributes = pci_attributes }\n       ->\n      {\n        To.Parsetree.pci_virt =\n          (copy_virtual_flag pci_virt);\n        To.Parsetree.pci_params =\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                ((copy_core_type x0),\n                  (copy_variance x1))) pci_params);\n        To.Parsetree.pci_name =\n          (copy_loc (fun x  -> x) pci_name);\n        To.Parsetree.pci_expr = (f0 pci_expr);\n        To.Parsetree.pci_loc = (copy_location pci_loc);\n        To.Parsetree.pci_attributes =\n          (copy_attributes pci_attributes)\n      }\n\nand copy_virtual_flag :\n  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =\n  function\n  | From.Asttypes.Virtual  -> To.Asttypes.Virtual\n  | From.Asttypes.Concrete  -> To.Asttypes.Concrete\n\nand copy_include_description :\n  From.Parsetree.include_description ->\n    To.Parsetree.include_description\n  =\n  fun x  ->\n    copy_include_infos copy_module_type x\n\nand copy_include_infos :\n  'f0 'g0 .\n    ('f0 -> 'g0) ->\n      'f0 From.Parsetree.include_infos ->\n        'g0 To.Parsetree.include_infos\n  =\n  fun f0  ->\n    fun\n      { From.Parsetree.pincl_mod = pincl_mod;\n        From.Parsetree.pincl_loc = pincl_loc;\n        From.Parsetree.pincl_attributes = pincl_attributes }\n       ->\n      {\n        To.Parsetree.pincl_mod = (f0 pincl_mod);\n        To.Parsetree.pincl_loc = (copy_location pincl_loc);\n        To.Parsetree.pincl_attributes =\n          (copy_attributes pincl_attributes)\n      }\n\nand copy_open_description :\n  From.Parsetree.open_description -> To.Parsetree.open_description =\n  fun\n    { From.Parsetree.popen_lid = popen_lid;\n      From.Parsetree.popen_override = popen_override;\n      From.Parsetree.popen_loc = popen_loc;\n      From.Parsetree.popen_attributes = popen_attributes }\n     ->\n    {\n      To.Parsetree.popen_lid =\n        (copy_loc copy_longident popen_lid);\n      To.Parsetree.popen_override =\n        (copy_override_flag popen_override);\n      To.Parsetree.popen_loc = (copy_location popen_loc);\n      To.Parsetree.popen_attributes =\n        (copy_attributes popen_attributes)\n    }\n\nand copy_override_flag :\n  From.Asttypes.override_flag -> To.Asttypes.override_flag =\n  function\n  | From.Asttypes.Override  -> To.Asttypes.Override\n  | From.Asttypes.Fresh  -> To.Asttypes.Fresh\n\nand copy_module_type_declaration :\n  From.Parsetree.module_type_declaration ->\n    To.Parsetree.module_type_declaration\n  =\n  fun\n    { From.Parsetree.pmtd_name = pmtd_name;\n      From.Parsetree.pmtd_type = pmtd_type;\n      From.Parsetree.pmtd_attributes = pmtd_attributes;\n      From.Parsetree.pmtd_loc = pmtd_loc }\n     ->\n    {\n      To.Parsetree.pmtd_name =\n        (copy_loc (fun x  -> x) pmtd_name);\n      To.Parsetree.pmtd_type =\n        (copy_option copy_module_type pmtd_type);\n      To.Parsetree.pmtd_attributes =\n        (copy_attributes pmtd_attributes);\n      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)\n    }\n\nand copy_module_declaration :\n  From.Parsetree.module_declaration ->\n    To.Parsetree.module_declaration\n  =\n  fun\n    { From.Parsetree.pmd_name = pmd_name;\n      From.Parsetree.pmd_type = pmd_type;\n      From.Parsetree.pmd_attributes = pmd_attributes;\n      From.Parsetree.pmd_loc = pmd_loc }\n     ->\n    {\n      To.Parsetree.pmd_name =\n        (copy_loc (fun x  -> x) pmd_name);\n      To.Parsetree.pmd_type =\n        (copy_module_type pmd_type);\n      To.Parsetree.pmd_attributes =\n        (copy_attributes pmd_attributes);\n      To.Parsetree.pmd_loc = (copy_location pmd_loc)\n    }\n\nand copy_type_extension :\n  From.Parsetree.type_extension -> To.Parsetree.type_extension =\n  fun\n    { From.Parsetree.ptyext_path = ptyext_path;\n      From.Parsetree.ptyext_params = ptyext_params;\n      From.Parsetree.ptyext_constructors = ptyext_constructors;\n      From.Parsetree.ptyext_private = ptyext_private;\n      From.Parsetree.ptyext_attributes = ptyext_attributes }\n     ->\n    {\n      To.Parsetree.ptyext_path =\n        (copy_loc copy_longident ptyext_path);\n      To.Parsetree.ptyext_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptyext_params);\n      To.Parsetree.ptyext_constructors =\n        (List.map copy_extension_constructor\n           ptyext_constructors);\n      To.Parsetree.ptyext_private =\n        (copy_private_flag ptyext_private);\n      To.Parsetree.ptyext_attributes =\n        (copy_attributes ptyext_attributes)\n    }\n\nand copy_extension_constructor :\n  From.Parsetree.extension_constructor ->\n    To.Parsetree.extension_constructor\n  =\n  fun\n    { From.Parsetree.pext_name = pext_name;\n      From.Parsetree.pext_kind = pext_kind;\n      From.Parsetree.pext_loc = pext_loc;\n      From.Parsetree.pext_attributes = pext_attributes }\n     ->\n    {\n      To.Parsetree.pext_name =\n        (copy_loc (fun x  -> x) pext_name);\n      To.Parsetree.pext_kind =\n        (copy_extension_constructor_kind pext_kind);\n      To.Parsetree.pext_loc = (copy_location pext_loc);\n      To.Parsetree.pext_attributes =\n        (copy_attributes pext_attributes)\n    }\n\nand copy_extension_constructor_kind :\n  From.Parsetree.extension_constructor_kind ->\n    To.Parsetree.extension_constructor_kind\n  =\n  function\n  | From.Parsetree.Pext_decl (x0,x1) ->\n      To.Parsetree.Pext_decl\n        ((copy_constructor_arguments x0),\n          (copy_option copy_core_type x1))\n  | From.Parsetree.Pext_rebind x0 ->\n      To.Parsetree.Pext_rebind\n        (copy_loc copy_longident x0)\n\nand copy_type_declaration :\n  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =\n  fun\n    { From.Parsetree.ptype_name = ptype_name;\n      From.Parsetree.ptype_params = ptype_params;\n      From.Parsetree.ptype_cstrs = ptype_cstrs;\n      From.Parsetree.ptype_kind = ptype_kind;\n      From.Parsetree.ptype_private = ptype_private;\n      From.Parsetree.ptype_manifest = ptype_manifest;\n      From.Parsetree.ptype_attributes = ptype_attributes;\n      From.Parsetree.ptype_loc = ptype_loc }\n     ->\n    {\n      To.Parsetree.ptype_name =\n        (copy_loc (fun x  -> x) ptype_name);\n      To.Parsetree.ptype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_core_type x0),\n                (copy_variance x1))) ptype_params);\n      To.Parsetree.ptype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              ((copy_core_type x0),\n                (copy_core_type x1),\n                (copy_location x2))) ptype_cstrs);\n      To.Parsetree.ptype_kind =\n        (copy_type_kind ptype_kind);\n      To.Parsetree.ptype_private =\n        (copy_private_flag ptype_private);\n      To.Parsetree.ptype_manifest =\n        (copy_option copy_core_type ptype_manifest);\n      To.Parsetree.ptype_attributes =\n        (copy_attributes ptype_attributes);\n      To.Parsetree.ptype_loc = (copy_location ptype_loc)\n    }\n\nand copy_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_type_kind :\n  From.Parsetree.type_kind -> To.Parsetree.type_kind =\n  function\n  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract\n  | From.Parsetree.Ptype_variant x0 ->\n      To.Parsetree.Ptype_variant\n        (List.map copy_constructor_declaration x0)\n  | From.Parsetree.Ptype_record x0 ->\n      To.Parsetree.Ptype_record\n        (List.map copy_label_declaration x0)\n  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open\n\nand copy_constructor_declaration :\n  From.Parsetree.constructor_declaration ->\n    To.Parsetree.constructor_declaration\n  =\n  fun\n    { From.Parsetree.pcd_name = pcd_name;\n      From.Parsetree.pcd_args = pcd_args;\n      From.Parsetree.pcd_res = pcd_res;\n      From.Parsetree.pcd_loc = pcd_loc;\n      From.Parsetree.pcd_attributes = pcd_attributes }\n     ->\n    {\n      To.Parsetree.pcd_name =\n        (copy_loc (fun x  -> x) pcd_name);\n      To.Parsetree.pcd_args =\n        (copy_constructor_arguments pcd_args);\n      To.Parsetree.pcd_res =\n        (copy_option copy_core_type pcd_res);\n      To.Parsetree.pcd_loc = (copy_location pcd_loc);\n      To.Parsetree.pcd_attributes =\n        (copy_attributes pcd_attributes)\n    }\n\nand copy_constructor_arguments :\n  From.Parsetree.constructor_arguments ->\n    To.Parsetree.constructor_arguments\n  =\n  function\n  | From.Parsetree.Pcstr_tuple x0 ->\n      To.Parsetree.Pcstr_tuple\n        (List.map copy_core_type x0)\n  | From.Parsetree.Pcstr_record x0 ->\n      To.Parsetree.Pcstr_record\n        (List.map copy_label_declaration x0)\n\nand copy_label_declaration :\n  From.Parsetree.label_declaration -> To.Parsetree.label_declaration\n  =\n  fun\n    { From.Parsetree.pld_name = pld_name;\n      From.Parsetree.pld_mutable = pld_mutable;\n      From.Parsetree.pld_type = pld_type;\n      From.Parsetree.pld_loc = pld_loc;\n      From.Parsetree.pld_attributes = pld_attributes }\n     ->\n    {\n      To.Parsetree.pld_name =\n        (copy_loc (fun x  -> x) pld_name);\n      To.Parsetree.pld_mutable =\n        (copy_mutable_flag pld_mutable);\n      To.Parsetree.pld_type =\n        (copy_core_type pld_type);\n      To.Parsetree.pld_loc = (copy_location pld_loc);\n      To.Parsetree.pld_attributes =\n        (copy_attributes pld_attributes)\n    }\n\nand copy_mutable_flag :\n  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =\n  function\n  | From.Asttypes.Immutable  -> To.Asttypes.Immutable\n  | From.Asttypes.Mutable  -> To.Asttypes.Mutable\n\nand copy_variance :\n  From.Asttypes.variance -> To.Asttypes.variance =\n  function\n  | From.Asttypes.Covariant  -> To.Asttypes.Covariant\n  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant\n  | From.Asttypes.Invariant  -> To.Asttypes.Invariant\n\nand copy_value_description :\n  From.Parsetree.value_description -> To.Parsetree.value_description\n  =\n  fun\n    { From.Parsetree.pval_name = pval_name;\n      From.Parsetree.pval_type = pval_type;\n      From.Parsetree.pval_prim = pval_prim;\n      From.Parsetree.pval_attributes = pval_attributes;\n      From.Parsetree.pval_loc = pval_loc }\n     ->\n    {\n      To.Parsetree.pval_name =\n        (copy_loc (fun x  -> x) pval_name);\n      To.Parsetree.pval_type =\n        (copy_core_type pval_type);\n      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);\n      To.Parsetree.pval_attributes =\n        (copy_attributes pval_attributes);\n      To.Parsetree.pval_loc = (copy_location pval_loc)\n    }\n\nand copy_arg_label :\n  From.Asttypes.arg_label -> To.Asttypes.arg_label =\n  function\n  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel\n  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0\n  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0\n\nand copy_closed_flag :\n  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =\n  function\n  | From.Asttypes.Closed  -> To.Asttypes.Closed\n  | From.Asttypes.Open  -> To.Asttypes.Open\n\nand copy_label :\n  From.Asttypes.label -> To.Asttypes.label = fun x  -> x\n\nand copy_rec_flag :\n  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =\n  function\n  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive\n  | From.Asttypes.Recursive  -> To.Asttypes.Recursive\n\nand copy_constant :\n  From.Parsetree.constant -> To.Parsetree.constant =\n  function\n  | From.Parsetree.Pconst_integer (x0,x1) ->\n      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0\n  | From.Parsetree.Pconst_string (x0,x1) ->\n      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pconst_float (x0,x1) ->\n      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))\n\nand copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =\n  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)\n\nand copy_longident : From.Longident.t -> To.Longident.t =\n  function\n  | From.Longident.Lident x0 -> To.Longident.Lident x0\n  | From.Longident.Ldot (x0,x1) ->\n      To.Longident.Ldot ((copy_longident x0), x1)\n  | From.Longident.Lapply (x0,x1) ->\n      To.Longident.Lapply\n        ((copy_longident x0), (copy_longident x1))\n\nand copy_loc :\n  'f0 'g0 .\n    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc\n  =\n  fun f0  ->\n    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->\n      {\n        To.Asttypes.txt = (f0 txt);\n        To.Asttypes.loc = (copy_location loc)\n      }\n\nand copy_location : From.Location.t -> To.Location.t =\n  fun\n    { From.Location.loc_start = loc_start;\n      From.Location.loc_end = loc_end;\n      From.Location.loc_ghost = loc_ghost }\n     ->\n    {\n      To.Location.loc_start = (copy_Lexing_position loc_start);\n      To.Location.loc_end = (copy_Lexing_position loc_end);\n      To.Location.loc_ghost = (copy_bool loc_ghost)\n    }\n\nand copy_bool : bool -> bool = function | false  -> false | true  -> true\n\nand copy_Lexing_position : Lexing.position -> Lexing.position =\n  fun\n    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }\n     ->\n    {\n      Lexing.pos_fname = pos_fname;\n      Lexing.pos_lnum = pos_lnum;\n      Lexing.pos_bol = pos_bol;\n      Lexing.pos_cnum = pos_cnum\n    }\n\nlet rec copy_out_phrase :\n  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =\n  function\n  | From.Outcometree.Ophr_eval (x0,x1) ->\n      To.Outcometree.Ophr_eval\n        ((copy_out_value x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ophr_signature x0 ->\n      To.Outcometree.Ophr_signature\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_sig_item x0),\n                (copy_option copy_out_value x1))) x0)\n  | From.Outcometree.Ophr_exception x0 ->\n      To.Outcometree.Ophr_exception\n        (let (x0,x1) = x0  in\n         ((copy_exn x0), (copy_out_value x1)))\n\nand copy_exn : exn -> exn = fun x  -> x\n\nand copy_out_sig_item :\n  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =\n  function\n  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->\n      To.Outcometree.Osig_class_type\n        ((copy_bool x0), x1,\n          (List.map\n             (fun x  ->\n                let (x0,x1) = x  in\n                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n             x2), (copy_out_class_type x3),\n          (copy_out_rec_status x4))\n  | From.Outcometree.Osig_typext (x0,x1) ->\n      To.Outcometree.Osig_typext\n        ((copy_out_extension_constructor x0),\n          (copy_out_ext_status x1))\n  | From.Outcometree.Osig_modtype (x0,x1) ->\n      To.Outcometree.Osig_modtype\n        (x0, (copy_out_module_type x1))\n  | From.Outcometree.Osig_module (x0,x1,x2) ->\n      To.Outcometree.Osig_module\n        (x0, (copy_out_module_type x1),\n          (copy_out_rec_status x2))\n  | From.Outcometree.Osig_type (x0,x1) ->\n      To.Outcometree.Osig_type\n        ((copy_out_type_decl x0),\n          (copy_out_rec_status x1))\n  | From.Outcometree.Osig_value x0 ->\n      To.Outcometree.Osig_value\n        (copy_out_val_decl x0)\n  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis\n\nand copy_out_val_decl :\n  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =\n  fun\n    { From.Outcometree.oval_name = oval_name;\n      From.Outcometree.oval_type = oval_type;\n      From.Outcometree.oval_prims = oval_prims;\n      From.Outcometree.oval_attributes = oval_attributes }\n     ->\n    {\n      To.Outcometree.oval_name = oval_name;\n      To.Outcometree.oval_type =\n        (copy_out_type oval_type);\n      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);\n      To.Outcometree.oval_attributes =\n        (List.map copy_out_attribute oval_attributes)\n    }\n\nand copy_out_type_decl :\n  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =\n  fun\n    { From.Outcometree.otype_name = otype_name;\n      From.Outcometree.otype_params = otype_params;\n      From.Outcometree.otype_type = otype_type;\n      From.Outcometree.otype_private = otype_private;\n      From.Outcometree.otype_immediate = otype_immediate;\n      From.Outcometree.otype_unboxed = otype_unboxed;\n      From.Outcometree.otype_cstrs = otype_cstrs }\n     ->\n    {\n      To.Outcometree.otype_name = otype_name;\n      To.Outcometree.otype_params =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))\n           otype_params);\n      To.Outcometree.otype_type =\n        (copy_out_type otype_type);\n      To.Outcometree.otype_private =\n        (copy_From_Asttypes_private_flag otype_private);\n      To.Outcometree.otype_immediate = (copy_bool otype_immediate);\n      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);\n      To.Outcometree.otype_cstrs =\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_type x0),\n                (copy_out_type x1))) otype_cstrs)\n    }\n\nand copy_out_module_type :\n  From.Outcometree.out_module_type -> To.Outcometree.out_module_type\n  =\n  function\n  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract\n  | From.Outcometree.Omty_functor (x0,x1,x2) ->\n      To.Outcometree.Omty_functor\n        (x0, (copy_option copy_out_module_type x1),\n          (copy_out_module_type x2))\n  | From.Outcometree.Omty_ident x0 ->\n      To.Outcometree.Omty_ident (copy_out_ident x0)\n  | From.Outcometree.Omty_signature x0 ->\n      To.Outcometree.Omty_signature\n        (List.map copy_out_sig_item x0)\n  | From.Outcometree.Omty_alias x0 ->\n      To.Outcometree.Omty_alias (copy_out_ident x0)\n\nand copy_out_ext_status :\n  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =\n  function\n  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first\n  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next\n  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception\n\nand copy_out_extension_constructor :\n  From.Outcometree.out_extension_constructor ->\n    To.Outcometree.out_extension_constructor\n  =\n  fun\n    { From.Outcometree.oext_name = oext_name;\n      From.Outcometree.oext_type_name = oext_type_name;\n      From.Outcometree.oext_type_params = oext_type_params;\n      From.Outcometree.oext_args = oext_args;\n      From.Outcometree.oext_ret_type = oext_ret_type;\n      From.Outcometree.oext_private = oext_private }\n     ->\n    {\n      To.Outcometree.oext_name = oext_name;\n      To.Outcometree.oext_type_name = oext_type_name;\n      To.Outcometree.oext_type_params =\n        (List.map (fun x  -> x) oext_type_params);\n      To.Outcometree.oext_args =\n        (List.map copy_out_type oext_args);\n      To.Outcometree.oext_ret_type =\n        (copy_option copy_out_type oext_ret_type);\n      To.Outcometree.oext_private =\n        (copy_From_Asttypes_private_flag oext_private)\n    }\n\nand copy_From_Asttypes_private_flag :\n  From.Asttypes.private_flag -> To.Asttypes.private_flag =\n  function\n  | From.Asttypes.Private  -> To.Asttypes.Private\n  | From.Asttypes.Public  -> To.Asttypes.Public\n\nand copy_out_rec_status :\n  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =\n  function\n  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not\n  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first\n  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next\n\nand copy_out_class_type :\n  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =\n  function\n  | From.Outcometree.Octy_constr (x0,x1) ->\n      To.Outcometree.Octy_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Octy_arrow (x0,x1,x2) ->\n      To.Outcometree.Octy_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_class_type x2))\n  | From.Outcometree.Octy_signature (x0,x1) ->\n      To.Outcometree.Octy_signature\n        ((copy_option copy_out_type x0),\n          (List.map copy_out_class_sig_item x1))\n\nand copy_out_class_sig_item :\n  From.Outcometree.out_class_sig_item ->\n    To.Outcometree.out_class_sig_item\n  =\n  function\n  | From.Outcometree.Ocsg_constraint (x0,x1) ->\n      To.Outcometree.Ocsg_constraint\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_method\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->\n      To.Outcometree.Ocsg_value\n        (x0, (copy_bool x1), (copy_bool x2),\n          (copy_out_type x3))\n\nand copy_out_type :\n  From.Outcometree.out_type -> To.Outcometree.out_type =\n  function\n  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract\n  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open\n  | From.Outcometree.Otyp_alias (x0,x1) ->\n      To.Outcometree.Otyp_alias\n        ((copy_out_type x0), x1)\n  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->\n      To.Outcometree.Otyp_arrow\n        (x0, (copy_out_type x1),\n          (copy_out_type x2))\n  | From.Outcometree.Otyp_class (x0,x1,x2) ->\n      To.Outcometree.Otyp_class\n        ((copy_bool x0), (copy_out_ident x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_constr (x0,x1) ->\n      To.Outcometree.Otyp_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_type x1))\n  | From.Outcometree.Otyp_manifest (x0,x1) ->\n      To.Outcometree.Otyp_manifest\n        ((copy_out_type x0),\n          (copy_out_type x1))\n  | From.Outcometree.Otyp_object (x0,x1) ->\n      To.Outcometree.Otyp_object\n        ((List.map\n            (fun x  ->\n               let (x0,x1) = x  in\n               (x0, (copy_out_type x1))) x0),\n          (copy_option copy_bool x1))\n  | From.Outcometree.Otyp_record x0 ->\n      To.Outcometree.Otyp_record\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1), (copy_out_type x2)))\n           x0)\n  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0\n  | From.Outcometree.Otyp_sum x0 ->\n      To.Outcometree.Otyp_sum\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2))) x0)\n  | From.Outcometree.Otyp_tuple x0 ->\n      To.Outcometree.Otyp_tuple\n        (List.map copy_out_type x0)\n  | From.Outcometree.Otyp_var (x0,x1) ->\n      To.Outcometree.Otyp_var ((copy_bool x0), x1)\n  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->\n      To.Outcometree.Otyp_variant\n        ((copy_bool x0), (copy_out_variant x1),\n          (copy_bool x2),\n          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))\n  | From.Outcometree.Otyp_poly (x0,x1) ->\n      To.Outcometree.Otyp_poly\n        ((List.map (fun x  -> x) x0), (copy_out_type x1))\n  | From.Outcometree.Otyp_module (x0,x1,x2) ->\n      To.Outcometree.Otyp_module\n        (x0, (List.map (fun x  -> x) x1),\n          (List.map copy_out_type x2))\n  | From.Outcometree.Otyp_attribute (x0,x1) ->\n      To.Outcometree.Otyp_attribute\n        ((copy_out_type x0),\n          (copy_out_attribute x1))\n\nand copy_out_attribute :\n  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =\n  fun { From.Outcometree.oattr_name = oattr_name }  ->\n    { To.Outcometree.oattr_name = oattr_name }\n\nand copy_out_variant :\n  From.Outcometree.out_variant -> To.Outcometree.out_variant =\n  function\n  | From.Outcometree.Ovar_fields x0 ->\n      To.Outcometree.Ovar_fields\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (copy_bool x1),\n                (List.map copy_out_type x2))) x0)\n  | From.Outcometree.Ovar_typ x0 ->\n      To.Outcometree.Ovar_typ (copy_out_type x0)\n\nand copy_out_value :\n  From.Outcometree.out_value -> To.Outcometree.out_value =\n  function\n  | From.Outcometree.Oval_array x0 ->\n      To.Outcometree.Oval_array\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0\n  | From.Outcometree.Oval_constr (x0,x1) ->\n      To.Outcometree.Oval_constr\n        ((copy_out_ident x0),\n          (List.map copy_out_value x1))\n  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis\n  | From.Outcometree.Oval_float x0 ->\n      To.Outcometree.Oval_float (copy_float x0)\n  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0\n  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0\n  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0\n  | From.Outcometree.Oval_nativeint x0 ->\n      To.Outcometree.Oval_nativeint x0\n  | From.Outcometree.Oval_list x0 ->\n      To.Outcometree.Oval_list\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_printer x0 ->\n      To.Outcometree.Oval_printer x0\n  | From.Outcometree.Oval_record x0 ->\n      To.Outcometree.Oval_record\n        (List.map\n           (fun x  ->\n              let (x0,x1) = x  in\n              ((copy_out_ident x0),\n                (copy_out_value x1))) x0)\n  | From.Outcometree.Oval_string (x0, _, _) -> To.Outcometree.Oval_string x0\n  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0\n  | From.Outcometree.Oval_tuple x0 ->\n      To.Outcometree.Oval_tuple\n        (List.map copy_out_value x0)\n  | From.Outcometree.Oval_variant (x0,x1) ->\n      To.Outcometree.Oval_variant\n        (x0, (copy_option copy_out_value x1))\n\nand copy_float : float -> float = fun x  -> x\n\nand copy_out_ident :\n  From.Outcometree.out_ident -> To.Outcometree.out_ident =\n  function\n  | From.Outcometree.Oide_apply (x0,x1) ->\n      To.Outcometree.Oide_apply\n        ((copy_out_ident x0),\n          (copy_out_ident x1))\n  | From.Outcometree.Oide_dot (x0,x1) ->\n      To.Outcometree.Oide_dot\n        ((copy_out_ident x0), x1)\n  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0\n\nlet rec copy_toplevel_phrase :\n  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =\n  function\n  | From.Parsetree.Ptop_def x0 ->\n      To.Parsetree.Ptop_def (copy_structure x0)\n  | From.Parsetree.Ptop_dir (x0,x1) ->\n      To.Parsetree.Ptop_dir\n        (x0, (copy_directive_argument x1))\n\nand copy_directive_argument :\n  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =\n  function\n  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none\n  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0\n  | From.Parsetree.Pdir_int (x0,x1) ->\n      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))\n  | From.Parsetree.Pdir_ident x0 ->\n      To.Parsetree.Pdir_ident (copy_longident x0)\n  | From.Parsetree.Pdir_bool x0 ->\n      To.Parsetree.Pdir_bool (copy_bool x0)\n\nlet copy_out_type_extension :\n  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =\n  fun\n    { From.Outcometree.otyext_name = otyext_name;\n      From.Outcometree.otyext_params = otyext_params;\n      From.Outcometree.otyext_constructors = otyext_constructors;\n      From.Outcometree.otyext_private = otyext_private }\n     ->\n    {\n      To.Outcometree.otyext_name = otyext_name;\n      To.Outcometree.otyext_params =\n        (List.map (fun x  -> x) otyext_params);\n      To.Outcometree.otyext_constructors =\n        (List.map\n           (fun x  ->\n              let (x0,x1,x2) = x  in\n              (x0, (List.map copy_out_type x1),\n                (copy_option copy_out_type x2)))\n           otyext_constructors);\n      To.Outcometree.otyext_private =\n        (copy_private_flag otyext_private)\n    }\n\nlet copy_cases x = List.map copy_case x\nlet copy_pat = copy_pattern\nlet copy_expr = copy_expression\nlet copy_typ = copy_core_type\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_405_406_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_406_405_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                         OCaml Migrate Parsetree                        *)\n(*                                                                        *)\n(*                             Frédéric Bour                              *)\n(*                                                                        *)\n(*   Copyright 2017 Institut National de Recherche en Informatique et     *)\n(*     en Automatique (INRIA).                                            *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\ninclude Migrate_parsetree_406_405_migrate\n\n(*$ open Printf\n    let fields = [\n      \"attribute\"; \"attributes\"; \"case\"; \"cases\"; \"class_declaration\";\n      \"class_description\"; \"class_expr\"; \"class_field\"; \"class_signature\";\n      \"class_structure\"; \"class_type\"; \"class_type_declaration\";\n      \"class_type_field\"; \"constructor_declaration\"; \"expr\"; \"extension\";\n      \"extension_constructor\"; \"include_declaration\"; \"include_description\";\n      \"label_declaration\"; \"location\"; \"module_binding\"; \"module_declaration\";\n      \"module_expr\"; \"module_type\"; \"module_type_declaration\";\n      \"open_description\"; \"pat\"; \"signature\"; \"signature_item\"; \"structure\";\n      \"structure_item\"; \"typ\"; \"type_declaration\"; \"type_extension\";\n      \"type_kind\"; \"value_binding\"; \"value_description\";\n      \"with_constraint\"; \"payload\"\n    ]\n  let foreach_field f =\n    printf \"\\n\";\n    List.iter f fields\n*)(*$*)\n\nlet copy_mapper = fun\n  ({ From.Ast_mapper.\n     (*$ foreach_field (printf \"%s;\\n\")*)\n     attribute;\n     attributes;\n     case;\n     cases;\n     class_declaration;\n     class_description;\n     class_expr;\n     class_field;\n     class_signature;\n     class_structure;\n     class_type;\n     class_type_declaration;\n     class_type_field;\n     constructor_declaration;\n     expr;\n     extension;\n     extension_constructor;\n     include_declaration;\n     include_description;\n     label_declaration;\n     location;\n     module_binding;\n     module_declaration;\n     module_expr;\n     module_type;\n     module_type_declaration;\n     open_description;\n     pat;\n     signature;\n     signature_item;\n     structure;\n     structure_item;\n     typ;\n     type_declaration;\n     type_extension;\n     type_kind;\n     value_binding;\n     value_description;\n     with_constraint;\n     payload;\n     (*$*)\n   } as mapper) ->\n  let module R = Migrate_parsetree_405_406_migrate in\n  {\n    To.Ast_mapper.\n    (*$ foreach_field (fun s ->\n          printf\n          \"%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\\n\" s s s s)\n    *)\n    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));\n    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));\n    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));\n    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));\n    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));\n    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));\n    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));\n    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));\n    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));\n    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));\n    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));\n    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));\n    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));\n    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));\n    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));\n    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));\n    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));\n    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));\n    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));\n    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));\n    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));\n    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));\n    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));\n    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));\n    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));\n    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));\n    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));\n    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));\n    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));\n    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));\n    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));\n    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));\n    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));\n    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));\n    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));\n    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));\n    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));\n    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));\n    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));\n    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));\n    (*$*)\n  }\n","(**************************************************************************)\n(*                                                                        *)\n(*                                 OCaml                                  *)\n(*                                                                        *)\n(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)\n(*                                                                        *)\n(*   Copyright 1996 Institut National de Recherche en Informatique et     *)\n(*     en Automatique.                                                    *)\n(*                                                                        *)\n(*   All rights reserved.  This file is distributed under the terms of    *)\n(*   the GNU Lesser General Public License version 2.1, with the          *)\n(*   special exception on linking described in the file LICENSE.          *)\n(*                                                                        *)\n(**************************************************************************)\n\n(* Ensure that [at_exit] functions are called at the end of every program *)\n\nlet _ = do_at_exit()\n"]}